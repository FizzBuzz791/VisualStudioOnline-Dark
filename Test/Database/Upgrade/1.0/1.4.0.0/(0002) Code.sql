/*
	Project: ReconcilorBhpbio
	Build Version: *
	Content: Code
	Generated: Monday, 23 November 2009 5:47 PM

	Build Manifest 1.0.3.0
	Copyright Snowden Technologies

	This file contains automatically generated content.
	Avoid modifying this content directly as most of this
	can be modified with the provided tools.
	For internal use only.
*/

Print 'Code: SnowdenCommon->Schema\Views\dbo.SecurityUserRole.viw'
GO

-- provides a standardised methodology of linking users to roles
-- this is used in quite a few places - best to centralise
IF Object_Id('dbo.SecurityUserRole') IS NOT NULL
	DROP VIEW dbo.SecurityUserRole
GO

CREATE VIEW dbo.SecurityUserRole
AS
SELECT UserId, RoleId
FROM dbo.SecurityRoleAssignment
WHERE UserId IS NOT NULL
UNION
SELECT ug.UserId, ra.RoleId
FROM dbo.SecurityUserGroup AS ug
	INNER JOIN dbo.SecurityRoleAssignment AS ra
		ON (ug.GroupId = ra.GroupId)
GO


GO


Print 'Code: SnowdenCommon->Schema\Functions\dbo.GetImportTypePhaseIdByName.udf'
GO

If object_id('dbo.GetImportTypePhaseIdByName') is not Null 
     Drop Function dbo.GetImportTypePhaseIdByName
Go 
  
Create Function dbo.GetImportTypePhaseIdByName 
( 
    @iImport_Type_Name Varchar(128),
	@iImport_Type_Phase_Name Varchar(128)
) 
Returns SmallInt
As 
Begin 
	Declare @Phase_ID SmallInt

	Select @Phase_ID = ITP.Import_Type_Phase_ID
	From IMPORT_TYPE As IT
		Inner Join IMPORT_TYPE_PHASE As ITP
			On IT.Import_Type_ID = ITP.Import_Type_ID
	Where IT.Import_Type_Name = @iImport_Type_Name
		And ITP.Import_Type_Phase_Name = @iImport_Type_Phase_Name

	Return @Phase_ID
End 
Go	

GO


Print 'Code: SnowdenCommon->Schema\Procedures\dbo.AddSupportLog.prc'
GO

IF OBJECT_ID('dbo.AddSupportLog') IS NOT NULL
     DROP PROCEDURE dbo.AddSupportLog  
GO 

CREATE PROCEDURE dbo.AddSupportLog 
(
	@iLogTypeName VARCHAR(31),
	@iComponent VARCHAR(256),
	@iDescription VARCHAR(2048),
	@iDetails VARCHAR(MAX),
	@iException VARCHAR(MAX),
	@oLogId BIGINT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @LogTypeId TINYINT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.AddSupportLog',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- look up the name and return an error if it cannot be found
		SET @LogTypeId =
			(
				SELECT LogTypeId
				FROM dbo.SupportLogType
				WHERE Name = @iLogTypeName
			)

		IF @LogTypeId IS NULL
		BEGIN
			RAISERROR('The specified log type cannot be found.', 16, 1)
		END

		-- insert the log entry
		INSERT INTO dbo.SupportLog
			(LogTypeId, Added, Component, Description, Details, Exception)
		VALUES
			(@LogTypeId, GetDate(), @iComponent, @iDescription, @iDetails, @iException)

		-- return the result
		SET @oLogId = SCOPE_IDENTITY()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSupportLog TO Public
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSupportLog">
 <Procedure>
	Adds an entry to the support log.
	Note: at this point in time it is not constrained to application.
    This can be later extended to cover more services.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.AddImport.prc'
GO

If Object_Id('dbo.AddImport') Is Not Null
	Drop Procedure dbo.AddImport
Go

Create Procedure dbo.AddImport
(
	@iImportName VarChar(128),
	@iImportGroupID SmallInt,
	@iImportTypeID SmallInt,
	@iDescription VarChar(255),
	@iIsActive Bit,
	@iDefaultKillTimeoutMinutes SmallInt,
	@oImportID SmallInt Output
)

With Encryption
As

Begin
	Set NoCount On
	
	Insert Into dbo.Import
	(
		ImportName, ImportGroupID, ImportTypeID, Description, IsActive,
		DefaultKillTimeoutMinutes
	)
	Values
	(
		@iImportName, @iImportGroupID, @iImportTypeID, @iDescription, @iIsActive,
		@iDefaultKillTimeoutMinutes
	)

	Set @oImportID = Scope_Identity()
End
Go


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.AddImportJob.prc'
GO

If Object_Id('dbo.AddImportJob') is not Null 
     Drop Procedure dbo.AddImportJob
Go 
  
Create Procedure dbo.AddImportJob
( 
	@iImportID SmallInt,
	@iPriority SmallInt = 1,
	@iImportJobStatusID Int = Null,
    @oImportJobID int = NULL output
) 
With Encryption
As 

Begin 
	Declare @ImportJobID Int

    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	-- select the initial job status, of "pending"
	If @iImportJobStatusID Is Null
	Begin
		Select @iImportJobStatusID = ImportJobStatusID
		From dbo.ImportJobStatus 
		Where ImportJobStatusName = 'PENDING'
	End

	-- create the new import job
	Insert Into dbo.ImportJob
	(
		ImportID, ImportJobStatusID, Priority
	)
	Values
	(
		@iImportID, @iImportJobStatusID, @iPriority
	)
	
	Set @ImportJobID = Scope_Identity()

	-- add the job status history record
	Exec dbo.AddImportJobStatushistory
		@iImportJobID = @ImportJobID,
		@iImportJobStatusID = @iImportJobStatusID
		
	Insert Into dbo.ImportJobParameter
	(
		ImportJobID, ImportParameterID, ParameterValue
	)
	Select
		@ImportJobID, IP.ImportParameterID, IP.DefaultParameterValue
	From dbo.ImportParameter As IP
	Where IP.ImportID = @iImportID
	

	-- return the result
	Set @oImportJobID = @ImportJobID

    Commit Transaction 
End 
Go	
GRANT EXECUTE ON dbo.AddImportJob TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.AddImportJobStatushistory.prc'
GO

If Object_Id('dbo.AddImportJobStatushistory') is not Null 
     Drop Procedure dbo.AddImportJobStatushistory 
Go 
  
Create Procedure dbo.AddImportJobStatushistory 
( 
    @iImportJobID	Int,
	@iImportJobStatusID Int,
	@oImportJobStatusHistoryID Int = Null Output
) 

With Encryption
As

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Insert Into dbo.ImportJobStatusHistory
	(
		ImportJobID, ImportJobStatusID, DateAdded
	)
	Values
	(
		@iImportJobID, @iImportJobStatusID, GetDate()
	)

	Set @oImportJobStatusHistoryID = Scope_Identity()

    Commit Transaction 
End 
Go	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.DeleteImportJob.PRC'
GO

If Object_Id('dbo.DeleteImportJob') is not Null 
     Drop Procedure dbo.DeleteImportJob
Go 
  
Create Procedure dbo.DeleteImportJob 
( 
    @iImportJobID int
) 

With Encryption
As 

Begin 
	Declare @ImportJobStatusIDPending Int
	Declare @ImportJobStatusIDQueued Int
	
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	
	-- TBD (add raiserror calls)
	-- only allow updating of priority for jobs in the PENDING/QUEUED state
	
	Select @ImportJobStatusIDPending = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'PENDING'

	Select @ImportJobStatusIDQueued = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'QUEUED'
	
	If Exists	(
					Select Top 1 * 
					From dbo.ImportJob 
					Where ImportJobID = @iImportJobID
						And ImportJobStatusID In (@ImportJobStatusIDQueued,@ImportJobStatusIDPending)
				)
	Begin	


	
	Delete
	From dbo.ImportJobStatusHistory
	Where ImportJobID = @iImportJobID
	
	Delete S
	From dbo.ImportHistorySync As S
		Inner Join dbo.ImportHistory As H
			On S.ImportHistoryID = H.ImportHistoryID
	Where ImportJobID = @iImportJobID
	
	Delete L
	From dbo.ImportHistoryLoad As L
		Inner Join dbo.ImportHistory As H
		On L.ImportHistoryID = H.ImportHistoryID
	Where ImportJobID = @iImportJobID
	
	Delete
	From dbo.ImportHistory
	Where ImportJobID = @iImportJobID
	
	Delete
	From dbo.ImportJobParameter
	Where ImportJobID = @iImportJobID

	Delete 
	From dbo.ImportJob
	Where ImportJobID = @iImportJobID
	

	End
	Else
	Begin
		RaisError('The jobid:%d is not in the pending or queued state.',
        16, 1, @iImportJobID)
	End
	
	
  
    Commit Transaction 
End 
Go
GRANT EXECUTE ON dbo.DeleteImportJob TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportGroupList.PRC'
GO

If Object_Id('dbo.GetImportGroupList') is not null
	Drop Procedure dbo.GetImportGroupList
Go

Create Procedure dbo.GetImportGroupList
(
	@iImportGroupID Smallint = Null
) 

With Encryption
As

Begin
	Set NoCount On

	Select IG.ImportGroupID, IG.ImportGroupName, IG.Description
	From dbo.ImportGroup As IG
	Where (ImportGroupID = @iImportGroupID Or @iImportGroupID Is Null)
End
Go
GRANT EXECUTE ON dbo.GetImportGroupList TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJob.PRC'
GO

If Object_Id('dbo.GetImportJob') is not Null 
     Drop Procedure dbo.GetImportJob
Go 
  
Create Procedure dbo.GetImportJob
( 
    @iImportJobID	int,
	@iVisibleOnly bit = NULL
) 

With Encryption
As 

Begin 

    Set NoCount On 

	If @iVisibleOnly = 0
		Set @iVisibleOnly = NULL

	--Job Recordset  
	Select IJ.ImportJobId, IJ.ImportID, 
		IJ.ImportJobStatusID, IJS.ImportJobStatusName,
		IJ.Priority
	From dbo.ImportJob as IJ
		Inner Join dbo.ImportJobStatus As IJS
			On IJ.ImportJobStatusID = IJS.ImportJobStatusID
	Where IJ.ImportJobID = @iImportJobID

	--Parameters Recordset
	Select IP.ImportParameterID, IP.ParameterName, IP.DisplayName,
		IsNull(IJP.ParameterValue, IP.DefaultParameterValue) As ParameterValue
	From dbo.ImportJob as IJ
		Inner Join dbo.ImportParameter As IP
			On IJ.ImportID = IP.ImportID
		Left Outer Join dbo.ImportJobParameter As IJP
			On IJP.ImportJobID = IJ.ImportJobID
				And IP.ImportParameterID = IJP.ImportParameterID
	Where IJ.ImportJobID = @iImportJobID
		And IP.IsRequired = 1
		And IP.IsVisible = IsNull(@iVisibleOnly, IP.IsVisible) 
	Order By IP.OrderNo
End 
Go	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportHistoryLoad.PRC'
GO

If Object_Id('dbo.GetImportHistoryLoad') is not Null 
     Drop Procedure dbo.GetImportHistoryLoad 
Go 
  
Create Procedure dbo.GetImportHistoryLoad 
( 
    @iImportJobID int
) 

With Encryption
As 

Begin 
    Set NoCount On

	-- view the job history for a load job
	
	Select ITP.ImportTypePhaseID, 
		ITP.ImportTypePhaseName, 
		IJH.JobDateStarted,
		IJH.JobDateCompleted,
		IJHL.LoadDateStarted,
		IJHL.LoadDateCompleted,
		IJHL.LoadRecordsLoaded,
		IJHL.ProcessDateStarted,
		IJHL.ProcessDateCompleted,
		IJHL.ProcessRecordsProcessed,
		IJH.CommandLine
	From dbo.ImportHistoryLoad As IJHL
		Inner Join dbo.ImportHistory As IJH
			On (IJH.ImportHistoryID = IJHL.ImportHistoryID)
		Left Outer Join dbo.ImportTypePhase As ITP
			On (IJH.ActivePhaseID = ITP.ImportTypePhaseID)
	Where IJH.ImportJobID = @iImportJobID	
End 
Go
GRANT EXECUTE ON dbo.GetImportHistoryLoad TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportHistorySync.PRC'
GO

If Object_Id('dbo.GetImportHistorySync') is not Null 
     Drop Procedure dbo.GetImportHistorySync 
Go 

Create Procedure dbo.GetImportHistorySync 
( 
    @iImportJobID int
) 

With Encryption
As 

Begin 
    Set NoCount On 
  
	-- view the job history for a sync job
	Select ITP.ImportTypePhaseID,
		ITP.ImportTypePhaseName,
		IJH.JobDateStarted,
		IJH.JobDateCompleted,
		IJHS.CompareDateStarted,
		IJHS.CompareDateCompleted,
		IJHS.CompareRecordsInserted,
		IJHS.CompareRecordsUpdated,
		IJHS.CompareRecordsDeleted,
		IJHS.ProcessDateStarted,
		IJHS.ProcessDateCompleted,
		IJHS.ProcessRecordsInserted,
		IJHS.ProcessRecordsUpdated,
		IJHS.ProcessRecordsDeleted,
		IJHS.ProcessRecordsConflicted,
		IJHS.ProcessRecordsValidationFailures,
		IJH.CommandLine
	From dbo.ImportHistorySync As IJHS
		Inner Join dbo.ImportHistory As IJH
			On (IJH.ImportHistoryID = IJHS.ImportHistoryID)
		Left Outer Join dbo.ImportTypePhase As ITP
			On (IJH.ActivePhaseID = ITP.ImportTypePhaseID)
	Where IJH.ImportJobID = @iImportJobID	
End 
Go
GRANT EXECUTE ON dbo.GetImportHistorySync TO CommonImportManager




GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJobList.PRC'
GO

If Object_Id('dbo.GetImportJobList') is not null
	Drop Procedure dbo.GetImportJobList
Go

Create Procedure dbo.GetImportJobList
(
	@iImportJobID SmallInt = Null,
	@iImportID SmallInt = Null,
	@iImportJobStatusID SmallInt = Null,
	@iStartDate DateTime = Null,
	@iEndDate DateTime = Null
) 

With Encryption
As

Begin
	Set NoCount On

	-- get a list of import jobs
	Select IJ.ImportJobID, IJ.ImportID, IJ.Priority, I.ImportName,
		IJ.ImportJobStatusID, IJS.ImportJobStatusName, IJSH.AddedDateTime,
		IJSH.LastActiveTime
	From dbo.ImportJob As IJ
		Inner Join dbo.Import As I
			On (IJ.ImportID = I.ImportID)
		Inner Join dbo.ImportJobStatus As IJS
			On (IJ.ImportJobStatusID = IJS.ImportJobStatusID)
		Left Join	(	
					Select IJSH.ImportJobID,
						Min(DateAdded) As AddedDateTime,
						Max(DateAdded) As LastActiveTime
					From dbo.ImportJobStatusHistory As IJSH
						Inner Join dbo.ImportJobStatus As IJS
							On IJS.ImportJobStatusID = IJSH.ImportJobStatusID
					Group By IJSH.ImportJobID
					) As IJSH
			On (IJSH.ImportJobID = IJ.ImportJobID)

	Where (IJ.ImportJobID = @iImportJobID Or @iImportJobID Is Null)
		And (IJ.ImportID = @iImportID Or	@iImportID Is Null)
		And (IJ.ImportJobStatusID = @iImportJobStatusID Or @iImportJobStatusID Is Null)
		And ((IJSH.AddedDateTime Between Coalesce(@iStartDate,'1-Jan-1900') 
			And Coalesce(@iEndDate,'31-Dec-2099') Or IJSH.AddedDateTime Is Null)
			Or
			(IJSH.LastActiveTime Between Coalesce(@iStartDate,'1-Jan-1900') 
			And Coalesce(@iEndDate,'31-Dec-2099') Or IJSH.LastActiveTime Is Null))
	Order By IJ.ImportJobID DESC
	
End
Go

GRANT EXECUTE ON dbo.GetImportJobList TO CommonImportManager
GO

GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJobParameters.PRC'
GO

If Object_Id('dbo.GetImportJobParameters') is not null
	Drop Procedure dbo.GetImportJobParameters
Go

Create Procedure dbo.GetImportJobParameters
(
	@iImportJobID Smallint
) 

With Encryption
As

Begin
	
	Set NoCount On

	-- get the default parameters for an import
	Select I.Description, IJP.ImportParameterID, IP.ParameterName, IP.DisplayName, IJP.ParameterValue, IP.IsRequired, 
		IP.DefaultParameterValue, IP.OrderNo, IP.IsVisible, IP.IsEnabled 
	From dbo.ImportJobParameter IJP
		Inner Join dbo.ImportParameter IP
			On (IJP.ImportParameterID = IP.ImportParameterID)
		Inner Join dbo.Import I
			On (IP.ImportID = I.ImportID)
	Where IJP.ImportJobID = @iImportJobID
	Order By IP.OrderNo

End
Go
GRANT EXECUTE ON dbo.GetImportJobParameters TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJobStatusHistory.PRC'
GO

If Object_Id('dbo.GetImportJobStatusHistory') is not null
	Drop Procedure dbo.GetImportJobStatusHistory
Go

Create Procedure dbo.GetImportJobStatusHistory
(
	@iImportJobID SmallInt
) 

With Encryption
As

Begin
	Set NoCount On

	-- view the status history for a job
	Select IJSH.ImportJobStatusID,
		IJS.ImportJobStatusName,
		IJS.Description,
		IJSH.DateAdded
	From dbo.ImportJobStatusHistory As IJSH
		Inner Join dbo.ImportJobStatus As IJS
			On (IJS.ImportJobStatusID = IJSH.ImportJobStatusID)
	Where IJSH.ImportJobID = @iImportJobID
End
Go
GRANT EXECUTE ON dbo.GetImportJobStatusHistory TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJobStatusList.PRC'
GO

If Object_Id('dbo.GetImportJobStatuslist') is not Null 
     Drop Procedure dbo.GetImportJobStatuslist 
Go 
  
Create Procedure dbo.GetImportJobStatuslist 
( 
    @iImportJobStatusID int = Null
) 

With Encryption
As
 
Begin 
    Set NoCount On 
    
	-- get the job status list
	Select IJS.ImportJobStatusID,
		IJS.ImportJobStatusName,
		IJS.Description
	From dbo.ImportJobStatus IJS
	Where (IJS.ImportJobStatusID = @iImportJobStatusID Or @iImportJobStatusID Is Null)
End 
Go
GRANT EXECUTE ON dbo.GetImportJobStatusList TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportList.prc'
GO

IF Object_Id('dbo.GetImportList') IS NOT NULL
	DROP PROCEDURE dbo.GetImportList
GO

CREATE PROCEDURE dbo.GetImportList
(
	@iImportID SMALLINT = NULL,
	@iImportGroupID SMALLINT = NULL,
	@iImportTypeID SMALLINT = NULL
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON

	SELECT i.ImportID, i.ImportName, i.ImportGroupID,
		i.ImportTypeID, i.Description, i.IsActive,
		i.DefaultKillTimeoutMinutes, g.Description As ImportGroupDescription,
		t.Description As ImportTypeDescription, t.ImportTypeName,
		CASE
			WHEN t.ImportTypeName = 'SYNC' THEN
				(
					SELECT COUNT(v.ImportSyncValidateId)
					FROM dbo.ImportSyncValidate AS v
						INNER JOIN dbo.ImportSyncQueue AS q
							ON (v.ImportSyncQueueId = q.ImportSyncQueueId)
					WHERE q.ImportId = i.ImportId
						AND q.IsPending = 1
				)
			ELSE NULL
		END AS ValidateCount,
		CASE
			WHEN t.ImportTypeName = 'SYNC' THEN
				(
					SELECT COUNT(c.ImportSyncConflictId)
					FROM dbo.ImportSyncConflict AS c
						INNER JOIN dbo.ImportSyncQueue AS q
							ON (c.ImportSyncQueueId = q.ImportSyncQueueId)
					WHERE q.ImportId = i.ImportId
						AND q.IsPending = 1
				)
			ELSE NULL
		END AS ConflictCount,
		CASE
			WHEN t.ImportTypeName = 'SYNC' THEN
				(
					SELECT COUNT(e.ImportSyncExceptionId)
					FROM dbo.ImportSyncException AS e
						INNER JOIN dbo.ImportSyncQueue AS q
							ON (e.ImportSyncQueueId = q.ImportSyncQueueId)
					WHERE q.ImportId = i.ImportId
						AND q.IsPending = 1
				)
			ELSE NULL
		END AS CriticalErrorCount
	FROM dbo.Import AS i
		INNER JOIN dbo.ImportType AS t
			ON (i.ImportTypeID = t.ImportTypeID)
		INNER JOIN dbo.ImportGroup AS g
			On (g.ImportGroupID = i.ImportGroupID)
	WHERE i.ImportID = ISNULL(@iImportID, i.ImportID)
		AND i.ImportGroupID = ISNULL(@iImportGroupID, i.ImportGroupId)
		And i.ImportTypeID = ISNULL(@iImportTypeID, i.ImportTypeID)
END
GO

GRANT EXECUTE ON dbo.GetImportList TO CommonImportManager
GO



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportNextJob.prc'
GO

If Object_Id('dbo.GetImportNextJob') is not null
	Drop Procedure dbo.GetImportNextJob
Go

Create Procedure dbo.GetImportNextJob

With Encryption
As

Begin

	Set NoCount On	

	-- Return the next record in the queue - ordered by priority and order inserted
	Select I.ImportName, IJS.Description, IJ.Priority, IJ.ImportJobID
	From dbo.ImportJob IJ
		Inner Join dbo.Import I
			On (IJ.ImportID = I.ImportID)
		Inner Join dbo.ImportJobStatus IJS
			On (IJ.ImportJobStatusID = IJS.ImportJobStatusID)
	Where ImportJobStatusName = 'QUEUED'
	Order By IJ.Priority, IJ.ImportJobID  

End
Go
GRANT EXECUTE ON dbo.GetImportNextJob TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportParameters.PRC'
GO

If Object_Id('dbo.GetImportParameters') is not null
	Drop Procedure dbo.GetImportParameters
Go

Create Procedure dbo.GetImportParameters
(
	@iImportID SmallInt
) 

With Encryption
As
	
Begin
	Set NoCount On

	-- get the default parameters for an import
	Select IP.DisplayName, IP.IsRequired, IP.ParameterName, IP.ImportParameterID,
		IP.DefaultParameterValue, IP.OrderNo, IP.IsVisible, IP.IsEnabled 
	From dbo.ImportParameter As IP
	Where IP.ImportID = @iImportID
	Order By IP.OrderNo
End
Go
GRANT EXECUTE ON dbo.GetImportParameters TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportTypeList.PRC'
GO

If Object_Id('dbo.GetImportTypeList') is not null
	Drop Procedure dbo.GetImportTypeList
Go

Create Procedure dbo.GetImportTypeList
(
	@iImportTypeID Smallint = Null
) 

With Encryption
As

Begin
	Set NoCount On

	-- returns a list of import types
	Select IT.ImportTypeID, IT.ImportTypeName, IT.Description
	From dbo.ImportType As IT
	Where (IT.ImportTypeID = @iImportTypeID Or @iImportTypeID Is Null)
End
Go
GRANT EXECUTE ON dbo.GetImportTypeList TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportTypePhaseList.PRC'
GO

If Object_Id('dbo.GetImportTypePhaseList') is not null
	Drop Procedure dbo.GetImportTypePhaseList
Go

Create Procedure dbo.GetImportTypePhaseList
(
	@iImportTypeID SmallInt = Null
)

With Encryption
As

Begin
	Set NoCount On

	-- returns a list of import type phases
	Select IT.ImportTypeID,
		ITP.ImportTypePhaseID,
		ITP.ImportTypePhaseName,
		ITP.Description 
	From dbo.ImportType As IT	
		Inner Join dbo.ImportTypePhase As ITP
			On (IT.ImportTypeID = ITP.ImportTypeID)
	Where (ITP.ImportTypeID = @iImportTypeID Or	@iImportTypeID Is Null)
End
Go
GRANT EXECUTE ON dbo.GetImportTypePhaseList TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportsRunningCount.PRC'
GO

IF OBJECT_ID('dbo.GetImportsRunningCount') IS NOT NULL 
     DROP PROCEDURE dbo.GetImportsRunningCount 
GO 
  
CREATE PROCEDURE dbo.GetImportsRunningCount 
( 
    @oNumImportsRunning INT OUTPUT
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SELECT @oNumImportsRunning = Count(*)
	FROM dbo.ImportJob AS J
		INNER JOIN dbo.ImportJobStatus AS S
			ON (J.ImportJobStatusId = S.ImportJobStatusId)
	WHERE S.ImportJobStatusName = 'RUNNING'
END 
GO 
GRANT EXECUTE ON dbo.GetImportsRunningCount TO CommonImportManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetImportsRunningCount">
 <Procedure>
	Outputs the number of imports running against the system
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryLoadProcessCompleted.PRC'
GO

If Object_Id('dbo.SetImportHistoryLoadProcessCompleted') is not Null 
     Drop Procedure dbo.SetImportHistoryLoadProcessCompleted
Go 
  
Create Procedure dbo.SetImportHistoryLoadProcessCompleted
( 
    @iImportHistoryId Int,
	@iProcessDateCompleted DateTime,
	@iProcessRecordsProcessed Int
) 

With Encryption
As 

Begin
	

    Set NoCount On  
    
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

    
    Update dbo.ImportHistory
    Set ActivePhaseID = Null
    Where ImportHistoryID = @iImportHistoryID
    
	Update dbo.ImportHistoryLoad
	Set ProcessDateCompleted = @iProcessDateCompleted,
		ProcessRecordsProcessed = @iProcessRecordsProcessed
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go	
GRANT EXECUTE ON dbo.SetImportHistoryLoadProcessCompleted TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryLoadProcessStarting.PRC'
GO

If Object_Id('dbo.SetImportHistoryLoadProcessStarting') is not Null 
     Drop Procedure dbo.SetImportHistoryLoadProcessStarting
Go 
  
Create Procedure dbo.SetImportHistoryLoadProcessStarting
( 
    @iImportHistoryId int,
	@iProcessDateStarted DateTime
) 

With Encryption
As 

Begin 
    Declare @ImportTypePhaseID SmallInt
	

    Set NoCount On  

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
    
	Set @ImportTypePhaseID =
		(
			Select P.ImportTypePhaseID
			From dbo.ImportTypePhase As P
				Inner Join dbo.ImportType As T
					On (P.ImportTypeID = T.ImportTypeID)
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
				Inner Join dbo.ImportHistory As IH
					On (I.ImportId = IH.ImportId)
			Where P.ImportTypePhaseName = 'Processing'
				And IH.ImportHistoryID = @iImportHistoryID
		)
	
	Update dbo.ImportHistory
	Set ActivePhaseID = @ImportTypePhaseID
	Where ImportHistoryID = @iImportHistoryID
	
	Update dbo.ImportHistoryLoad
	Set ProcessDateStarted = @iProcessDateStarted
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistoryLoadProcessStarting TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncCompareCompleted.PRC'
GO

If Object_Id('dbo.SetImportHistorysynccomparecompleted') is not Null 
     Drop Procedure dbo.SetImportHistorysynccomparecompleted
Go 
  
Create Procedure dbo.SetImportHistorysynccomparecompleted
( 
    @iImportHistoryId Int,
	@iCompareDateCompleted DateTime,
	@iCompareRecordsInserted Int,
	@iCompareRecordsUpdated Int,
	@iCompareRecordsDeleted Int
) 

With Encryption
As 

Begin 
	

    Set NoCount On  

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

    Update dbo.ImportHistory
    Set ActivePhaseID = Null
    Where ImportHistoryID = @iImportHistoryID

	Update dbo.ImportHistorySync
	Set CompareDateCompleted = @iCompareDateCompleted,
		CompareRecordsInserted = @iCompareRecordsInserted,
		CompareRecordsUpdated = @iCompareRecordsUpdated,
		CompareRecordsDeleted = @iCompareRecordsDeleted
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go	
GRANT EXECUTE ON dbo.SetImportHistorySyncCompareCompleted TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncCompareStarting.PRC'
GO

If Object_Id('dbo.SetImportHistorySyncCompareStarting') is not Null 
     Drop Procedure dbo.SetImportHistorySyncCompareStarting
Go 
  
Create Procedure dbo.SetImportHistorySyncCompareStarting
( 
    @iImportHistoryId Int,
	@iCompareDateStarted DateTime
) 

With Encryption
As 

Begin 
	Declare @ImportTypePhaseID SmallInt
	

    Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @ImportTypePhaseID =
		(
			Select P.ImportTypePhaseID
			From dbo.ImportTypePhase As P
				Inner Join dbo.ImportType As T
					On (P.ImportTypeID = T.ImportTypeID)
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
				Inner Join dbo.ImportHistory As IH
					On (I.ImportId = IH.ImportId)
			Where P.ImportTypePhaseName = 'Comparing'
				And IH.ImportHistoryID = @iImportHistoryID
		)
		    
	Update dbo.ImportHistory
	Set ActivePhaseID = @ImportTypePhaseID
	Where ImportHistoryID = @iImportHistoryID

	Update dbo.ImportHistorySync
	Set CompareDateStarted = @iCompareDateStarted
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go	
GRANT EXECUTE ON dbo.SetImportHistorySyncCompareStarting TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncPrepareCompleted.PRC'
GO

If Object_Id('dbo.SetImportHistorySyncPrepareCompleted') is not Null 
     Drop Procedure dbo.SetImportHistorySyncPrepareCompleted
Go 
  
Create Procedure dbo.SetImportHistorySyncPrepareCompleted
( 
    @iImportHistoryId Int,
	@iPrepareDateCompleted DateTime
) 

With Encryption
As 

Begin 
	

    Set NoCount On  
    
    Set Transaction Isolation Level Repeatable Read
    Begin Transaction

	Update dbo.ImportHistory
	Set ActivePhaseID = Null
	Where ImportHistoryID = @iImportHistoryID

	Update dbo.ImportHistorySync
	Set PrepareDateCompleted = @iPrepareDateCompleted
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistorySyncPrepareCompleted TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncPrepareStarting.PRC'
GO

If Object_Id('dbo.SetImportHistorySyncPrepareStarting') is not Null 
     Drop Procedure dbo.SetImportHistorySyncPrepareStarting 
Go 
  
Create Procedure dbo.SetImportHistorySyncPrepareStarting
( 
    @iImportHistoryId Int,
	@iPrepareDateStarted DateTime
) 

With Encryption
As 

Begin
	Declare @ImportTypePhaseID SmallInt
	

    Set NoCount On  

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @ImportTypePhaseID =
		(
			Select P.ImportTypePhaseID
			From dbo.ImportTypePhase As P
				Inner Join dbo.ImportType As T
					On (P.ImportTypeID = T.ImportTypeID)
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
				Inner Join dbo.ImportHistory As IH
					On (I.ImportId = IH.ImportId)
			Where P.ImportTypePhaseName = 'Preparing'
				And IH.ImportHistoryID = @iImportHistoryID
		)
		
	Update dbo.ImportHistory
	Set ActivePhaseID = @ImportTypePhaseID
	Where ImportHistoryID = @iImportHistoryID

	Update dbo.ImportHistorySync
	Set PrepareDateStarted = @iPrepareDateStarted
	Where ImportHistoryID = @iImportHistoryID
	
	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistorySyncPrepareStarting TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncProcessCompleted.PRC'
GO

If Object_Id('dbo.SetImportHistorySyncProcessCompleted') is not Null 
     Drop Procedure dbo.SetImportHistorySyncProcessCompleted
Go 
  
Create Procedure dbo.SetImportHistorySyncProcessCompleted
( 
    @iImportHistoryID int,
	@iProcessDateCompleted DateTime,
	@iProcessRecordsInserted Int,
	@iProcessRecordsUpdated Int,
	@iProcessRecordsDeleted Int,
	@iProcessRecordsConflicted Int,
	@iProcessRecordsValidationFailures Int,
	@iProcessRecordsException Int
) 

With Encryption
As 

Begin 
	

    Set NoCount On 
    
    Set Transaction Isolation Level Repeatable Read
    Begin Transaction
    
    
    Update dbo.ImportHistory
    Set ActivePhaseID = Null
    Where ImportHistoryID = @iImportHistoryID
    
	Update dbo.ImportHistorySync
	Set ProcessDateCompleted = @iProcessDateCompleted,
		ProcessRecordsInserted = @iProcessRecordsInserted,
		ProcessRecordsUpdated = @iProcessRecordsUpdated,
		ProcessRecordsDeleted = @iProcessRecordsDeleted,
		ProcessRecordsConflicted = @iProcessRecordsConflicted,
		ProcessRecordsValidationFailures = @iProcessRecordsValidationFailures,
		ProcessRecordsException = @iProcessRecordsException
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go	
GRANT EXECUTE ON dbo.SetImportHistorySyncProcessCompleted TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistorySyncProcessStarting.PRC'
GO

If Object_Id('dbo.SetImportHistorySyncProcessStarting') is not Null 
     Drop Procedure dbo.SetImportHistorySyncProcessStarting
Go 
  
Create Procedure dbo.SetImportHistorySyncProcessStarting
( 
    @iImportHistoryID Int,
	@iProcessDateStarted DateTime
) 

With Encryption
As 

Begin 
	Declare @ImportTypePhaseID SmallInt

    Set NoCount On  

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @ImportTypePhaseID =
		(
			Select P.ImportTypePhaseID
			From dbo.ImportTypePhase As P
				Inner Join dbo.ImportType As T
					On (P.ImportTypeID = T.ImportTypeID)
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
				Inner Join dbo.ImportHistory As IH
					On (I.ImportId = IH.ImportId)
			Where P.ImportTypePhaseName = 'Processing'
				And IH.ImportHistoryID = @iImportHistoryID
		)
    
	Update dbo.ImportHistory
	Set ActivePhaseID = @ImportTypePhaseID
	Where ImportHistoryID = @iImportHistoryID

	Update dbo.ImportHistorySync
	Set ProcessDateStarted = @iProcessDateStarted
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistorySyncProcessStarting TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImport.prc'
GO

If Object_Id('dbo.UpdateImport') Is Not Null
	Drop Procedure dbo.UpdateImport
Go

Create Procedure dbo.UpdateImport
(
	@iImportID SmallInt,
	@iUpdateImportName Bit = 0,
	@iImportName VarChar(128) = Null,
	@iUpdateImportGroupID Bit = 0,
	@iImportGroupID SmallInt = Null,
	@iUpdateImportTypeID Bit = 0,
	@iImportTypeID SmallInt = Null,
	@iUpdateDescription Bit = 0,
	@iDescription VarChar(255) = Null,
	@iUpdateIsActive Bit = 0,
	@iIsActive Bit = Null,
	@iUpdateDefaultKillTimeoutMinutes Bit = 0,
	@iDefaultKillTimeoutMinutes SmallInt = Null
)

With Encryption
As

Begin
	Set NoCount On
	
	Update dbo.Import
	Set ImportName = (Case When @iUpdateImportName = 1 Then @iImportName Else ImportName End),
		ImportGroupID = (Case When @iUpdateImportGroupID = 1 Then @iImportGroupID Else ImportGroupID End), 
		ImportTypeID = (Case When @iUpdateImportTypeID = 1 Then @iImportTypeID Else ImportTypeID End),
		Description = (Case When @iUpdateDescription = 1 Then @iDescription Else Description End),
		IsActive = (Case When @iUpdateIsActive = 1 Then @iIsActive Else IsActive End),
		DefaultKillTimeoutMinutes = (Case When @iUpdateDefaultKillTimeoutMinutes = 1 Then @iDefaultKillTimeoutMinutes Else DefaultKillTimeoutMinutes End)
	Where ImportID = @iImportID
End
Go
GRANT EXECUTE ON dbo.UpdateImport TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImportJob.PRC'
GO

If Object_Id('dbo.UpdateImportJob') is not Null 
     Drop Procedure dbo.UpdateImportJob
Go 
  
Create Procedure dbo.UpdateImportJob 
( 
    @iImportJobID Int,
	@iImportJobStatusID SmallInt = NULL,
	@iPriority SmallInt = NULL,
	@iUpdateImportJobStatusID bit = 0,
	@iUpdatePriority bit = 0
) 

With Encryption
As 

Begin



	Declare @Allowed Table
	(
		StateFrom VarChar(31) Collate Database_Default Not Null,
		StateFromID Int,
		StateTo VarChar(31) Collate Database_Default Not Null,
		StateToID Int
	)
	
	Declare @ImportJobStatusIDPending Int
	Declare @ImportJobStatusIDQueued Int
	
	-- TBD (add raiserror calls)
	-- only allow updating of priority for jobs in the PENDING/QUEUED state

	
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	-- TBD - error conditions (add raiserror calls)
	-- only allow updating of Priority for PENDING/QUEUED
	-- only allow updating of JobStatus between the following states
	--   a. PENDING --> QUEUED
	--   b. QUEUED --> PENDING
	--   c. QUEUED --> RUNNING
	--   d. RUNNING --> SUCCEEDED
	--   e. RUNNING --> FAILED
	--   f. RUNNING --> KILLED
	--   g. RUNNING --> UNKNOWN
	--   h. UNKNOWN --> SUCCESSFUL
	--   i. UNKNOWN --> FAILED
	
	Insert Into @Allowed
	(
		StateFrom, StateTo
	)
	Select 'PENDING', 'QUEUED'
	Union All
	Select 'QUEUED', 'PENDING'
	Union All
	Select 'QUEUED', 'RUNNING'
	Union All
	Select 'RUNNING', 'SUCCEEDED'
	Union All
	Select 'RUNNING', 'FAILED'
	Union All
	Select 'RUNNING', 'KILLED'
	Union All
	Select 'RUNNING', 'UNKNOWN'
	Union All
	Select 'UNKNOWN', 'SUCCESSFUL'
	Union All
	Select 'UNKNOWN', 'FAILED'
	
		
	Select @ImportJobStatusIDPending = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'PENDING'

	Select @ImportJobStatusIDQueued = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'QUEUED'
	
	Update A
	Set StateFromID =
		(
			Select ImportJobStatusID
			From dbo.ImportJobStatus
			Where ImportJobStatusName = A.StateFrom
		),
		StateToID =
		(
			Select ImportJobStatusID
			From dbo.ImportJobStatus
			Where ImportJobStatusName = A.StateTo
		)
	From @Allowed A
	
	
	
	If		(
			Exists (
						Select Top 1 * 
						From dbo.ImportJob 
						Where ImportJobID = @iImportJobID 
							And	ImportJobStatusID In (@ImportJobStatusIDPending,@ImportJobStatusIDQueued)
					)
			Or @iUpdatePriority = 0
			) 
		And 
			(
			Exists (
						Select Top 1 1
						From dbo.ImportJob I
							Inner Join @ALLOWED As A
								On (A.StateFromID = I.ImportJobStatusID)
						Where I.ImportJobID = @iImportJobID
							And A.StateToID = @iImportJobStatusID
					)
			Or @iUpdateImportJobStatusID = 0
			)										
	Begin	
		Update I 
		Set ImportJobStatusID =
				Case 
					When @iUpdateImportJobStatusID = 1 Then 
						@iImportJobStatusID 
					Else 
						ImportJobStatusID 
				End,
			Priority =
				Case 
					When @iUpdatePriority = 1 Then 
						@iPriority 
					Else 
						Priority 
				End
		From dbo.ImportJob As I
		Where ImportJobID = @iImportJobID
	  
		-- Audit Trail
		-- If the Import Job Status is being updated 
		-- we need to write history record 
		If @iUpdateImportJobStatusID = 1
		Begin
			Exec dbo.AddImportJobStatushistory
				@iImportJobID = @iImportJobID,
				@iImportJobStatusID = @iImportJobStatusID 
		End
	End
	Else
	Begin
				RaisError('The jobid:%d is not in the correct state.',
        16, 1, @iImportJobID)
	End
	

    Commit Transaction 
End 
Go	
GRANT EXECUTE ON dbo.UpdateImportJob TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImportJobParameter.PRC'
GO

If Object_Id('dbo.UpdateImportJobParameter') is not Null 
     Drop Procedure dbo.UpdateImportJobParameter
Go 
  
Create Procedure dbo.UpdateImportJobParameter 
( 
    @iImportJobID Int,
	@iImportParameterID Int,
	@iParameterValue VarChar(1023) = Null
) 

With Encryption
As 

Begin
	Declare @ImportJobStatusIDPending Int
	Declare @ImportJobStatusIDQueued Int
    Set NoCount On 
    
    Select @ImportJobStatusIDPending = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'PENDING'
	
	
	Select @ImportJobStatusIDQueued = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'QUEUED'
 
	-- TBD (add raiserror calls)
	-- only allow updating of parameters for jobs in the PENDING state 
	If Exists	(
					Select Top 1 * 
					From dbo.ImportJobParameter P
						Inner Join dbo.ImportJob J
							On J.ImportJobID = P.ImportJobID
					Where J.ImportJobID = @iImportJobID 
						And	J.ImportJobStatusID In (@ImportJobStatusIDPending,
														@ImportJobStatusIDQueued)
				)
	Begin
	Update dbo.ImportJobParameter 
	Set ParameterValue = @iParameterValue
	Where ImportParameterID = @iImportParameterID
		And ImportJobID = @iImportJobID
	End
	Else
	Begin
			RaisError('The jobid:%d is not in the pending state.',
        16, 1, @iImportJobID)
	End
End 
Go	
GRANT EXECUTE ON dbo.UpdateImportJobParameter TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImportParameter.PRC'
GO

If Object_Id('dbo.UpdateImportParameter') is not Null 
     Drop Procedure dbo.UpdateImportParameter
Go 
  
Create Procedure dbo.UpdateImportParameter 
( 
    @iImportID	smallint,
    @iImportParameterID smallint,
    @iUpdateImportParameterDisplayName bit = 0,
    @iDisplayName	varchar(255) = NULL,
    @iUpdateImportParameterIsRequired bit = 0,
    @iIsRequired	bit = Null,
    @iUpdateImportParameterDefaultParameterValue bit = 0,
    @iDefaultParameterValue varchar(512) = NULL,
    @iUpdateImportParameterOrderNo bit = 0,
    @iOrderNo smallint = NULL,
    @iUpdateImportParameterIsVisible bit = 0,
    @iIsVisible bit = NULL,
    @iUpdateImportParameterIsEnabled bit = 0,
    @iIsEnabled bit = NULL
) 

With Encryption
As 

Begin 

    Set NoCount On 
  
	-- If OrderNo is changed ensure that there is not another
	-- record with the same OrderNo for this @iImportID
	If @iUpdateImportParameterOrderNo = 1 
		And Exists (Select 1
					From dbo.ImportParameter As IP
					Where IP.ImportID = @iImportID
						And IP.OrderNo = @iOrderNo)
	Begin
		RaisError('Parameter with this OrderNo already exists for this Import.', 16, 1)
	End
	Else
	Begin
		Update IP 
		Set DisplayName =
				Case 
					When @iUpdateImportParameterDisplayName = 1 Then 
						@iDisplayName 
					Else 
						DisplayName 
				End,
			IsRequired =
				Case 
					When @iUpdateImportParameterIsRequired = 1 Then 
						@iIsRequired
					Else 
						IsRequired 
				End,
			DefaultParameterValue =
				Case 
					When @iUpdateImportParameterDefaultParameterValue = 1 Then 
						@iDefaultParameterValue
					Else 
						DefaultParameterValue 
				End,
			OrderNo =
				Case 
					When @iUpdateImportParameterOrderNo = 1 Then 
						@iOrderNo
					Else 
						OrderNo 
				End,
			IsVisible =
				Case 
					When @iUpdateImportParameterIsVisible = 1 Then 
						@iIsVisible 
					Else 
						IsVisible 
				End,
			IsEnabled =
				Case 
					When @iUpdateImportParameterIsEnabled = 1 Then 
						@iIsEnabled
					Else 
						IsEnabled 
				End
		From dbo.ImportParameter As IP
		Where ImportID = @iImportID
			And ImportParameterID = @iImportParameterID
	End
  
End 
Go	
GRANT EXECUTE ON dbo.UpdateImportParameter TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportStatusList.PRC'
GO

 If Object_Id('dbo.GetImportStatusList') is not Null 
     Drop Procedure dbo.GetImportStatusList 
Go 
  
Create Procedure dbo.GetImportStatusList
(
	@iImportJobStatusName Varchar (31) = Null
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ImportJobStatusID,
			ImportJobStatusName,
			Description
	From dbo.ImportJobStatus
	Where ImportJobStatusName = @iImportJobStatusName
	Or @iImportJobStatusName Is Null

End 
Go
GRANT EXECUTE ON dbo.GetImportStatusList TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImportJobPriority.prc'
GO

If Object_Id('dbo.UpdateImportJobPriority') Is Not Null
	Drop Procedure dbo.UpdateImportJobPriority
Go

Create Procedure dbo.UpdateImportJobPriority
(
	@iImportJobID Int,
	@iPriority SmallInt
)

With Encryption
As

Begin
	Set NoCount On

	Declare @ImportJobStatusIDPending Int
	Declare @ImportJobStatusIDQueued Int
	
	-- TBD (add raiserror calls)
	-- only allow updating of priority for jobs in the PENDING/QUEUED state
	
	Select @ImportJobStatusIDPending = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'PENDING'

	Select @ImportJobStatusIDQueued = ImportJobStatusID
	From dbo.ImportJobStatus Where ImportJobStatusName = 'QUEUED'
	
	If Exists	(
					Select Top 1 * 
					From dbo.ImportJob 
					Where ImportJobID = @iImportJobID 
						And ImportJobStatusID In (@ImportJobStatusIDQueued,@ImportJobStatusIDPending)
				)
	Begin
	Update dbo.ImportJob
	Set Priority = @iPriority
	Where ImportJobID = @iImportJobID
	End
	Else
	Begin
		RaisError('The jobid:%d is not in the pending or queued state.',
        16, 1, @iImportJobID)
	End
End
Go


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.UpdateImportJobStatus.prc'
GO

If Object_Id('dbo.UpdateImportJobStatus') Is Not Null
	Drop Procedure dbo.UpdateImportJobStatus
Go

Create Procedure dbo.UpdateImportJobStatus
(
	@iImportJobID Int,
	@iImportJobStatusID SmallInt
)

With Encryption
As

Begin

	Declare @Allowed Table
	(
		StateFrom VarChar(31) Collate Database_Default Not Null,
		StateFromID Int,
		StateTo VarChar(31) Collate Database_Default Not Null,
		StateToID Int
	)
	
	Set NoCount On
	
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
	
	-- set up a list of valid from/to states
	
	Insert Into @Allowed
	(
		StateFrom, StateTo
	)
	Select 'PENDING', 'QUEUED'
	Union All
	Select 'QUEUED', 'PENDING'
	Union All
	Select 'QUEUED', 'RUNNING'
	Union All
	Select 'RUNNING', 'SUCCEEDED'
	Union All
	Select 'RUNNING', 'FAILED'
	Union All
	Select 'RUNNING', 'KILLED'
	Union All
	Select 'RUNNING', 'UNKNOWN'
	Union All
	Select 'UNKNOWN', 'SUCCESSFUL'
	Union All
	Select 'UNKNOWN', 'FAILED'
	
	-- Determine the job status id values of each state from the dbo.ImportJobStatus table.
	Update A
	Set StateFromID =
		(
			Select ImportJobStatusID
			From dbo.ImportJobStatus
			Where ImportJobStatusName = A.StateFrom
		),
		StateToID =
		(
			Select ImportJobStatusID
			From dbo.ImportJobStatus
			Where ImportJobStatusName = A.StateTo
		)
	From @Allowed A
	
	-- if the state change is valid, then allow the update to occur
	-- otherwise, throw an error
	
	If Exists
		(
			Select Top 1 1
			From dbo.ImportJob I
				Inner Join @Allowed As A
					On (A.StateFromID = I.ImportJobStatusID)
			Where I.ImportJobID = @iImportJobID
				And A.StateToID = @iImportJobStatusID
		)
	Begin
		Update dbo.ImportJob
		Set ImportJobStatusID = @iImportJobStatusID
		Where ImportJobID = @iImportJobID
	
		-- add the job status history record
		Exec dbo.AddImportJobStatushistory
			@iImportJobID = @iImportJobID,
			@iImportJobStatusID = @iImportJobStatusID
	End
	Else
	Begin
		RaisError('The jobid:%d is not in the correct state.', 16, 1, @iImportJobID)
	End
	
	Commit Transaction
End
Go


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryCompleted.prc'
GO

If Object_ID('dbo.SetImportHistoryCompleted') Is Not Null
	Drop Procedure dbo.SetImportHistoryCompleted
Go

Create Procedure dbo.SetImportHistoryCompleted
(
	@iImportHistoryId Int,
	@iJobDateCompleted DateTime,
	@iSuccessFlag Bit,
	@iInternalMessages VarChar(Max)
)
With Encryption 
As
Begin
	Set NoCount On
	
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
	
	Update dbo.ImportHistory
	Set JobDateCompleted = @iJobDateCompleted,
		SuccessFlag = @iSuccessFlag,
		InternalMessages = @iInternalMessages
	Where ImportHistoryId = @iImportHistoryId

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.SetImportHistoryCompleted TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryLoadPrepareCompleted.PRC'
GO

If Object_Id('dbo.SetImportHistoryLoadPrepareCompleted') is not Null 
     Drop Procedure dbo.SetImportHistoryLoadPrepareCompleted
Go 
  
Create Procedure dbo.SetImportHistoryLoadPrepareCompleted
( 
    @iImportHistoryId Int,
	@iLoadDateCompleted DateTime,
	@iLoadRecordsLoaded Int
) 

With Encryption
As 

Begin 
	

    Set NoCount On
    
    Set Transaction Isolation Level Repeatable Read
    Begin Transaction
    
    Update dbo.ImportHistory
    Set ActivePhaseID = Null
    Where ImportHistoryID = @iImportHistoryID
    
	Update dbo.ImportHistoryLoad
	Set LoadDateCompleted = @iLoadDateCompleted,
		LoadRecordsLoaded = @iLoadRecordsLoaded
	Where ImportHistoryID = @iImportHistoryID

	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistoryLoadPrepareCompleted TO CommonImportManager



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryLoadPrepareStarting.PRC'
GO

If Object_Id('dbo.SetImportHistoryLoadPrepareStarting') is not Null 
     Drop Procedure dbo.SetImportHistoryLoadPrepareStarting 
Go 
  
Create Procedure dbo.SetImportHistoryLoadPrepareStarting
( 
    @iImportHistoryId Int,
	@iLoadDateStarted DateTime
) 

With Encryption
As 

Begin 
    Declare @ImportTypePhaseID SmallInt
	
    
    Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @ImportTypePhaseID =
		(
			Select P.ImportTypePhaseID
			From dbo.ImportTypePhase As P
				Inner Join dbo.ImportType As T
					On (P.ImportTypeID = T.ImportTypeID)
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
				Inner Join dbo.ImportHistory As IH
					On (I.ImportId = IH.ImportId)
			Where P.ImportTypePhaseName = 'Preparing'
				And IH.ImportHistoryID = @iImportHistoryID
		)


    Update dbo.ImportHistory
    Set ActivePhaseID = @ImportTypePhaseID
    Where ImportHistoryID = @iImportHistoryID
    
	Update dbo.ImportHistoryLoad
	Set LoadDateStarted = @iLoadDateStarted
	Where ImportHistoryID = @iImportHistoryID
	
	Commit Transaction
End 
Go
GRANT EXECUTE ON dbo.SetImportHistoryLoadPrepareStarting TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.SetImportHistoryStarting.prc'
GO

If Object_ID('dbo.SetImportHistoryStarting') Is Not Null
	Drop Procedure dbo.SetImportHistoryStarting
Go

Create Procedure dbo.SetImportHistoryStarting
(
	@ioImportHistoryID Int Output,
	@iImportId Int,
	@iImportJobId Int,
	@iCommandLine VarChar(Max),
	@iJobDateStarted DateTime
)
With Encryption 
As
Begin
	
	Declare @ImportTypeName VarChar(128)
	Declare @ImportJobStatusID SmallInt

    Set NoCount On  

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- remove existing job history records for this job
	-- really, they shouldn't be in there
	-- there should be a 1:1 relationship between jobs and the history

	If @ioImportHistoryID Is Not Null
	Begin
		Delete
		From dbo.ImportHistorySync
		Where ImportHistoryID = @ioImportHistoryID
		
		Delete
		From dbo.ImportHistoryLoad
		Where ImportHistoryID = @ioImportHistoryID

		Delete
		From dbo.ImportHistory
		Where ImportHistoryID = @ioImportHistoryID
	End
	
	-- create the new job history record
	Insert Into dbo.ImportHistory
	(
		CommandLine,ImportId,ImportJobId, ActivePhaseID, JobDateStarted, JobDateCompleted,
		SuccessFlag, InternalMessages
	)
	Values
	(
		@iCommandLine,@iImportId,@iImportJobId, Null, @iJobDateStarted, Null,
		Null, Null
	)
	
	Set @ioImportHistoryID = Scope_Identity()

	-- create the new specific record (based on the import type)
	
	Set @ImportTypeName =
		(
			Select T.ImportTypeName
			From dbo.ImportType As T
				Inner Join dbo.Import As I
					On (T.ImportTypeID = I.ImportTypeID)
			Where I.ImportId = @iImportId
		)
		
	If @ImportTypeName = 'SYNC'
	Begin
		Insert Into dbo.ImportHistorySync
		(
			ImportHistoryID, PrepareDateStarted, PrepareDateCompleted,
			CompareDateStarted, CompareDateCompleted,
			CompareRecordsInserted, CompareRecordsUpdated, CompareRecordsDeleted,
			ProcessDateStarted, ProcessDateCompleted,
			ProcessRecordsInserted, ProcessRecordsUpdated, ProcessRecordsDeleted,
			ProcessRecordsConflicted, ProcessRecordsValidationFailures
		)
		Values
		(
			@ioImportHistoryID, Null, Null,
			Null, Null,
			Null, Null, Null,
			Null, Null,
			Null, Null, Null,
			Null, Null
		)
	End
	Else If @ImportTypeName = 'LOAD'
	Begin
		Insert Into dbo.ImportHistoryLoad
		(
			ImportHistoryID,
			LoadDateStarted, LoadDateCompleted, LoadRecordsLoaded,
			ProcessDateStarted, ProcessDateCompleted, ProcessRecordsProcessed
		)
		Values
		(
			@ioImportHistoryID,
			Null, Null, Null,
			Null, Null, Null
		)
	End
		
	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.SetImportHistoryStarting TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncChangedField.prc'
GO

If Object_Id('dbo.AddImportSyncChangedField') Is Not Null
	Drop Procedure dbo.AddImportSyncChangedField
Go

Create Procedure dbo.AddImportSyncChangedField
(
	@iImportSyncQueueId BigInt,
	@iChangedField VarChar(255)
	
)

With Encryption
As

Begin

Insert into dbo.[ImportSyncChangedField]
(
	ImportSyncQueueId, ChangedField
)
Values
(
	@iImportSyncQueueId, @iChangedField
)

End
Go
GRANT EXECUTE ON dbo.AddImportSyncChangedField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncConflict.prc'
GO

If Object_Id('dbo.AddImportSyncConflict') Is Not Null
Drop Procedure dbo.AddImportSyncConflict
Go

Create Procedure dbo.AddImportSyncConflict
(
	@iImportSyncQueueId BigInt,
	@iUserMessage VarChar(Max),
	@iInternalMessage VarChar(Max),
	@oImportSyncConflictId BigInt Output
	
)

With Encryption
As
Begin

	Insert Into dbo.ImportSyncConflict
	(
		ImportSyncQueueId, UserMessage, InternalMessage
	)
	Values
	(
		@iImportSyncQueueId, @iUserMessage, @iInternalMessage
	)
	
	Select @oImportSyncConflictId = Scope_Identity()
		

End
Go
GRANT EXECUTE ON dbo.AddImportSyncConflict TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncConflictField.prc'
GO

If Object_Id('dbo.AddImportSyncConflictField') Is Not Null
Drop Procedure dbo.AddImportSyncConflictField
Go

Create Procedure dbo.AddImportSyncConflictField
(
	@iImportSyncConflictId BigInt,
	@iField VarChar(255)
)

With Encryption
As
Begin

	Insert Into dbo.ImportSyncConflictField
	(
		ImportSyncConflictId, Field
	)
	Values
	(
		@iImportSyncConflictId, @iField
	)

End
Go
GRANT EXECUTE ON dbo.AddImportSyncConflictField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncQueue.prc'
GO

If Object_Id('dbo.AddImportSyncQueue') Is Not Null
	Drop Procedure dbo.AddImportSyncQueue
Go

Create Procedure dbo.AddImportSyncQueue
(
	@iImportSyncRowId BigInt,
	@iOrderNo BigInt,
	@iIsPending Bit,
	@iSyncAction Char(1),
	@iImportSyncTableId SmallInt,
	@iImportId SmallInt,
	@iInitialComparedDateTime DateTime,
	@iLastProcessedDateTime DateTime,
	@iInitialCompareImportJobId SmallInt,
	@iLastProcessImportJobId SmallInt,
	@oImportSyncQueueId BigInt Output
	
)

With Encryption
As

Begin


Insert Into dbo.[ImportSyncQueue]
(
	ImportSyncRowId,OrderNo,IsPending,SyncAction,ImportSyncTableId, ImportId,			InitialComparedDateTime, LastProcessedDateTime,InitialCompareImportJobId, LastProcessImportJobId
)
Values
(
	@iImportSyncRowId,@iOrderNo,@iIsPending,@iSyncAction, @iImportSyncTableId, @iImportId,
	@iInitialComparedDateTime,@iLastProcessedDateTime,@iInitialCompareImportJobId,@iLastProcessImportJobId
)

Set @oImportSyncQueueId = Scope_Identity()

End
Go
GRANT EXECUTE ON dbo.AddImportSyncQueue TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncRelationship.prc'
GO

 If Object_Id('dbo.AddImportSyncRelationship') Is Not Null
	Drop Procedure dbo.AddImportSyncRelationship
Go

Create Procedure dbo.AddImportSyncRelationship
(
	@iImportSyncRowId BigInt,
	@iParentImportSyncRowId BigInt,
	@iIsCurrent Bit
)
With Encryption
As
Begin

Insert Into dbo.ImportSyncRelationship
(
	ImportSyncRowId, ParentImportSyncRowId, IsCurrent	
)
Values
(
	@iImportSyncRowId,@iParentImportSyncRowId,@iIsCurrent
)

End
Go
GRANT EXECUTE ON dbo.AddImportSyncRelationship TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncRow.prc'
GO

If Object_Id('dbo.AddImportSyncRow') Is Not Null
	Drop Procedure dbo.AddImportSyncRow
Go

Create Procedure dbo.AddImportSyncRow
(
	@iImportId SmallInt,
	@iImportSyncTableId SmallInt,
	@iIsCurrent Bit,
	@iSourceRow Xml,
	@iDestinationRow Xml,
	@iIsUpdated Bit,
	@iIsDeleted Bit,
	@iPreviousImportSyncRowId BigInt,
	@iRootImportSyncRowId BigInt,
	@oImportSyncRowId BigInt Output
	
)

With Encryption
As

Begin

	Insert Into dbo.[ImportSyncRow]
	(
		ImportId, ImportSyncTableId, IsCurrent, SourceRow, DestinationRow, IsUpdated, IsDeleted, PreviousImportSyncRowId, RootImportSyncRowId
	)
	Values
	(
		@iImportId, @iImportSyncTableId, @iIsCurrent, @iSourceRow, @iDestinationRow, @iIsUpdated, @iIsDeleted, @iPreviousImportSyncRowId, @iRootImportSyncRowId
	)

	Set @oImportSyncRowId = Scope_Identity()

	If @iRootImportSyncRowId < 0
	Begin
	Update dbo.[ImportSyncRow]
		Set RootImportSyncRowId = @oImportSyncRowId
	Where ImportSyncRowId = @oImportSyncRowId
	End

End
Go
GRANT EXECUTE ON dbo.AddImportSyncRow TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncValidate.prc'
GO

If Object_Id('dbo.AddImportSyncValidate') Is Not Null
Drop Procedure dbo.AddImportSyncValidate
Go

Create Procedure dbo.AddImportSyncValidate
(
	@iImportSyncQueueId BigInt,
	@iUserMessage VarChar(Max),
	@iInternalMessage VarChar(Max),
	@oImportSyncValidateId BigInt Output
	
)

With Encryption
As
Begin

	Insert Into dbo.ImportSyncValidate
	(
		ImportSyncQueueId, UserMessage, InternalMessage
	)
	Values
	(
		@iImportSyncQueueId, @iUserMessage, @iInternalMessage
	)
	
	Select @oImportSyncValidateId = Scope_Identity()
		

End
Go
GRANT EXECUTE ON dbo.AddImportSyncValidate TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.AddImportSyncValidateField.prc'
GO

If Object_Id('dbo.AddImportSyncValidateField') Is Not Null
Drop Procedure dbo.AddImportSyncValidateField
Go

Create Procedure dbo.AddImportSyncValidateField
(
	@iImportSyncValidateId BigInt,
	@iField VarChar(255)
)

With Encryption
As
Begin

	Insert Into dbo.ImportSyncValidateField
	(
		ImportSyncValidateId, Field
	)
	Values
	(
		@iImportSyncValidateId, @iField
	)

End
Go
GRANT EXECUTE ON dbo.AddImportSyncValidateField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.DeleteImportSyncChangedField.prc'
GO

If Object_Id('dbo.DeleteImportSyncChangedField') Is Not Null
Drop Procedure dbo.DeleteImportSyncChangedField
Go

Create Procedure dbo.DeleteImportSyncChangedField
(
	@iImportSyncQueueId BigInt,
	@iChangedField VarChar(255)
	
)

With Encryption
As

Begin

Delete From dbo.[ImportSyncChangedField]
Where ImportSyncQueueId = @iImportSyncQueueId
	And ChangedField = @iChangedField

End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncChangedField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.DeleteImportSyncConflict.prc'
GO

If Object_Id('dbo.DeleteImportSyncConflict') Is Not Null
Drop Procedure dbo.DeleteImportSyncConflict
Go

Create Procedure dbo.DeleteImportSyncConflict
(
	@iImportSyncQueueId BigInt
	
)

With Encryption
As
Begin

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteImportSyncConflict',
		@TransactionCount = @@TranCount 


	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		EXEC dbo.DeleteImportSyncConflictField @iImportSyncQueueId
	
		Delete 
		From dbo.ImportSyncConflict
		Where ImportSyncQueueId = @iImportSyncQueueId
	
			-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH

End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncConflict TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.DeleteImportSyncConflictField.prc'
GO

If Object_Id('dbo.DeleteImportSyncConflictField') Is Not Null
Drop Procedure dbo.DeleteImportSyncConflictField
Go

Create Procedure dbo.DeleteImportSyncConflictField
(
	@iImportSyncQueueId BigInt
	
)

With Encryption
As
Begin

	Delete ISCF
	From dbo.ImportSyncConflictField As ISCF
		Inner Join dbo.ImportSyncConflict As ISC
			On ISCF.ImportSyncConflictId = ISC.ImportSyncConflictId
	Where ImportSyncQueueId = @iImportSyncQueueId

End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncConflictField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.DeleteImportSyncValidate.prc'
GO

If Object_Id('dbo.DeleteImportSyncValidate') Is Not Null
Drop Procedure dbo.DeleteImportSyncValidate
Go

Create Procedure dbo.DeleteImportSyncValidate
(
	@iImportSyncQueueId BigInt
	
)

With Encryption
As
Begin

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteImportSyncValidate',
		@TransactionCount = @@TranCount 


	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		EXEC dbo.Deleteimportsyncvalidatefield @iImportSyncQueueId
	
		Delete 
		From dbo.ImportSyncValidate
		Where ImportSyncQueueId = @iImportSyncQueueId
	
			-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncValidate TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.DeleteImportSyncValidateField.prc'
GO

If Object_Id('dbo.DeleteImportSyncValidateField') Is Not Null
Drop Procedure dbo.DeleteImportSyncValidateField
Go

Create Procedure dbo.DeleteImportSyncValidateField
(
	@iImportSyncQueueId BigInt
	
)

With Encryption
As
Begin

	Delete ISVF
	From dbo.ImportSyncValidateField As ISVF
		Inner Join dbo.ImportSyncValidate As ISV
			On ISVF.ImportSyncValidateId = ISV.ImportSyncValidateId
	Where ImportSyncQueueId = @iImportSyncQueueId

End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncValidateField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportCurrentOrderNo.prc'
GO

If Object_Id('dbo.GetImportCurrentOrderNo') Is Not Null 
     Drop Procedure dbo.GetImportCurrentOrderNo
Go 
  
Create Procedure dbo.GetImportCurrentOrderNo
(
	@iImportId SmallInt
)
With Encryption
As
 
Begin 

	Declare @OrderNo Int
	Set @OrderNo = 0

    Set NoCount On 
    
    Select @OrderNo = Coalesce(Max(OrderNo),0)
    From dbo.ImportSyncQueue As ISQ
    Where ImportId = @iImportId
    
    Select @OrderNo
    
End
Go
GRANT EXECUTE ON dbo.GetImportCurrentOrderNo TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportIdFromName.prc'
GO

 If Object_Id('dbo.GetImportIdFromName') is not null
	Drop Procedure dbo.GetImportIdFromName
Go

Create Procedure dbo.GetImportIdFromName
(
	@iImportName VarChar(128)
) 

With Encryption
As

Begin

	Select ImportId
	From dbo.Import
	Where ImportName = @iImportName
End
Go
GRANT EXECUTE ON dbo.GetImportIdFromName TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncChangedField.prc'
GO

    If Object_Id('dbo.GetImportSyncChangedField') Is Not Null 
     Drop Procedure dbo.GetImportSyncChangedField
Go 
  
Create Procedure dbo.GetImportSyncChangedField
(
	@iImportId SmallInt,
	@iIsPending Bit = Null
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ISCF.ImportSyncQueueId,
		ISCF.ChangedField
	From dbo.ImportSyncQueue As ISQ
		Inner Join dbo.ImportSyncRow As ISR
			On ISR.ImportSyncRowId = ISQ.ImportSyncRowId
		Inner Join dbo.ImportSyncChangedField As ISCF
			On ISQ.ImportSyncQueueId = ISCF.ImportSyncQueueId
	Where ISR.ImportId = @iImportId
		And (ISQ.IsPending = @iIsPending Or @iIsPending Is Null)
	Order By ISQ.OrderNo Desc

End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncChangedField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncChangedFieldBySyncQueueId.prc'
GO

 If Object_Id('dbo.GetImportSyncChangedFieldBySyncQueueId') Is Not Null
	Drop Procedure dbo.GetImportSyncChangedFieldBySyncQueueId
Go

Create Procedure dbo.GetImportSyncChangedFieldBySyncQueueId
(
	@iImportSyncQueueId BigInt
)

With Encryption
As

Begin

Select ImportSyncQueueId, ChangedField
From dbo.ImportSyncChangedField
Where ImportSyncQueueId = @iImportSyncQueueId

End
Go
GRANT EXECUTE ON dbo.GetImportSyncChangedFieldBySyncQueueId TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncChildRows.prc'
GO

If Object_Id('dbo.GetImportSyncChildRows') Is Not Null 
     Drop Procedure dbo.GetImportSyncChildRows 
Go 

Create Procedure dbo.GetImportSyncChildRows
(
	@iImportSyncRowId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On
    
	Select ISR.*, IST.Name As TableName, ISQ.IsPending, ISQ.SyncAction, 
			Coalesce(ISC.ConflictCount,0) As ConflictCount,
			Coalesce(ISV.ValidateCount,0) As ValidateCount
	From dbo.ImportSyncRelationship As ISRE
		Inner Join dbo.ImportSyncRow As ISR
			On ISR.ImportSyncRowId = ISRE.ImportSyncRowId
		Inner Join dbo.ImportSyncTable As IST
			On IST.ImportSyncTableId = ISR.ImportSyncTableId
			And IST.ImportId = ISR.ImportId
		Inner Join dbo.ImportSyncQueue As ISQ
			On ISQ.ImportSyncRowId = ISR.ImportSyncRowId
		Left Join 
			( 
			Select Count(*) As ValidateCount, ImportSyncQueueId
			From dbo.ImportSyncValidate
			Group By ImportSyncQueueId
			) As ISV
			On ISV.ImportSyncQueueId = ISQ.ImportSyncQueueId
		Left Join 
			( 
			Select Count(*) As ConflictCount, ImportSyncQueueId
			From dbo.ImportSyncConflict
			Group By ImportSyncQueueId
			) As ISC
			On ISC.ImportSyncQueueId = ISQ.ImportSyncQueueId
		Inner Join
			(
			Select Max(ImportSyncQueueId) As ImportSyncQueueId, ImportSyncRowId
			From dbo.ImportSyncQueue
			Group By ImportSyncRowId
			) As VW
			On VW.ImportSyncQueueID = ISQ.ImportSyncQueueID
			And VW.ImportSyncRowId = ISR.ImportSyncRowId
	Where ISRE.IsCurrent = 1
		And @iImportSyncRowId = ISRE.ParentImportSyncRowId
    
End
Go
GRANT EXECUTE ON dbo.GetImportSyncChildRows TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncConflict.prc'
GO

  If Object_Id('dbo.GetImportSyncConflict') Is Not Null 
     Drop Procedure dbo.GetImportSyncConflict
Go 
  
Create Procedure dbo.GetImportSyncConflict
(
	@iImportSyncQueueId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ISC.ImportSyncConflictId,
		ISC.ImportSyncQueueId,
		ISC.UserMessage,
		ISC.InternalMessage
	From dbo.ImportSyncConflict As ISC
	Where ImportSyncQueueId = @iImportSyncQueueId

End 
Go	 
GRANT EXECUTE ON dbo.GetImportSyncConflict TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncConflictField.prc'
GO

   If Object_Id('dbo.GetImportSyncConflictField') Is Not Null 
     Drop Procedure dbo.GetImportSyncConflictField
Go 
  
Create Procedure dbo.GetImportSyncConflictField
(
	@iImportSyncQueueId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ISCF.ImportSyncConflictId,
		ISCF.Field
	From dbo.ImportSyncConflict As ISC
		Inner Join dbo.ImportSyncConflictField As ISCF
			On ISCF.ImportSyncConflictId = ISC.ImportSyncConflictId
	Where @iImportSyncQueueId = ISC.ImportSyncQueueId

End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncConflictField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncParentRows.prc'
GO

If Object_Id('dbo.GetImportSyncParentRows') Is Not Null 
     Drop Procedure dbo.GetImportSyncParentRows 
Go 

Create Procedure dbo.GetImportSyncParentRows
(
	@iImportSyncRowId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On


	Select ISR.*, IST.Name As TableName, ISQ.IsPending, 
		ISQ.SyncAction, Coalesce(ISC.ConflictCount,0) As ConflictCount , 
		Coalesce(ISV.ValidateCount,0) As ValidateCount
	From dbo.ImportSyncRelationship As ISRE
		Inner Join dbo.ImportSyncRow As ISR
			On ISRE.ParentImportSyncRowId = ISR.ImportSyncRowId
		Inner Join dbo.ImportSyncTable As IST
			On IST.ImportSyncTableId = ISR.ImportSyncTableId
			And IST.ImportId = ISR.ImportId
		Inner Join dbo.ImportSyncQueue As ISQ
			On ISQ.ImportSyncRowId = ISR.ImportSyncRowId
		Left Join 
			( 
			Select Count(*) As ValidateCount, ImportSyncQueueId
			From dbo.ImportSyncValidate
			Group By ImportSyncQueueId
			) As ISV
			On ISV.ImportSyncQueueId = ISQ.ImportSyncQueueId
		Left Join 
			( 
			Select Count(*) As ConflictCount, ImportSyncQueueId
			From dbo.ImportSyncConflict
			Group By ImportSyncQueueId
			) As ISC
			On ISC.ImportSyncQueueId = ISQ.ImportSyncQueueId
		Inner Join
			(
			Select Max(ImportSyncQueueId) As ImportSyncQueueId, ImportSyncRowId
			From dbo.ImportSyncQueue
			Group By ImportSyncRowId
			) As VW
			On VW.ImportSyncQueueID = ISQ.ImportSyncQueueID
			And VW.ImportSyncRowId = ISR.ImportSyncRowId
	Where ISRE.IsCurrent = 1
		And @iImportSyncRowId = ISRE.ImportSyncRowId


End
Go
GRANT EXECUTE ON dbo.GetImportSyncParentRows TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncQueue.prc'
GO

 If Object_Id('dbo.GetImportSyncQueue') Is Not Null 
     Drop Procedure dbo.GetImportSyncQueue 
Go 
  
Create Procedure dbo.GetImportSyncQueue
(
	@iImportId SmallInt,
	@iIsPending Bit = Null
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ISQ.ImportSyncQueueId,
		ISQ.ImportSyncRowId,
		ISQ.ImportSyncTableId,
		ISQ.IsPending,
		ISQ.OrderNo,
		ISQ.SyncAction,
		ISQ.InitialComparedDateTime,
		ISQ.LastProcessedDateTime,
		ISQ.InitialCompareImportJobId,
		ISQ.LastProcessImportJobId,
		ISQ.ImportId		
	From dbo.ImportSyncQueue As ISQ
	Where ISQ.ImportId = @iImportId
		And (ISQ.IsPending = @iIsPending Or @iIsPending Is Null)
	Order By ISQ.OrderNo Desc

End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncQueue TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncRelationship.prc'
GO

IF OBJECT_ID('dbo.GetImportSyncRelationship') IS NOT NULL 
     DROP PROCEDURE dbo.GetImportSyncRelationship 
GO 
  
CREATE PROCEDURE dbo.GetImportSyncRelationship
(
	@iImportId SMALLINT,
	@iIsCurrent BIT
)
WITH ENCRYPTION
AS
BEGIN
	SELECT isre.ImportSyncRowId,
		isre.ParentImportSyncRowId,
		isre.IsCurrent
	FROM dbo.ImportSyncRelationship AS isre
		INNER JOIN dbo.ImportSyncRow AS isr
			ON (isr.ImportSyncRowId = isre.ImportSyncRowId)
	WHERE isr.ImportId = @iImportId
		AND (isre.IsCurrent = @iIsCurrent OR @iIsCurrent IS NULL)
END
GO

GRANT EXECUTE ON dbo.GetImportSyncRelationship TO CommonImportManager
GO


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncRows.prc'
GO

IF OBJECT_ID('dbo.GetImportSyncRows') IS NOT NULL
     DROP PROCEDURE dbo.GetImportSyncRows
GO

CREATE PROCEDURE dbo.GetImportSyncRows
(
	@iImportId SMALLINT,
	@iImportSyncTableId SMALLINT,
	@iIsCurrent BIT,
	@iIsUpdated BIT,
	@iIsDeleted BIT
)
WITH ENCRYPTION
AS
BEGIN
    SET NOCOUNT ON
    
	SELECT ImportSyncRowId,	ImportId, ImportSyncTableId, IsCurrent,
		SourceRow, DestinationRow,
		IsUpdated, IsDeleted, PreviousImportSyncRowId, RootImportSyncRowId
	FROM dbo.ImportSyncRow
	WHERE ImportId = @iImportId
		AND IsUpdated = ISNULL(@iIsUpdated, IsUpdated)
		AND IsDeleted = ISNULL(@iIsDeleted, IsDeleted)
		AND ImportSyncTableId = ISNULL(@iImportSyncTableId, ImportSyncTableId)
		AND IsCurrent = ISNULL(@iIsCurrent, IsCurrent)
	ORDER BY ImportSyncRowId ASC
END
GO
	
GRANT EXECUTE ON dbo.GetImportSyncRows TO CommonImportManager
GO


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncTableIdFromName.prc'
GO

 If Object_Id('dbo.GetImportSyncTableIdFromName') Is Not Null 
     Drop Procedure dbo.GetImportSyncTableIdFromName 
Go 
  
Create Procedure dbo.GetImportSyncTableIdFromName
(
	@iImportId SmallInt,
	@iImportSyncTableName VarChar(255)
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ImportSyncTableId
	From dbo.ImportSyncTable
	Where [Name] = @iImportSyncTableName
		And ImportId = @iImportId

End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncTableIdFromName TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncValidate.prc'
GO

  If Object_Id('dbo.GetImportSyncValidate') Is Not Null 
     Drop Procedure dbo.GetImportSyncValidate
Go 
  
Create Procedure dbo.GetImportSyncValidate
(
	@iImportSyncQueueId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ImportSyncValidateId,
		ImportSyncQueueId,
		UserMessage,
		InternalMessage
	From dbo.ImportSyncValidate
	Where ImportSyncQueueId = @iImportSyncQueueId

End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncValidate TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportSyncValidateField.prc'
GO

  If Object_Id('dbo.GetImportSyncValidateField') Is Not Null 
     Drop Procedure dbo.GetImportSyncValidateField
Go 
  
Create Procedure dbo.GetImportSyncValidateField
(
	@iImportSyncQueueId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On 
    
	-- get the job status list
	Select ISVF.ImportSyncValidateId,
		ISVF.Field
	From dbo.ImportSyncValidate As ISV
		Inner Join dbo.ImportSyncValidateField As ISVF
			On ISVF.ImportSyncValidateId = ISV.ImportSyncValidateId
	Where ISV.ImportSyncQueueId = @iImportSyncQueueId
End 
Go	
GRANT EXECUTE ON dbo.GetImportSyncValidateField TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetNextSyncQueueEntry.prc'
GO

 If Object_Id('dbo.GetNextSyncQueueEntry') Is Not Null
	Drop Procedure dbo.GetNextSyncQueueEntry
Go

Create Procedure dbo.GetNextSyncQueueEntry
(
	@iOrderNo BigInt = Null,
	@iImportId SmallInt
)
With Encryption 
As
Begin

Select Top 1 ISQ.ImportSyncQueueId,
	ISQ.ImportSyncRowId,
	ISQ.IsPending,
	ISQ.OrderNo,
	ISQ.SyncAction,
	ISQ.InitialComparedDateTime,
	ISQ.LastProcessedDateTime,
	ISQ.InitialCompareImportJobId,
	ISQ.LastProcessImportJobId,
	IST.Name As TableName,
	ISQ.ImportId,
	ISQ.ImportSyncTableId
From dbo.ImportSyncQueue As ISQ
	Inner Join dbo.ImportSyncTable As IST
		On IST.ImportSyncTableId = ISQ.ImportSyncTableId
Where ISQ.IsPending = 1
	And ISQ.OrderNo > Coalesce(@iOrderNo,-1)
	And ISQ.ImportId = @iImportId
Order By OrderNo Asc

End
Go
GRANT EXECUTE ON dbo.GetNextSyncQueueEntry TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.UpdateImportSyncQueue.prc'
GO

 If Object_Id('dbo.UpdateImportSyncQueue') Is Not Null
	Drop Procedure dbo.UpdateImportSyncQueue
Go

Create Procedure dbo.UpdateImportSyncQueue
(
	@iImportSyncRowId BigInt,
	@iOrderNo BigInt,
	@iIsPending Bit,
	@iSyncAction Char(1),
	@iInitialComparedDateTime DateTime,
	@iLastProcessedDateTime DateTime,
	@iInitialCompareImportJobId Int,
	@iImportSyncTableId SmallInt,
	@iImportId SmallInt,
	@iLastProcessImportJobId Int,
	@iImportSyncQueueId BigInt
	
)

With Encryption
As

Begin

Update dbo.[ImportSyncQueue]
Set ImportSyncRowId = @iImportSyncRowId,
	OrderNo = @iOrderNo,
	IsPending = @iIsPending,
	ImportId = @iImportId,
	ImportSyncTableId = @iImportSyncTableId,
	SyncAction = @iSyncAction,
	InitialComparedDateTime = @iInitialComparedDateTime,
	LastProcessedDateTime = @iLastProcessedDateTime,
	InitialCompareImportJobId = @iInitialCompareImportJobId,
	LastProcessImportJobId = @iLastProcessImportJobId
Where ImportSyncQueueId = @iImportSyncQueueId

End
Go
GRANT EXECUTE ON dbo.UpdateImportSyncQueue TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.UpdateImportSyncRelationship.prc'
GO

If Object_Id('dbo.UpdateImportSyncRelationship') Is Not Null
	Drop Procedure dbo.UpdateImportSyncRelationship
Go

Create Procedure dbo.UpdateImportSyncRelationship
(
	@iImportSyncRowId BigInt,
	@iParentImportSyncRowId BigInt,
	@iIsCurrent Bit
)
With Encryption
As
Begin

Update dbo.ImportSyncRelationship
	Set IsCurrent = @iIsCurrent
Where ImportSyncRowId = @iImportSyncRowId
	And ParentImportSyncRowId = @iParentImportSyncRowId
	
End
Go
GRANT EXECUTE ON dbo.UpdateImportSyncRelationship TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.UpdateImportSyncRow.prc'
GO

 If Object_Id('dbo.UpdateImportSyncRow') Is Not Null
	Drop Procedure dbo.UpdateImportSyncRow
Go

Create Procedure dbo.UpdateImportSyncRow
(
	@iImportId SmallInt,
	@iImportSyncTableId SmallInt,
	@iIsCurrent Bit,
	@iSourceRow Xml,
	@iDestinationRow Xml,
	@iIsUpdated Bit,
	@iIsDeleted Bit,
	@iPreviousImportSyncRowId BigInt,
	@iRootImportSyncRowId BigInt,
	@iImportSyncRowId BigInt
)

With Encryption
As

Begin

	Update dbo.[ImportSyncRow]
	Set ImportId = @iImportId,
		ImportSyncTableId = @iImportSyncTableId,
		IsCurrent = @iIsCurrent,
		SourceRow = @iSourceRow,
		DestinationRow = @iDestinationRow,
		IsUpdated = @iIsUpdated,
		IsDeleted = @iIsDeleted,
		PreviousImportSyncRowId = @iPreviousImportSyncRowId,
		RootImportSyncRowId = @iRootImportSyncRowId
	Where ImportSyncRowId = @iImportSyncRowId

End
Go
GRANT EXECUTE ON dbo.UpdateImportSyncRow TO CommonImportManager


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.DbaClearImportData.prc'
GO

IF Object_Id('dbo.DbaClearImportData') IS NOT NULL
	DROP PROCEDURE dbo.DbaClearImportData
GO

CREATE PROCEDURE dbo.DbaClearImportData
(
	@iImportName VARCHAR(128)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @ImportId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DbaClearImportData',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @ImportId =
			(
				SELECT ImportId
				FROM dbo.Import
				WHERE ImportName = @iImportName
			)

		IF @ImportId IS NULL
		BEGIN
			RAISERROR('Unable to resolve the import requested.', 16, 1)
		END

		DELETE
		FROM dbo.ImportSyncConflictField
		WHERE ImportSyncConflictId IN
			(
				SELECT ImportSyncConflictId
				FROM dbo.ImportSyncConflict
				WHERE ImportSyncQueueId IN
					(
						SELECT ImportSyncQueueId
						FROM dbo.ImportSyncQueue
						WHERE Importid = @ImportId
					)
			)
			
		DELETE
		FROM dbo.ImportSyncConflict
		WHERE ImportSyncQueueId IN
			(
				SELECT ImportSyncQueueId
				FROM dbo.ImportSyncQueue
				WHERE ImportId = @ImportId
			)
		
		DELETE
		FROM dbo.ImportSyncValidateField
		WHERE ImportSyncValidateId IN
			(
				SELECT ImportSyncValidateId
				FROM dbo.ImportSyncValidate
				WHERE ImportSyncQueueId IN
					(
						SELECT ImportSyncQueueId
						FROM dbo.ImportSyncQueue
						WHERE Importid = @ImportId
					)
			)

		DELETE
		FROM dbo.ImportSyncValidate
		WHERE ImportSyncQueueId IN
			(
				SELECT ImportSyncQueueId
				FROM dbo.ImportSyncQueue
				WHERE ImportId = @ImportId
			)

		DELETE
		FROM dbo.ImportSyncChangedField
		WHERE ImportSyncQueueId IN
			(
				SELECT ImportSyncQueueId
				FROM dbo.ImportSyncQueue
				WHERE ImportId = @ImportId
			)

		DELETE
		FROM dbo.ImportSyncException
		WHERE ImportSyncQueueId IN
			(
				SELECT ImportSyncQueueId
				FROM dbo.ImportSyncQueue
				WHERE ImportId = @ImportId
			)

		DELETE
		FROM dbo.ImportSyncQueue
		WHERE ImportId = @ImportId

		DELETE
		FROM dbo.ImportSyncRelationship
		WHERE ImportSyncRowId IN
			(
				SELECT ImportSyncRowId
				FROM dbo.ImportSyncRow
				WHERE ImportId = @ImportId
			)

		DELETE
		FROM dbo.ImportSyncRelationship
		WHERE ParentImportSyncRowId IN
			(
				SELECT ImportSyncRowId
				FROM dbo.ImportSyncRow
				WHERE ImportId = @ImportId
			)

		DELETE
		FROM dbo.ImportSyncRow
		WHERE ImportId = @ImportId
		OPTION (MAXDOP 1)
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.DbaClearImportJobs.prc'
GO

IF Object_Id('dbo.DbaClearImportJobs') IS NOT NULL
	DROP PROCEDURE dbo.DbaClearImportJobs
GO

CREATE PROCEDURE dbo.DbaClearImportJobs
(
	@iImportName VARCHAR(128)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @ImportId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DbaClearImportJobs',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF @iImportName IS NULL
		BEGIN
			SET @ImportId = NULL
		END
		ELSE
		BEGIN
			SET @ImportId =
				(
					SELECT ImportId
					FROM dbo.Import
					WHERE ImportName = @iImportName
				)
		END

		DELETE
		FROM dbo.ImportJobStatusHistory
		WHERE ImportJobId IN
			(
				SELECT ImportJobId
				FROM dbo.ImportJob
				WHERE ImportId = ISNULL(@ImportId, ImportId)
			)

		DELETE
		FROM dbo.ImportHistorySync
		WHERE ImportHistoryId IN
			(
				SELECT h.ImportHistoryId
				FROM dbo.ImportHistory AS h
				WHERE h.ImportId = ISNULL(@ImportId, h.ImportId)
			)

		DELETE
		FROM dbo.ImportHistoryLoad
		WHERE ImportHistoryId IN
			(
				SELECT h.ImportHistoryId
				FROM dbo.ImportHistory AS h
				WHERE h.ImportId = ISNULL(@ImportId, h.ImportId)
			)

		DELETE
		FROM dbo.ImportHistory
		WHERE ImportJobId IN
			(
				SELECT ImportJobId
				FROM dbo.ImportJob
				WHERE ImportId = ISNULL(@ImportId, ImportId)
			)

		DELETE
		FROM dbo.ImportJobParameter
		WHERE ImportJobId IN
			(
				SELECT ImportJobId
				FROM dbo.ImportJob
				WHERE ImportId = ISNULL(@ImportId, ImportId)
			)

		DELETE
		FROM dbo.ImportJob
		WHERE ImportId = ISNULL(@ImportId, ImportId)
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.DbaGetImportStatus.prc'
GO

IF Object_Id('dbo.DbaGetImportStatus') IS NOT NULL
	DROP PROCEDURE dbo.DbaGetImportStatus
GO

CREATE PROCEDURE dbo.DbaGetImportStatus
(
	@iImportName VARCHAR(128),
	@iShowConflictsAndValidates BIT
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ImportId INT
	DECLARE @TotalRows INT
	DECLARE @TotalRelationships INT
	DECLARE @TotalQueue INT
	DECLARE @PendingQueue INT
	DECLARE @PendingValidate INT
	DECLARE @PendingConflict INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DbaGetImportStatus',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @ImportId =
			(
				SELECT ImportId
				FROM dbo.Import
				WHERE ImportName = @iImportName
			)

		SET @TotalRows =
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncRow WITH (READUNCOMMITTED)
				WHERE ImportId = @ImportId
			)

		SET @TotalRelationships =
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncRelationship AS rel WITH (READUNCOMMITTED)
					INNER JOIN dbo.ImportSyncRow AS r WITH (READUNCOMMITTED)
						ON (rel.ImportSyncRowId = r.ImportSyncRowId
							OR rel.ParentImportSyncRowId = r.ImportSyncRowId)
				WHERE ImportId = @ImportId
			)

		SET @TotalQueue = 
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncQueue WITH (READUNCOMMITTED)
				WHERE ImportId = @ImportId
			)

		SET @PendingQueue = 
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncQueue WITH (READUNCOMMITTED)
				WHERE ImportId = @ImportId
					AND IsPending = 1
			)

		SET @PendingValidate = 
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncValidate AS v WITH (READUNCOMMITTED)
					INNER JOIN dbo.ImportSyncQueue AS q WITH (READUNCOMMITTED)
						ON (v.ImportSyncQueueId = q.ImportSyncQueueId)
				WHERE q.ImportId = @ImportId
					AND q.IsPending = 1
			)

		SET @PendingConflict = 
			(
				SELECT COUNT(1)
				FROM dbo.ImportSyncConflict AS c WITH (READUNCOMMITTED)
					INNER JOIN dbo.ImportSyncQueue AS q WITH (READUNCOMMITTED)
						ON (c.ImportSyncQueueId = q.ImportSyncQueueId)
				WHERE q.ImportId = @ImportId
					AND q.IsPending = 1
			)

		SELECT @TotalRows AS TotalRows,
			@TotalRelationships AS TotalRelationships,
			@TotalQueue AS TotalQueue,
			@PendingQueue AS PendingQueue,
			@PendingValidate AS PendingValidate,
			@PendingConflict AS PendingConflict

		IF ISNULL(@iShowConflictsAndValidates, 0) = 1
		BEGIN
			SELECT UserMessage, COUNT(1) AS Occurrence
			FROM dbo.ImportSyncValidate WITH (READUNCOMMITTED)
			WHERE ImportSyncQueueId IN
				(
					SELECT ImportSyncQueueId
					FROM dbo.ImportSyncQueue WITH (READUNCOMMITTED)
					WHERE ImportId = @ImportId
						AND IsPending = 1
				)
			GROUP BY UserMessage
			ORDER BY COUNT(1) DESC

			SELECT UserMessage, COUNT(1) AS Occurrence
			FROM dbo.ImportSyncConflict WITH (READUNCOMMITTED)
			WHERE ImportSyncQueueId IN
				(
					SELECT ImportSyncQueueId
					FROM dbo.ImportSyncQueue WITH (READUNCOMMITTED)
					WHERE ImportId = @ImportId
						AND IsPending = 1
				)
			GROUP BY UserMessage
			ORDER BY COUNT(1) DESC
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetImportsyncrow.prc'
GO

If Object_Id('dbo.GetImportSyncRow') Is Not Null 
     Drop Procedure dbo.GetImportSyncRow
Go 
  
Create Procedure dbo.GetImportSyncRow
(
	@iImportSyncRowId BigInt
)
With Encryption
As
 
Begin 

    Set NoCount On 
    


	Select ISR.ImportSyncRowId,
		ISR.ImportId,
		ISR.ImportSyncTableId,
		ISR.IsCurrent,
		SourceRow,
		DestinationRow,
		IsUpdated,
		IsDeleted,
		PreviousImportSyncRowId,
		RootImportSyncRowId
	From dbo.ImportSyncRow As ISR
	Where ISR.ImportSyncRowId = @iImportSyncRowId
	
End
Go
GRANT EXECUTE ON dbo.GetImportSyncRow TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.addimportsyncexception.prc'
GO

 If Object_Id('dbo.AddImportSyncException') Is Not Null
Drop Procedure dbo.AddImportSyncException
Go

Create Procedure dbo.AddImportSyncException
(
	@iImportSyncQueueId BigInt,
	@iUserMessage VarChar(Max),
	@iInternalMessage VarChar(Max),
	@oImportSyncExceptionId BigInt Output
	
)

With Encryption
As
Begin

	Insert Into dbo.ImportSyncException
	(
		ImportSyncQueueId, UserMessage, InternalMessage
	)
	Values
	(
		@iImportSyncQueueId, @iUserMessage, @iInternalMessage
	)
	
	Select @oImportSyncExceptionId = Scope_Identity()
		

End
Go
GRANT EXECUTE ON dbo.AddImportSyncException TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.deleteimportsyncexception.prc'
GO

If Object_Id('dbo.DeleteImportSyncException') Is Not Null
Drop Procedure dbo.DeleteImportSyncException
Go

Create Procedure dbo.DeleteImportSyncException
(
	@iImportSyncQueueId BigInt
	
)

With Encryption
As
Begin

	Delete 
	From dbo.ImportSyncException
	Where ImportSyncQueueId = @iImportSyncQueueId

End
Go
GRANT EXECUTE ON dbo.DeleteImportSyncException TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\Import\dbo.GetLastImport.prc'
GO

If Object_Id('dbo.GetLastImport') is not null
	Drop Procedure dbo.GetLastImport
Go

Create Procedure dbo.GetLastImport
(
	@iImportId Int
)

With Encryption
As

Begin
	Set NoCount On
	
	Select Top 1 * 
	From dbo.ImportHistory As IH
	Where ImportId = @iImportId
	And SuccessFlag = 1
	Order By JobDateCompleted Desc

End
Go
GRANT EXECUTE ON dbo.GetLastImport TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\import\dbo.getimportsyncconflictgrouping.prc'
GO

IF OBJECT_ID('dbo.GetImportSyncConflictGrouping') IS NOT NULL
	DROP PROCEDURE dbo.GetImportSyncConflictGrouping
GO

CREATE PROCEDURE dbo.GetImportSyncConflictGrouping
(
	@iImportId SMALLINT
)
WITH ENCRYPTION
AS
BEGIN 
	SELECT c.UserMessage, Count(*) AS Occurrence
	FROM dbo.ImportSyncConflict AS c
		INNER JOIN dbo.ImportSyncQueue AS q
			ON (q.ImportSyncQueueId = c.ImportSyncQueueId
				AND q.ImportId = @iImportId)
	WHERE q.IsPending = 1
	GROUP BY c.UserMessage
END
GO

GRANT EXECUTE ON dbo.GetImportSyncConflictGrouping TO CommonImportManager
GO


GO


Print 'Code: SnowdenCommon->schema\Procedures\import\dbo.getimportsyncconflictrecords.prc'
GO

IF OBJECT_ID('dbo.GetImportSyncConflictRecords') IS NOT NULL
     DROP PROCEDURE dbo.GetImportSyncConflictRecords
GO

CREATE PROCEDURE dbo.GetImportSyncConflictRecords
(
	@iUserMessage VARCHAR(MAX),
	@iImportId SMALLINT,
	@iPage INT,
	@iPageSize INT
)
WITH ENCRYPTION
AS
BEGIN
	-- note: PageSize can be NULL to allow full exports

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @Result TABLE
	(
		ImportSyncConflictId BIGINT NOT NULL,
		ImportSyncRowId BIGINT NOT NULL,
		SourceRow XML NOT NULL,
		Page INT NULL,
		PRIMARY KEY CLUSTERED (ImportSyncConflictId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetImportSyncConflictRecords',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Result
			(ImportSyncConflictId, ImportSyncRowId, SourceRow, Page)
		SELECT c.ImportSyncConflictId, r.ImportSyncRowId, r.SourceRow,
			(ROW_NUMBER() OVER (ORDER BY c.ImportSyncConflictId ASC) - 1) / @iPageSize AS Page
		FROM dbo.ImportSyncConflict AS c
			INNER JOIN dbo.ImportSyncQueue AS q
				ON (q.ImportSyncQueueId = c.ImportSyncQueueId)
			INNER JOIN dbo.ImportSyncRow AS r
				ON (r.ImportSyncRowId = q.ImportSyncRowId)
		WHERE c.UserMessage = @iUserMessage
			AND q.ImportId = @iImportId
			AND q.IsPending = 1

		-- return the results for the requested page number
		SELECT ImportSyncConflictId, ImportSyncRowId, SourceRow, Page
		FROM @Result
		WHERE (@iPageSize IS NULL) OR (Page = @iPage)

		-- return the results for the number of pages that are in the database
		SELECT MAX(Page) AS LastPage
		FROM @Result
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetImportSyncConflictRecords TO CommonImportManager
GO

/* testing
EXEC dbo.GetImportSyncConflictRecords
	@iUserMessage = 'There is already an adjustment on this date/shift for this Stockpile.',
	@iImportId = 8,
	@iPage = 0,
	@iPageSize = 10
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\import\dbo.getimportsyncvalidategrouping.prc'
GO

IF Object_Id('dbo.GetImportSyncValidateGrouping') Is Not Null 
     DROP PROCEDURE dbo.GetImportSyncValidateGrouping
GO
  
CREATE PROCEDURE dbo.GetImportSyncValidateGrouping
(
	@iImportId SMALLINT
)
WITH ENCRYPTION
AS
BEGIN 
	SELECT v.UserMessage, Count(1) AS Occurrence
	FROM dbo.ImportSyncValidate As v
		INNER JOIN dbo.ImportSyncQueue AS q
			ON (q.ImportSyncQueueId = v.ImportSyncQueueId
				AND q.ImportId = @iImportId)
	WHERE q.IsPending = 1
	GROUP BY v.UserMessage
END
GO	

GRANT EXECUTE ON dbo.GetImportSyncValidateGrouping TO CommonImportManager
GO

/* testing
EXEC dbo.GetImportSyncValidateGrouping @iImportId=1
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\import\dbo.getimportsyncvalidaterecords.prc'
GO

IF OBJECT_ID('dbo.GetImportSyncValidateRecords') IS NOT NULL
     DROP PROCEDURE dbo.GetImportSyncValidateRecords
GO

CREATE PROCEDURE dbo.GetImportSyncValidateRecords
(
	@iUserMessage VARCHAR(MAX),
	@iImportId SMALLINT,
	@iPage INT,
	@iPageSize INT
)
WITH ENCRYPTION
AS
BEGIN
	-- note: PageSize can be NULL to allow full exports

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @Result TABLE
	(
		ImportSyncValidateId BIGINT NOT NULL,
		ImportSyncRowId BIGINT NOT NULL,
		SourceRow XML NOT NULL,
		Page INT NULL,
		PRIMARY KEY CLUSTERED (ImportSyncValidateId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetImportSyncValidateRecords',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Result
			(ImportSyncValidateId, ImportSyncRowId, SourceRow, Page)
		SELECT v.ImportSyncValidateId, r.ImportSyncRowId, r.SourceRow,
			(ROW_NUMBER() OVER (ORDER BY ImportSyncValidateId ASC) - 1) / @iPageSize AS Page
		FROM dbo.ImportSyncValidate AS v
			INNER JOIN dbo.ImportSyncQueue AS q
				ON (q.ImportSyncQueueId = v.ImportSyncQueueId)
			INNER JOIN dbo.ImportSyncRow AS r
				ON (r.ImportSyncRowId = q.ImportSyncRowId)
		WHERE v.UserMessage = @iUserMessage
			AND q.ImportId = @iImportId
			AND q.IsPending = 1

		-- return the results for the requested page number
		SELECT ImportSyncValidateId, ImportSyncRowId, SourceRow, Page
		FROM @Result
		WHERE (@iPageSize IS NULL) OR (Page = @iPage)

		-- return the results for the number of pages that are in the database
		SELECT MAX(Page) AS LastPage
		FROM @Result
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetImportSyncValidateRecords TO CommonImportManager
GO

/* testing
EXEC dbo.GetImportSyncValidateRecords
	@iUserMessage = 'The Grade Value cannot be less than zero.',
	@iImportId = 1,
	@iPage = 1,
	@iPageSize = 10
*/

GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImport.prc'
GO

IF OBJECT_ID('dbo.GetImport') IS NOT NULL
     DROP PROCEDURE dbo.GetImport  
GO 
  
CREATE PROCEDURE dbo.GetImport 
(
	@iImportId SMALLINT,
	@iIncludeStatistics BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @SyncRowStatistics TABLE
	(
		TotalRows INT NOT NULL,
		InsertedRows INT NOT NULL,
		UpdatedRows INT NOT NULL,
		DeletedRows INT NOT NULL
	)

	DECLARE @SyncQueueStatistics TABLE
	(
		SyncAction CHAR(1) COLLATE DATABASE_DEFAULT NOT NULL,
		TotalRecords INT NOT NULL,
		TotalPendingRecords INT NOT NULL,
		PendingValidationErrorRecords INT NOT NULL,
		PendingConflictRecords INT NOT NULL
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetImport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- the base import information
		SELECT i.ImportName, i.ImportGroupId, g.ImportGroupName, i.ImportTypeId, t.ImportTypeName,
			i.Description, i.IsActive, i.DefaultKillTimeoutMinutes
		FROM dbo.Import AS i
			INNER JOIN dbo.ImportGroup AS g
				ON (i.ImportGroupId = g.ImportGroupId)
			INNER JOIN dbo.ImportType AS t
				ON (i.ImportTypeId = t.ImportTypeId)
		WHERE i.ImportId = @iImportId

		-- a list of tables
		SELECT Name
		FROM dbo.ImportSyncTable
		WHERE ImportId = @iImportId

		-- returns data row statistics
		IF @iIncludeStatistics = 1
		BEGIN
			INSERT INTO @SyncRowStatistics
				(TotalRows, InsertedRows, UpdatedRows, DeletedRows)
			SELECT COUNT(1) AS TotalRows,
				SUM(CASE WHEN IsUpdated = 0 AND IsDeleted = 0 THEN 1 ELSE 0 END) AS InsertedRows,
				SUM(CASE WHEN IsUpdated = 1 THEN 1 ELSE 0 END) AS UpdatedRows,
				SUM(CASE WHEN IsDeleted = 1 THEN 1 ELSE 0 END) AS DeletedRows
			FROM dbo.ImportSyncRow
			WHERE ImportId = @iImportId
			OPTION (MAXDOP 1)
		END

		SELECT TotalRows, InsertedRows, UpdatedRows, DeletedRows
		FROM @SyncRowStatistics

		-- returns queue statistics
		IF @iIncludeStatistics = 1
		BEGIN
			INSERT INTO @SyncQueueStatistics
				(SyncAction, TotalRecords, TotalPendingRecords, PendingValidationErrorRecords, PendingConflictRecords)
			SELECT sa.SyncAction,
				COUNT(1) AS TotalRecords,
				SUM(CASE WHEN q.IsPending = 1 THEN 1 ELSE 0 END) AS TotalPendingRecords,
				ISNULL(MAX(v.ValidationErrorCount), 0) AS PendingValidationErrorRecords,
				ISNULL(MAX(c.ConflictCount), 0) AS PendingConflictRecords
			FROM
					(
						SELECT 'I' AS SyncAction
						UNION ALL
						SELECT 'U'
						UNION ALL
						SELECT 'D'
					) AS sa
				LEFT OUTER JOIN dbo.ImportSyncQueue AS q
					ON (sa.SyncAction = q.SyncAction
						AND q.ImportId = @iImportId)
				LEFT OUTER JOIN
					(
						SELECT q2.SyncAction, COUNT(DISTINCT q2.ImportSyncQueueId) AS ValidationErrorCount
						FROM dbo.ImportSyncValidate AS v2
							INNER JOIN dbo.ImportSyncQueue AS q2
								ON (v2.ImportSyncQueueId = q2.ImportSyncQueueId)
						WHERE q2.IsPending = 1
							AND q2.ImportId = @iImportId
						GROUP BY q2.SyncAction
					) AS v
					ON (v.SyncAction = sa.SyncAction)
				LEFT OUTER JOIN
					(
						SELECT q2.ImportId, q2.SyncAction, COUNT(DISTINCT q2.ImportSyncQueueId) AS ConflictCount
						FROM dbo.ImportSyncConflict AS c2
							INNER JOIN dbo.ImportSyncQueue AS q2
								ON (c2.ImportSyncQueueId = q2.ImportSyncQueueId)
						WHERE q2.IsPending = 1
							AND q2.ImportId = @iImportId
						GROUP BY q2.ImportId, q2.SyncAction
					) AS c
					ON (c.SyncAction = sa.SyncAction)
			GROUP BY sa.SyncAction
		END

		SELECT SyncAction, TotalRecords, TotalPendingRecords, PendingValidationErrorRecords, PendingConflictRecords
		FROM @SyncQueueStatistics

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetImport TO CommonImportManager
GO


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Import\dbo.GetImportJobImportHistoryLatestInternalMessage.prc'
GO

 IF OBJECT_ID('dbo.GetImportJobImportHistoryLatestInternalMessage') IS NOT NULL
	DROP PROCEDURE dbo.GetImportJobImportHistoryLatestInternalMessage
GO

CREATE PROCEDURE dbo.GetImportJobImportHistoryLatestInternalMessage
(
	@iImportJobId INT,
	@oInternalMessage VARCHAR(MAX) = NULL OUTPUT
)
WITH ENCRYPTION 
AS
BEGIN

	SELECT TOP 1 @oInternalMessage = InternalMessages
	FROM ImportHistory
	WHERE ImportJobId = @iImportJobId
	ORDER BY ImportHistoryId DESC

END
GO

GRANT EXECUTE ON dbo.GetImportJobImportHistoryLatestInternalMessage TO CommonImportManager


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.getsecurityroles.prc'
GO

IF OBJECT_ID('dbo.GetSecurityRoles') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityRoles
GO 
  
CREATE PROCEDURE dbo.GetSecurityRoles
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT RoleId, Description
		FROM dbo.SecurityRole
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityRoles TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityRoles">
 <Procedure>
	Returns all security roles within the system.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.updatesecurityuser.prc'
GO

IF OBJECT_ID('dbo.UpdateSecurityUser') IS NOT NULL
	DROP PROCEDURE dbo.UpdateSecurityUser
GO 

CREATE PROCEDURE dbo.UpdateSecurityUser
(
	@iUserId INT,
	@iUpdateNTAccountName BIT,
	@iNTAccountName VARCHAR(64),
	@iUpdateNTAccountSid BIT,
	@iNTAccountSid VARCHAR(256),
	@iUpdateFirstName BIT,
	@iFirstName VARCHAR(256),
	@iUpdateLastName BIT,
	@iLastName VARCHAR(256),
	@iUpdateEmailAddress BIT,
	@iEmailAddress VARCHAR(256)
)
AS 
BEGIN 
	SET NOCOUNT ON

	BEGIN TRY
		UPDATE dbo.SecurityUser
		SET NTAccountName = (CASE WHEN @iUpdateNTAccountName = 1 THEN @iNTAccountName ELSE NTAccountName END),
			NTAccountSid = (CASE WHEN @iUpdateNTAccountSid = 1 THEN @iNTAccountSid ELSE NTAccountSid END),
			FirstName = (CASE WHEN @iUpdateFirstName = 1 THEN @iFirstName ELSE FirstName END),
			LastName = (CASE WHEN @iUpdateLastName = 1 THEN @iLastName ELSE LastName END),
			EmailAddress = (CASE WHEN @iUpdateEmailAddress = 1 THEN @iEmailAddress ELSE EmailAddress END)
		WHERE UserId = @iUserId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateSecurityUser TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateSecurityUser">
 <Procedure>
	Updates an existing user.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.getsecuritygroup.prc'
GO

 IF OBJECT_ID('dbo.GetSecurityGroup') IS NOT NULL
     DROP PROCEDURE dbo.GetSecurityGroup
GO 
  
CREATE PROCEDURE dbo.GetSecurityGroup
(
	@iGroupId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.GetSecurityGroup',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF (@iGroupId IS NULL)
		BEGIN
			RAISERROR('Group Id must not be null.', 16, 1)
		END

		SELECT NTAccountName, NTAccountSid
		FROM dbo.SecurityGroup
		WHERE GroupId = @iGroupId
		
		SELECT sr.RoleId, sr.Description As RoleDescription
		FROM dbo.SecurityRoleAssignment AS sra
			INNER JOIN dbo.SecurityRole AS sr
				ON sr.RoleId = sra.RoleId
		WHERE sra.GroupId= @iGroupId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityGroup">
 <Procedure>
	Returns a detailed summary relevant to the requested group.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.updatesecuritygroup.prc'
GO

IF OBJECT_ID('dbo.UpdateSecurityGroup') IS NOT NULL
	DROP PROCEDURE dbo.UpdateSecurityGroup
GO 

CREATE PROCEDURE dbo.UpdateSecurityGroup
(
	@iGroupId INT,
	@iNTAccountName VARCHAR(64),
	@iNTAccountSid VARCHAR(256)
)
AS 
BEGIN 
	SET NOCOUNT ON
	BEGIN TRY
	
		UPDATE dbo.SecurityGroup
		SET NTAccountName = @iNTAccountName,
			NTAccountSid = @iNTAccountSid
		WHERE GroupId = @iGroupId
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateSecurityGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateSecurityGroup">
 <Procedure>
	Updates an existing group
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.deletesecuritygroup.prc'
GO

IF OBJECT_ID('dbo.DeleteSecurityGroup') IS NOT NULL
     DROP PROCEDURE dbo.DeleteSecurityGroup  
GO 
  
CREATE PROCEDURE dbo.DeleteSecurityGroup 
(
	@iGroupId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteSecurityGroup',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		DELETE
		FROM dbo.SecurityUserGroup
		WHERE GroupId = @iGroupId

		DELETE
		FROM dbo.SecurityRoleAssignment
		WHERE GroupId = @iGroupId
		DELETE 
		FROM dbo.SecurityGroup
		WHERE GroupId = @iGroupId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.DeleteSecurityGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteSecurityGroup">
 <Procedure>
	Deletes a group and all role assignmnets associated with the group.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.updatesecurityrole.prc'
GO

IF OBJECT_ID('dbo.UpdateSecurityRole') IS NOT NULL
     DROP PROCEDURE dbo.UpdateSecurityRole  
GO 
  
CREATE PROCEDURE dbo.UpdateSecurityRole 
(
	@iRoleId VARCHAR(31),
	@iDescription VARCHAR(255)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateSecurityRole',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRole
				WHERE RoleId = @iRoleId
			)
		BEGIN
			RaisError('The role id does not exist.',16,1)
		END
		
		UPDATE dbo.SecurityRole
		SET Description = @iDescription
		WHERE RoleId = @iRoleId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateSecurityRole TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateSecurityRole">
 <Procedure>
	Updates an existing role.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.AddOrUpdateSecurityUserSetting.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateSecurityUserSetting') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateSecurityUserSetting
GO 
  
CREATE PROCEDURE dbo.AddOrUpdateSecurityUserSetting
(
	@iUserId INT,
	@iSettingTypeName VARCHAR(256),
	@iSettingValue VARCHAR(MAX),
	@iAutoAddSettingType BIT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @UserSettingTypeId SMALLINT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.AddOrUpdateSecurityUserSetting',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF (@iUserId IS NULL)
		BEGIN
			RAISERROR('User Id must not be null.', 16, 1)
		END

		IF (@iSettingTypeName IS NULL)
		BEGIN
			RAISERROR('Setting type name must not be null.', 16, 1)
		END

		IF (@iSettingValue IS NULL)
		BEGIN
			RAISERROR('Setting value must not be null.', 16, 1)
		END

		IF (@iAutoAddSettingType IS NULL)
		BEGIN
			RAISERROR('Auto add setting type must not be null.', 16, 1)
		END

		-- find the setting type, throw an error if it doesn't exist and we can't add it
		SET @UserSettingTypeId =
			(
				SELECT UserSettingTypeId
				FROM dbo.SecurityUserSettingType
				WHERE Name = @iSettingTypeName
			)

		IF (@UserSettingTypeId IS NULL AND @iAutoAddSettingType = 0)
		BEGIN
			RAISERROR('Unable to determine setting type.', 16, 1)
		END
		ELSE IF (@UserSettingTypeId IS NULL AND @iAutoAddSettingType = 1)
		BEGIN
			-- add automatically
			INSERT INTO dbo.SecurityUserSettingType
				(Name, Description)
			VALUES
				(@iSettingTypeName, @iSettingTypeName)

			SET @UserSettingTypeId = Scope_Identity()
		END

		-- find the setting - and insert/update it accordingly
		IF EXISTS
			(
				SELECT 1
				FROM dbo.SecurityUserSetting
				WHERE UserId = @iUserId
					AND UserSettingTypeId = @UserSettingTypeId
			)
		BEGIN
			-- found - update it
			UPDATE dbo.SecurityUserSetting
			SET Value = @iSettingValue
			WHERE UserId = @iUserId
				AND UserSettingTypeId = @UserSettingTypeId
		END
		ELSE
		BEGIN
			-- not found - insert it
			INSERT INTO dbo.SecurityUserSetting
				(UserId, UserSettingTypeId, Value)
			VALUES
				(@iUserId, @UserSettingTypeId, @iSettingValue)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddOrUpdateSecurityUserSetting TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateSecurityUserSetting">
 <Procedure>
	Sets the user setting for the specified user.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.AddSecurityGroup.prc'
GO

IF OBJECT_ID('dbo.AddSecurityGroup') IS NOT NULL
	DROP PROCEDURE dbo.AddSecurityGroup
GO 

CREATE PROCEDURE dbo.AddSecurityGroup
(
	@iNTAccountName VARCHAR(64),
	@iNTAccountSid VARCHAR(256),
	@oGroupId INT OUTPUT
)
AS 
BEGIN 
	SET NOCOUNT ON
	BEGIN TRY
		INSERT INTO dbo.SecurityGroup
			(NTAccountName, NTAccountSid)
		VALUES
			(@iNTAccountName, @iNTAccountSid)

		SET @oGroupId = Scope_Identity()
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityGroup">
 <Procedure>
	Creates a new group.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.AddSecurityUser.prc'
GO

IF OBJECT_ID('dbo.AddSecurityUser') IS NOT NULL
     DROP PROCEDURE dbo.AddSecurityUser
GO 
  
CREATE PROCEDURE dbo.AddSecurityUser
(
	@iNTAccountName VARCHAR(64),
	@iNTAccountSid VARCHAR(256),
	@iFirstName VARCHAR(256),
	@iLastName VARCHAR(256),
	@iEmailAddress VARCHAR(256),
	@oUserId INT OUTPUT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddSecurityUser',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- if provided, check that the accountname and sid are unique
		IF NOT (ISNULL(@iNTAccountName, @iNTAccountSid) IS NULL)
			AND EXISTS
			(
				SELECT 1
				FROM dbo.SecurityUser
				WHERE NTAccountName = ISNULL(@iNTAccountName, NTAccountName)
					OR NTAccountSid = ISNULL(@iNTAccountSid, NTAccountSid)
			)
		BEGIN
			RAISERROR('The NTAccountName / NTAccountSid are not unique.', 16, 1)
		END
	
		-- add the user
		INSERT INTO dbo.SecurityUser
			(NTAccountName, NTAccountSid, IsActive, FirstName, LastName, EmailAddress)
		VALUES
			(@iNTAccountName, @iNTAccountSid, 1, @iFirstName, @iLastName, @iEmailAddress)

		SET @oUserId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityUser TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityUser">
 <Procedure>
	Creates a new user.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.AddSecurityUserGroup.prc'
GO

IF OBJECT_ID('dbo.AddSecurityUserGroup') IS NOT NULL
	DROP PROCEDURE dbo.AddSecurityUserGroup
GO 
  
CREATE PROCEDURE dbo.AddSecurityUserGroup
(
	@iUserId INT,
	@iGroupId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId must not be null.', 16, 1)
		END

		IF @iGroupId IS NULL
		BEGIN
			RAISERROR('The GroupId must not be null.', 16, 1)
		END

		INSERT INTO dbo.SecurityUserGroup
			(UserId, GroupId)
		VALUES
			(@iUserId, @iGroupId)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityUserGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityUserGroup">
 <Procedure>
	Creates a user/group relationship.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.ClearSecurityUserSetting.prc'
GO

IF OBJECT_ID('dbo.ClearSecurityUserSetting') IS NOT NULL
     DROP PROCEDURE dbo.ClearSecurityUserSetting
GO 
  
CREATE PROCEDURE dbo.ClearSecurityUserSetting
(
	@iUserId INT,
	@iSettingTypeName VARCHAR(256)
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @UserSettingTypeId SMALLINT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.ClearSecurityUserSetting',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId must not be null.', 16, 1)
		END

		-- find the setting type (if it has been supplied - if not then it will be NULL)
		SET @UserSettingTypeId =
			(
				SELECT UserSettingTypeId
				FROM dbo.SecurityUserSettingType
				WHERE Name = @iSettingTypeName
			)

		-- clear all settings that are related to this user, and
		-- all settings if the SettingTypeName is NULL - or it has been provided then match the specific entry
		IF @iSettingTypeName IS NULL
		BEGIN
			DELETE
			FROM dbo.SecurityUserSetting
			WHERE UserId = @iUserId
		END
		ELSE
		BEGIN
			DELETE
			FROM dbo.SecurityUserSetting
			WHERE UserId = @iUserId
				AND UserSettingTypeId = @UserSettingTypeId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ClearSecurityUserSetting TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.ClearSecurityUserSetting">
 <Procedure>
	Clears all settings (or a specified setting) for a given user.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.DeleteSecurityUserGroup.prc'
GO

IF OBJECT_ID('dbo.DeleteSecurityUserGroup') IS NOT NULL
	DROP PROCEDURE dbo.DeleteSecurityUserGroup
GO 
  
CREATE PROCEDURE dbo.DeleteSecurityUserGroup
(
	@iUserId INT,
	@iGroupId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId must not be null.', 16, 1)
		END

		DELETE 
		FROM dbo.SecurityUserGroup
		WHERE UserId = @iUserId
			AND GroupId = ISNULL(@iGroupId, GroupId)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteSecurityUserGroup TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteSecurityUserGroup">
 <Procedure>
	Deletes the specified user/group relationship.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityGroups.prc'
GO

IF OBJECT_ID('dbo.GetSecurityGroups') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityGroups
GO 

CREATE PROCEDURE dbo.GetSecurityGroups
(
	@iNTAccountName VARCHAR(64),
	@iNTAccountSid VARCHAR(64)
)
AS 
BEGIN 
	SET NOCOUNT ON
	BEGIN TRY
		SELECT GroupId, NTAccountName, NTAccountSid
		FROM dbo.SecurityGroup
		WHERE NTAccountName = ISNULL(@iNTAccountName, NTAccountName)
			OR NTAccountSid = ISNULL(@iNTAccountSid, NTAccountSid)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityGroups TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityGroups">
 <Procedure>
	Returns a list of groups within the system (both active and inactive) and their associated details.
	Only returns those groups that match on the given NTAccountName.  Note that this would usually be 1:1 however
	there is no guarantee that the NTAccountName is unique to a given group id.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityOption.prc'
GO

 IF OBJECT_ID('dbo.GetSecurityOption') IS NOT NULL
     DROP PROCEDURE dbo.GetSecurityOption  
GO 
  
CREATE PROCEDURE dbo.GetSecurityOption 
(
	@iApplicationId VARCHAR(31),
    @iOptionId VARCHAR(255)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetSecurityOption',
		@TransactionCount = @@TranCount 
		
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY



 		IF @iApplicationId IS NULL OR @iOptionId IS NULL
		BEGIN
			RAISERROR('The option and application must be not be null',16,1) 
		END
		
		SELECT Application_Id AS ApplicationId,
			Option_Id AS OptionId,
			Option_Group_Id AS OptionGroupId,
			Description, 
			Sort_Order AS SortOrder
		FROM dbo.SecurityOption
		WHERE Application_Id = @iApplicationId
			AND Option_Id = @iOptionId
			
		SELECT Role_Id AS RoleId
		FROM dbo.SecurityRoleOption
		WHERE Option_Id = @iOptionId
			AND Application_Id = @iApplicationId
			
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityOption">
 <Procedure>
	Gets the security option details.
	Gets the roles that the security option has assignments to.
 </Procedure>
</TAG>
*/

GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityOptions.prc'
GO

IF OBJECT_ID('dbo.GetSecurityOptions') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityOptions
GO 
  
CREATE PROCEDURE dbo.GetSecurityOptions
(
	@iUserId INT
)
AS 
BEGIN 
	SET NOCOUNT ON
	
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId must not be null.', 16, 1)
		END
		
		SELECT ro.Option_Id
		FROM dbo.SecurityRoleOption AS ro
			INNER JOIN dbo.SecurityUserRole AS ur
				ON (ro.Role_Id = ur.RoleId)
		WHERE ur.UserId = @iUserId
		GROUP BY ro.Option_Id
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityOptions TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityOptions">
 <Procedure>
	Returns a list of options available/assigned to a particular user, via their roles - based on direct assignment and group membership.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityUserGroups.prc'
GO

IF OBJECT_ID('dbo.GetSecurityUserGroups') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityUserGroups
GO 
  
CREATE PROCEDURE dbo.GetSecurityUserGroups
(
	@iUserId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId must not be null.', 16, 1)
		END
		
		SELECT g.GroupId, g.NTAccountName, g.NTAccountSid
		FROM dbo.SecurityGroup AS g
			INNER JOIN dbo.SecurityUserGroup AS ug
				ON (g.GroupId = ug.GroupId)
		WHERE ug.UserId = @iUserId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityUserGroups TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityUserGroups">
 <Procedure>
	Provides a summary of groups the specified user is associated with.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityUsers.prc'
GO

IF OBJECT_ID('dbo.GetSecurityUsers') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityUsers
GO 

CREATE PROCEDURE dbo.GetSecurityUsers
(
	@iNTAccountName VARCHAR(64),
	@iNTAccountSid VARCHAR(64)
)
AS 
BEGIN 
	SET NOCOUNT ON
	
	BEGIN TRY
		SELECT UserId, NTAccountName, NTAccountSid, IsActive, FirstName, LastName, EmailAddress
		FROM dbo.SecurityUser
		WHERE NTAccountName = ISNULL(@iNTAccountName, NTAccountName)
			OR NTAccountSid = ISNULL(@iNTAccountSid, NTAccountSid)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityUsers TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityUsers">
 <Procedure>
	Returns a list of users within the system (both active and inactive) and their associated details.
	Only returns those users that match on the given NTAccountName.  Note that this would usually be 1:1 however
	there is no guarantee that the NTAccountName is unique to a given user id.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityUserSetting.prc'
GO

IF OBJECT_ID('dbo.GetSecurityUserSetting') IS NOT NULL
	DROP PROCEDURE dbo.GetSecurityUserSetting
GO

CREATE PROCEDURE dbo.GetSecurityUserSetting
(
	@iUserId INT,
	@iSettingTypeName VARCHAR(256),
	@oSettingValue VARCHAR(MAX) OUTPUT
)
AS
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SET @oSettingValue =
			(
				SELECT s.Value
				FROM dbo.SecurityUserSetting AS s
					INNER JOIN dbo.SecurityUserSettingType AS st
						ON (s.UserSettingTypeId = st.UserSettingTypeId)
				WHERE s.UserId = @iUserId
					AND st.Name = @iSettingTypeName
			)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetSecurityUserSetting TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityUserSetting">
 <Procedure>
	Gets a user setting.  Returns null if no setting is available, otherwise returns the required value.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.GetSecurityUser.prc'
GO

 IF OBJECT_ID('dbo.GetSecurityUser') IS NOT NULL
     DROP PROCEDURE dbo.GetSecurityUser
GO 
  
CREATE PROCEDURE dbo.GetSecurityUser
(
	@iUserId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.GetSecurityUser',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF (@iUserId IS NULL)
		BEGIN
			RAISERROR('User Id must not be null.', 16, 1)
		END

		--Get the user details
		SELECT NTAccountName, NTAccountSid, IsActive, FirstName, LastName, EmailAddress
		FROM dbo.SecurityUser
		WHERE UserId = @iUserId
		
		--Get roles assigned directly to user
		SELECT sr.RoleId, sr.Description AS RoleDescription
		FROM dbo.SecurityRoleAssignment AS sra
			INNER JOIN dbo.SecurityRole AS sr
				ON sr.RoleId = sra.RoleId
		WHERE sra.UserId = @iUserId

		--Get roles assigned indirectly to user through groups.
		SELECT sr.RoleId, sr.Description AS RoleDescription, sg.NTAccountName
		FROM dbo.SecurityRoleAssignment AS sra
			INNER JOIN dbo.SecurityRole AS sr
				ON sr.RoleId = sra.RoleId
			INNER JOIN dbo.SecurityUserGroup AS sug
				ON sug.GroupId = sra.GroupId
			INNER JOIN dbo.SecurityGroup AS sg
				ON sg.GroupId = sug.GroupId
		WHERE sug.UserId = @iUserId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityUser TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityUser">
 <Procedure>
	Returns a detailed summary relevant to the requested user.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.ActivateSecurityUser.prc'
GO

IF OBJECT_ID('dbo.ActivateSecurityUser') IS NOT NULL
	DROP PROCEDURE dbo.ActivateSecurityUser  
GO 
  
CREATE PROCEDURE dbo.ActivateSecurityUser
(
	@iUserId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId cannot be null.', 16, 1)
		END

		-- Activate the user
		UPDATE dbo.SecurityUser
		SET IsActive = 1
		WHERE UserID = @iUserId
		
		-- quick check to see if it updated as expected
		IF @@RowCount = 0
		BEGIN
			RAISERROR('The requested UserId was not found.', 16, 1)
		END
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ActivateSecurityUser TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.ActivateSecurityUser">
 <Procedure>
	Activates a security user.
 </Procedure>
</TAG>
*/



GO


Print 'Code: SnowdenCommon->Schema\Procedures\Security\dbo.DeactivateSecurityUser.prc'
GO

IF OBJECT_ID('dbo.DeactivateSecurityUser') IS NOT NULL
	DROP PROCEDURE dbo.DeactivateSecurityUser  
GO 
  
CREATE PROCEDURE dbo.DeactivateSecurityUser
(
	@iUserId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	BEGIN TRY
		IF @iUserId IS NULL
		BEGIN
			RAISERROR('The UserId cannot be null.', 16, 1)
		END

		-- deactivate the user
		UPDATE dbo.SecurityUser
		SET IsActive = 0
		WHERE UserID = @iUserId
		
		-- quick check to see if it updated as expected
		IF @@RowCount = 0
		BEGIN
			RAISERROR('The requested UserId was not found.', 16, 1)
		END
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeactivateSecurityUser TO CommonSecurityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeactivateSecurityUser">
 <Procedure>
	Deactivates a security user.
 </Procedure>
</TAG>
*/


GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.addsecurityrole.prc'
GO

IF OBJECT_ID('dbo.AddSecurityRole') IS NOT NULL
     DROP PROCEDURE dbo.AddSecurityRole  
GO 
  
CREATE PROCEDURE dbo.AddSecurityRole 
(
	@iRoleId VARCHAR(31),
	@iDescription VARCHAR(255)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddSecurityRole',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- code goes here
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRole
				WHERE RoleId = @iRoleId
			)
		BEGIN
			RaisError('This role already exists in the system',16,1)
		END
		
		INSERT INTO dbo.SecurityRole
		(
			RoleId, Description
		)
		SELECT @iRoleId, @iDescription

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityRole TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityRole">
 <Procedure>
	Adds a new role.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.addsecurityroleoption.prc'
GO

IF OBJECT_ID('dbo.AddSecurityRoleOption') IS NOT NULL
     DROP PROCEDURE dbo.AddSecurityRoleOption  
GO 
  
CREATE PROCEDURE dbo.AddSecurityRoleOption
(
	@iRoleId VARCHAR(31),
	@iOptionId VARCHAR(255),
	@iApplicationId VARCHAR(31)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddSecurityRoleOption',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- code goes here
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityOption
				WHERE Option_Id = @iOptionId
					AND Application_Id = @iApplicationId
			)
		BEGIN
			RaisError('This option does not exist in the system',16,1)
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRoleOption
				WHERE Option_Id = @iOptionId
					AND Role_Id = @iRoleId
					AND Application_Id = @iApplicationId
			)
		BEGIN
			RaisError('The option is already registered against the role',16,1)
		END
		
		INSERT INTO dbo.SecurityRoleOption
		(
			Role_Id, Application_Id, Option_Id
		)
		SELECT @iRoleId, Application_Id,Option_Id
		FROM dbo.SecurityOption
		WHERE Option_Id = @iOptionId
			AND Application_Id = @iApplicationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityRoleOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityRoleOption">
 <Procedure>
	Associates an option with a role.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.deletesecurityrole.prc'
GO

IF OBJECT_ID('dbo.DeleteSecurityRole') IS NOT NULL
     DROP PROCEDURE dbo.DeleteSecurityRole  
GO 
  
CREATE PROCEDURE dbo.DeleteSecurityRole 
(
	@iRoleId VARCHAR(31)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteSecurityRole',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		--Check to see if the role still exists in the system
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRole
				WHERE RoleId = @iRoleId
			)
		BEGIN
			RaisError('This role does not exist in the system.',16,1)
		END
		
		--Check to see if the role still has assignments
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRoleAssignment
				WHERE RoleId = @iRoleId
			)
		BEGIN
			RaisError('This role is still assigned to a user or group.',16,1)
		END
		
		--Delete the security role.
		DELETE 
		FROM dbo.SecurityRole
		WHERE RoleId = @iRoleId
		
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteSecurityRole TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteSecurityRole">
 <Procedure>
	Removes a role
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.deletesecurityoption.prc'
GO

  IF OBJECT_ID('dbo.DeleteSecurityOption') IS NOT NULL
     DROP PROCEDURE dbo.DeleteSecurityOption  
GO 
  
CREATE PROCEDURE dbo.DeleteSecurityOption 
(
	@iApplicationId VARCHAR(31),
    @iOptionId VARCHAR(255)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteSecurityOption',
		@TransactionCount = @@TranCount 
		
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

 		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.SecurityOption
				WHERE Application_Id = @iApplicationId
					AND Option_Id = @iOptionId
			)
		BEGIN
			RAISERROR('The option does not exist.',16,1) 
		END
		
		DELETE
		FROM dbo.SecurityOption
		WHERE Application_Id = @iApplicationId
			AND Option_Id = @iOptionId
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteSecurityOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteSecurityOption">
 <Procedure>
	Deletes a security option.
 </Procedure>
</TAG>
*/

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.deletesecurityroleoption.prc'
GO

IF OBJECT_ID('dbo.DeleteSecurityRoleOption') IS NOT NULL
     DROP PROCEDURE dbo.DeleteSecurityRoleOption  
GO 
  
CREATE PROCEDURE dbo.DeleteSecurityRoleOption
(
	@iRoleId VARCHAR(31),
	@iApplicationId VARCHAR(31),
	@iOptionId VARCHAR(31)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteSecurityRoleOption',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
				
		DELETE FROM dbo.SecurityRoleOption
		WHERE Option_Id = @iOptionId
			AND Application_Id = @iApplicationId
			AND Role_Id = @iRoleId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteSecurityRoleOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteSecurityRoleOption">
 <Procedure>
	Deletes an option associated with a security role.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.getsecurityrole.prc'
GO

IF OBJECT_ID('dbo.GetSecurityRole') IS NOT NULL
     DROP PROCEDURE dbo.GetSecurityRole  
GO 
  
CREATE PROCEDURE dbo.GetSecurityRole 
(
	@iRoleId VARCHAR(31)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetSecurityRole',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		
		--Role only
		SELECT RoleId, Description AS RoleDescription
		FROM dbo.SecurityRole
		WHERE RoleId = @iRoleId
		
		--Users and groups assigned to the role
		SELECT sr.RoleId, sr.Description AS RoleDescription, sra.AssignmentId, 
			sra.UserId, sra.GroupId, su.NTAccountName AS UserNTAccountName,
			sg.NTAccountName AS GroupNTAccountName, su.FirstName AS UserFirstName,
			su.LastName AS UserLastName,
			CASE WHEN sra.UserId IS NULL THEN 0 ELSE 1 END As IsUserAssignment
		FROM dbo.SecurityRole AS sr
			INNER JOIN dbo.SecurityRoleAssignment AS sra
				ON sr.RoleId = sra.RoleId
			LEFT JOIN dbo.SecurityUser AS su
				ON su.UserId = sra.UserId
			LEFT JOIN dbo.SecurityGroup AS sg
				ON sg.GroupId = sra.GroupId
		WHERE sr.RoleId = @iRoleId
		
		--Options assigned to the role
		SELECT sr.RoleId, sr.Description AS RoleDescription, so.Application_Id AS ApplicationId, 
			so.Option_Id AS OptionId, so.Option_Group_Id As OptionGroupId,
			CASE WHEN sro.Application_Id IS NULL THEN 0 ELSE 1 END AS Assigned,
			so.Description AS OptionDescription
		FROM dbo.SecurityRole AS sr
			CROSS JOIN dbo.SecurityOption AS so
			LEFT JOIN dbo.SecurityRoleOption AS sro
				ON sr.RoleId = sro.Role_Id
				AND so.Option_Id = sro.Option_Id
				AND sro.Application_Id = so.Application_Id
		WHERE sr.RoleId = @iRoleId
		ORDER BY so.Option_Group_Id, so.Sort_Order, sro.Option_Id
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetSecurityRole TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetSecurityRole">
 <Procedure>
	Returns summarised information about an existing role.
 </Procedure>
</TAG>
*/	



GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.AddSecurityOption.prc'
GO

 IF OBJECT_ID('dbo.AddSecurityOption') IS NOT NULL
     DROP PROCEDURE dbo.AddSecurityOption  
GO 
  
CREATE PROCEDURE dbo.AddSecurityOption 
(
	@iApplicationId VARCHAR(31),
    @iOptionId VARCHAR(255),
	@iOptionGroupId VARCHAR(255) = NULL,
	@iDescription VARCHAR(255) = NULL,
	@iSortOrder INT = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddSecurityOption',
		@TransactionCount = @@TranCount 
		
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY



 		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.SecurityOption
				WHERE Application_Id = @iApplicationId
					AND Option_Id = @iOptionId
			)
		BEGIN
			INSERT INTO dbo.SecurityOption
			(
				Option_Id, Application_Id, Option_Group_Id, Description, Sort_Order
			)
			SELECT @iOptionId, @iApplicationId, @iOptionGroupId, @iDescription, @iSortOrder
		END
		ELSE
		BEGIN
			RAISERROR('The option already exists for this application',16,1) 
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddSecurityOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddSecurityOption">
 <Procedure>
	Adds a security option.
 </Procedure>
</TAG>
*/

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.UpdateSecurityOption.prc'
GO

 IF OBJECT_ID('dbo.UpdateSecurityOption') IS NOT NULL
     DROP PROCEDURE dbo.UpdateSecurityOption  
GO 
  
CREATE PROCEDURE dbo.UpdateSecurityOption 
(
	@iApplicationId VARCHAR(31),
    @iOptionId VARCHAR(255),
	@iOptionGroupId VARCHAR(255) = NULL,
	@iDescription VARCHAR(255) = NULL,
	@iSortOrder INT = NULL,
	@iUpdateOptionGroupId BIT,
	@iUpdateDescription BIT,
	@iUpdateSortOrder BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateSecurityOption',
		@TransactionCount = @@TranCount 
		
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		IF NOT EXISTS
		(
			SELECT TOP 1 1 
			FROM dbo.SecurityOption
			WHERE Application_Id = @iApplicationId
			AND Option_Id = @iOptionId
		)
		BEGIN
			RaisError('The option id does not exist for this application',16,1)
		END
		
		UPDATE dbo.SecurityOption
		SET Option_Group_Id = CASE WHEN @iUpdateOptionGroupId = 1 THEN @iOptionGroupId ELSE Option_Group_Id END,
			Description = CASE WHEN @iUpdateDescription = 1 THEN @iDescription ELSE Description END,
			Sort_Order = CASE WHEN @iUpdateSortOrder = 1 THEN @iSortOrder ELSE Sort_Order END
		WHERE Application_Id = @iApplicationId
			AND Option_Id = @iOptionId
	
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateSecurityOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateSecurityOption">
 <Procedure>
	Updates a security option.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.addroleassignment.prc'
GO

IF OBJECT_ID('dbo.AddRoleAssignment') IS NOT NULL
     DROP PROCEDURE dbo.AddRoleAssignment  
GO 
  
CREATE PROCEDURE dbo.AddRoleAssignment
(
	@iRoleId VARCHAR(31),
	@iUserId INT,
	@iGroupId INT,
	@oAssignmentId INT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddRoleAssignment',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF 
			(
				(@iUserId IS NOT NULL
				AND @iGroupId IS NOT NULL)
			OR
				(@iUserId IS NULL
				AND @iGroupId IS NULL)
			)
		BEGIN
			RaisError('Only UserId or GroupId should be supplied',16,1)
		END	
		
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityUser
				WHERE UserId = @iUserId
			) AND @iUserId IS NOT NULL
		BEGIN
			RaisError('The user does not exist',16,1)
		END
		
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityGroup
				WHERE GroupId = @iGroupId
			) AND @iGroupId IS NOT NULL
		BEGIN
			RaisError('The group does not exist',16,1)
		END
	
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRole
				WHERE RoleId = @iRoleId
			)
		BEGIN
			RaisError('The role does not exist',16,1)
		END
	
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRoleAssignment
				WHERE RoleId = @iRoleId
					AND (UserId = @iUserId OR @iUserId IS NULL)
					AND (GroupId = @iGroupId OR @iGroupId IS NULL)
			)
		BEGIN
			RaisError('The user or group has already been assigned to this role',16,1)
		END

		INSERT INTO dbo.SecurityRoleAssignment
		(
			RoleId, UserId, GroupId
		)
		SELECT @iRoleId, @iUserId, @iGroupId
		
		SET @oAssignmentId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddRoleAssignment TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddRoleAssignment">
 <Procedure>
	Associates a user or group with a role.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.deleteroleassignment.prc'
GO

IF OBJECT_ID('dbo.DeleteRoleAssignment') IS NOT NULL
     DROP PROCEDURE dbo.DeleteRoleAssignment  
GO 
  
CREATE PROCEDURE dbo.DeleteRoleAssignment 
(
	@iAssignmentId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteRoleAssignment',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityRoleAssignment
				WHERE AssignmentId = @iAssignmentId
			)
		BEGIN
			RaisError('The role assignment association does not exist',16,1)
		END
		
		DELETE FROM dbo.SecurityRoleAssignment
		WHERE AssignmentId = @iAssignmentId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteRoleAssignment TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteRoleAssignment">
 <Procedure>
	Remove a role assignment.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->schema\Procedures\security\dbo.SaveSecurityOption.prc'
GO

 IF OBJECT_ID('dbo.SaveSecurityOption') IS NOT NULL
     DROP PROCEDURE dbo.SaveSecurityOption  
GO 
  
CREATE PROCEDURE dbo.SaveSecurityOption 
(
	@iApplicationId VARCHAR(31),
    @iOptionId VARCHAR(255),
	@iOptionGroupId VARCHAR(255) = NULL,
	@iDescription VARCHAR(255) = NULL,
	@iSortOrder INT = NULL,
	@iUpdateOptionGroupId BIT,
	@iUpdateDescription BIT,
	@iUpdateSortOrder BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveSecurityOption',
		@TransactionCount = @@TranCount 
		
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		If Not Exists
			(
				Select 1
				From dbo.SecurityOption
				Where Application_Id = @iApplicationId
					And Option_Id = @iOptionId
			)
		Begin
			Insert Into dbo.SecurityOption
			(
				Option_Id, Application_Id, Option_Group_Id, Description, Sort_Order
			)
			Select @iOptionId, @iApplicationId, @iOptionGroupId, @iDescription, @iSortOrder
		End
		Else
		Begin
			Update dbo.SecurityOption
			Set Option_Group_Id = Case When @iUpdateOptionGroupId = 1 Then @iOptionGroupId Else Option_Group_Id End,
				Description = Case When @iUpdateDescription = 1 Then @iDescription Else Description End,
				Sort_Order = Case When @iUpdateSortOrder = 1 Then @iSortOrder Else Sort_Order End
			Where Application_Id = @iApplicationId
				And Option_Id = @iOptionId
		End
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveSecurityOption TO CommonSecurityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.SaveSecurityOption">
 <Procedure>
	Saves a security option.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: SnowdenCommon->Schema\Procedures\dbo.StandardCatchBlock.PRC'
GO

IF OBJECT_ID('dbo.StandardCatchBlock') IS NOT NULL 
     DROP PROCEDURE dbo.StandardCatchBlock 
GO 
  
CREATE PROCEDURE dbo.StandardCatchBlock 
WITH ENCRYPTION 
AS 
BEGIN 
	DECLARE @ErrorMessage NVARCHAR(MAX),
		@ErrorSeverity INT,
		@ErrorState INT,
		@ErrorProcedure NVARCHAR(255)

	SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
		@ErrorState = ERROR_STATE(), @ErrorProcedure = ERROR_PROCEDURE()

	--Because the reraise is done inside of this procedure append
	--the original thrower of the error to the message 
	--and ignore any unwinding StandardCatchBlock calls.
	IF @ErrorProcedure <> 'StandardCatchBlock' 
	BEGIN
		SELECT @ErrorMessage = 'Error thrown in ' + @ErrorProcedure + ': ' + @ErrorMessage
	END

	--Rethrow the error
	RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.StandardCatchBlock">
 <Procedure>
	Encapsulates rethrow code that can be placed in any sql try catch block.
 </Procedure>
</TAG>
*/	 

GO


Print 'Code: ReconcilorCore->Schema\Views\dbo.WeightometerFlowPeriodView.viw'
GO

IF Object_Id('dbo.WeightometerFlowPeriodView') IS NOT NULL
	DROP VIEW dbo.WeightometerFlowPeriodView
GO

CREATE VIEW dbo.WeightometerFlowPeriodView
AS
SELECT wfp.Weightometer_Id,
	(
		SELECT TOP 1 DATEADD(DAY, 1, wfp2.End_Date)
		FROM dbo.WeightometerFlowPeriod AS wfp2
		WHERE wfp.Weightometer_Id = wfp2.Weightometer_Id
			AND wfp2.End_Date < ISNULL(wfp.End_Date, DATEADD(DAY, 1, wfp2.End_Date))
		ORDER BY wfp2.End_Date DESC
	) AS Start_Date,
	End_Date, Source_Stockpile_Id, Source_Crusher_Id, Source_Mill_Id, Destination_Stockpile_Id,
	Destination_Crusher_Id, Destination_Mill_Id, Is_Calculated, Processing_Order_No
FROM dbo.WeightometerFlowPeriod AS wfp
GO


GO


Print 'Code: ReconcilorCore->Schema\Views\dbo.WeightometerSampleView.viw'
GO

IF Object_Id('dbo.WeightometerSampleView') IS NOT NULL
	DROP VIEW dbo.WeightometerSampleView
GO

CREATE VIEW dbo.WeightometerSampleView
AS
SELECT ws.Weightometer_Sample_Id, ws.Weightometer_Id, ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift, ws.Order_No,
	(CASE WHEN ws.Source_Stockpile_Id IS NULL THEN wfp.Source_Stockpile_Id ELSE ws.Source_Stockpile_Id END) AS Source_Stockpile_Id,
	(CASE WHEN ws.Source_Stockpile_Id IS NULL THEN NULL ELSE ws.Source_Build_Id END) AS Source_Build_Id,
	(CASE WHEN ws.Source_Stockpile_Id IS NULL THEN NULL ELSE ws.Source_Component_Id END) AS Source_Component_Id,
	(CASE WHEN ws.Source_Stockpile_Id IS NULL THEN wfp.Source_Crusher_Id ELSE NULL END) AS Source_Crusher_Id,
	(CASE WHEN ws.Source_Stockpile_Id IS NULL THEN wfp.Source_Mill_Id ELSE NULL END) AS Source_Mill_Id,
	(CASE WHEN ws.Destination_Stockpile_Id IS NULL THEN wfp.Destination_Stockpile_Id ELSE ws.Destination_Stockpile_Id END) AS Destination_Stockpile_Id,
	(CASE WHEN ws.Destination_Stockpile_Id IS NULL THEN NULL ELSE ws.Destination_Build_Id END) AS Destination_Build_Id,
	(CASE WHEN ws.Destination_Stockpile_Id IS NULL THEN NULL ELSE ws.Destination_Component_Id END) AS Destination_Component_Id,
	(CASE WHEN ws.Destination_Stockpile_Id IS NULL THEN wfp.Destination_Crusher_Id ELSE NULL END) AS Destination_Crusher_Id,
	(CASE WHEN ws.Destination_Stockpile_Id IS NULL THEN wfp.Destination_Mill_Id ELSE NULL END) AS Destination_Mill_Id,
	Tonnes, Corrected_Tonnes, ISNULL(Corrected_Tonnes, Tonnes) AS Effective_Tonnes
FROM dbo.WeightometerSample AS ws
	LEFT OUTER JOIN dbo.WeightometerFlowPeriodView AS wfp
		ON (ws.Weightometer_Id = wfp.Weightometer_Id
			AND
				(
					ws.Weightometer_Sample_Date >= ISNULL(wfp.Start_Date, ws.Weightometer_Sample_Date)
					AND ws.Weightometer_Sample_Date <= ISNULL(wfp.End_Date, ws.Weightometer_Sample_Date)
				)
			)
GO


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.Mround.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Mround]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[Mround]
GO

Create Function dbo.Mround
(
	@pNumber Float(53),
	@pMultiple Float(53)
)
Returns Float(53)
With Encryption As
Begin
	Declare @Divisor Float(53)
	
	Set @Divisor = Round(@pNumber / @pMultiple, 0)
	
	Return @Divisor * @pMultiple
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="Mround">
 <Function>
	Round the value to the near whole value.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsInApprovedMonth.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[IsInApprovedMonth]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[IsInApprovedMonth]
GO

Create Function dbo.IsInApprovedMonth
(
	@Date Datetime
)
Returns Bit
With Encryption As
Begin
	Declare @RetVal Bit

	/* Check to see if the month in which the date falls has already been approved */
	Set @RetVal = 0

	Select @RetVal = Is_Approved
	From MonthlyApproval
	Where Month(Monthly_Approval_Month) = Month(@Date)
	And Year(Monthly_Approval_Month) = Year(@Date)

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="IsInApprovedMonth">
 <Function>
	Check to see if the month in which the date falls has already been approved.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetWetTonnes.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetWetTonnes]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetWetTonnes]
GO

CREATE Function [dbo].[GetWetTonnes]
(
	@iTonnes Float,
	@iMoisture Float
) 
Returns Float
With Encryption As
Begin
Declare @RetVal Float

	If (@iMoisture <> 100)
	Begin
		Select @RetVal = (@iTonnes / (1 - (Isnull(@iMoisture,0)/100.0)))
	End
	Else
	Begin
		Select @RetVal = @iTonnes
	End
	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetWetTonnes">
 <Function>
	Converts Dry Tonnes to Wet.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetWetQualityPercentage.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetWetQualityPercentage]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetWetQualityPercentage]
GO

Create Function [dbo].[GetWetQualityPercentage]
(
	@iQualityPercentage Float,
	@iMoisture Float
)
Returns Float
With Encryption As
Begin
	Declare @RetVal Float

	Select @RetVal = Case 
						When @iMoisture Is Not NULL Then (@iQualityPercentage * (1 - (Isnull(@iMoisture, 0)/100.0)))
						Else NULL
					 End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetWetQualityPercentage">
 <Function>
	Converts Dry Qualities to Wet.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDryTonnes.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDryTonnes]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDryTonnes]
GO

CREATE Function [dbo].[GetDryTonnes]
(
	@iTonnes Float,
	@iMoisture Float
)
-- =============================================
-- Author:		Nigel Linton
-- Create date: 25-May-2006
-- Description:	Converts Wet Tonnes to Dry
-- =============================================

Returns Float

With Encryption As

Begin

Declare @RetVal Float

	Select @RetVal = (@iTonnes * (1 - (Isnull(@iMoisture,0)/100.0)))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDryTonnes">
 <Function>
	Returns the dry tonnes.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDryQualityPercentage.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDryQualityPercentage]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDryQualityPercentage]
GO

Create Function [dbo].[GetDryQualityPercentage]
(
	@iQualityPercentage Float,
	@iMoisture Float
)

Returns Float

With Encryption As

Begin

Declare @RetVal Float

	Select @RetVal = Case
						When @iMoisture <> 100 Then (@iQualityPercentage / (1 - (Isnull(@iMoisture, 0)/100.0)))
						When @iMoisture Is Not Null Then @iQualityPercentage
						Else NULL
					End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="GetDryQualityPercentage">
 <Function>
	Returns the percentage of dry quantity.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetStockpileType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetStockpileType]
GO

CREATE Function dbo.GetStockpileType

(@Stockpile_Id Int,
@Date Datetime)

Returns Varchar(31)

With Encryption As

Begin

Declare @RetVal Varchar(31)

	Set @Date = dbo.GetDateDay(@Date)

	/* Get the current stockpile type for this stockpile on this date */
	Select @RetVal = Stockpile_Type_Id
	From StockpileStockpileTypePeriod P
	Where Stockpile_Id = @Stockpile_Id
	And (P.End_Date = 	(Select Min(End_Date)
				From StockpileStockpileTypePeriod P2
				Where P2.Stockpile_Id = P.Stockpile_Id
				And End_Date Is Not Null
				And End_Date >= @Date)
	Or (P.End_Date Is Null And 	(Select Min(End_Date)
					From StockpileStockpileTypePeriod P2
					Where P2.Stockpile_Id = P.Stockpile_Id
					And End_Date >= @Date) Is Null))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileType">
 <Function>
	Returns the current stockpile type for the given stockpile on the given date.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileStockpileGroups.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetStockpileStockpileGroups]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetStockpileStockpileGroups]
GO

CREATE Function dbo.GetStockpileStockpileGroups

(@Stockpile_Id Int,
@Current_Stockpile_Group_Id Varchar(31))

Returns Varchar(8000)

With Encryption As

Begin

Declare @RetVal Varchar(8000)
Declare @Stockpile_Group_Id Varchar(255)

	Set @RetVal = ''

	/* Get a cursor of all the stockpile groups to which this stockpile belongs */
	Declare Group_Curs Cursor For
	Select SGS.Stockpile_Group_Id
	From StockpileGroupStockpile SGS
	Where SGS.Stockpile_Id = @Stockpile_Id
	And SGS.Stockpile_Group_Id <> @Current_Stockpile_Group_Id
	Order By SGS.Stockpile_Group_Id

	Open Group_Curs

	Fetch Next From Group_Curs Into
	 @Stockpile_Group_Id

	/* For each stockpile for the group */
	While (@@Fetch_Status = 0)
	Begin
		/* Add it to the list */
		If (@RetVal <> '')
		Begin
			Set @RetVal = @RetVal + ', '
		End

		Set @RetVal = @RetVal + @Stockpile_Group_Id

		Fetch Next From Group_Curs Into
		 @Stockpile_Group_Id
	End

	Close Group_Curs
	Deallocate Group_Curs


	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileStockpileGroups">
 <Function>
	Returns a string of Stockpile groups for a given stockpile.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileAdjustmentType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetStockpileAdjustmentType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetStockpileAdjustmentType]
GO

Create Function dbo.GetStockpileAdjustmentType
 (@Is_Add_Or_Remove Bit,
  @Is_Grades_Adjustment Bit,
  @Is_Tonnes_Adjustment Bit,
  @Is_Stockpile_Transfer Bit)
 Returns VarChar(31)
With Encryption As
Begin
	Return Case 
			When (@Is_Stockpile_Transfer) = 1 Then 'Stockpile Transfer' Collate Database_Default
	        When (@Is_Add_Or_Remove = 0) And (@Is_Grades_Adjustment = 0) And (@Is_Tonnes_Adjustment = 0) Then 'Other Reset' Collate Database_Default
	        When (@Is_Add_Or_Remove = 0) And (@Is_Grades_Adjustment = 0) And (@Is_Tonnes_Adjustment = 1) Then 'Manual Tonnes Reset' Collate Database_Default
	        When (@Is_Add_Or_Remove = 0) And (@Is_Grades_Adjustment = 1) And (@Is_Tonnes_Adjustment = 0) Then 'Manual Grades Reset' Collate Database_Default
	        When (@Is_Add_Or_Remove = 0) And (@Is_Grades_Adjustment = 1) And (@Is_Tonnes_Adjustment = 1) Then 'Manual Tonnes/Grades Reset' Collate Database_Default
	        When (@Is_Add_Or_Remove = 1) And (@Is_Grades_Adjustment = 0) And (@Is_Tonnes_Adjustment = 0) Then 'Other Adjustment' Collate Database_Default
	        When (@Is_Add_Or_Remove = 1) And (@Is_Grades_Adjustment = 0) And (@Is_Tonnes_Adjustment = 1) Then 'Manual Tonnes Adjustment' Collate Database_Default
	        When (@Is_Add_Or_Remove = 1) And (@Is_Grades_Adjustment = 1) And (@Is_Tonnes_Adjustment = 0) Then 'Manual Grades Adjustment' Collate Database_Default
	        When (@Is_Add_Or_Remove = 1) And (@Is_Grades_Adjustment = 1) And (@Is_Tonnes_Adjustment = 1) Then 'Manual Tonnes/Grades Adjustment' Collate Database_Default
	       End
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileAdjustmentType">
 <Function>
	Returns the stockpile adjustment type.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetShiftTypeOrderNo.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetShiftTypeOrderNo]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetShiftTypeOrderNo]
GO

Create Function dbo.GetShiftTypeOrderNo

(@Shift Char(1))

Returns Int

With Encryption As

Begin

Declare @RetVal Int

	Select @RetVal = Order_No
	From ShiftType
	Where Shift = @Shift

	Return (@RetVal)
End
GO

GRANT EXECUTE ON dbo.GetShiftTypeOrderNo TO RecalcDirect
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetShiftTypeOrderNo">
 <Function>
	Returns the order number for the given shift.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetShiftTypeName.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetShiftTypeName]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetShiftTypeName]
GO

Create Function dbo.GetShiftTypeName

(@Shift Char(1))

Returns Varchar(31)

With Encryption As

Begin

Declare @RetVal Varchar(31)

	Select @RetVal = Name
	From ShiftType
	Where Shift = @Shift

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetShiftTypeName">
 <Function>
	Returns the shift name for the given shift.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetShiftType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetShiftType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetShiftType]
GO

Create Function dbo.GetShiftType

(@Order_No Int)

Returns Char(1)

With Encryption As

Begin

Declare @RetVal Char(1)

	Select @RetVal = Shift
	From ShiftType
	Where Order_No = @Order_No

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetShiftType">
 <Function>
	Returns the shift type for the given order number.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetPreviousShiftType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPreviousShiftType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetPreviousShiftType]
GO

CREATE Function dbo.GetPreviousShiftType

(@Shift Char(1))

Returns Char(1)

With Encryption As

Begin

Declare @RetVal Char(1)
Declare @Order_No Int
Declare @Min_Order_No Int

	Set @RetVal = Null

	Select @Order_No = Order_No
	From ShiftType
	Where Shift = @Shift

	Select @Min_Order_No = Min(Order_No)
	From ShiftType

	If (@Order_No = @Min_Order_No)
	Begin
		Select @RetVal = Shift
		From ShiftType
		Where Order_No = 	(Select Max(Order_No)
					From ShiftType)
	End
	Else
	Begin
		Select @RetVal = Shift
		From ShiftType
		Where Order_No = 	(Select Max(Order_No)
					From ShiftType
					Where Order_No < @Order_No)
	End

	/* If no value was found */
	If (@RetVal Is Null)
	Begin
		/* There must be only one shift, so use it */
		Select @RetVal = Min(Shift)
		From ShiftType
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetPreviousShiftType">
 <Function>
	Returns the previous shift type. 
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetNextShiftType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetNextShiftType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetNextShiftType]
GO

Create Function dbo.GetNextShiftType

(@Shift Char(1))

Returns Char(1)

With Encryption As

Begin

Declare @RetVal Char(1)
Declare @Order_No Int
Declare @Max_Order_No Int

	Set @RetVal = Null

	Select @Order_No = Order_No
	From ShiftType
	Where Shift = @Shift

	Select @Max_Order_No = Max(Order_No)
	From ShiftType

	If (@Order_No = @Max_Order_No)
	Begin
		Select @RetVal = Shift
		From ShiftType
		Where Order_No = 	(Select Min(Order_No)
					From ShiftType)
	End
	Else
	Begin
		Select @RetVal = Shift
		From ShiftType
		Where Order_No = 	(Select Min(Order_No)
					From ShiftType
					Where Order_No > @Order_No)
	End

	/* If no value was found */
	If (@RetVal Is Null)
	Begin
		/* There must be only one shift, so use it */
		Select @RetVal = Min(Shift)
		From ShiftType
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetNextShiftType">
 <Function>
	Returns the next shift type to the given shift type.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialTypeGroupMaterialTypes.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetMaterialTypeGroupMaterialTypes]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetMaterialTypeGroupMaterialTypes]
GO

CREATE Function dbo.GetMaterialTypeGroupMaterialTypes

(@Material_Type_Group_Id Int)

Returns Varchar(8000)

With Encryption As

Begin

Declare @RetVal Varchar(8000)
Declare @Description Varchar(255)

	Set @RetVal = ''

	/* Get a cursor of all the material types belonging to this group */
	Declare Material_Type_Curs Cursor For
	Select MT.Description
	From MaterialType MT
	Where MT.Material_Type_Group_Id = @Material_Type_Group_Id
	Order By MT.Description

	Open Material_Type_Curs

	Fetch Next From Material_Type_Curs Into
	 @Description

	/* For each stockpile for the group */
	While (@@Fetch_Status = 0)
	Begin
		/* Add it to the list */
		If (@RetVal <> '')
		Begin
			Set @RetVal = @RetVal + ', '
		End

		Set @RetVal = @RetVal + @Description

		Fetch Next From Material_Type_Curs Into
		 @Description
	End

	Close Material_Type_Curs
	Deallocate Material_Type_Curs

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetMaterialTypeGroupMaterialTypes">
 <Function>
	Return the Material types from the given Material type group ID.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetFirstShiftType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetFirstShiftType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetFirstShiftType]
GO

Create Function dbo.GetFirstShiftType

()

Returns Char(1)

With Encryption As

Begin

Declare @RetVal Char(1)


	Select @RetVal = Shift
	From ShiftType
	Where Order_No = 	(Select Min(Order_No)
				From ShiftType)

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetFirstShiftType">
 <Function>
	Returns the first shift type.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetEncryptedString.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetEncryptedString]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetEncryptedString]
GO

CREATE Function dbo.GetEncryptedString

(@String Varchar(1023))

Returns Varchar(1023)

With Encryption As

Begin

Declare @RetVal Varchar(1023)
Declare @Char Char(1)
Declare @i Int
Declare @TempAsc Int
	
	Set @RetVal = ''
	Set @i = 1

	While (@i <= Len(@String))
	Begin
		Set @TempAsc = Ascii(SubString(@String, @i, 1))

		If (@TempAsc Between 65 And 90)
		Begin
			Set @TempAsc = @TempAsc + 5
			If (@TempAsc > 90)
			Begin
				Set @TempAsc = @TempAsc - 26
			End
		End
		Else
		Begin
			If (@TempAsc Between 97 And 122)
			Begin
				Set @TempAsc = @TempAsc + 5
				If (@TempAsc > 122)
				Begin
					Set @TempAsc = @TempAsc - 26
				End
			End
		End

		Set @RetVal = @RetVal + Char(@TempAsc)

		Set @i = @i + 1
	End

	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetEncryptedString">
 <Function>
	Returns given string encypted.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDigblockSurveySummaryRecordNo.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockSurveySummaryRecordNo]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDigblockSurveySummaryRecordNo]
GO

CREATE Function dbo.GetDigblockSurveySummaryRecordNo

(@Digblock_Survey_Summary_Id Int,
@NT_Login Varchar(255))

Returns Int

With Encryption As

Begin

Declare @RetVal Int
Declare @Digblock_Survey_Date Datetime
Declare @Digblock_Survey_Shift Char(1)
Declare @Digblock_Survey_Type_Id Int
Declare @Digblock_Survey_Id Int
Declare @Record_No Int

	Set @RetVal = Null

	Select @Digblock_Survey_Id = Digblock_Survey_Id,
	 @Record_No = Record_No
	From DigblockSurveySummary
	Where Digblock_Survey_Summary_Id = @Digblock_Survey_Summary_Id

	Select @RetVal = Count(*) + 1
	From DigblockSurveySummary
	Where Digblock_Survey_Id = @Digblock_Survey_Id
	And ((@NT_Login Is Null) Or (NT_Login = @NT_Login))
	And Record_No < @Record_No

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDigblockSurveySummaryRecordNo">
 <Function>
	Returns the number of Digblock Survey Summary records for a given Digblock Survey Summary ID.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDigblockSurveyReconciledTonnesPerTruck.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockSurveyReconciledTonnesPerTruck]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDigblockSurveyReconciledTonnesPerTruck]
GO

CREATE Function dbo.GetDigblockSurveyReconciledTonnesPerTruck

(@Actual_Tonnes Float,
@Haulage_Tonnes Float,
@Average_Tonnes Float)

Returns Float

With Encryption As

Begin

Declare @RetVal Float

	-- Old method for this calculation
	--If (@Haulage_Tonnes > 0)
	--Begin
	--	Select @RetVal = Round(@Actual_Tonnes * @Average_Tonnes / @Haulage_Tonnes, 2)
	--End

	Set @RetVal = Null

	If ((Cast(@Average_Tonnes As Int) > 0) And (Cast(@Haulage_Tonnes As Int) / Cast(@Average_Tonnes As Int)) > 0)
	Begin
		Select @RetVal = Round(Cast(@Actual_Tonnes As Int)
						 / (Cast(@Haulage_Tonnes As Int) / Cast(@Average_Tonnes As Int)), 2)
	End

	If (@RetVal Is Null)
	Begin
		If (@Actual_Tonnes = 0)
		Begin
			Set @RetVal = 0
		End
		Else
		Begin
			Set @RetVal = Round(@Actual_Tonnes, 2)
		End
	End

	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDigblockSurveyReconciledTonnesPerTruck">
 <Function>
	Returns the calculated tonnes.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDefaultBlockModel.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDefaultBlockModel]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDefaultBlockModel]
GO

Create Function dbo.GetDefaultBlockModel

(@Block_Model_Type_Id Int)

Returns Int

With Encryption As

Begin

Declare @RetVal Int

	/* Get the default block model for this type of block model */
	Select @RetVal = Block_Model_Id
	From BlockModel
	Where Block_Model_Type_Id = @Block_Model_Type_Id
	And Is_Default = 1

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDefaultBlockModel">
 <Function>
	Get the default block model for this type of block model.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDecryptedString.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDecryptedString]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDecryptedString]
GO

CREATE Function dbo.GetDecryptedString

(@Encrypted_String Varchar(1023))

Returns Varchar(1023)

With Encryption As

Begin

Declare @RetVal Varchar(1023)
Declare @Char Char(1)
Declare @i Int
Declare @TempAsc Int
	
	Set @RetVal = ''
	Set @i = 1

	While (@i <= Len(@Encrypted_String))
	Begin
		Set @TempAsc = Ascii(SubString(@Encrypted_String, @i, 1))

		If (@TempAsc Between 65 And 90)
		Begin
			Set @TempAsc = @TempAsc - 5
			If (@TempAsc < 65)
			Begin
				Set @TempAsc = @TempAsc + 26
			End
		End
		Else
		Begin
			If (@TempAsc Between 97 And 122)
			Begin
				Set @TempAsc = @TempAsc - 5
				If (@TempAsc < 97)
				Begin
					Set @TempAsc = @TempAsc + 26
				End
			End
		End

		Set @RetVal = @RetVal + Char(@TempAsc)

		Set @i = @i + 1
	End

	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDecryptedString">
 <Function>
	Returns a decrypted string.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDatePeriodRatio.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDatePeriodRatio]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDatePeriodRatio]
GO

CREATE Function dbo.GetDatePeriodRatio

(@pPeriod_From DateTime, @pPeriod_To DateTime,
 @pDate_From DateTime, @pDate_To DateTime)

Returns Float

With Encryption As

Begin
	Declare @Delta_Period Float
	Declare @Delta_Date Float

	Declare @Date_From DateTime
	Declare @Date_To DateTime

	-- does the date requested fall completely outside of the period?
	If (@pDate_From > @pPeriod_To) Or (@pDate_To < @pPeriod_From)
		Return 0
	Else

	If @pDate_From < @pPeriod_From
		Set @Date_From = @pPeriod_From
	Else
		Set @Date_From = @pDate_From

	If @pDate_To > @pPeriod_To
		Set @Date_To = @pPeriod_To
	Else
		Set @Date_To = @pDate_To

	Set @Delta_Period = DateDiff(s, @pPeriod_From, DateAdd(Day, 1, @pPeriod_To))
	Set @Delta_Date = DateDiff(s, @Date_From, DateAdd(Day, 1, @Date_To))

	Return @Delta_Date / @Delta_Period
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDatePeriodRatio">
 <Function>
	Returns the Date period ratio.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateMonth.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDateMonth]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDateMonth]
GO

CREATE Function dbo.GetDateMonth
 (@Datetime Datetime)
Returns Datetime
With Encryption As
Begin
	Declare @RetVal Datetime

	/* Return just the first day of the given month */
	Set @RetVal = Cast(Cast(Year(@Datetime) As Varchar) + '-' + Cast(Month(@Datetime) As Varchar) + '-1' As Datetime)

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDateMonth">
 <Function>
	Return just the first day of the given month
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateList.udf'
GO

If Object_Id('dbo.GetDateList') Is Not Null
	Drop Function dbo.GetDateList
Go

Create Function dbo.GetDateList
(
	@Start_Date Datetime,
	@End_Date Datetime,
	@Breakdown Varchar(5),
	@Step Int
)

Returns @DATE_LIST Table
(
	This_Date Datetime Not Null Primary Key
)

With Encryption As

Begin
	Declare @This_Date Datetime

	Set @This_Date = @Start_Date

	While (@This_Date <= @End_Date)
	Begin
		Insert Into @DATE_LIST
		 (This_Date)
		Values(@This_Date)
	
		If @Breakdown = 'Day'
			Set @This_Date = DateAdd(Day, @Step, @This_Date)
		Else If @Breakdown = 'Week'
			Set @This_Date = DateAdd(Week, @Step, @This_Date)
		Else If @Breakdown = 'Month'
			Set @This_Date = DateAdd(Month, @Step, @This_Date)
		Else If @Breakdown = 'Year'
			Set @This_Date = DateAdd(Year, @Step, @This_Date)
	End	

	Return
End
Go
GRANT SELECT ON dbo.GetDateList TO RecalcDirect


/*
<TAG Name="Data Dictionary" FunctionName="GetDateList">
 <Function>
	Returns a date list.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateDay.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDateDay]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDateDay]
GO

CREATE Function dbo.GetDateDay

(@Datetime Datetime)

Returns Datetime

With Encryption As

Begin

Declare @RetVal Datetime

	/* Return just the date part of the given datetime */
	Set @RetVal = Cast(Cast(Year(@Datetime) As Varchar) + '-' + Cast(Month(@Datetime) As Varchar) + '-' + Cast(Day(@Datetime) As Varchar) As Datetime)

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDateDay">
 <Function>
	Return just the date part of the given datetime.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetBuildableStockpileBuild.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetBuildableStockpileBuild]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetBuildableStockpileBuild]
GO

CREATE Function dbo.GetBuildableStockpileBuild

(@Stockpile_Id Int,
@Date Datetime,
@Shift Char(1))

Returns Int

With Encryption As

Begin

Declare @RetVal Int

	/* Get the last build of this stockpile which is active on this date and has one or more active components */
	/*  and is not yet reclaiming */
	Select @RetVal = Max(B.Build_Id)
	From StockpileBuild B
	Where B.Stockpile_Id = @Stockpile_Id
	And ((B.Start_Date Is Null) Or (B.Start_Date <= @Date)
	Or (B.Start_Date = @Date And dbo.GetShiftTypeOrderNo(B.Start_Shift) <= dbo.GetShiftTypeOrderNo(@Shift)))
	And ((B.End_Date Is Null) Or (B.End_Date > @Date)
	Or (B.End_Date = @Date And dbo.GetShiftTypeOrderNo(B.End_Shift) >= dbo.GetShiftTypeOrderNo(@Shift)))
	And ((B.Reclaim_Start_Date Is Null) Or (B.Reclaim_Start_Date > @Date)
	Or (B.Reclaim_Start_Date = @Date And dbo.GetShiftTypeOrderNo(B.Reclaim_Start_Shift) > dbo.GetShiftTypeOrderNo(@Shift)))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetBuildableStockpileBuild">
 <Function>
	Get the last build of this stockpile which is active on this date and has 
	one or more active components and is not yet reclaiming. 
 </Function>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesTruckExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesTruckExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesTruckExist]
GO

CREATE Function dbo.DoesTruckExist

(@Truck_Id Char(31))

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the given shift code is valid in the system */
	Select @Count = Count(*)
	From Truck
	Where Truck_Id = @Truck_Id

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="DoesTruckExist">
 <Function>
	Returns 1 if given truck exists, 0 if given truck does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesStockpileSurveyTypeExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesStockpileSurveyTypeExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesStockpileSurveyTypeExist]
GO

Create Function dbo.DoesStockpileSurveyTypeExist

(@Stockpile_Survey_Type_Id Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the given stockpile survey type is valid in the system */
	Select @Count = Count(*)
	From StockpileSurveyType
	Where Stockpile_Survey_Type_Id = @Stockpile_Survey_Type_Id

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesStockpileSurveyTypeExist">
 <Function>
	Returns 1 if given stockpile survey type exists, 0 if given stockpile survey type does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesStockpileSurveySampleExist.udf'
GO

If Object_Id('dbo.DoesStockpileSurveySampleExist') Is Not Null
	Drop Function dbo.DoesStockpileSurveySampleExist
Go

CREATE Function dbo.DoesStockpileSurveySampleExist
(
	@Stockpile_Id Int,
	@Build_Id Int,
	@Stockpile_Survey_Date Datetime,
	@Stockpile_Survey_Shift Char(1)
)

Returns Bit

With Encryption 
As

Begin

	Declare @RetVal Bit
	Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the given stockpile survey sample is already in the system */
	Select @Count = Count(*)
	From StockpileSurveySample
	Where Stockpile_Id = @Stockpile_Id
		And ((Build_Id = @Build_Id)
		Or (Build_Id Is Null
		And @Build_Id Is Null))
		And Stockpile_Survey_Date = @Stockpile_Survey_Date
		And Stockpile_Survey_Shift = @Stockpile_Survey_Shift

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End

GO

/*
<TAG Name="Data Dictionary" FunctionName="DoesStockpileSurveySampleExist">
 <Function>
	Returns 1 if given stockpile survey sample exists, 0 if given stockpile survey sample does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesStockpileExist.udf'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DoesStockpileExist'))
	Drop Function dbo.DoesStockpileExist
Go

Create Function dbo.DoesStockpileExist
(
	@iStockpile_Name Varchar(31)
)

Returns Bit

With Encryption 
As

Begin

	Declare @RetVal Bit

	Select @RetVal = 0

	If ((Select Count(*) From Stockpile Where Stockpile_Name = @iStockpile_Name) = 1)
	Begin
		Select @RetVal = 1
	End

	Return (@RetVal)

End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesStockpileExist">
 <Function>
	Returns 1 if given stockpile exists, 0 if given stockpile does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesStockpileBuildExist.udf'
GO

If Object_Id('dbo.DoesStockpileBuildExist') Is Not Null
	Drop Function dbo.DoesStockpileBuildExist
Go

Create Function dbo.DoesStockpileBuildExist
(
	@Stockpile_Id Int,
	@Build_Id Int
)

Returns Bit

With Encryption 
As

Begin

	Declare @RetVal Bit

	Set @RetVal = 0

	If ((Select Count(*) From StockpileBuild Where Stockpile_Id = @Stockpile_Id And Build_Id = @Build_Id) = 1)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End

GO

/*
<TAG Name="Data Dictionary" FunctionName="DoesStockpileBuildExist">
 <Function>
	Returns 1 if given stockpile build exists, 0 if given stockpile build does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesStockpileBuildComponentExist.udf'
GO

If Object_Id('dbo.DoesStockpileBuildComponentExist') Is Not Null
	Drop Function dbo.DoesStockpileBuildComponentExist
Go

Create Function dbo.DoesStockpileBuildComponentExist
(
	@Stockpile_Id Int,
	@Build_Id Int,
	@Component_Id Int
)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Set @RetVal = 0

	If ((Select Count(*) From StockpileBuildComponent Where Stockpile_Id = @Stockpile_Id And Build_Id = @Build_Id And Component_Id = @Component_Id) > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End

GO



/*
<TAG Name="Data Dictionary" FunctionName="DoesStockpileBuildComponentExist">
 <Function>
	Returns 1 if given stockpile build component exists, 0 if given stockpile build component does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesShiftTypeExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesShiftTypeExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesShiftTypeExist]
GO

Create Function dbo.DoesShiftTypeExist

(@Shift Char(1))

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the given shift code is valid in the system */
	Select @Count = Count(*)
	From ShiftType
	Where Shift = @Shift

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesShiftTypeExist">
 <Function>
	Returns 1 if given shift type exists, 0 if given shift type does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesModelBlockPartialExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesModelBlockPartialExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesModelBlockPartialExist]
GO

CREATE Function dbo.DoesModelBlockPartialExist

(@Model_Block_Id Int,
@Sequence_No Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the model block exists based on any of the details given */
	Select @Count = Count(*)
	From ModelBlockPartial
	Where Model_Block_Id = @Model_Block_Id
 	And Sequence_No = @Sequence_No

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesModelBlockPartialExist">
 <Function>
	Returns 1 if given model block partial exists, 0 if given model block partial does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesModelBlockExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesModelBlockExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesModelBlockExist]
GO

CREATE Function dbo.DoesModelBlockExist

(@Block_Model_Id Int,
@Model_Block_Id Int = Null,
@Code Varchar(31) = Null,
@X Float = Null,
@Y Float = Null,
@Z Float = Null)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @RetVal = 0

	/* Check to see if the model block exists based on any of the details given */
	Select @Count = Count(*)
	From ModelBlock
	Where Block_Model_Id = @Block_Model_Id
 	And ((Model_Block_Id = @Model_Block_Id)
 	Or (((Code = @Code) And (@Code Is Not Null))
	Or (X = @X And Y = @Y And Z = @Z) And (@X Is Not Null And @Y Is Not Null And @Z Is Not Null)))

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesModelBlockExist">
 <Function>
	Returns 1 if given model block exists, 0 if given model block does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesDigblockExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesDigblockExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesDigblockExist]
GO

Create Function dbo.DoesDigblockExist

(@Digblock_Id Varchar(31))

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Select @RetVal = 0

	If Exists(Select Top 1 1 From dbo.Digblock Where Digblock_Id = @Digblock_Id)
	Begin
		Select @RetVal = 1
	End

	Return (@RetVal)
End
GO

GRANT EXECUTE ON dbo.DoesDigblockExist TO CoreDigblockManager
GO

/*
<TAG Name="Data Dictionary" FunctionName="dbo.DoesDigblockExist">
 <Function>
	Returns 1 if given digblock exists, 0 if given digblock does not exist.
 </Function>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsStockpileBuildReclaimable.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[IsStockpileBuildReclaimable]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[IsStockpileBuildReclaimable]
GO

CREATE Function dbo.IsStockpileBuildReclaimable
(
	@Stockpile_Id Int,
	@Build_Id Int,
	@Date Datetime,
	@Shift Char(1)
)
Returns Bit
With Encryption As
Begin
	Declare @Start_Date Datetime
	Declare @Start_Shift Char(1)
	Declare @Reclaim_Start_Date Datetime
	Declare @Reclaim_Start_Shift Char(1)
	Declare @End_Date Datetime
	Declare @End_Shift Char(1)
	Declare @Stockpile_State_Id Char(10)
	Declare @RetVal Bit

	/* Check to see whether the stockpile build is currently active */
	Select @Start_Date = Start_Date, @Start_Shift = Start_Shift,
	 @Reclaim_Start_Date = Reclaim_Start_Date, @Reclaim_Start_Shift = Reclaim_Start_Shift,
	 @End_Date = End_Date, @End_Shift = End_Shift,
	 @Stockpile_State_Id = Stockpile_State_Id
	From StockpileBuild
	Where Stockpile_Id = @Stockpile_Id
	And Build_Id = @Build_Id

	Set @RetVal = 0

	If (@Start_Date Is Not Null)
	Begin
		/* If the stockpile build is currently not building */
		If (@Stockpile_State_Id <> 'BUILDING')
		Begin
			Select @RetVal = 1

			/* If the stockpile build has not yet been opened */
			If (((@Date < @Start_Date) Or (@Date = @Start_Date And dbo.GetShiftTypeOrderNo(@Shift) < dbo.GetShiftTypeOrderNo(@Start_Shift)))
			And(@Start_Date Is Not Null))
			Begin
				Select @RetVal = 0
			End
		
			/* If the stockpile build is already closed */
			If (((@Date > @End_Date) Or (@Date = @End_Date And dbo.GetShiftTypeOrderNo(@Shift) > dbo.GetShiftTypeOrderNo(@End_Shift)))
			And (@End_Date Is Not Null) And (@RetVal = 1))
			Begin
				Select @RetVal = 0
			End
	
			/* If the stockpile has not yet entered reclaim mode, or is currently in building mode */
			If (((@Date < @Reclaim_Start_Date) Or (@Date = @Reclaim_Start_Date And dbo.GetShiftTypeOrderNo(@Shift) < dbo.GetShiftTypeOrderNo(@Reclaim_Start_Shift)))
			And (@Reclaim_Start_Date Is Not Null) And (@RetVal = 1))
			Begin
				Select @RetVal = 0
			End
		End
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="IsStockpileBuildReclaimable">
 <Function>
	Check to see whether the stockpile build is currently active.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsStockpileBuildBuildable.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[IsStockpileBuildBuildable]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[IsStockpileBuildBuildable]
GO

CREATE Function dbo.IsStockpileBuildBuildable
(
	@Stockpile_Id Int,
	@Build_Id Int,
	@Date Datetime,
	@Shift Char(1)
)
Returns Bit
With Encryption As
Begin
	Declare @Start_Date Datetime
	Declare @Start_Shift Char(1)
	Declare @Reclaim_Start_Date Datetime
	Declare @Reclaim_Start_Shift Char(1)
	Declare @End_Date Datetime
	Declare @End_Shift Char(1)
	Declare @RetVal Bit

	/* Check to see whether the stockpile build is currently active */
	Select @Start_Date = Start_Date, @Start_Shift = Start_Shift,
	 @Reclaim_Start_Date = Reclaim_Start_Date, @Reclaim_Start_Shift = Reclaim_Start_Shift,
	 @End_Date = End_Date, @End_Shift = End_Shift
	From StockpileBuild
	Where Stockpile_Id = @Stockpile_Id
	And Build_Id = @Build_Id

	Set @RetVal = 0

	If (@Start_Date Is Not Null)
	Begin
		Select @RetVal = 1
	
		/* If the stockpile build has not yet been opened */
		If (((@Date < @Start_Date) Or (@Date = @Start_Date And dbo.GetShiftTypeOrderNo(@Shift) < dbo.GetShiftTypeOrderNo(@Start_Shift)))
		And(@Start_Date Is Not Null))
		Begin
			Select @RetVal = 0
		End
	
		/* If the stockpile build is already closed */
		If (((@Date > @End_Date) Or (@Date = @End_Date And dbo.GetShiftTypeOrderNo(@Shift) > dbo.GetShiftTypeOrderNo(@End_Shift)))
		And (@End_Date Is Not Null) And (@RetVal = 1))
		Begin
			Select @RetVal = 0
		End

		/* If the stockpile has already entered reclaim mode */
		If (((@Date > @Reclaim_Start_Date) Or (@Date = @Reclaim_Start_Date And dbo.GetShiftTypeOrderNo(@Shift) >= dbo.GetShiftTypeOrderNo(@Reclaim_Start_Shift)))
		And (@Reclaim_Start_Date Is Not Null) And (@RetVal = 1))
		Begin
			Select @RetVal = 0
		End
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="IsStockpileBuildBuildable">
 <Function>
	Check to see whether the stockpile build is currently active.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsDigblockActive.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[IsDigblockActive]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[IsDigblockActive]
GO

CREATE Function dbo.IsDigblockActive
(
	@Digblock_Id Varchar(31),
	@Date Datetime,
	@Shift Char(1)
)
Returns Bit
With Encryption As
Begin
	Declare @Start_Date Datetime
	Declare @Start_Shift Char(1)
	Declare @End_Date Datetime
	Declare @End_Shift Char(1)
	Declare @RetVal Bit
	Declare @First_Shift Char(1)
	Declare @Last_Shift Char(1)

	/* Check to see whether the digblock is currently active */
	Select @Start_Date = Start_Date, @Start_Shift = Start_Shift,
	 @End_Date = End_Date, @End_Shift = End_Shift
	From Digblock
	Where Digblock_Id = @Digblock_Id

	Set @RetVal = 0

	If (@Start_Date Is Not Null)
	Begin
		Select @RetVal = 1

		/* If a specific shift has been given */
		If (@Shift Is Not Null)
		Begin
			/* Use that shift for checking */
			Set @First_Shift = @Shift
			Set @Last_Shift = @Shift
		End
		Else
		Begin
			/* Use the actual first and last shifts */
			Set @First_Shift = dbo.GetFirstShiftType ()
			Set @Last_Shift = dbo.GetLastShiftType ()
		End


		/* If the digblock has not yet been opened or is not set as activated */
		If ((((@Date < @Start_Date)
		Or (@Date = @Start_Date And dbo.GetShiftTypeOrderNo(@First_Shift) < dbo.GetShiftTypeOrderNo(@Start_Shift)))
		Or (@Start_Date Is Null)))
		Begin
			Select @RetVal = 0
		End
	
		/* If the stockpile is already closed */
		If (((@Date > @End_Date)
		Or (@Date = @End_Date And dbo.GetShiftTypeOrderNo(@Last_Shift) > dbo.GetShiftTypeOrderNo(@End_Shift)))
		And (@End_Date Is Not Null) And (@RetVal = 1))
		Begin
			Select @RetVal = 0
		End
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="IsDigblockActive">
 <Function>
	Check to see whether the digblock is currently active.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetRecalcProgressPercentage.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetRecalcProgressPercentage]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetRecalcProgressPercentage]
GO

CREATE Function dbo.GetRecalcProgressPercentage

(@Start_Date Datetime,
@Start_Shift Char(1),
@End_Date Datetime,
@End_Shift Char(1),
@Current_Date Datetime,
@Current_Shift Char(1))

Returns Real

With Encryption As

Begin

Declare @RetVal Real
Declare @Total_Shifts Int
Declare @Current_Shifts Int
Declare @This_Date Datetime
Declare @This_Shift Char(1)
Declare @No_Shifts_Per_Day Int

	Select @No_Shifts_Per_Day = Count(*)
	From ShiftType


	Set @Total_Shifts = 0
	Set @This_Date = @Start_Date
	Set @This_Shift = @Start_Shift

	While ((@This_Date < @End_Date)
	Or (@This_Date = @End_Date And dbo.GetShiftTypeOrderNo(@This_Shift) < dbo.GetShiftTypeOrderNo(@End_Shift)))
	Begin
		Set @Total_Shifts = @Total_Shifts + 1

		If (@This_Shift = dbo.GetLastShiftType())
		Begin
			Set @This_Date = DateAdd(Day, 1, @This_Date)
			Set @This_Shift = dbo.GetFirstShiftType()
		End
		Else
		Begin
			Set @This_Shift = dbo.GetNextShiftType(@This_Shift)
		End
	End


	Set @Current_Shifts = 0
	Set @This_Date = @Start_Date
	Set @This_Shift = @Start_Shift

	While ((@This_Date < @Current_Date)
	Or (@This_Date = @Current_Date And dbo.GetShiftTypeOrderNo(@This_Shift) < dbo.GetShiftTypeOrderNo(@Current_Shift)))
	Begin
		Set @Current_Shifts = @Current_Shifts + 1

		If (@This_Shift = dbo.GetLastShiftType())
		Begin
			Set @This_Date = DateAdd(Day, 1, @This_Date)
			Set @This_Shift = dbo.GetFirstShiftType()
		End
		Else
		Begin
			Set @This_Shift = dbo.GetNextShiftType(@This_Shift)
		End
	End

	If (@Total_Shifts > 0)
	Begin
		Set @RetVal = 100 * Cast(@Current_Shifts As Real) / Cast(@Total_Shifts As Real)
	End
	Else
	Begin
		Set @RetVal = 100
	End

	If (@RetVal > 100)
	Begin
		Set @RetVal = 100
	End


	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetRecalcProgressPercentage">
 <Function>
	Returns the recalc progress percentage.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeParentLocationTypeList.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationTypeParentLocationTypeList]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationTypeParentLocationTypeList]
GO

CREATE Function dbo.GetLocationTypeParentLocationTypeList

(@Location_Type_Id TINYINT)

Returns @LocationType Table (Location_Type_Id TINYINT)

With Encryption As

Begin

Declare @Current_Location_Type_Id TINYINT

	-- Insert the given location type into the return table
	Insert Into @LocationType
	 (Location_Type_Id)
	Values (@Location_Type_Id)

	Set @Current_Location_Type_Id = @Location_Type_Id

	-- While there is a current location type
	While (@Current_Location_Type_Id Is Not Null)
	Begin
		-- Get the current location type's parent type, if any
		Select @Current_Location_Type_Id = Parent_Location_Type_Id
		From LocationType
		Where Location_Type_Id = @Current_Location_Type_Id

		-- If this parent location type exists
		If (@Current_Location_Type_Id Is Not Null)
		Begin
			-- Insert it into the return table
			Insert Into @LocationType
			 (Location_Type_Id)
			Values (@Current_Location_Type_Id)
		End
	End

	Return
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeParentLocationTypeList">
 <Function>
	Returns the given location type's parent type.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeChildLocationTypeList.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationTypeChildLocationTypeList]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationTypeChildLocationTypeList]
GO

CREATE Function dbo.GetLocationTypeChildLocationTypeList

(@Location_Type_Id TINYINT)

Returns @LocationType Table (Location_Type_Id TINYINT)

With Encryption As

Begin

Declare @Child_Location_Type_Id TINYINT

	-- Get a cursor of the location types which are children of this one
	Declare Location_Curs Cursor Local Fast_Forward For
	Select Location_Type_Id
	From LocationType
	Where Parent_Location_Type_Id = @Location_Type_Id
	Order By Location_Type_Id

	Open Location_Curs

	Fetch Next From Location_Curs Into
	 @Child_Location_Type_Id

	-- For each child location type
	While (@@Fetch_Status = 0)
	Begin
		-- Insert this child location type
		Insert Into @LocationType
		 (Location_Type_Id)
		Values (@Child_Location_Type_Id)

		-- Insert any of it's children
		Insert Into @LocationType
		 (Location_Type_Id)
		Select Location_Type_Id
		From dbo.GetLocationTypeChildLocationTypeList(@Child_Location_Type_Id)


		Fetch Next From Location_Curs Into
		 @Child_Location_Type_Id
	End

	Close Location_Curs
	Deallocate Location_Curs

	Return
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeChildLocationTypeList">
 <Function>
	Returns a list of location types for child locations from the given parent location.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLastShiftType.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLastShiftType]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLastShiftType]
GO

CREATE Function dbo.GetLastShiftType

()

Returns Char(1)

With Encryption As

Begin

Declare @RetVal Char(1)


	Select @RetVal = Shift
	From ShiftType
	Where Order_No = 	(Select Max(Order_No)
				From ShiftType)

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLastShiftType">
 <Function>
	Returns the last shift type.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetGramsPerOunce.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetGramsPerOunce]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetGramsPerOunce]
GO

CREATE Function [dbo].[GetGramsPerOunce]

()

Returns Real

With Encryption As

Begin

Declare @Ounces_Type Varchar(255)
Declare @RetVal Real

	Declare @value Varchar(255)

	Exec dbo.GetSystemSetting
		@iSetting_Id = 'OUNCES_TYPE',
		@iValue = @value Output

	/* Get the system setting for which type of ounces to use */
	Select @Ounces_Type = Coalesce(@value, '')

	/*  Disambiguation of the "ounce"
	
	http://en.wikipedia.org/wiki/Grain_%28measure%29
	http://en.wikipedia.org/wiki/Pound_%28mass%29
	http://en.wikipedia.org/wiki/Ounce

	The following table was derived using the references above

	1 grain = weight of grain of barley
	        = 0.06479891 grams

	*** APOTHECARIES' ***
	obsolete term
	1 apothecaries' ounce = 1 troy ounce

	*** TROY ***
	used for the pricing of precious metals (ie gold, platinum, silver)
	12 troy ounces = 1 troy pound
	1 troy pound = 5760 grains

	*** AVOIDRDUPOIS ***
	commonly abbreviated as lb in American usage
	16 avoirdupois ounces = 1 avoirdupois pound
	1 avoirdupois pound = 7000 grains

	*/

	If (@Ounces_Type = 'TROY')
	Begin
		-- troy ounce
		Set @RetVal = 31.1034768
	End
	Else
	Begin
		-- avoirdupois ounce
		Set @RetVal = 28.349523125
	End

	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetGramsPerOunce">
 <Function>
	Get the system setting for which type of ounces to use

	Disambiguation of the "ounce"
	http://en.wikipedia.org/wiki/Grain_%28measure%29
	http://en.wikipedia.org/wiki/Pound_%28mass%29
	http://en.wikipedia.org/wiki/Ounce

	The following table was derived using the references above

	1 grain = weight of grain of barley
	        = 0.06479891 grams

	*** APOTHECARIES' ***
	obsolete term
	1 apothecaries' ounce = 1 troy ounce

	*** TROY ***
	used for the pricing of precious metals (ie gold, platinum, silver)
	12 troy ounces = 1 troy pound
	1 troy pound = 5760 grains

	*** AVOIDRDUPOIS ***
	commonly abbreviated as lb in American usage
	16 avoirdupois ounces = 1 avoirdupois pound
	1 avoirdupois pound = 7000 grains
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateShiftStartDatetime.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDateShiftStartDatetime]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDateShiftStartDatetime]
GO

CREATE Function dbo.GetDateShiftStartDatetime
(
	@Date Datetime,
	@Shift Char(1)
)
Returns Datetime
With Encryption As
Begin

	Declare @RetVal Datetime
	Declare @Order_No Int
	Declare @Start_Time Datetime
	Declare @Day_Offset Int

	-- Initialise the return value to the given date
	Set @RetVal = @Date

	-- Get the details of the given shift
	Select @Order_No = Order_No,
		@Start_Time = Start_Time,
		@Day_Offset = Day_Offset
	From ShiftType
	Where Shift = @Shift

	--Apply Offset First
	Set @RetVal = DateAdd(Day, @Day_Offset, @RetVal)

	-- Add the hours and minutes of the start time value to get the required date/time
	Set @RetVal = DateAdd(Hour, DatePart(Hour, @Start_Time), 
						DateAdd(Minute, DatePart(Minute, @Start_Time), 
						DateAdd(Second, DatePart(Second, @Start_Time), @RetVal)))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDateShiftStartDatetime">
 <Function>
	Returns the shift start date or time.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateShiftEndDatetime.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDateShiftEndDatetime]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetDateShiftEndDatetime]
GO

Create Function dbo.GetDateShiftEndDatetime
(
	@Date Datetime,
	@Shift Char(1)
)
Returns Datetime
With Encryption As
Begin

	Declare @RetVal Datetime
	Declare @Order_No Int
	Declare @Start_Time Datetime
	Declare @End_Time Datetime
	Declare @Day_Offset Int

	-- Initialise the return value to the given date
	Set @RetVal = @Date

	-- Get the details of the given shift
	Select @Order_No = Order_No,
		@Start_Time = Start_Time,
		@End_Time = End_Time,
		@Day_Offset = Day_Offset
	From dbo.ShiftType 
	Where Shift = @Shift

	--Apply Offset First
	Set @RetVal = DateAdd(Day, @Day_Offset, @RetVal)

	-- If we crossed a date boundary
	If DatePart(Hour, @End_Time) < DatePart(Hour, @Start_Time)
	Begin
		Set @RetVal = DateAdd(Day, 1, @RetVal)
	End

	-- Add the hours and minutes of the start time value to get the required date/time
	Set @RetVal = DateAdd(Hour, DatePart(Hour, @End_Time), 
						DateAdd(Minute, DatePart(Minute, @End_Time), 
						DateAdd(Second, DatePart(Second, @End_Time), @RetVal)))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetDateShiftEndDatetime">
 <Function>
	Returns the shift end date or time.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateRangeList.udf'
GO

If Object_Id('dbo.GetDateRangeList') Is Not Null
	Drop Function dbo.GetDateRangeList
Go

Create Function dbo.GetDateRangeList
(
	@Start_Date Datetime,
	@End_Date Datetime,
	@Interval Varchar(15),
	@Step Int
)

Returns @DATE_LIST Table
(
	Start_Date Datetime,
	End_Date Datetime,
	Primary Key (Start_Date Asc)
)

With Encryption
As

Begin
	Insert Into @DATE_LIST
	(
		Start_Date, End_Date
	)
	Select This_Date,
		Case @Interval
			When 'Day' Then DateAdd(Day, -1, DateAdd(Day, @Step, This_Date))
			When 'Week' Then DateAdd(Day, -1, DateAdd(Week, @Step, This_Date))
			When 'Month' Then DateAdd(Day, -1, DateAdd(Month, @Step, This_Date))
			When 'Year' Then DateAdd(Day, -1, DateAdd(Year, @Step, This_Date))
			Else Null
		End As End_Date
		From dbo.GetDateList(@Start_Date, @End_Date, @Interval, @Step)
		Group By This_Date

	Return
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetDateRangeList">
 <Function>
	Returns a list of dates with a given range.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesBlockModelTypeExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesBlockModelTypeExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesBlockModelTypeExist]
GO

Create Function dbo.DoesBlockModelTypeExist

(@Block_Model_Type_Id Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Set @RetVal = 0

	If ((Select Count(*) From BlockModelType Where Block_Model_Type_Id = @Block_Model_Type_Id) > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesBlockModelTypeExist">
 <Function>
	Returns 1 if given block model type exists, 0 if given block model type does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.CompareDateShift.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CompareDateShift]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[CompareDateShift]
GO

CREATE Function dbo.CompareDateShift

(@Date_1 Datetime,
@Shift_1 Char(1),
@Comparison_Type Varchar(2),
@Date_2 Datetime,
@Shift_2 Char(1))

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Set @RetVal = Null

	If (@Comparison_Type = '=')
	Begin
		Set @RetVal = 0

		If ((@Date_1 = @Date_2)
		And (@Shift_1 = @Shift_2))
		Begin
			Set @RetVal = 1
		End
	End
	Else If (@Comparison_Type = '<')
	Begin
		Set @RetVal = 0

		If ((@Date_1 < @Date_2)
		Or (@Date_1 = @Date_2
		And dbo.GetShiftTypeOrderNo(@Shift_1) < dbo.GetShiftTypeOrderNo(@Shift_2)))
		Begin
			Set @RetVal = 1
		End
	End
	Else If (@Comparison_Type = '>')
	Begin
		Set @RetVal = 0

		If ((@Date_1 > @Date_2)
		Or (@Date_1 = @Date_2
		And dbo.GetShiftTypeOrderNo(@Shift_1) > dbo.GetShiftTypeOrderNo(@Shift_2)))
		Begin
			Set @RetVal = 1
		End
	End
	Else If (@Comparison_Type = '<=')
	Begin
		Set @RetVal = 0

		If ((@Date_1 < @Date_2)
		Or (@Date_1 = @Date_2
		And dbo.GetShiftTypeOrderNo(@Shift_1) <= dbo.GetShiftTypeOrderNo(@Shift_2)))
		Begin
			Set @RetVal = 1
		End
	End
	Else If (@Comparison_Type = '>=')
	Begin
		Set @RetVal = 0

		If ((@Date_1 > @Date_2)
		Or (@Date_1 = @Date_2
		And dbo.GetShiftTypeOrderNo(@Shift_1) >= dbo.GetShiftTypeOrderNo(@Shift_2)))
		Begin
			Set @RetVal = 1
		End
	End

	Return @RetVal
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="CompareDateShift">
 <Function>
	Compares Dates two dates and shifts, returns 1 if correct, returns 0 if incorrect.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsInApprovedDigblockSurveyPeriod.udf'
GO

if object_id('dbo.IsInApprovedDigblockSurveyPeriod') is not NULL
	Drop Function dbo.IsInApprovedDigblockSurveyPeriod
GO

Create Function dbo.IsInApprovedDigblockSurveyPeriod
(
	@iDate Datetime,
	@iShift Char(1) = Null,
	@iDigblock_Id Varchar(31)
)

Returns Int
With Encryption As

Begin
	Declare @RetVal Bit

	Declare @Digblock_Survey_Type_Id Int
	Declare @Location_Id Int
	Declare @curLOCATIONS Cursor
	Declare @Shift Char(1)

	-- if the shift is not supplied, use the last shift of the day
	-- this check is more pessimistic, but will enforce no entries
	-- within an approved survey
	If @iShift Is Null
		Set @Shift = dbo.GetLastShiftType()
	Else
		Set @Shift = @iShift

	-- Find the Digblock Survey Type
	Set @Digblock_Survey_Type_Id = NULL	

	Set @curLOCATIONS = Cursor Local Fast_Forward Read_Only For
		Select DL.Location_Id 
		From DigblockLocation DL
		Where Digblock_Id = @iDigblock_Id
	Open @curLOCATIONS

	-- Grab the first Location based survey type	
	-- If the site is not using location based depletions this will return NULL
	-- and the period will check against all survey types
	Fetch Next From @curLOCATIONS Into @Location_Id
	While @@Fetch_Status = 0 And @Digblock_Survey_Type_Id Is Null
	Begin
		Select @Digblock_Survey_Type_Id = DST.Digblock_Survey_Type_Id
		From Location As L
			Inner Join dbo.GetLocationParentLocationList(@Location_Id) LL
			On L.Location_Id = LL.Location_Id
			Inner Join DigblockSurveyType DST
			On L.Location_Type_Id = DST.Location_Type_Id	
	
		Fetch Next From @curLOCATIONS Into @Location_Id	
	End
	Close @curLOCATIONS

	-- Check to see whether the date and shift falls in an approved depletion period
	Select @RetVal = 0
	
	Select Top 1 @RetVal = (Case When Adjust_Haulage = 1 Then Is_Approved Else 0 End)
	From DigblockSurvey
	Where Is_Entire_Digblock = 0
		And dbo.CompareDateShift(Digblock_Survey_Date, Digblock_Survey_Shift, '>=', @iDate, @Shift) = 1
		And Digblock_Survey_Date >= @iDate  -- for index purposes
		And (@Digblock_Survey_Type_Id Is Null Or Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id) --Limit to Location Depletion Survey
		And @iDigblock_Id Is Not Null -- If haulage is NOT from a block then it is NOT within a Digblock Survey Period. (DCONTI 21-Feb-2007)
	Order By Digblock_Survey_Date, dbo.GetShiftTypeOrderNo(Digblock_Survey_Shift)
	
	Return (@RetVal)
End
Go
GRANT EXECUTE ON dbo.IsInApprovedDigblockSurveyPeriod TO RecalcDirect

/*
<TAG Name="Data Dictionary" FunctionName="IsInApprovedDigblockSurveyPeriod">
 <Function>
	If the shift is not supplied, use the last shift of the day	this check is more 
	pessimistic, but will enforce no entries within an approved survey.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsDigblockSurveyApproved.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[IsDigblockSurveyApproved]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[IsDigblockSurveyApproved]
GO

Create Function dbo.IsDigblockSurveyApproved
(
	@Digblock_Survey_Date Datetime,
	@Digblock_Survey_Shift Char(1),
	@Digblock_Survey_Type_Id Int
)
Returns Bit
With Encryption As
Begin
	Declare @Is_Approved Bit

	Set @Digblock_Survey_Date = dbo.GetDateDay(@Digblock_Survey_Date)

	Select @Is_Approved = Is_Approved
	From DigblockSurvey
	Where Digblock_Survey_Date = @Digblock_Survey_Date
	 And Digblock_Survey_Shift = @Digblock_Survey_Shift
	 And Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id

	Return @Is_Approved
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="IsDigblockSurveyApproved">
 <Function>
	Check to see whether the digblock is approved.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeLocationTypeId.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationTypeLocationTypeId]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationTypeLocationTypeId]
GO

Create Function [dbo].[GetLocationTypeLocationTypeId]

(@Location_Id Int,
@Location_Type_Id TINYINT)

Returns Varchar(31)

With Encryption As

Begin

Declare @Name Varchar(31)
Declare @Found Bit
Declare @Parent_Location_Id Int
Declare @Current_Location_Type_Id TINYINT

	Set @Found = 0

	-- Get the location type and name for the given location record
	Select @Name = Location_Type_Id,
	 @Parent_Location_Id = Parent_Location_Id,
	 @Current_Location_Type_Id = Location_Type_Id
	From Location
	Where Location_Id = @Location_Id

	If (@Current_Location_Type_Id = @Location_Type_Id)
	Begin
		Set @Found = 1
	End

	-- While there are parent records, and the type is not the one which is required to be returned
	While ((@Parent_Location_Id Is Not Null) And (@Current_Location_Type_Id <> @Location_Type_Id))
	Begin
		-- Keep getting the parent of this location
		Select @Name = Location_Type_Id,
		 @Parent_Location_Id = Parent_Location_Id,
		 @Current_Location_Type_Id = Location_Type_Id
		From Location
		Where Location_Id = @Parent_Location_Id

		If (@Current_Location_Type_Id = @Location_Type_Id)
		Begin
			Set @Found = 1
		End
	End

	If (@Found = 0)
	Begin
		Set @Name = Null
	End

	Return @Name
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeLocationTypeId">
 <Function>
	Returns the location type ID for the given location record.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeLocationName.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationTypeLocationName]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationTypeLocationName]
GO

CREATE Function [dbo].[GetLocationTypeLocationName]

(@Location_Id Int,
@Location_Type_Id TINYINT)

Returns Varchar(31)

With Encryption As

Begin

Declare @Name Varchar(31)
Declare @Found Bit
Declare @Parent_Location_Id Int
Declare @Current_Location_Type_Id TINYINT

	Set @Found = 0

	-- Get the location type and name for the given location record
	Select @Name = Name,
	 @Parent_Location_Id = Parent_Location_Id,
	 @Current_Location_Type_Id = Location_Type_Id
	From Location
	Where Location_Id = @Location_Id

	If (@Current_Location_Type_Id = @Location_Type_Id)
	Begin
		Set @Found = 1
	End

	-- While there are parent records, and the type is not the one which is required to be returned
	While ((@Parent_Location_Id Is Not Null) And (@Current_Location_Type_Id <> @Location_Type_Id))
	Begin
		-- Keep getting the parent of this location
		Select @Name = Name,
		 @Parent_Location_Id = Parent_Location_Id,
		 @Current_Location_Type_Id = Location_Type_Id
		From Location
		Where Location_Id = @Parent_Location_Id

		If (@Current_Location_Type_Id = @Location_Type_Id)
		Begin
			Set @Found = 1
		End
	End

	If (@Found = 0)
	Begin
		Set @Name = Null
	End

	Return @Name
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeLocationName">
 <Function>
	Return the location name for the given location record.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeLocationId.udf'
GO

If Object_Id('dbo.GetLocationTypeLocationId') Is Not Null
	Drop Function dbo.GetLocationTypeLocationId
Go

Create Function dbo.GetLocationTypeLocationId
(
	@iLocation_Id Int,
	@iLocation_Type_Id TINYINT
)

Returns Int

With Encryption
As

Begin

	Declare @Location_Id Int
	Declare @Found Bit
	Declare @Parent_Location_Id Int
	Declare @Current_Location_Type_Id TINYINT

	Set @Found = 0

	-- Get the location type and name for the given location record
	Select @Location_Id = Location_Id,
		@Parent_Location_Id = Parent_Location_Id,
		@Current_Location_Type_Id = Location_Type_Id
	From dbo.Location
	Where Location_Id = @iLocation_Id

	If (@Current_Location_Type_Id = @iLocation_Type_Id)
	Begin
		Set @Found = 1
	End

	-- While there are parent records, and the type is not the one which is required to be returned
	While ((@Parent_Location_Id Is Not Null) And (@Current_Location_Type_Id <> @iLocation_Type_Id))
	Begin
		-- Keep getting the parent of this location
		Select @Location_Id = Location_Id,
			@Parent_Location_Id = Parent_Location_Id,
			@Current_Location_Type_Id = Location_Type_Id
		From dbo.Location
		Where Location_Id = @Parent_Location_Id

		If (@Current_Location_Type_Id = @iLocation_Type_Id)
		Begin
			Set @Found = 1
		End
	End

	If (@Found = 0)
	Begin
		Set @Location_Id = Null
	End

	Return @Location_Id
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeLocationId">
 <Function>
	Returns the location ID for the given location type that is related to the location passed in.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationParentLocationList.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationParentLocationList]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationParentLocationList]
GO

CREATE Function dbo.GetLocationParentLocationList

(@Location_Id Int)

Returns @Location Table (Location_Id Int)

With Encryption As

Begin

Declare @Parent_Location_Id Int

	-- Get a cursor of the locations which are parent of this one
	Declare Location_Curs Cursor Local Fast_Forward For
	Select Parent_Location_Id
	From Location
	Where Location_Id = @Location_Id
	Order By Name

	Open Location_Curs

	Fetch Next From Location_Curs Into
	 @Parent_Location_Id

	-- For each child location
	While (@@Fetch_Status = 0)
	Begin
		-- Insert this parent location
		Insert Into @Location
		 (Location_Id)
		Values (@Parent_Location_Id)

		-- Insert any of it's children
		Insert Into @Location
		 (Location_Id)
		Select Location_Id
		From dbo.GetLocationParentLocationList(@Parent_Location_Id)


		Fetch Next From Location_Curs Into
		 @Parent_Location_Id
	End

	Close Location_Curs
	Deallocate Location_Curs

	Return
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationParentLocationList">
 <Function>
	Returns parent location of the given child location.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationChildLocationList.udf'
GO

IF Object_Id('dbo.GetLocationChildLocationList') IS NOT NULL
	DROP FUNCTION dbo.GetLocationChildLocationList
GO

CREATE FUNCTION dbo.GetLocationChildLocationList
(
	@Location_Id INT
)
RETURNS @Location TABLE
(
	Location_Id INT NOT NULL,
	PRIMARY KEY (Location_Id)
)
WITH ENCRYPTION
AS
BEGIN
	INSERT INTO @Location 
	(
		Location_Id
	)
	SELECT Location_Id
	FROM dbo.GetLocationSubtree(@Location_Id)

	DELETE @Location
	WHERE Location_Id = @Location_Id
	
	RETURN
END
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationChildLocationList">
 <Function>
	Returns a list of child locations from the given parent location - minus the parent.
 </Function>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesMaterialTypeExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesMaterialTypeExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesMaterialTypeExist]
GO

Create Function dbo.DoesMaterialTypeExist

(@MaterialID Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Select @RetVal = 0

	If ((Select Count(*) From MaterialType Where Material_Type_Id = @MaterialID) > 0)
	Begin
		Select @RetVal = 1
	End

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="DoesMaterialTypeExist">
 <Function>
	Returns 1 if given material type exists, 0 if given material type does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesDigblockSurveyExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesDigblockSurveyExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesDigblockSurveyExist]
GO

CREATE Function dbo.DoesDigblockSurveyExist

(@Digblock_Survey_Date Datetime,
@Digblock_Survey_Shift Char(1),
@Digblock_Survey_Type_Id Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit
Declare @Count Int

	Set @Digblock_Survey_Date = dbo.GetDateDay (@Digblock_Survey_Date)

	Set @RetVal = 0

	Select @Count = Count(*)
	From DigblockSurvey
	Where Digblock_Survey_Date = @Digblock_Survey_Date
	And Digblock_Survey_Shift = @Digblock_Survey_Shift
	And Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id

	If (@Count > 0)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesDigblockSurveyExist">
 <Function>
	Returns 1 if given digblock survey exists, 0 if given digblock survey does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesBlockModelExist.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesBlockModelExist]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesBlockModelExist]
GO

Create Function dbo.DoesBlockModelExist

(@Block_Model_Id Int)

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Set @RetVal = 0

	If ((Select Count(*) From BlockModel Where Block_Model_Id = @Block_Model_Id) = 1)
	Begin
		Set @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="DoesBlockModelExist">
 <Function>
	Returns 1 if given block model exists, 0 if given block model does not exist.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialTypeIsWaste.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetMaterialTypeIsWaste]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetMaterialTypeIsWaste]
GO

CREATE Function dbo.GetMaterialTypeIsWaste

(@Material_Type_Id Int,
@Waste_Type_Id Varchar(31),
@Date Datetime)

Returns Bit

With Encryption As
/*-----------------------------------------------------------------------------
--  Name: GetMaterialTypeIsWaste
--  Purpose: Returns whether or not a Material Type is Waste
--
--  @Material_Type_Id Int
--  @Waste_Type_Id Varchar(31)
--  @Date Datetime - As at date to compare against end date of a waste period
--
--  Created By:		Unknown
--  Created Date: Unknown
--  Modified By:  Joshua Freitas
--  Modified Date: 11/08/2006
--
--  Changes
--  - Simplified Function to fully utilise a performance increase
--
------------------------------------------------------------------------------*/
Begin
	Declare @RetVal Bit

	select top 1 @RetVal = m.Is_Waste
	from MaterialTypeWasteTypePeriod m 
	Where m.Material_Type_Id = @Material_Type_Id
	And m.Waste_Type_Id = @Waste_Type_Id
	And (m.End_Date >= @Date or m.End_Date is Null)
	order by isNull(End_Date, '2999-01-01') asc

	Return @RetVal
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetMaterialTypeIsWaste">
 <Function>
	Returns whether or not a Material Type is Waste.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.IsStockpileBuildActive.udf'
GO

If Object_Id('dbo.IsStockpileBuildActive') Is Not Null
	Drop Function dbo.IsStockpileBuildActive
Go

CREATE Function dbo.IsStockpileBuildActive
(
	@Stockpile_Id Int,
	@Build_Id Int,
	@Date Datetime,
	@Shift Char(1)
)

Returns Bit

With Encryption 
As

Begin

	Declare @Start_Date Datetime
	Declare @Start_Shift Char(1)
	Declare @End_Date Datetime
	Declare @End_Shift Char(1)
	Declare @RetVal Bit

	/* Check to see whether the stockpile build is currently active */
	If (@Build_Id Is Not Null)
	Begin
		Select @Start_Date = Start_Date, @Start_Shift = Start_Shift,
		 @End_Date = End_Date, @End_Shift = End_Shift
		From StockpileBuild
		Where Stockpile_Id = @Stockpile_Id
		And Build_Id = @Build_Id
	End
	Else
	Begin
		Select Top 1 @Start_Date = Start_Date, @Start_Shift = Start_Shift
		From StockpileBuild
		Where Stockpile_Id = @Stockpile_Id
		Order By Start_Date, dbo.GetShiftTypeOrderNo (Start_Shift)

		Select Top 1 @End_Date = End_Date, @End_Shift = End_Shift
		From StockpileBuild
		Where Stockpile_Id = @Stockpile_Id
		Order By Start_Date Desc, dbo.GetShiftTypeOrderNo (Start_Shift) Desc
	End

	Set @RetVal = 0

	If (@Start_Date Is Not Null)
	Begin
		Select @RetVal = 1
	
		/* If the stockpile build has not yet been opened */
		If (((@Date < @Start_Date) Or (@Date = @Start_Date And dbo.GetShiftTypeOrderNo(@Shift) < dbo.GetShiftTypeOrderNo(@Start_Shift)))
		And(@Start_Date Is Not Null))
		Begin
			Select @RetVal = 0
		End
	
		/* If the stockpile build is already closed */
		If (((@Date > @End_Date) Or (@Date = @End_Date And dbo.GetShiftTypeOrderNo(@Shift) > dbo.GetShiftTypeOrderNo(@End_Shift)))
		And (@End_Date Is Not Null) And (@RetVal = 1))
		Begin
			Select @RetVal = 0
		End
	End

	Return (@RetVal)
End

GO

/*
<TAG Name="Data Dictionary" FunctionName="IsStockpileBuildActive">
 <Function>
	Check to see whether the stockpile build is currently active note that the @Build_Id
	is optional it is a requirement that whenever a Start_Date != NULL, the Start_Shift 
	must also be not NULL the same requirement is true for End_Date and End_Shift.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileGroupStockpiles.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetStockpileGroupStockpiles]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetStockpileGroupStockpiles]
GO

CREATE Function [dbo].[GetStockpileGroupStockpiles]

(@Stockpile_Group_Id Varchar(31),
@Display_Descriptions Bit,
@Display_Invisible Bit = 1)

Returns Varchar(8000)

With Encryption As

Begin

Declare @RetVal Varchar(8000)
Declare @Stockpile Varchar(255)

	Set @RetVal = ''

	/* Get a cursor of all the stockpiles belonging to this group */
	Declare Stockpile_Curs Cursor For
	Select	Case When (@Display_Descriptions = 0) Then
			S.Stockpile_Name
		Else
			S.Description
		End
	From Stockpile S, StockpileGroupStockpile SGS
	Where S.Stockpile_Id = SGS.Stockpile_Id
	And SGS.Stockpile_Group_Id = @Stockpile_Group_Id
	And (@Display_Invisible = 1 Or Is_Visible = 1)
	Order By	Case When (@Display_Descriptions = 0) Then
				S.Stockpile_Id
			Else
				S.Description
			End

	Open Stockpile_Curs

	Fetch Next From Stockpile_Curs Into
	 @Stockpile

	/* For each stockpile for the group */
	While (@@Fetch_Status = 0)
	Begin
		/* Add it to the list */
		If (@RetVal <> '')
		Begin
			Set @RetVal = @RetVal + ', '
		End

		Set @RetVal = @RetVal + RTrim(LTrim(@Stockpile))

		Fetch Next From Stockpile_Curs Into
		 @Stockpile
	End

	Close Stockpile_Curs
	Deallocate Stockpile_Curs


	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileGroupStockpiles">
 <Function>
	Returns a string of stockpiles within a given stockpile group.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetReclaimableStockpileBuild.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetReclaimableStockpileBuild]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetReclaimableStockpileBuild]
GO

CREATE Function dbo.GetReclaimableStockpileBuild
(
	@Stockpile_Id Int,
	@Date Datetime,
	@Shift Char(1)
)

Returns Int

With Encryption 
As

Begin

Declare @RetVal Int

	Select @RetVal = Max(B.Build_Id)
	From StockpileBuild B
	Where B.Stockpile_Id = @Stockpile_Id
	And ((B.Start_Date Is Null) Or (B.Start_Date <= @Date)
	Or (B.Start_Date = @Date And dbo.GetShiftTypeOrderNo(B.Start_Shift) <= dbo.GetShiftTypeOrderNo(@Shift)))
	And ((B.End_Date Is Null) Or (B.End_Date > @Date)
	Or (B.End_Date = @Date And dbo.GetShiftTypeOrderNo(B.End_Shift) >= dbo.GetShiftTypeOrderNo(@Shift)))
	And ((B.Stockpile_State_Id = 'NORMAL') Or ((B.Reclaim_Start_Date Is Not Null) And ((B.Reclaim_Start_Date < @Date)
	Or (B.Reclaim_Start_Date = @Date And dbo.GetShiftTypeOrderNo(B.Reclaim_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Shift)))))

	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetReclaimableStockpileBuild">
 <Function>
	Returns the latest stockpile build ID for the given stockpile, shift and date.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetWeightometerSourceStockpile.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetWeightometerSourceStockpile]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetWeightometerSourceStockpile]
GO

Create Function dbo.GetWeightometerSourceStockpile
(
	@Weightometer_Id Varchar(31),
	@This_Date Datetime
)
Returns Varchar(31)
With Encryption As
Begin

	Declare @End_Date Datetime
	Declare @Stockpile Varchar(31)

	Select @End_Date = Min(WFP.End_Date)
	From WeightometerFlowPeriod WFP
	Where WFP.End_Date >= @This_Date

	Select @Stockpile = Source_Stockpile_Id
	From WeightometerFlowPeriod WFP
	Where WFP.End_Date = @End_Date
	Or (@End_Date Is Null And WFP.End_Date Is Null)

	Return (@Stockpile)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetWeightometerSourceStockpile">
 <Function>
	Returns the source stockpile ID for a given weightometer and date.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetWeightometerDestinationStockpile.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetWeightometerDestinationStockpile]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetWeightometerDestinationStockpile]
GO

Create Function dbo.GetWeightometerDestinationStockpile
(
	@Weightometer_Id Varchar(31),
	@This_Date Datetime
)
Returns Varchar(31)
With Encryption As
Begin

	Declare @End_Date Datetime
	Declare @Stockpile Varchar(31)

	Select @End_Date = Min(WFP.End_Date)
	From WeightometerFlowPeriod WFP
	Where WFP.End_Date >= @This_Date

	Select @Stockpile = Destination_Stockpile_Id
	From WeightometerFlowPeriod WFP
	Where WFP.End_Date = @End_Date
	Or (@End_Date Is Null And WFP.End_Date Is Null)

	Return (@Stockpile)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetWeightometerDestinationStockpile">
 <Function>
	Returns the Destination stockpile ID for a given weightometer and date.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetFirstHaulageId.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetFirstHaulageId'))
	Drop Function dbo.GetFirstHaulageId
Go

Create Function dbo.GetFirstHaulageId
(
	@iHaulage_Id Int
)

Returns Int
With Encryption
As

Begin
	-- find the first haulage record in the chain

	Declare @Haulage_Id Int
	Declare @Previous_Haulage_Id Int

	-- loop through all records within the Haulage chain,
	-- stopping at the beginning

	Set @Haulage_Id = @iHaulage_Id
	Set @Previous_Haulage_Id = @iHaulage_Id
	While (@Previous_Haulage_Id Is Not Null)
	Begin
		Set @Previous_Haulage_Id = Null
		Select @Previous_Haulage_Id = Parent_Haulage_Id
		From Haulage
		Where Haulage_Id = @Haulage_Id

		If @Previous_Haulage_Id Is Not Null
		Begin
			Set @Haulage_Id = @Previous_Haulage_Id
		End
	End

	Return @Haulage_Id
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetFirstHaulageId">
 <Function>
	Returns the first haulage record in the chain.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetHaulageRawConflictFlag.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetHaulageRawConflictFlag'))
	Drop Function dbo.GetHaulageRawConflictFlag
Go

Create Function dbo.GetHaulageRawConflictFlag
(
	@iHaulage_Raw_Id Int
)

Returns Bit
With Encryption
As

Begin
	-- if a HaulageRaw record has changed in any way, return 1
	-- this is determined by:
	-- 1) whether the Haulage_Raw_Id in question has been resolved,
	--    and the resolved record has been updated
	-- 2) Haulage can not be deleted within an approved digblock period

	Declare @Conflict Bit
	Declare @Haulage_Raw_Id Int

	-- need to determine if any of these records have a Haulage record
	-- associated that has been approved or modified

	Set @Haulage_Raw_Id = dbo.GetLastHaulageRawId(@iHaulage_Raw_Id)

	Set @Conflict = 0	
	
	If Exists 
	(	
		Select 1
		From dbo.Haulage H
		Where H.Haulage_Raw_Id = @Haulage_Raw_Id
			And H.Haulage_State_Id In ('M', 'A')
	)
	Or Exists 
	(
		Select 1
		From dbo.Haulage H
		Where H.Haulage_Raw_Id = @Haulage_Raw_Id
			And H.Haulage_State_Id = 'N'
			And H.Source_Digblock_Id Is Not Null
			And dbo.IsInApprovedDigblockSurveyPeriod(H.Haulage_Date, H.Haulage_Shift, H.Source_Digblock_Id) = 1 
	)
	Begin
		Set @Conflict = 1
	End

	Return @Conflict
End
Go
GRANT EXECUTE ON dbo.GetHaulageRawConflictFlag TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" FunctionName="GetHaulageRawConflictFlag">
 <Function>
	If a HaulageRaw record has changed in any way, return 1
	this is determined by:
	1) whether the Haulage_Raw_Id in question has been resolved,
	2) the resolved record has been updated
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLastHaulageId.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetLastHaulageId'))
	Drop Function dbo.GetLastHaulageId
Go

Create Function dbo.GetLastHaulageId
(
	@iHaulage_Id Int
)

Returns Int
With Encryption
As

Begin
	-- find the latest haulage raw record in the chain

	Declare @Haulage_Id Int
	Declare @Next_Haulage_Id Int

	-- loop through all records within the Haulage chain,
	-- stopping at the end

	Set @Haulage_Id = @iHaulage_Id
	Set @Next_Haulage_Id = @iHaulage_Id
	While (@Next_Haulage_Id Is Not Null)
	Begin
		Set @Next_Haulage_Id = Null
		Select @Next_Haulage_Id = Child_Haulage_Id
		From Haulage
		Where Haulage_Id = @Haulage_Id

		If @Next_Haulage_Id Is Not Null
		Begin
			Set @Haulage_Id = @Next_Haulage_Id
		End
	End

	Return @Haulage_Id
End
Go
 
/*
<TAG Name="Data Dictionary" FunctionName="GetLastHaulageId">
 <Function>
	Returns the latest haulage raw record in the chain.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLastHaulageRawId.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetLastHaulageRawId'))
	Drop Function dbo.GetLastHaulageRawId
Go

Create Function dbo.GetLastHaulageRawId
(
	@iHaulage_Raw_Id Int
)

Returns Int
With Encryption
As

Begin
	-- find the latest haulage raw record in the chain

	Declare @Haulage_Raw_Id Int
	Declare @Next_Haulage_Raw_Id Int

	-- loop through all records within the HaulageRaw chain,
	-- stopping at the end

	Set @Haulage_Raw_Id = @iHaulage_Raw_Id
	Set @Next_Haulage_Raw_Id = @iHaulage_Raw_Id
	While (@Next_Haulage_Raw_Id Is Not Null)
	Begin
		Set @Next_Haulage_Raw_Id = Null
		Select @Next_Haulage_Raw_Id = Child_Haulage_Raw_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @Haulage_Raw_Id

		If @Next_Haulage_Raw_Id Is Not Null
		Begin
			Set @Haulage_Raw_Id = @Next_Haulage_Raw_Id
		End
	End

	Return @Haulage_Raw_Id
End
Go
  GRANT EXECUTE ON dbo.GetLastHaulageRawId TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" FunctionName="GetLastHaulageRawId">
 <Function>
	Returns the latest haulage raw record in the chain.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetHaulageSplitResolveByDigblockTonnes.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetHaulageSplitResolveByDigblockTonnes'))
	Drop Function dbo.GetHaulageSplitResolveByDigblockTonnes
Go

Create Function dbo.GetHaulageSplitResolveByDigblockTonnes
(
	@iHaulage_Resolve_Split_Id Int
)

Returns @RESULT Table
(
	Digblock_Id VarChar(31) Collate Database_Default Not Null,
	Ratio Float Not Null
)

With Encryption
As

Begin
	-- standard function to enable "split resolution"
	-- uses the digblock start tonnes to produce the desired ratio

	Declare @Tonnes Float

	Select @Tonnes = Sum(D.Start_Tonnes)
	From HaulageResolveSplitDecode HRSD
		Inner Join Digblock D
		On (D.Digblock_Id = HRSD.Digblock_Id)
	Where HRSD.Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id

	Insert Into @RESULT
		(Digblock_Id, Ratio)
	Select HRSD.Digblock_Id, Sum(D.Start_Tonnes) / @Tonnes As Ratio
	From HaulageResolveSplitDecode HRSD
		Inner Join Digblock D
		On (D.Digblock_Id = HRSD.Digblock_Id)
	Where HRSD.Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	Group By HRSD.Digblock_Id

	Return
End
Go

GRANT SELECT ON dbo.GetHaulageSplitResolveByDigblockTonnes TO CoreHaulageManager

 
/*
<TAG Name="Data Dictionary" FunctionName="GetHaulageSplitResolveByDigblockTonnes">
 <Function>
	Standard function to enable "split resolution", uses the digblock start tonnes to 
	produce the desired ratio.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateshiftAsDatetime.udf'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.GetDateshiftAsDatetime'))
	Drop Function dbo.GetDateshiftAsDatetime
Go

Create Function dbo.GetDateshiftAsDatetime
(
	@iDate DateTime,
	@iShift Char(1)
)

Returns DateTime

With Encryption
As

Begin
	Declare @Time DateTime
	Declare @Start_Time DateTime
	Declare @Shift_Crossing_Order_No Int
	Declare @Order_No Int
	Declare @Day_Offset Int

	-- get the start time of the shift
	Select @Start_Time = (Start_Time - dbo.GetDateDay(Start_Time)),
		@Order_No = Order_No,
		@Day_Offset = Day_Offset
	From ShiftType
	Where Shift = @iShift

	Set @Time = DateAdd(d, @Day_Offset, @iDate) + @Start_Time

	Return @Time
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetDateshiftAsDatetime">
 <Function>
	Returns the shift start time and date.
 </Function>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDatetimeAsDate.udf'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.GetDatetimeAsDate'))
	Drop Function dbo.GetDatetimeAsDate
Go

Create Function dbo.GetDatetimeAsDate
(
	@iDateTime DateTime
)
Returns DateTime
With Encryption As
Begin
	Declare @returnDate	DateTime
	Declare @dayOffset Int
	Declare @shiftStart DateTime
	Declare @shift Char(1)

	--Determine the Shift
	Set @shift = dbo.GetDatetimeAsShift(@iDateTime)

	Select @returnDate = dbo.GetDateDay(@iDateTime)

	Select @shiftStart = DateAdd(minute, DateDiff(minute, dbo.GetDateDay(Start_Time), Start_Time), @returnDate),
		@dayOffset = Day_Offset
	From dbo.ShiftType
	Where Shift = @shift

	If @shiftStart > @iDateTime
	Begin
		Select @shiftStart = DateAdd(day, -1, @shiftStart)
	End
	
	Select @returnDate = dbo.GetDateDay(DateAdd(day, @dayOffset * -1, @shiftStart))

	Return @returnDate
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetDatetimeAsDate">
 <Function>
	Determines the date for a given date and time.
 </Function>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDatetimeAsShift.udf'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.GetDatetimeAsShift'))
	Drop Function dbo.GetDatetimeAsShift
Go

Create Function dbo.GetDatetimeAsShift
(
	@iDateTime DateTime
)

Returns Char(1)

With Encryption
As

Begin
	Declare @Time DateTime
	Declare @Shift Char(1)
	Declare @Shift_Crossing_Order_No Int

	-- determine the time component individually
	Set @Time = @iDateTime - dbo.GetDateDay(@iDateTime)

	-- check whether this time component directly matches an existing shift
	Set @Shift =
		(
			Select Top 1 Shift
			From dbo.ShiftType
			Where (Start_Time - dbo.GetDateDay(Start_Time)) <= @Time
			Order By Start_Time Desc
		)

	If @Shift Is Null
	Begin
		-- determine the SHIFT that crosses the midnight boundary
		Select @Shift = Shift
		From ShiftType
		Where Start_Time > End_Time
			And End_Time > dbo.GetDateDay(End_Time)
	End

	Return @Shift
End
Go


/*
<TAG Name="Data Dictionary" FunctionName="GetDatetimeAsShift">
 <Function>
	Determines the shift for a given date and time.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetFirstHaulageRawId.udf'
GO

If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.GetFirstHaulageRawId'))
	Drop Function dbo.GetFirstHaulageRawId
Go

Create Function dbo.GetFirstHaulageRawId
(
	@iHaulage_Raw_Id Int
)

Returns Int
With Encryption
As

Begin
	-- find the first haulage raw record in the chain

	Declare @Haulage_Raw_Id Int
	Declare @Previous_Haulage_Raw_Id Int

	-- loop through all records within the HaulageRaw chain,
	-- stopping at the end

	Set @Haulage_Raw_Id = @iHaulage_Raw_Id
	Set @Previous_Haulage_Raw_Id = @iHaulage_Raw_Id
	While (@Previous_Haulage_Raw_Id Is Not Null)
	Begin
		Set @Previous_Haulage_Raw_Id = Null
		Select @Previous_Haulage_Raw_Id = Parent_Haulage_Raw_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @Haulage_Raw_Id

		If @Previous_Haulage_Raw_Id Is Not Null
		Begin
			Set @Haulage_Raw_Id = @Previous_Haulage_Raw_Id
		End
	End

	Return @Haulage_Raw_Id
End
Go
GRANT EXECUTE ON dbo.GetFirstHaulageRawId TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" FunctionName="GetFirstHaulageRawId">
 <Function>
	Returns the first haulage raw record in the chain.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetHaulageHierarchy.udf'
GO

If object_id('dbo.GetHaulageHierarchy') is Not Null
	Drop Function dbo.GetHaulageHierarchy
Go

Create Function dbo.GetHaulageHierarchy
(
	@iHaulage_Id Int
)

Returns @RESULT Table
(
	Haulage_Id Int Not Null,
	Level Int Not Null,
	Primary Key (Haulage_Id)
)
With Encryption
As

Begin
	-- returns the full hierarchy of haualge records
	-- passing in any haulage ID will resolve its full chain
	-- from the first record through to the last

	Declare @Haulage_Id Int
	Declare @Level Int
	Declare @Haulage Table
	(
		Haulage_Id Int Not Null,
		Level Int Not Null,
		Visited Bit Not Null,
		Primary Key (Haulage_Id)
	)

	Set @Haulage_Id = dbo.GetFirstHaulageId(@iHaulage_Id)
	Set @Level = 1

	Insert Into @Haulage
		(Haulage_Id, Level, Visited)
	Select @Haulage_Id, @Level, 0

	-- build the Haulage table
	While @Haulage_Id Is Not Null
	Begin
		-- insert all of the children for this record
		Insert Into @Haulage
			(Haulage_Id, Level, Visited)
		Select Haulage_Id, (@Level + 1), 0
		From Haulage
		Where Parent_Haulage_Id = @Haulage_Id

		-- set the record as "visited"
		Update @Haulage
		Set Visited = 1
		Where Haulage_Id = @Haulage_Id

		-- find the next record to visit
		Set @Haulage_Id = Null
		Select Top 1 @Haulage_Id = Haulage_Id,
			@Level = Level
		From @Haulage
		Where Visited = 0
	End

	Insert Into @RESULT
		(Haulage_Id, Level)
	Select Haulage_Id, Level
	From @Haulage
	Order By Haulage_Id

	Return
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetHaulageHierarchy">
 <Function>
	Returns the full hierarchy of haualge records passing in any haulage ID 
	will resolve its full chain from the first record through to the last.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationRelationship.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetLocationRelationship]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[GetLocationRelationship]
GO

CREATE Function dbo.GetLocationRelationship
(
	@First_Location_Id Int,
	@Second_Location_Id Int
)

Returns Int

With Encryption As

Begin

	------------------------------------------------------------------------------------------------------------
	-- Function: dbo.GetLocationRelationship
	-- Date Created: 08-Dec-2006
	-- Developer: Logan Anderson
	-- Purpose:	Allows two locations to be compared in a heirachy
	-- Parameters:
	--	- @First_Location_Id    A location id from the Location Table
	--	- @Second_Location_Id	Another location id from the Location Table
	-- Returns:
	--	- 0: Locations are identical, or share the same parent, grandparent etc (i.e. same level)
	--	- Positive Integer: The second location is higher within a direct chain in the hierachy, 
	--                      value = number of levels difference
	--	- Negative Integer: The second location is lower within a direct chain in the hierachy, 
	--                      value = number of levels difference
	--	- NULL:	No heirachy relationship exists for the two locations.
	------------------------------------------------------------------------------------------------------------

	Declare @Rowcount Int
	Declare @Parent_Found Bit
	Declare @Return_Code Int
	Declare @Hierarchy_Level Int

	Declare @Relationship Table (
		Child_Location_Id Int Not Null, 
		First_Flag Bit Not Null,
		Parent_Location_Id Int Null, 
		Hierarchy_Level Int Not Null,
		Primary Key Clustered
		(
			Child_Location_Id, First_Flag
		)
	)


	Set @Hierarchy_Level = 0


	
				
	Insert Into @Relationship (
			Child_Location_Id, First_Flag, Parent_Location_Id, Hierarchy_Level
	)
	Select Location_Id, 1, Parent_Location_Id, @Hierarchy_Level
		From Location
		Where Location_Id = @First_Location_Id	

	Union All

	Select Location_Id, 0, Parent_Location_Id, @Hierarchy_Level
		From Location
		Where Location_Id = @Second_Location_Id	


	Set @Rowcount = 1

	While @Rowcount > 0
	Begin
		

		Insert Into @Relationship (
			Child_Location_Id, First_Flag, Parent_Location_Id, Hierarchy_Level
		)

		Select LT.Location_Id, R.First_Flag, LT.Parent_Location_Id, @Hierarchy_Level + 1
		From Location LT
			Inner Join @RELATIONSHIP R
				On LT.Location_Id = R.Parent_Location_Id
		Where R.Hierarchy_Level = @Hierarchy_Level			

		Set @Rowcount = @@Rowcount

		Select @Return_Code = 0 --Same Level within a Hierarchy
			From @RELATIONSHIP R1
			Inner Join @RELATIONSHIP R2
				On R1.Hierarchy_Level = R2.Hierarchy_Level
				And R1.Parent_Location_Id = R2.Parent_Location_Id		
			Where R1.First_Flag = 1
			And R2.First_Flag = 0

		If @Return_Code Is Not Null Return @Return_Code

		Select @Return_Code = Hierarchy_Level	--Postive Integer, Second Value is Parent or Higher in Chain
					From @RELATIONSHIP R
					Where  R.First_Flag = 1
					And R.Child_Location_Id = @Second_Location_Id

		If @Return_Code Is Not Null Return @Return_Code


		Select @Return_Code = -(Hierarchy_Level)	--Negative Integer, Second Value is Child or Lower in Chain
					From @RELATIONSHIP R
					Where  R.First_Flag = 0
					And R.Child_Location_Id = @First_Location_Id

		If @Return_Code Is Not Null Return @Return_Code
		
		Set @Hierarchy_Level = @Hierarchy_Level + 1

	End

	Return Null --No Direct Chain or Same Level Relationship Found

End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationRelationship">
 <Function>
	Purpose: Allows two locations to be compared in a heirachy
	Parameters:
	- @First_Location_Id    A location id from the Location Table
	- @Second_Location_Id	Another location id from the Location Table
	Returns:
	- 0: Locations are identical, or share the same parent, grandparent etc (i.e. same level)
	- Positive Integer: The second location is higher within a direct chain in the hierachy, 
	                     value = number of levels difference
	- Negative Integer: The second location is lower within a direct chain in the hierachy, 
	                     value = number of levels difference
	- NULL:	No heirachy relationship exists for the two locations.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDigblockSurveyPeriodDetails.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockSurveyPeriodDetails]') and xtype in (N'FN', N'IF', N'TF'))
	drop function dbo.GetDigblockSurveyPeriodDetails
Go

Create Function dbo.GetDigblockSurveyPeriodDetails

()

Returns @SURVEY_PERIOD_DETAILS Table
(
	Digblock_Survey_Id Int,
	Digblock_Survey_Date Datetime,
	Digblock_Survey_Shift Char(1),
	Digblock_Survey_Type_Id Int,
	Previous_Digblock_Survey_Date Datetime,
	Previous_Digblock_Survey_Shift Char(1),
	Start_Date Datetime,
	Start_Shift Char(1),
	Is_Approved Bit
)

Begin

	-- Insert details for each digblock survey period, as well as the previous period of the same type (if any)
	Insert Into @SURVEY_PERIOD_DETAILS
	(
		Digblock_Survey_Id, Digblock_Survey_Date,
		Digblock_Survey_Shift, Digblock_Survey_Type_Id,
		Previous_Digblock_Survey_Date, Previous_Digblock_Survey_Shift, Is_Approved
	)
	Select DS.Digblock_Survey_Id, DS.Digblock_Survey_Date,
		DS.Digblock_Survey_Shift, DS.Digblock_Survey_Type_Id,
		DSP.Digblock_Survey_Date, DSP.Digblock_Survey_Shift, DS.Is_Approved
	From DigblockSurvey DS
		Left Outer Join DigblockSurvey DSP
			On DS.Digblock_Survey_Type_Id = DSP.Digblock_Survey_Type_Id
			And DSP.Digblock_Survey_Date =
			(
				Select Max(S2.Digblock_Survey_Date)
				From DigblockSurvey S2
				Where DS.Digblock_Survey_Type_Id = S2.Digblock_Survey_Type_Id
					And dbo.CompareDateShift (S2.Digblock_Survey_Date, S2.Digblock_Survey_Shift, '<',
												DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift) = 1
			)
			And dbo.GetShiftTypeOrderNo(DSP.Digblock_Survey_Shift) =
				(
					Select Max(dbo.GetShiftTypeOrderNo(S2.Digblock_Survey_Shift))
					From DigblockSurvey S2
					Where DS.Digblock_Survey_Type_Id = S2.Digblock_Survey_Type_Id
						And dbo.CompareDateShift (S2.Digblock_Survey_Date, S2.Digblock_Survey_Shift, '<',
													DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift) = 1
						And S2.Digblock_Survey_Date =	(
															Select Max(S3.Digblock_Survey_Date)
															From DigblockSurvey S3
															Where DS.Digblock_Survey_Type_Id = S3.Digblock_Survey_Type_Id
																And dbo.CompareDateShift (S3.Digblock_Survey_Date, S3.Digblock_Survey_Shift, '<',
																							DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift) = 1
														)
				)

	-- Set the start details
	Update @SURVEY_PERIOD_DETAILS
	Set	Start_Date =	Case When (Previous_Digblock_Survey_Shift = dbo.GetLastShiftType()) Then
							DateAdd(Day, 1, Previous_Digblock_Survey_Date)
						Else
							Previous_Digblock_Survey_Date
						End,
		Start_Shift =	Case When (Previous_Digblock_Survey_Shift = dbo.GetLastShiftType()) Then
							dbo.GetFirstShiftType()
						Else
							dbo.GetNextShiftType (Previous_Digblock_Survey_Shift)
						End

	-- Set the start details for any records which do not have them set (i.e. the first survey for the given type)
	Update SPD
	Set	Start_Date = TH.Haulage_Date,
		Start_Shift = TH.Haulage_Shift
	From @SURVEY_PERIOD_DETAILS SPD,
		(
			Select Top 1 Haulage_Date, Haulage_Shift
			From Haulage
			Order By Haulage_Date, dbo.GetShiftTypeOrderNo (Haulage_Shift)
		) TH
	Where Start_Date Is Null


	Return
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetDigblockSurveyPeriodDetails">
 <Function>
	Returns a table result of all the depletion dates and their details.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileName.udf'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetStockpileName'))
	Drop Function dbo.GetStockpileName
Go

Create Function dbo.GetStockpileName
(
	@iStockpile_Id Int
)

Returns Varchar(31)

With Encryption 
As

Begin

	Declare @RetVal Varchar(31)

	Select @RetVal = Stockpile_Name From Stockpile Where Stockpile_Id = @iStockpile_Id

	Return (@RetVal)

End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileName">
 <Function>
	Returns the Stockpile Name from the stockpile id.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeHierarchy.udf'
GO

If Object_Id('dbo.GetLocationTypeHierarchy') Is Not Null
	Drop Function dbo.GetLocationTypeHierarchy
GO

Create Function dbo.GetLocationTypeHierarchy
(
	@iReturn_Lowest_Only Bit = 0
)
Returns @RETURN_TABLE Table 
(
	Location_Level Int,
	Location_Type_Id TINYINT,
	Abs_Parent_Location_Id Varchar(31) Collate Database_Default,
	Bottom_In_Hierarchy Bit Default(0)
)
With Encryption As
Begin

	Declare @Loop Int
	Set @Loop = 0
  
	-- Obtain the highest level of all hierarchy to loop down with. (Where Parent Is Null)
	Insert Into @RETURN_TABLE
		(Location_Level, Location_Type_Id, Abs_Parent_Location_Id, Bottom_In_Hierarchy)
	Select 0, Location_Type_Id, Location_Type_Id,
	Case 
		When Exists (Select 1 
					 From dbo.LocationType As T 
					 Where T.Parent_Location_Type_Id = LT.Location_Type_Id) Then 0 
		Else 1 
	End
	FROM dbo.LocationType As LT
	Where Parent_Location_Type_Id Is Null

	-- While new children are still being added at a higher Level, keep cycling through them.
	While Exists (Select 1 From @RETURN_TABLE Where Location_Level = @Loop)
	Begin

		-- Insert Into the table with a loop of the next level, any location types which have 
		-- a parent of any in the current level of the loop.
		Insert Into @RETURN_TABLE
			(Location_Level, Location_Type_Id, Abs_Parent_Location_Id, Bottom_In_Hierarchy)
		Select @Loop + 1, LT.Location_Type_Id, TT.Abs_Parent_Location_Id,
		Case -- Case there are more location types with a parent location type of this, then it isn't bottom.
			When Exists (Select 1 
						 From dbo.LocationType As T 
						 Where T.Parent_Location_Type_Id = LT.Location_Type_Id) Then 0 
			Else 1 
		End
		FROM @RETURN_TABLE As TT
			Inner Join dbo.LocationType As LT
				On TT.Location_Type_Id = LT.Parent_Location_Type_Id
		Where Location_Level = @Loop

		Set @Loop = @Loop + 1 -- Increment to the next level
	End

	-- If only the lowest are to be retrieved, delete all location_types which are not.
	If @iReturn_Lowest_Only = 1
	Begin
		Delete 
		From @RETURN_TABLE
		Where Bottom_In_Hierarchy = 0
	End
  
	Return
End
Go

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationTypeHierarchy">
 <Function>
	Returns a list of all the Location Types and how deep they are into the hierarchy.
	@iReturn_Lowest_Only can be set to true to allow only the lowest level's of each 
	Hierarchy to be retrieved.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileVisibility.udf'
GO

If Object_Id('dbo.GetStockpileVisibility') Is Not Null
	Drop Function dbo.GetStockpileVisibility
Go

Create Function dbo.GetStockpileVisibility
(
	@iStockpile_Id Int,
	@iDate Datetime
)

Returns Bit

With Encryption
As

Begin

	Declare @RetVal Bit
	Set @iDate = dbo.GetDateDay(@iDate)

	/* Get the current stockpile visibility for this stockpile on this date */
	Select @RetVal = Coalesce(P.Is_Visible, S.Is_Visible)
	From dbo.Stockpile As S
		Left Join dbo.StockpileStockpileVisibilityPeriod As P
			On S.Stockpile_Id = P.Stockpile_Id
	Where S.Stockpile_Id = @iStockpile_Id
	And	(
		-- Where the visibility period is in a period with an end date, and not the final period
		P.End_Date = 
					(
						Select Min(P2.End_Date)
						From dbo.StockpileStockpileVisibilityPeriod As P2
						Where P2.Stockpile_Id = P.Stockpile_Id
							And P2.End_Date Is Not Null
							And P2.End_Date >= @iDate
					)
		Or	
		--Where the visibility period is in the last period
			(
			P.End_Date Is Null And (
									Select Min(P2.End_Date)
									From dbo.StockpileStockpileVisibilityPeriod As P2
									Where P2.Stockpile_Id = P.Stockpile_Id
										And P2.End_Date >= @iDate
									) Is Null
			)
		)
					
	Return (@RetVal)
End
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileVisibility">
 <Function>
	Returns the current stockpile visibility for the given stockpile on the given date.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GeneratePsuedoRandomNumber.udf'
GO

If object_id('dbo.GeneratePsuedoRandomNumber') Is Not Null 
     Drop Function dbo.GeneratePsuedoRandomNumber 
Go 
  
Create Function dbo.GeneratePsuedoRandomNumber 
( 
    @iSeed Real,
	@iMovement Real,
	@iBaseValue Real
) 
Returns Real
With Encryption As 
Begin 
	--Two Sin Waves mixed with a Cos Wave
	Return Sin(2 * Power(@iSeed, 3.00)) * Cos(2.00 * @iSeed) * @iMovement + @iBaseValue
End 
Go 

/*
<TAG Name="Data Dictionary" FunctionName="dbo.GeneratePsuedoRandomNumber">
 <Function>
	Used to generate a deterministic number that looks random. Movement is the
	max amount amount of movement the random will have. For example
	a movement of 0.5 and a base of 10 will produce results around 10.0 to 10.5. 
	This function will ALWAYS return the SAME value. 	
 </Function>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetDateShiftAsInt.udf'
GO

If object_id('dbo.GetDateShiftAsInt') Is Not Null 
     Drop Function dbo.GetDateShiftAsInt 
Go 
  
Create Function dbo.GetDateShiftAsInt
( 
    @iDate DateTime,
	@iShift_Order Int
) 
Returns Int
As 
Begin 
	Return (DateDiff(d, '1980-01-01', @iDate) * 1000) + @iShift_Order
End 
Go 

/*
<TAG Name="Data Dictionary" FunctionName="GetDateShiftAsInt">
 <Function>
	Uses math to convert a date and shift to an integer by getting the
	days from 1st Jan 1980 multiplied by 1000 (allowing shift
	orders of up to 999) then adding the Order number. 
 </Function>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetSystemStartDate.udf'
GO

If object_id('dbo.GetSystemStartDate') is not Null 
     Drop Function dbo.GetSystemStartDate 
Go 
  
Create Function dbo.GetSystemStartDate()
Returns DateTime
With Encryption As 
Begin 
    Declare @ReturnVal DateTime

	Select @ReturnVal = Min(Start_Date)
	From dbo.StockpileBuild As B
	
	Return @ReturnVal
End 
Go 

/*
<TAG Name="Data Dictionary" FunctionName="dbo.GetSystemStartDate">
 <Function>
	Returns the reconcilor effective system start date based on the first stockpile build.
 </Function>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetBlockReconciliationLocationLevel.udf'
GO

IF OBJECT_ID('dbo.GetBlockReconciliationLocationLevel') IS NOT NULL
	DROP FUNCTION dbo.GetBlockReconciliationLocationLevel
GO

CREATE FUNCTION dbo.GetBlockReconciliationLocationLevel
(
	@iLevel1 VARCHAR(31),
	@iLevel2 VARCHAR(31),
	@iLevel3 VARCHAR(31),
	@iLevel4 VARCHAR(31),
	@iLevel5 VARCHAR(31)
)

-------------------------------------------------------------------------------
--  Function: dbo.GetBlockReconciliationLocationLevel
--	Created: 19-Oct-2007
--	Dev: JBC
--  For Core Standard reports
--------------------------------------------------------------------------------

RETURNS @LocationLevel TABLE 
(
	Location_Type_Id TINYINT,
	Location_Level VARCHAR(31) COLLATE DATABASE_DEFAULT
)
WITH ENCRYPTION 
AS

BEGIN

	DECLARE @Level INT

	DECLARE @LocationHierarchy TABLE
	(
		Location_Type_Id TINYINT,
		Location_Level INT
	)

	DECLARE @LocationLevelList TABLE 
	(
		Location_Type_Id TINYINT,
		Location_Level VARCHAR(31) COLLATE DATABASE_DEFAULT
	)

	IF @iLevel1 IS NOT NULL OR @iLevel1 <> ''
	BEGIN

		--Check that the type is valid (LEVEL 1)
		IF EXISTS (SELECT 1 
					FROM LocationType 
					WHERE Location_Type_Id = @iLevel1)
		BEGIN
			SET @Level = 1

			INSERT INTO @LocationHierarchy
			(
				Location_Type_ID, Location_Level
			)
			SELECT lh.Location_Type_ID,lth.Location_Level
			FROM 
				(SELECT @iLevel1 As Location_Type_ID
				UNION
				SELECT Location_Type_ID
				FROM GetLocationTypeChildLocationTypeList(@iLevel1) 
				) AS lh
				INNER JOIN GetLocationTypeHierarchy(0) AS lth
					ON lh.Location_Type_ID = lth.Location_Type_ID

			INSERT INTO @LocationLevelList
			(
				Location_Type_Id,
				Location_Level
			)
			SELECT lh.Location_Type_ID, 
				'Level' + Convert(Char(1),
					CASE WHEN m.Min_Level > @Level
						THEN lh.Location_Level - (m.Min_Level - @Level)
						ELSE (CASE WHEN m.Min_Level < @Level
							THEN lh.Location_Level + (@Level - m.Min_Level)
							ELSE lh.Location_Level
							END)
						END
					) As Location_Level
			FROM @LocationHierarchy as lh
				Cross Join (
					SELECT MIN(Location_Level) As Min_Level
					FROM @LocationHierarchy
				) As m

			DELETE FROM @LocationHierarchy

			--Check that the type is valid (LEVEL 2)
			IF EXISTS (SELECT 1 
						FROM LocationType 
						WHERE Location_Type_Id = @iLevel2)
			BEGIN

				SET @Level = 2

				INSERT INTO @LocationHierarchy
				(
					Location_Type_ID, Location_Level
				)
				SELECT lh.Location_Type_ID,lth.Location_Level
				FROM 
					(SELECT @iLevel2 As Location_Type_ID
					UNION
					SELECT Location_Type_ID
					FROM GetLocationTypeChildLocationTypeList(@iLevel2) 
					) AS lh
					INNER JOIN GetLocationTypeHierarchy(0) AS lth
						ON lh.Location_Type_ID = lth.Location_Type_ID

				INSERT INTO @LocationLevelList
				(
					Location_Type_Id,
					Location_Level
				)
				SELECT lh.Location_Type_ID, 
					'Level' + Convert(Char(1),
						CASE WHEN m.Min_Level > @Level
							THEN lh.Location_Level - (m.Min_Level - @Level)
							ELSE (CASE WHEN m.Min_Level < @Level
								THEN lh.Location_Level + (@Level - m.Min_Level)
								ELSE lh.Location_Level
								END)
							END
						) As Location_Level
				FROM @LocationHierarchy as lh
					Cross Join (
						SELECT MIN(Location_Level) As Min_Level
						FROM @LocationHierarchy
					) As m

				DELETE FROM @LocationHierarchy

				--Check that the type is valid (LEVEL 3)
				IF EXISTS (SELECT 1 
							FROM LocationType 
							WHERE Location_Type_Id = @iLevel3)
				BEGIN

					SET @Level = 3

					INSERT INTO @LocationHierarchy
					(
						Location_Type_ID, Location_Level
					)
					SELECT lh.Location_Type_ID,lth.Location_Level
					FROM 
						(SELECT @iLevel3 As Location_Type_ID
						UNION
						SELECT Location_Type_ID
						FROM GetLocationTypeChildLocationTypeList(@iLevel3) 
						) AS lh
						INNER JOIN GetLocationTypeHierarchy(0) AS lth
							ON lh.Location_Type_ID = lth.Location_Type_ID

					INSERT INTO @LocationLevelList
					(
						Location_Type_Id,
						Location_Level
					)
					SELECT lh.Location_Type_ID, 
						'Level' + Convert(Char(1),
							CASE WHEN m.Min_Level > @Level
								THEN lh.Location_Level - (m.Min_Level - @Level)
								ELSE (CASE WHEN m.Min_Level < @Level
									THEN lh.Location_Level + (@Level - m.Min_Level)
									ELSE lh.Location_Level
									END)
								END
							) As Location_Level
					FROM @LocationHierarchy as lh
						Cross Join (
							SELECT MIN(Location_Level) As Min_Level
							FROM @LocationHierarchy
						) As m

					DELETE FROM @LocationHierarchy

					--Check that the type is valid (LEVEL 4)
					IF EXISTS (SELECT 1 
								FROM LocationType 
								WHERE Location_Type_Id = @iLevel4)
					BEGIN

						SET @Level = 4

						INSERT INTO @LocationHierarchy
						(
							Location_Type_ID, Location_Level
						)
						SELECT lh.Location_Type_ID,lth.Location_Level
						FROM 
							(SELECT @iLevel4 As Location_Type_ID
							UNION
							SELECT Location_Type_ID
							FROM GetLocationTypeChildLocationTypeList(@iLevel4) 
							) AS lh
							INNER JOIN GetLocationTypeHierarchy(0) AS lth
								ON lh.Location_Type_ID = lth.Location_Type_ID

						INSERT INTO @LocationLevelList
						(
							Location_Type_Id,
							Location_Level
						)
						SELECT lh.Location_Type_ID, 
							'Level' + Convert(Char(1),
								CASE WHEN m.Min_Level > @Level
									THEN lh.Location_Level - (m.Min_Level - @Level)
									ELSE (CASE WHEN m.Min_Level < @Level
										THEN lh.Location_Level + (@Level - m.Min_Level)
										ELSE lh.Location_Level
										END)
									END
								) As Location_Level
						FROM @LocationHierarchy as lh
							Cross Join (
								SELECT MIN(Location_Level) As Min_Level
								FROM @LocationHierarchy
							) As m

						DELETE FROM @LocationHierarchy

						--Check that the type is valid (LEVEL 5)
						IF EXISTS (SELECT 1 
									FROM LocationType 
									WHERE Location_Type_Id = @iLevel5)
						BEGIN

							SET @Level = 5

							INSERT INTO @LocationHierarchy
							(
								Location_Type_ID, Location_Level
							)
							SELECT lh.Location_Type_ID,lth.Location_Level
							FROM 
								(SELECT @iLevel5 As Location_Type_ID
								UNION
								SELECT Location_Type_ID
								FROM GetLocationTypeChildLocationTypeList(@iLevel5) 
								) AS lh
								INNER JOIN GetLocationTypeHierarchy(0) AS lth
									ON lh.Location_Type_ID = lth.Location_Type_ID

							INSERT INTO @LocationLevelList
							(
								Location_Type_Id,
								Location_Level
							)
							SELECT lh.Location_Type_ID, 
								'Level' + Convert(Char(1),
									CASE WHEN m.Min_Level > @Level
										THEN lh.Location_Level - (m.Min_Level - @Level)
										ELSE (CASE WHEN m.Min_Level < @Level
											THEN lh.Location_Level + (@Level - m.Min_Level)
											ELSE lh.Location_Level
											END)
										END
									) As Location_Level
							FROM @LocationHierarchy as lh
								Cross Join (
									SELECT MIN(Location_Level) As Min_Level
									FROM @LocationHierarchy
								) As m

							DELETE FROM @LocationHierarchy						
						END
					END
				END
			END
		END
	END
	ELSE
	BEGIN
	
		SET @Level = 1

		INSERT INTO @LocationHierarchy
		(
			Location_Type_ID, Location_Level
		)
		SELECT lh.Location_Type_ID, lth.Location_Level  
		FROM GetLocationTypeChildLocationTypeList(NULL) AS lh
			INNER JOIN GetLocationTypeHierarchy(0) AS lth
				ON lh.Location_Type_ID = lth.Location_Type_ID

		INSERT INTO @LocationLevelList
		(
			Location_Type_Id,
			Location_Level
		)
		SELECT lh.Location_Type_ID, 
			'Level' + Convert(Char(1),
				CASE WHEN m.Min_Level > @Level
					THEN lh.Location_Level - (m.Min_Level - @Level)
					ELSE (CASE WHEN m.Min_Level < @Level
						THEN lh.Location_Level + (@Level - m.Min_Level)
						ELSE lh.Location_Level
						END)
					END
				) As Location_Level
		FROM @LocationHierarchy as lh
			Cross Join (
				SELECT MIN(Location_Level) As Min_Level
				FROM @LocationHierarchy
			) As m

	END

	--Select the top levels for each location
	INSERT INTO @LocationLevel
	(
		Location_Type_Id, Location_Level
	) 
	SELECT Location_Type_ID, Min(Location_Level) As Location_Level
	FROM @LocationLevelList
	GROUP BY Location_Type_ID
	ORDER BY Location_Level

	RETURN

END
GO


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationIdByName.udf'
GO

If Object_Id('dbo.GetLocationIdByName') Is Not Null
	Drop Function dbo.GetLocationIdByName
GO

Create Function dbo.GetLocationIdByName
(
	@iName VARCHAR(31),
	@iLocation_Type_Id TINYINT,
	@iParent_Location_Id INT
)
Returns Int
With Encryption
As
Begin

	Declare @ReturnVal Int	

	Select @ReturnVal = Location_Id
	From dbo.Location
	Where Location_Type_Id = @iLocation_Type_Id
		And Name = @iName
		And (@iParent_Location_Id = Parent_Location_Id Or 
			(@iParent_Location_Id Is Null And Parent_Location_Id Is Null))

	Return (@ReturnVal)

End
GO

GRANT EXECUTE ON dbo.GetLocationIdByName TO CoreUtilityManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetStockpileId.udf'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetStockpileId'))
	Drop Function dbo.GetStockpileId
Go

Create Function dbo.GetStockpileId
(
	@iStockpile_Name Varchar(31) 
)

Returns Int

With Encryption 
As

Begin

	Declare @RetVal Int

	Select @RetVal = Stockpile_Id From Stockpile Where Stockpile_Name = @iStockpile_Name

	Return (@RetVal)

End
GO
GRANT EXECUTE ON dbo.GetStockpileId TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" FunctionName="GetStockpileId">
 <Function>
	Returns the Stockpile Id from the stockpile name.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.DoesDigblockHaveHaulage.udf'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DoesDigblockHaveHaulage]') and xtype in (N'FN', N'IF', N'TF'))
	drop function [dbo].[DoesDigblockHaveHaulage]
GO

Create Function dbo.DoesDigblockHaveHaulage

(@Digblock_Id Varchar(31))

Returns Bit

With Encryption As

Begin

Declare @RetVal Bit

	Select @RetVal = 0

	If Exists(Select Top 1 1 From dbo.Haulage Where Source_Digblock_Id = @Digblock_Id)
	Begin
		Select @RetVal = 1
	End

	Return (@RetVal)
End
GO


/*
<TAG Name="Data Dictionary" FunctionName="dbo.DoesDigblockHaveHaulage">
 <Function>
	Returns 1 if given digblock has haulage against it, 0 if given digblock does not exist.
 </Function>
</TAG>
*/ 


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationSubtree.udf'
GO

 IF Object_Id('dbo.GetLocationSubtree') IS NOT NULL
	DROP FUNCTION dbo.GetLocationSubtree
GO

CREATE FUNCTION dbo.GetLocationSubtree
(
	@Location_Id INT
)
RETURNS @Location TABLE
(
	Location_Id INT NOT NULL,
	PRIMARY KEY (Location_Id)
)
WITH ENCRYPTION
AS
BEGIN
	-- AT SOME POINT ONCE PROVEN TO BE CORRECT USE THE BELOW INSTEAD.
	--INSERT INTO @Location
	--	(Location_Id)
	--SELECT LocationId
	--FROM dbo.GetLocationSubtreeByLocationType

	DECLARE @Current_Location_Type_Id TINYINT
	DECLARE @Next_Location_Type_Id TINYINT

	--if Location Id was Null then return everything
	IF @Location_Id IS NULL
	BEGIN
		INSERT INTO @Location
		(
			Location_Id
		)
		SELECT Location_Id
		FROM dbo.LOCATION
	END
	Else
	BEGIN
		-- determine the location id to seed the process
		SELECT @Current_Location_Type_Id = lt.Location_Type_Id
		FROM dbo.LocationType AS lt
			INNER JOIN Location AS l
				ON lt.Parent_Location_Type_Id = l.Location_Type_Id
		WHERE l.Location_Id = @Location_Id

		-- add the seed record
		INSERT INTO @Location
		(
			Location_Id
		)
		SELECT @Location_Id

		-- at each level, add all child records
		WHILE (@Current_Location_Type_Id IS NOT NULL)
		BEGIN
			-- add all records FROM the current level
			INSERT INTO @Location
			(
				Location_Id
			)
			SELECT l.Location_Id
			FROM dbo.Location AS l 
				INNER JOIN @Location AS l2
					ON l.Parent_Location_Id = l2.Location_Id
			WHERE l.Location_Type_Id = @Current_Location_Type_Id

			-- advance to the next lowest location type id
			SET @Next_Location_Type_Id = NULL

			SELECT @Next_Location_Type_Id = Location_Type_Id
			FROM dbo.LocationType
			WHERE Parent_Location_Type_Id = @Current_Location_Type_Id

			SET @Current_Location_Type_Id = @Next_Location_Type_Id
		END
	END

	RETURN
END
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationSubtree">
 <Function>
	Returns a list of child locations from the given parent location - including the parent.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialCategoryChildMaterialCategoryList.udf'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.GetMaterialCategoryChildMaterialCategoryList'))
	Drop Function dbo.GetMaterialCategoryChildMaterialCategoryList
Go

Create Function dbo.GetMaterialCategoryChildMaterialCategoryList
(
	@iMaterialCategoryId Varchar(31)
)
Returns @MaterialCategory Table
	(
	MaterialCategoryId Varchar(31) Collate Database_Default
	)

With Encryption
As

Begin

Declare @ChildMaterialCategoryId Varchar(31)

	-- Get a cursor of the MaterialType types which are children of this one
	Declare Material_Curs Cursor Local Fast_Forward For
	Select MaterialCategoryId
	From MaterialCategory
	Where ParentMaterialCategoryId = @iMaterialCategoryId
	Order By MaterialCategoryId

	Open Material_Curs

	Fetch Next From Material_Curs Into
	 @ChildMaterialCategoryId

	-- For each child MaterialType type
	While (@@Fetch_Status = 0)
	Begin
		-- Insert this child MaterialType type
		Insert Into @MaterialCategory
		 (MaterialCategoryId)
		Values (@ChildMaterialCategoryId)

		-- Insert any of it's children
		Insert Into @MaterialCategory
		 (MaterialCategoryId)
		Select MaterialCategoryId
		From dbo.GetMaterialCategoryChildMaterialCategoryList(@ChildMaterialCategoryId)

		Fetch Next From Material_Curs Into
		 @ChildMaterialCategoryId
	End

	Close Material_Curs
	Deallocate Material_Curs

	Return
End

GO

/*
<TAG Name="Data Dictionary" FunctionName="GetMaterialCategoryChildMaterialCategoryList">
 <Function>
	Returns a list of MaterialType categories for child Materials from the given parent MaterialType.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialTypeSubtree.udf'
GO

IF OBJECT_ID('dbo.GetMaterialTypeSubtree') IS NOT NULL
	DROP FUNCTION dbo.GetMaterialTypeSubtree
GO

CREATE FUNCTION dbo.GetMaterialTypeSubtree
(
	@iMaterialTypeId INT
)
RETURNS @MaterialType TABLE
(
	MaterialTypeId INT NOT NULL,
	PRIMARY KEY (MaterialTypeId)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @CurrentMaterialTypeCategory VARCHAR(31)
	DECLARE @NextMaterialTypeCategory VARCHAR(31)

	IF @iMaterialTypeId IS NULL
	BEGIN
		INSERT INTO @MaterialType
			(MaterialTypeId)
		SELECT Material_Type_Id
		FROM dbo.MaterialType
	END
	ELSE
	BEGIN
		-- Determine the Material Type Category to seed the process
		SELECT @CurrentMaterialTypeCategory = MC.MaterialCategoryId
		FROM dbo.MaterialType AS MT
			INNER JOIN dbo.MaterialCategory AS MC
				ON MT.Material_Category_Id = MC.ParentMaterialCategoryId
		WHERE MT.Material_Type_Id = @iMaterialTypeId
		
		-- Seed Record
		INSERT INTO @MaterialType
			(MaterialTypeId)
		SELECT @iMaterialTypeId

		-- Loop through each level.
		WHILE (@CurrentMaterialTypeCategory IS NOT NULL)
		BEGIN
			INSERT INTO @MaterialType
				(MaterialTypeId)
			SELECT CMT.Material_Type_Id
			FROM dbo.MaterialType AS CMT
				INNER JOIN @MaterialType AS MT
					ON MT.MaterialTypeId = CMT.Parent_Material_Type_Id
			WHERE CMT.Material_Category_Id = @CurrentMaterialTypeCategory
			

			-- Advance to the next lowest Material Category Id
			SET @NextMaterialTypeCategory = NULL
			SELECT @NextMaterialTypeCategory = MaterialCategoryId
			FROM dbo.MaterialCategory
			WHERE ParentMaterialCategoryId = @CurrentMaterialTypeCategory
			SET @CurrentMaterialTypeCategory = @NextMaterialTypeCategory
		END
	END
	
	RETURN
END

GO

/*
<TAG Name="Data Dictionary" FunctionName="GetMaterialTypeSubtree">
 <Function>
	Returns a list of child material types from the provided parent material type - including the parent.
 </Function>
</TAG>
*/ 

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialsByCategory.udf'
GO

IF Object_Id('dbo.GetMaterialsByCategory') IS NOT NULL
	DROP FUNCTION dbo.GetMaterialsByCategory
GO

CREATE FUNCTION dbo.GetMaterialsByCategory
(
	@iMaterialCategoryId VARCHAR(31)
)
RETURNS @MaterialsByCategory TABLE
(
	RootMaterialTypeId INT NOT NULL,
	MaterialTypeId INT NOT NULL,
	Depth TINYINT NOT NULL,

	PRIMARY KEY (RootMaterialTypeId, MaterialTypeId)
)
AS
BEGIN
	DECLARE @Depth TINYINT

	SET @Depth = 0

	-- seed the list
	INSERT INTO @MaterialsByCategory
	(
		RootMaterialTypeId, MaterialTypeId, Depth
	)
	SELECT Material_Type_Id, Material_Type_Id, @Depth
	FROM dbo.MaterialType
	WHERE Material_Category_Id = @iMaterialCategoryId

	-- loop until no new records are found
	-- usage of Rowcount ensures a fast query
	-- can be rewritten if it offends
	WHILE @@RowCount > 0
	BEGIN
		SET @Depth = @Depth + 1

		INSERT INTO @MaterialsByCategory
		(
			RootMaterialTypeId, MaterialTypeId, Depth
		)
		SELECT mc.RootMaterialTypeId, mt.Material_Type_Id, @Depth
		FROM @MaterialsByCategory AS mc
			INNER JOIN dbo.MaterialType AS mt
				ON (mc.MaterialTypeId = mt.Parent_Material_Type_Id)
		WHERE mc.Depth = (@Depth - 1)
	END

	RETURN
END
GO

/*
<TAG Name="Data Dictionary" FunctionName="dbo.GetMaterialsByCategory">
 <Function>
	Based on the category requested, this routine returns a list of all child material types that are
	associated.
 </Function>
</TAG>
*/ 

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialCategoryMaterialType.UDF'
GO

IF OBJECT_ID('dbo.GetMaterialCategoryMaterialType') IS NOT NULL
	DROP Function dbo.GetMaterialCategoryMaterialType
GO

CREATE FUNCTION dbo.GetMaterialCategoryMaterialType
(
	@iMaterialTypeId INT,
	@iMaterialCategory VARCHAR(31)
)
RETURNS INT
WITH ENCRYPTION
AS
BEGIN
	DECLARE @MaterialTypeId INT
	DECLARE @Found BIT
	DECLARE @ParentMaterialTypeId INT
	DECLARE @CurrentMaterialCategory VARCHAR(31)

	SET @Found = 0

	-- Get the material category and name for the given location record
	SELECT @MaterialTypeId = Material_Type_Id,
		@ParentMaterialTypeId = Parent_Material_Type_Id,
		@CurrentMaterialCategory = Material_Category_Id
	FROM dbo.MaterialType
	WHERE Material_Type_Id = @iMaterialTypeId

	IF (@CurrentMaterialCategory = @iMaterialCategory)
	BEGIN
		SET @Found = 1
	END

	-- While there are parent records, and the category is not the one which is required to be returned
	WHILE ((@ParentMaterialTypeId IS NOT NULL) AND (@CurrentMaterialCategory <> @iMaterialCategory))
	BEGIN
		-- Keep getting the parent of this material type
		SELECT @MaterialTypeId = Material_Type_Id,
			@ParentMaterialTypeId = Parent_Material_Type_Id,
			@CurrentMaterialCategory = Material_Category_Id
		FROM dbo.MaterialType
		WHERE Material_Type_Id = @ParentMaterialTypeId

		IF (@CurrentMaterialCategory = @iMaterialCategory)
		BEGIN
			SET @Found = 1
		END
	END

	IF (@Found = 0)
	BEGIN
		SET @MaterialTypeId = NULL
	END

	RETURN @MaterialTypeId
END
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetMaterialCategoryMaterialType">
 <Function>
	Returns the Material Type for the given material Category that is related to the material type passed in.
 </Function>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationChildMap.udf'
GO

IF OBJECT_ID('dbo.GetLocationChildMap') IS NOT NULL 
     DROP FUNCTION dbo.GetLocationChildMap
GO 

CREATE FUNCTION dbo.GetLocationChildMap
(
	@iLocationId INT,
	@iLocationTypeId INT
)
RETURNS @LocationMap TABLE
(
	LocationId INT NOT NULL,
	ChildLocationId INT NOT NULL
	PRIMARY KEY (LocationId, ChildLocationId)
)
BEGIN
	DECLARE @CurrentLocationTypeId TINYINT
	DECLARE @LowestLocationTypeId TINYINT
	DECLARE @LocationId INT
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)

	-- Setup the Location ID
	SET @LocationId = @iLocationId
	IF @LocationId < 1
	BEGIN
		SET @LocationId = NULL
	END

	-- Set the Lowest Location Type, If it was null get it from location table.
	SET @LowestLocationTypeId = @iLocationTypeId
	IF @iLocationTypeId IS NULL
	BEGIN
		SELECT @LowestLocationTypeId = LT.Location_Type_Id
		FROM dbo.LocationType AS LT
			LEFT JOIN dbo.LocationType AS CLT
				ON CLT.Parent_Location_Type_Id = LT.Location_Type_Id
		WHERE CLT.Location_Type_Id IS NULL
	END

	INSERT INTO @Location
		(LocationId)
	SELECT @LocationId AS LocationId
	WHERE @LocationId IS NOT NULL
	UNION
	SELECT Location_Id
	FROM dbo.GetLocationChildLocationList(@LocationId)
	WHERE Location_ID IS NOT NULL

	INSERT INTO @LocationMap
		(LocationId, ChildLocationId)
	SELECT L.Location_Id, L.Location_Id
	FROM dbo.Location AS L
		--INNER JOIN (
		--			SELECT @LocationId AS LocationId
		--			WHERE @LocationId IS NOT NULL
		--			UNION
		--			SELECT Location_Id
		--			FROM dbo.GetLocationChildLocationList(@LocationId)
		--			WHERE Location_ID IS NOT NULL
		--			) AS RL
		--	ON (RL.LocationId = L.Location_Id)
		INNER JOIN dbo.LocationType AS LT
			ON (LT.Location_Type_Id = L.Location_Type_Id)
		INNER JOIN dbo.GetLocationTypeParentLocationTypeList(@LowestLocationTypeId) AS LTP
			ON (LTP.Location_Type_Id = LT.Location_Type_Id)
		LEFT JOIN dbo.Location AS CL
			ON CL.Parent_Location_Id = L.Location_Id
	WHERE CL.Location_Id IS NULL
		OR LTP.Location_Type_Id = @LowestLocationTypeId
	GROUP BY L.Location_Id

	-- Clean up. (Figure out why the above inner join is slow and then you can remove this bit.
	DELETE LL
	FROM @LocationMap AS LL
		LEFT JOIN @Location AS L
			ON L.LocationId = LL.LocationId
	WHERE L.LocationId IS NULL


	-- Go up the locations to the top grabbing the
	SET @CurrentLocationTypeId = @LowestLocationTypeId
	WHILE EXISTS (
					SELECT 1
					FROM dbo.LocationType
					WHERE Location_Type_Id = @CurrentLocationTypeId
				  )
	BEGIN
		INSERT INTO @LocationMap
			(LocationId, ChildLocationId)			
		SELECT L.Parent_Location_Id, LM.ChildLocationId
		FROM @LocationMap LM
			INNER JOIN dbo.Location AS L
				ON L.Location_Id = LM.LocationId
		WHERE L.Location_Type_Id = @CurrentLocationTypeId
			AND L.Parent_Location_Id IS NOT NULL

		-- Get Next Location Type
		SELECT @CurrentLocationTypeId = Parent_Location_Type_Id
		FROM dbo.LocationType
		WHERE Location_Type_Id = @CurrentLocationTypeId
	END
	
	RETURN
END
GO

/*
<TAG Name="Data Dictionary" FunctionName="GetLocationChildMap">
 <Function>
	Returns a map of child locations and a row for each of it's parents. Child locations are determined by 
	the lowest location type provided or if the location has no children. Location parameter can filter out 
	locations not to be included.
 </Function>
</TAG>
*/

--
--select Count(1) from dbo.GetLocationChildMap(null, null)




GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationSubtreeByLocationType.udf'
GO

IF Object_Id('dbo.GetLocationSubtreeByLocationType') IS NOT NULL
	DROP FUNCTION dbo.GetLocationSubtreeByLocationType
GO

CREATE FUNCTION dbo.GetLocationSubtreeByLocationType
(
	@iRootLocationId INT,
	@iHighestLocationTypeId SMALLINT,
	@iLowestLocationTypeId SMALLINT
)
RETURNS @Location TABLE
(
	LocationId INT NOT NULL,
	PRIMARY KEY (LocationId)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @RootLocationTypeId SMALLINT
	DECLARE @CurrentLocationTypeId SMALLINT
	DECLARE @CurrentRelativeDepth SMALLINT
	DECLARE @AbsoluteDepthRoot SMALLINT
	DECLARE @AbsoluteDepthHighest SMALLINT

	DECLARE @LocationType TABLE
	(
		LocationTypeId SMALLINT NOT NULL,
		RelativeDepth SMALLINT NOT NULL,
		ParentLocationTypeId SMALLINT NULL,
		PartialListing BIT NOT NULL,
		PRIMARY KEY (LocationTypeId, RelativeDepth, PartialListing)
	)

	INSERT INTO @LocationType
		(LocationTypeId, RelativeDepth, ParentLocationTypeId, PartialListing)
	SELECT LocationTypeId, RelativeDepth, ParentLocationTypeId, 1
	FROM dbo.GetLocationTypeRange(@iHighestLocationTypeId, @iLowestLocationTypeId)
	UNION ALL
	SELECT LocationTypeId, RelativeDepth, ParentLocationTypeId, 0
	FROM dbo.GetLocationTypeRange(NULL, NULL)
	ORDER BY RelativeDepth ASC

	-----
	-- seed the list based on the highest location type and requested root location

	-- we have the following options:
	-- 1. The RootLocationId IS NULL - find the highest depth and load all associated location id's
	-- 2. The RootLocationId is known - if it's within the type range then simply load that record	
	-- 3. The RootLocationId is known - if it's below the range then return nothing
	-- 4. The RootLocationId is known - if it's above the range then recursively call this routine to find
	--									the location id's which are start this hierarchy

	IF @iRootLocationId IS NULL
	BEGIN
		SET @RootLocationTypeId =
			(
				SELECT LocationTypeId
				FROM @LocationType
				WHERE RelativeDepth = 0
					And PartialListing = 1
			)

		INSERT INTO @Location
			(LocationId)
		SELECT Location_Id
		FROM dbo.Location
		WHERE Location_Type_Id = @RootLocationTypeId
	END
	ELSE
	BEGIN
		-- the Location Id is known, work out its Location Type Id
		SELECT @RootLocationTypeId = Location_Type_Id
		FROM dbo.Location
		WHERE Location_Id = @iRootLocationId

		-- if it is part of the partial list then start at this level	
		IF EXISTS
			(
				SELECT 1
				FROM @LocationType
				WHERE LocationTypeId = @RootLocationTypeId
					AND PartialListing = 1
			)
		BEGIN
			INSERT INTO @Location
				(LocationId)
			SELECT @iRootLocationId
		END
		-- if it is above the listing then find the appropriate starting level
		ELSE
		BEGIN
			SET @AbsoluteDepthRoot =
				(
					SELECT RelativeDepth
					FROM @LocationType
					WHERE LocationTypeId = @RootLocationTypeId
						AND PartialListing = 0
				)

			SET @AbsoluteDepthHighest = 
				(
					SELECT MIN(RelativeDepth)
					FROM @LocationType
					WHERE LocationTypeId = ISNULL(@iHighestLocationTypeId, LocationTypeId)
						AND PartialListing = 0
				)

			IF @AbsoluteDepthRoot < @AbsoluteDepthHighest
			BEGIN
				-- use the subtree call to find the location id's that start at the requested depth
				INSERT INTO @Location
					(LocationId)
				SELECT s.LocationId
				FROM dbo.GetLocationSubtreeByLocationType(@iRootLocationId, NULL, @iHighestLocationTypeId) AS s
					INNER JOIN dbo.Location AS l
						ON (s.LocationId = l.Location_Id)
				WHERE l.Location_Type_Id = @iHighestLocationTypeId

				SET @RootLocationTypeId = @iHighestLocationTypeId
			END
			ELSE
			BEGIN
				-- allow no records to be returned
				SET @RootLocationTypeId = NULL
			END
		END
	END

	-- collect each level and add it to the output list
	SET @CurrentLocationTypeId = @RootLocationTypeId

	WHILE (@CurrentLocationTypeId IS NOT NULL)
	BEGIN
		INSERT INTO @Location
			(LocationId)
		SELECT l.Location_Id
		FROM dbo.Location AS l 
			INNER JOIN @Location AS l2
				ON (l.Parent_Location_Id = l2.LocationId)
		WHERE l.Location_Type_Id = @CurrentLocationTypeId

		SET @CurrentLocationTypeId =
			(
				SELECT LocationTypeId
				FROM @LocationType
				WHERE ParentLocationTypeId = @CurrentLocationTypeId
					AND PartialListing = 1
			)
	END

	RETURN
END
GO


GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetMaterialTypeLocationDescriptionCSV.udf'
GO

  IF OBJECT_ID('dbo.GetMaterialTypeLocationDescriptionCSV') IS NOT NULL 
     DROP FUNCTION dbo.GetMaterialTypeLocationDescriptionCSV
Go 

CREATE FUNCTION dbo.GetMaterialTypeLocationDescriptionCSV
(
	@iMaterialTypeId INT
)
RETURNS VARCHAR(255)
BEGIN
		
	DECLARE @Cur CURSOR
	DECLARE @LocationName VARCHAR(31)
	DECLARE @Locations VARCHAR(8000)
	
	SET @Locations = ''
	
	SET @Cur = CURSOR FOR
		SELECT L.Description
		FROM Location L
			INNER JOIN MaterialTypeLocation MTL
				ON MTL.Location_Id = L.Location_Id
		WHERE MTL.Material_Type_Id = @iMaterialTypeId
		
	OPEN @Cur
	
	FETCH NEXT FROM @Cur INTO @LocationName
	
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
	
		IF @Locations <> ''
		BEGIN
			SET @Locations = @Locations + ', '
		END
		
		SET @Locations = @Locations + @LocationName
		
		FETCH NEXT FROM @Cur INTO @LocationName
	END
	
	CLOSE @Cur
	DEALLOCATE @Cur
		
	RETURN @Locations
END
GO

GO


Print 'Code: ReconcilorCore->Schema\Functions\dbo.GetLocationTypeRange.udf'
GO

IF Object_Id('dbo.GetLocationTypeRange') IS NOT NULL
	DROP FUNCTION dbo.GetLocationTypeRange
GO

CREATE FUNCTION dbo.GetLocationTypeRange
(
	@iHighestLocationTypeId SMALLINT,
	@iLowestLocationTypeId SMALLINT
)
RETURNS @LocationType TABLE
(
	LocationTypeId SMALLINT NOT NULL,
	RelativeDepth SMALLINT,
	ParentLocationTypeId SMALLINT NULL,
	PRIMARY KEY (LocationTypeId)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @CurrentLocationTypeId SMALLINT
	DECLARE @CurrentParentLocationTypeId SMALLINT
	DECLARE @NextLocationTypeId SMALLINT
	DECLARE @NextParentLocationTypeId SMALLINT
	DECLARE @RelativeDepth SMALLINT
	DECLARE @LowestEncounteredError BIT

	-----
	-- build the Location Type list that we'll draw from

	SET @RelativeDepth = 0
	IF @iHighestLocationTypeId IS NOT NULL
	BEGIN
		-- set the top level - from the top level
		SET @CurrentLocationTypeId = @iHighestLocationTypeId
		SET @CurrentParentLocationTypeId =
			(
				SELECT Parent_Location_Type_Id
				FROM dbo.LocationType
				WHERE Location_Type_Id = @iHighestLocationTypeId
			)
	END
	ELSE
	BEGIN
		-- load the top level
		SET @CurrentParentLocationTypeId = NULL
		SET @CurrentLocationTypeId =
			(
				SELECT Location_Type_Id
				FROM dbo.LocationType
				WHERE Parent_Location_Type_Id IS NULL
			)
	END

	SET @LowestEncounteredError = 0
	IF @iLowestLocationTypeId IS NOT NULL
	BEGIN
		SET @LowestEncounteredError = 1
	END

	WHILE (@CurrentLocationTypeId IS NOT NULL)
	BEGIN
		INSERT INTO @LocationType
			(LocationTypeId, ParentLocationTypeId, RelativeDepth)
		SELECT @CurrentLocationTypeId, @CurrentParentLocationTypeId, @RelativeDepth

		-- increment the loop
		SET @RelativeDepth = @RelativeDepth + 1
		
		IF (@iLowestLocationTypeId IS NOT NULL)
			AND (@CurrentLocationTypeId = @iLowestLocationTypeId)
		BEGIN
			SET @CurrentLocationTypeId = NULL
			SET @LowestEncounteredError = 0
		END
		ELSE
		BEGIN
			SELECT @NextLocationTypeId = NULL,
				@NextParentLocationTypeId = NULL

			SELECT @NextLocationTypeId = Location_Type_Id,
				@NextParentLocationTypeId = Parent_Location_Type_Id
			FROM dbo.LocationType
			WHERE Parent_Location_Type_Id = @CurrentLocationTypeId

			SELECT @CurrentLocationTypeId = @NextLocationTypeId,
				@CurrentParentLocationTypeId = @NextParentLocationTypeId
		END
	END

	IF @LowestEncounteredError = 1
	BEGIN
		DELETE
		FROM @LocationType
	END

	RETURN
END
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.PivotTable.prc'
GO

IF object_id('dbo.PivotTable') IS NOT NULL 
     DROP PROCEDURE dbo.PivotTable 
GO 
  
CREATE PROCEDURE dbo.PivotTable 
( 
    @iTargetTable SYSNAME,
	@iPivotTable SYSNAME,
	@iJoinColumns VARCHAR(max),
	@iPivotColumn VARCHAR(max),
	@iPivotValue VARCHAR(max),
	@iPivotType VARCHAR(max),
	@iPivotOrderColumn VARCHAR(8000) = '',
	@iPivotOrderDirection VARCHAR(5) = 'ASC'
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @curField CURSOR
	DECLARE @Pivot_Field VARCHAR(255)

	DECLARE @updateSQL VARCHAR(max)
	DECLARE @alterSQL VARCHAR(max)

	CREATE TABLE dbo.#PIVOT_TABLE__PIVOT_FIELD
	(
		Pivot_Field VARCHAR(255) COLLATE Database_Default NOT NULL,
		Order_Field VARCHAR(255) COLLATE Database_Default NULL
	)

	IF @iPivotOrderColumn <> ''
	BEGIN
		INSERT INTO dbo.#PIVOT_TABLE__PIVOT_FIELD
		(
			Pivot_Field, Order_Field
		)
		EXEC (
				'SELECT [' + @iPivotColumn + '], [' + @iPivotOrderColumn + '] ' + 
				'FROM [' + @iPivotTable + '] ' + 
				'GROUP BY [' + @iPivotColumn + '], [' + @iPivotOrderColumn + '] ' +
				'ORDER BY [' + @iPivotOrderColumn + '] ' + @iPivotOrderDirection	
			)
	END
	ELSE -- Order Alphabetically
	BEGIN
		INSERT INTO #PIVOT_TABLE__PIVOT_FIELD
		(
			Pivot_Field
		)
		EXEC (
				'SELECT [' + @iPivotColumn + '] ' +
				'FROM [' + @iPivotTable + '] ' +
				'GROUP BY [' + @iPivotColumn + '] ' +
				'ORDER BY [' + @iPivotColumn + '] '
			)
	END

	SET @curField = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
		SELECT Pivot_Field
		FROM #PIVOT_TABLE__PIVOT_FIELD

	OPEN @curField
	FETCH NEXT FROM @curField INTO @Pivot_Field

	--Initialise dynamic SQL
	SELECT @alterSQL = '', @updateSQL = ''

	WHILE @@Fetch_Status = 0
	BEGIN
		SELECT @alterSQL = @alterSQL + 
			'ALTER TABLE [' + @iTargetTable + '] ' + 
			'Add [' + @Pivot_Field + '] ' + @iPivotType + ' NULL '

		SELECT @updateSQL = @updateSQL + ' ' +
			'UPDATE [' + @iTargetTable + '] ' +
			'SET [' + @Pivot_Field + '] = [' + @iPivotTable + '].[' + @iPivotValue + '] ' +
			'FROM [' + @iTargetTable + '] ' +
			'	INNER JOIN [' + @iPivotTable + '] ON (' + @iJoinColumns + ') ' +
			'WHERE [' + @iPivotTable + '].[' + @iPivotColumn + '] = ''' + @Pivot_Field + ''' '
	
		--We are close to the varchar cap so run it as a batch now
		IF (Len(@alterSQL) > 7000 OR Len(@updateSQL) > 7000)
		BEGIN
			EXEC(@alterSQL)
			EXEC(@updateSQL)

			--Reinitialise dynamic SQL
			SELECT @alterSQL = '', @updateSQL = '' 
		END

		FETCH NEXT FROM @curField INTO @Pivot_Field
	END

	CLOSE @curField

	--IF theres sql to run still THEN run it
	IF @alterSQL <> '' 
	BEGIN
		EXEC(@alterSQL)
		EXEC(@updateSQL)
	END

	DROP TABLE #PIVOT_TABLE__PIVOT_FIELD
END 
GO 

/*
<TAG Name="Data Dictionary" ProcedureName="PivotTable">
 <Procedure>
	Pivots fields from the @iPivotTable and stores the results in the @iTargetTable.
	Errors are not raised
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddAuditHistory.prc'
GO

If object_id('dbo.AddAuditHistory') is Not NULL
	Drop Procedure dbo.AddAuditHistory
Go

Create Procedure dbo.AddAuditHistory

(
	@iAudit_Type_Name Varchar(255),
	@iAudit_Type_Group_Id Int,
	@iDescription Varchar(1023),
	@iHyperlink Varchar(1023),
	@iDetails Varchar(4095),
	@iUser_Id Int = Null,
	@iIs_Visible Bit = 1
)

With Encryption
As

Begin

	Declare @Audit_Type_Id Int

	Set NoCount On

	-- Get the audit type id for this audit type name
	Select @Audit_Type_Id = Audit_Type_Id
	From AuditType
	Where Name = @iAudit_Type_Name

	-- If the given audit type does not exist
	If (@Audit_Type_Id Is Null)
	Begin
		-- Add it, and obtain the new record's ID
		Insert Into AuditType
		(
			Audit_Type_Group_Id, Name
		)
		Values
		(
			@iAudit_Type_Group_Id, @iAudit_Type_Name
		)

		Set @Audit_Type_Id = Scope_Identity()
	End

	-- Insert the audit record
	Insert Into AuditHistory
	(
		Audit_Type_Id, Audit_History_Datetime,
		Description, Hyperlink, Details,
		[User_Id], Is_Visible
	)
	Values
	(
		@Audit_Type_Id, GetDate(),
		@iDescription, @iHyperlink, @iDetails,
		@iUser_Id, @iIs_Visible
	)
End
Go
GRANT EXECUTE ON dbo.AddAuditHistory TO CoreEventManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddAuditHistory">
 <Procedure>
	Adds a audit history record to AuditHistory.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcHistory.prc'
GO

If object_id('dbo.GetRecalcHistory') is not Null 
     Drop Procedure dbo.GetRecalcHistory
Go 
  
Create Procedure dbo.GetRecalcHistory
( 
    @iRecalc_History_Id BigInt = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select RH.*, 
		RS.Name As Recalc_State_Name, 
		RS.Description As Recalc_State_Description
	From RecalcHistory As RH
		Left Join RecalcState As RS
			On RH.Recalc_State_Id = RS.Recalc_State_Id
	Where @iRecalc_History_Id = RH.Recalc_History_Id
		Or @iRecalc_History_Id Is Null

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcHistory TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcHistory">
 <Procedure>
	Retreives a specific Recalc History Log entry and returns it along with its Recalc State Record.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcHistoryList.prc'
GO

 IF OBJECT_ID('dbo.GetRecalcHistoryList') IS NOT NULL 
     DROP PROCEDURE dbo.GetRecalcHistoryList
GO 
  
CREATE PROCEDURE dbo.GetRecalcHistoryList
( 
    @iDate_From Datetime,
	@iDate_To Datetime,
	@iRecalcLevel INT = NULL,
	@iRecalcState VARCHAR(31) = NULL,
	@iLimitRecords BIT = 0
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  	
    SET TRANSACTION Isolation Level Repeatable Read 
    BEGIN TRANSACTION 
  
	IF @iLimitRecords = 1
	BEGIN
		SET ROWCOUNT 100
	END
  
	SELECT RH.*,
		RS.Name AS Recalc_State_Name, 
		RS.Description AS Recalc_State_Description
	FROM RecalcHistory AS RH
		LEFT JOIN RecalcState AS RS
			ON RH.Recalc_State_Id = RS.Recalc_State_Id
	--WHERE clause covers following scenarios
	--1. WHERE the recalc has started before the @iDate_To AND has NOT yet finished
	--2. WHERE a recalc has started before the @iDate_To AND finished after the @iDate_From
	WHERE (dbo.GetDateDay(End_Datetime) >= @iDate_From 
		OR @iDate_From IS NULL OR End_Datetime IS NULL)
		AND (dbo.GetDateDay(Start_Datetime) <= @iDate_To
			OR @iDate_To IS NULL)
		AND ((@iRecalcLevel = 1 AND Recalc_Type_Id = 'Level 1')
			OR (@iRecalcLevel = 2 AND Recalc_Type_Id = 'Level 2')
			OR @iRecalcLevel IS NULL)
		AND (@iRecalcState = RS.Name OR @iRecalcState IS NULL)

	IF @iLimitRecords = 1
	BEGIN
		SET ROWCOUNT 0
	END
  
    COMMIT TRANSACTION     
END 
GO 
GRANT EXECUTE ON dbo.GetRecalcHistoryList TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcHistoryList">
 <Procedure>
	Retrieves a list of recalc events that are within the filter's range.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetPreviousDateShift.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPreviousDateShift]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetPreviousDateShift]
GO

CREATE Procedure [dbo].[GetPreviousDateShift]

(@Date Datetime,
@Shift Char(1),
@Previous_Date Datetime Output,
@Previous_Shift Char(1) Output)

With Encryption As

Declare @Order_No Int
Declare @Min_Order_No Int

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set @Date = dbo.GetDateDay (@Date)

	Select @Order_No = Order_No
	From ShiftType
	Where Shift = @Shift

	Select @Min_Order_No = Min(Order_No)
	From ShiftType

	If (@Order_No = @Min_Order_No)
	Begin
		Select @Previous_Shift = Shift
		From ShiftType
		Where Order_No = 	(Select Max(Order_No)
					From ShiftType)

		Set @Previous_Date = DateAdd (Day, -1, @Date)
	End
	Else
	Begin
		Select @Previous_Shift = Shift
		From ShiftType
		Where Order_No = 	(Select Max(Order_No)
					From ShiftType
					Where Order_No < @Order_No)

		Set @Previous_Date = @Date
	End

	/* If no value was found */
	If (@Previous_Shift Is Null)
	Begin
		/* There must be only one shift, so use it */
		Select @Previous_Shift = Min(Shift)
		From ShiftType

		Set @Previous_Date = DateAdd (Day, -1, @Date)
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetPreviousDateShift">
 <Procedure>
	Returns the previous shift date.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL2Raise.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL2Raise]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcL2Raise]
GO

CREATE Procedure dbo.RecalcL2Raise

(@pDate Datetime,
 @pShift Char(1))

With Encryption As

Begin
	Declare @Approval_End_Date DateTime
	Declare @Approval_End_Shift Char(1)
	Declare @Approval_Flag Bit
	
	Set NoCount On

	If (@pDate Is Not Null) And (@pShift Is Not Null)
	Begin
		Set Transaction Isolation Level Repeatable Read
		Begin Transaction

		--Strip Time Component
		Set @pDate = DateAdd(d, DateDiff(d, '1901-01-01', @pDate), '1901-01-01')

		-- determine if there are monthly approvals involved, and the period that it corresponds to
		-- note that we need to specify the closing balance (End_Date / End_Shift) to define the end of the period
		If Exists (Select 1 From MonthlyApproval Where Is_Approved = 1)
		Begin
			Set @Approval_Flag = 1

			-- determine the approval period
			Set @Approval_End_Date = (Select DateAdd(Month, 1, Max(Monthly_Approval_Month))
			                          From MonthlyApproval
			                          Where Is_Approved = 1)
			Set @Approval_End_Date = dbo.GetDateMonth(@Approval_End_Date)
			Set @Approval_End_Shift = dbo.GetFirstShiftType()

			Exec dbo.GetPreviousDateShift @Date=@Approval_End_Date,
			                                 @Shift=@Approval_End_Shift,
			                                 @Previous_Date=@Approval_End_Date Output,
			                                 @Previous_Shift=@Approval_End_Shift Output
		End
		Else
		Begin
			Set @Approval_Flag = 0
			Set @Approval_End_Date = Null
			Set @Approval_End_Shift = Null
		End

		-- if there are no monthly approvals involved
		If (@Approval_Flag = 0)
		   Or (dbo.CompareDateShift(@Approval_End_Date, @Approval_End_Shift, '>', @pDate, @pShift) = 0)
		Begin
			-- queue as per normal
			Insert Into RecalcL2queue
			 (Recalc_Date, Recalc_Shift)
			Values (@pDate, @pShift)
		End
		-- if there are monthly approvals involved
		Else
		Begin
			-- the date is within an approval period
			-- store the original for later processing (ie when the month becomes unapproved)
			Insert Into RecalcL2queueWithheld
			 (Recalc_Date, Recalc_Shift)
			Values (@pDate, @pShift)

			-- also, since the L2 date corresponds to a period, rather than a date,
			-- submit the partial period to the L2 queue as per normal
			Insert Into RecalcL2queue
			 (Recalc_Date, Recalc_Shift)
			Values (@Approval_End_Date, @Approval_End_Shift)
		End

		Commit Transaction
	End
End
GO

GRANT EXECUTE ON dbo.RecalcL2Raise TO CoreRecalc
GO

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL2Raise">
 <Procedure>
	This routine writes to the Level 2 queue.
	Need to determine if there are monthly approvals involved, and the period that it corresponds to.
	If there are no monthly approvals involved queue as per normal into table RecalcL2queue.
	If there are monthly approvals involved the date is within an approval period store the 
	original for later processing (ie when the month becomes unapproved) into table RecalcL2queueWithheld.
	Also, since the Level 2 date corresponds to a period, rather than a date, submit the 
	partial period to the Level 2 queue as per normal into table RecalcL2queue.		
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL1Raise.prc'
GO

If Object_Id('RecalcL1Raise') Is Not Null
	Drop Procedure dbo.RecalcL1Raise
Go

Create Procedure dbo.RecalcL1Raise
(
	@pDate Datetime,
	@pRaise_Recalc_Event Bit = 1
)

With Encryption
As

Begin
	-- note: this is the only routine allowed to WRITE to the L1 queue
	-- note: @Raise_Recalc_Event is a compatiblity flag

	Declare @Date DateTime

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
		
	-- strip time Component
	Set @Date = dbo.GetDateDay(@pDate)

	-- need to perform a check to see whether the entry falls within an approved month
	If dbo.IsInApprovedMonth(@pDate) = 0
	Begin
		-- if the Date is outside of the approval period
		-- add it to the queue as per normal
		Insert Into RecalcL1queue
			(Recalc_Date)
		Values
			(@Date)
	End
	Else
	Begin
		-- if the date is within an approval period
		-- store this for later processing (ie when the month becomes unapproved)
		Insert Into RecalcL1queueWithheld
			(Recalc_Date)
		Values
			(@Date)
	End	

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL1Raise">
 <Procedure>
	This is the only routine allowed to WRITE to the Level 1 queue.
	@Raise_Recalc_Event is a compatiblity flag.
	Need to perform a check to see whether the entry falls within an approved month.
	If the Date is outside of the approval period add it to the queue as per normal 
	into table RecalcL1queue.
	If the date is within an approval period store this for later processing (ie when 
	the month becomes unapproved) into table RecalcL1queueWithheld.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL2ReprocessWithheld.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL2ReprocessWithheld]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcL2ReprocessWithheld]
GO

Create Procedure dbo.RecalcL2ReprocessWithheld

(@pEnd_Date DateTime,
 @pEnd_Shift Char(1))

With Encryption As

Begin
	Declare @Recalc_Date DateTime
	Declare @Recalc_Shift Char(1)

	Declare @L2_WITHHELD Table
	 (Recalc_Date DateTime,
	  Recalc_Shift Char(1) Collate Database_Default,
	  Primary Key (Recalc_Date, Recalc_Shift))

	-- resubmit L2 events
	-- take a copy of the current L2_WITHHELD table
	-- move through the records in order, resubmitting them for processing
	-- note that a temporary copy is used as records may be re-withheld

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- take a working copy
	Insert Into @L2_WITHHELD
	 (Recalc_Date, Recalc_Shift)
	Select Distinct Recalc_Date, Recalc_Shift
	From RecalcL2queueWithheld
	Where Recalc_Date <= @pEnd_Date
	 And dbo.GetShiftTypeOrderNo(Recalc_Shift) <= dbo.GetShiftTypeOrderNo(@pEnd_Shift)

	-- delete the existing affected entries
	Delete
	From RecalcL2queueWithheld
	Where Recalc_Date <= @pEnd_Date
	 And dbo.GetShiftTypeOrderNo(Recalc_Shift) <= dbo.GetShiftTypeOrderNo(@pEnd_Shift)

	While (Select Count(*) From @L2_WITHHELD) > 0
	Begin
		-- retrieve the earliest entry
		Select Top 1 @Recalc_Date = Recalc_Date,
		 @Recalc_Shift = Recalc_Shift
		From @L2_WITHHELD
		Order By Recalc_Date Desc, dbo.GetShiftTypeOrderNo(Recalc_Shift) Desc

		-- submit it to the L2 Queue
		Exec RecalcL2Raise @Recalc_Date, @Recalc_Shift

		-- remove the entry
		Delete
		From @L2_WITHHELD
		Where Recalc_Date = @Recalc_Date
		 And Recalc_Shift = @Recalc_Shift
	End

	Commit Transaction
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.RecalcL2ReprocessWithheld">
 <Procedure>
	Resubmits Level 2 events.
	Takes a copy of the current L2_WITHHELD table, moves through the records in order, 
	resubmitting them for processing.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL2ClearQueue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL2ClearQueue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcL2ClearQueue]
GO

Create Procedure dbo.RecalcL2ClearQueue

(@pMax_L2Queue_Id Int)

With Encryption As

Begin
	Set NoCount On
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- archive the entries
	Insert Into RecalcL2queueProcessed
	 (L2Queue_Id, Recalc_Date, Recalc_Shift, Queue_Added_DateTime, Processed_Max_L2Queue_Id)
	Select L2Queue_Id, Recalc_Date, Recalc_Shift, Added_DateTime, @pMax_L2Queue_Id
	From RecalcL2queue
	Where L2Queue_Id <= @pMax_L2Queue_Id

	-- delete the entries
	Delete
	From RecalcL2queue
	Where L2Queue_Id <= @pMax_L2Queue_Id

	Commit Transaction
End
GO

GRANT EXECUTE ON dbo.RecalcL2ClearQueue TO CoreRecalc
GO

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL2ClearQueue">
 <Procedure>
	Archives all the processed entries into table RecalcL2queueProcessed.
	Then deletes the entried from the queue (table RecalcL2queue).
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL1ReprocessWithheld.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL1ReprocessWithheld]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcL1ReprocessWithheld]
GO

Create Procedure dbo.RecalcL1ReprocessWithheld

(@pStart_Date DateTime,
 @pEnd_Date DateTime)

With Encryption As

Begin
	Declare @Recalc_Date DateTime

	Declare @L1_WITHHELD Table
	 (Recalc_Date DateTime,
	  Primary Key (Recalc_Date))

	-- resubmit L1 events
	-- take a copy of the current L1_WITHHELD table
	-- move through the records in order, resubmitting them for processing
	-- note that a temporary copy is used as records may be re-withheld

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- take a working copy
	Insert Into @L1_WITHHELD
	 (Recalc_Date)
	Select Distinct Recalc_Date
	From RecalcL1queueWithheld
	Where Recalc_Date Between @pStart_Date And @pEnd_Date

	-- delete the existing affected entries
	Delete
	From RecalcL1queueWithheld
	Where Recalc_Date Between @pStart_Date And @pEnd_Date

	While (Select Count(*) From @L1_WITHHELD) > 0
	Begin
		-- retrieve the earliest entry
		Select Top 1 @Recalc_Date = Recalc_Date
		From @L1_WITHHELD
		Order By Recalc_Date Asc

		-- submit it to the L1 Queue
		Exec RecalcL1Raise @Recalc_Date

		-- remove the entry
		Delete
		From @L1_WITHHELD
		Where Recalc_Date = @Recalc_Date
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL1ReprocessWithheld">
 <Procedure>
	This stored procedure resubmits L1 events. Take a copy of the current RecalcL1queueWithheld
	table. Moves through the records in order, resubmitting them for processing (RecalcL1Raise).
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcProgress.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetRecalcProgress]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure dbo.GetRecalcProgress
GO

Create Procedure dbo.GetRecalcProgress

With Encryption
As

Begin

	Declare @L1_Queue_Count Int
	Declare @L2_Queue_Count Int
	Declare @L2_Queue_Date_Min DateTime
	Declare @L2_Queue_Shift_Min Char(1)
	Declare @Process_Count Int

	Set NoCount On
	
	-- Determine if a L1 is running
	Select @L1_Queue_Count = Count(Distinct Recalc_Date)
	From RecalcL1queue With (ReadUncommitted)

	-- Determine if a L2 is running
	Select @L2_Queue_Count = Count(*)
	From RecalcL2queue With (ReadUncommitted)

	If @L1_Queue_Count > 0
	Begin
		Select 'Level 1' As Process, 'Processing Level 1 Queue' As Description

		Select @L2_Queue_Count = Count(Distinct Recalc_Date)
		From RecalcL2queue With (ReadUncommitted)

		Select Top 1 @L2_Queue_Date_Min = Recalc_Date,
			@L2_Queue_Shift_Min = Recalc_Shift
		From RecalcL2queue With (ReadUncommitted)
		Order By Recalc_Date Asc, dbo.GetShiftTypeOrderNo(Recalc_Shift) Asc

		Select @L1_Queue_Count As Count_Distinct_L1_Dates,
			@L2_Queue_Count As Count_Distinct_L2_Dates,
			@L2_Queue_Date_Min As L2_Start_Date,
			@L2_Queue_Shift_Min As L2_Start_Shift
	End
	Else If @L2_Queue_Count > 0
	Begin
		Select 'Level 2' As Process, 'Processing Level 2 Queue' As Description

		If Exists (Select 1 From RecalcHistory With (ReadUncommitted) Where End_DateTime Is Null)
		Begin
			-- If the L2 has had time to write the RecalcHistory record
			Select Start_Date, Start_Shift,
				End_Date, End_Shift,
				Current_Processing_Date, Current_Processing_Shift,
				RS.Name As Recalc_State,
				dbo.GetRecalcProgressPercentage
					(
						Start_Date, Start_Shift,
						End_Date, End_Shift,
						Current_Processing_Date, Current_Processing_Shift
					) As Percentage_Complete
			From RecalcHistory RH With (ReadUncommitted)
				Inner Join RecalcState RS
					On RH.Recalc_State_Id = RS.Recalc_State_Id
			Where End_DateTime Is Null
		End
		Else
		Begin
			-- If there is no RecalcHistory record ready
			Select Null As Start_Date, Null As Start_Shift,
				Null As End_Date, Null As End_Shift,
				Null As Current_Processing_Date, Null As Current_Processing_Shift,
				'Starting' As Recalc_State, Null As Percentage_Complete
		End
	End
	Else
	Begin
		Select 'NA' As Process, 'No Activity' As Description
	End
End
Go
GRANT EXECUTE ON dbo.GetRecalcProgress TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcProgress">
 <Procedure>
	Returns the recalc in progress.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL1RaisePeriod.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL1RaisePeriod]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcL1RaisePeriod]
GO

CREATE Procedure [dbo].[RecalcL1RaisePeriod]

(@iStart_Date Datetime = Null,
 @iEnd_Date Datetime = Null)

With Encryption As

Begin
	Declare @This_Date Datetime
	Declare @Start_Date Datetime
	Declare @End_Date Datetime
	Declare @Is_Approved Bit
	Declare @Result Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- if the end date is not specified, calculate through to today
	If @iStart_Date Is Null
		Set @Start_Date = (Select Min(Start_Date) From StockpileBuild)
	Else
		Set @Start_Date = @iStart_Date
	
	Set @End_Date = Coalesce(@iEnd_Date, Cast(Convert(VarChar, GetDate(), 106) AS DateTime))
	Set @This_Date = @Start_Date

	/* For each date in the given range */
	While (@This_Date <= @End_Date)
	Begin
		Execute RecalcL1Raise @pDate=@This_Date

		Select @This_Date = DateAdd(Day, 1, @This_Date)
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL1RaisePeriod">
 <Procedure>
	This procedure calls stored procedure Recalc_Li_Raise for each date in a given range.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL1RaiseByHaulage.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.RecalcL1RaiseByHaulage'))
	Drop Procedure dbo.RecalcL1RaiseByHaulage
Go

Create Procedure dbo.RecalcL1RaiseByHaulage
(
	@iHaulage_Id VarChar(31)
)

With Encryption
As

Begin
	Declare @Haulage_Date DateTime

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @Haulage_Date = (	Select Haulage_Date
							From Haulage
							Where Haulage_Id = @iHaulage_Id)
							
	Exec dbo.RecalcL1Raise
		@pDate = @Haulage_Date

	Commit Transaction
End

Go 
/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL1RaiseByHaulage">
 <Procedure>
	Raises a L1 Recalc for the date of the haulage @iHaulage_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddRecalcHistory.prc'
GO

If object_id('dbo.AddRecalcHistory') is Not NULL
	Drop Procedure dbo.AddRecalcHistory
Go

Create Procedure dbo.AddRecalcHistory

(
	@iRecalc_Type_Id Varchar(31),
	@iStart_Datetime Datetime = Null,
	@iEnd_Datetime Datetime = Null,
	@iStart_Date Datetime = Null,
	@iStart_Shift Char(1) = Null,
	@iEnd_Date Datetime = Null,
	@iEnd_Shift Char(1) = Null,
	@iRecalc_State_Id Int,
	@iMax_Queue_Id BigInt = Null,
	@iError_Message Varchar(255) = Null,
	@iError_Details Varchar(4095) = Null,
	@oRecalc_History_Id Int = Null Output
)

With Encryption
As

Begin

	Set NoCount On

	-- Clear up any old recalc records of this type
	Update RH
	Set	End_Datetime = Start_Datetime,
		Recalc_State_Id =	(
								Select RS.Recalc_State_Id
								From dbo.RecalcState RS
								Where RS.Name = 'Cancelled'
							)
	From dbo.RecalcHistory RH
	Where End_Datetime Is Null
		And Recalc_Type_Id = @iRecalc_Type_Id	

	-- Insert the new history record
	Insert Into dbo.RecalcHistory
	(
		Recalc_Type_Id,
		Start_Datetime, End_Datetime,
		[Start_Date], Start_Shift,
		End_Date, End_Shift,
		Current_Processing_Date, Current_Processing_Shift,
		Recalc_State_Id,
		Max_Queue_Id, [Error_Message], Error_Details
	)
	Values
	(
		@iRecalc_Type_Id,
		Coalesce(@iStart_Datetime, GetDate()), @iEnd_Datetime,
		dbo.GetDateDay (@iStart_Date), @iStart_Shift,
		dbo.GetDateDay (@iEnd_Date), @iEnd_Shift,
		dbo.GetDateDay (@iStart_Date), @iStart_Shift,
		@iRecalc_State_Id,
		@iMax_Queue_Id, @iError_Message, @iError_Details
	)

	Set @oRecalc_History_Id = Scope_Identity()
End
Go
GRANT EXECUTE ON dbo.AddRecalcHistory TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="AddRecalcHistory">
 <Procedure>
	Adds a new record to the RecalcHistory table. This table is used in both recalc logging
	and recalc management.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateRecalcHistory.prc'
GO

If object_id('dbo.UpdateRecalcHistory') is Not NULL
	Drop Procedure dbo.UpdateRecalcHistory
Go

Create Procedure dbo.UpdateRecalcHistory

(
	@iRecalc_History_Id BigInt,
	@iUpdate_Start_Datetime Bit = 0,
	@iStart_Datetime Datetime = Null,
	@iUpdate_End_Datetime Bit = 0,
	@iEnd_Datetime Datetime = Null,
	@iUpdate_Start_Date Bit = 0,
	@iStart_Date Datetime = Null,
	@iUpdate_Start_Shift Bit = 0,
	@iStart_Shift Char(1) = Null,
	@iUpdate_End_Date Bit = 0,
	@iEnd_Date Datetime = Null,
	@iUpdate_End_Shift Bit = 0,
	@iEnd_Shift Char(1) = Null,
	@iUpdate_Current_Processing_Date Bit = 0,
	@iCurrent_Processing_Date Datetime = Null,
	@iUpdate_Current_Processing_Shift Bit = 0,
	@iCurrent_Processing_Shift Char(1) = Null,
	@iUpdate_Recalc_State_Id Bit = 0,
	@iRecalc_State_Id Int = Null,
	@iUpdate_No_Restarts Bit = 0,
	@iNo_Restarts Int = Null,
	@iUpdate_Max_Queue_Id Bit = 0,
	@iMax_Queue_Id BigInt = Null,
	@iUpdate_Error_Message Bit = 0,
	@iError_Message Varchar(255) = Null,
	@iUpdate_Error_Details Bit = 0,
	@iError_Details Varchar(4095) = Null
)

With Encryption
As

Begin

	Set NoCount On

	-- Update the history record
	Update dbo.RecalcHistory
	Set	Start_Datetime =	Case When (@iUpdate_Start_Datetime = 1) Then
								@iStart_Datetime
							Else
								Start_Datetime
							End,
		End_Datetime =	Case When (@iUpdate_End_Datetime = 1) Then
							@iEnd_Datetime
						Else
							End_Datetime
						End,
		[Start_Date] =	Case When (@iUpdate_Start_Date = 1) Then
							@iStart_Date
						Else
							[Start_Date]
						End,
		Start_Shift =	Case When (@iUpdate_Start_Shift = 1) Then
							@iStart_Shift
						Else
							Start_Shift
						End,
		End_Date =	Case When (@iUpdate_End_Date = 1) Then
						@iEnd_Date
					Else
						End_Date
					End,
		End_Shift =	Case When (@iUpdate_End_Shift = 1) Then
						@iEnd_Shift
					Else
						End_Shift
					End,
		Current_Processing_Date =	Case When (@iUpdate_Current_Processing_Date = 1) Then
										@iCurrent_Processing_Date
									Else
										Current_Processing_Date
									End,
		Current_Processing_Shift =	Case When (@iUpdate_Current_Processing_Shift = 1) Then
										@iCurrent_Processing_Shift
									Else
										Current_Processing_Shift
									End,
		Recalc_State_Id =	Case When (@iUpdate_Recalc_State_Id = 1) Then
								@iRecalc_State_Id
							Else
								Recalc_State_Id
							End,
		No_Restarts =	Case When (@iUpdate_No_Restarts = 1) Then
							@iNo_Restarts
						Else
							No_Restarts
						End,
		Max_Queue_Id =	Case When (@iUpdate_Max_Queue_Id = 1) Then
							@iMax_Queue_Id
						Else
							Max_Queue_Id
						End,
		[Error_Message] =	Case When (@iUpdate_Error_Message = 1) Then
								@iError_Message
							Else
								[Error_Message]
							End,
		Error_Details =		Case When (@iUpdate_Error_Details = 1) Then
								@iError_Details
							Else
								Error_Details
							End
	Where Recalc_History_Id = @iRecalc_History_Id
End
Go
GRANT EXECUTE ON dbo.UpdateRecalcHistory TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateRecalcHistory">
 <Procedure>
	Updates an existing record in the RecalcHistory table. This table is used for both recalc logging
	and recalc management.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcL2UpdateQueueProcessedDateShift.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcL2UpdateQueueProcessedDateShift]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure dbo.RecalcL2UpdateQueueProcessedDateShift
GO

Create Procedure dbo.RecalcL2UpdateQueueProcessedDateShift

(
	@iMax_Queue_Id Int,
	@iProcessed_Date Datetime,
	@iProcessed_Shift Char(1)
)

With Encryption As

Begin

	Set NoCount On
	
	-- Set the new processed date/shift value for all recalcs on or before the given queue id
	Update RecalcL2queue
	Set	Processed_Date = @iProcessed_Date,
		Processed_Shift = @iProcessed_Shift
	Where L2Queue_Id <= @iMax_Queue_Id
End
Go
GRANT EXECUTE ON dbo.RecalcL2UpdateQueueProcessedDateShift TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcL2UpdateQueueProcessedDateShift">
 <Procedure>
	 Sets the new processed date/shift value for all recalcs on or before the given queue ID.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.CalcVirtualFlowRaise.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CalcVirtualFlowRaise]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[CalcVirtualFlowRaise]
GO

Create Procedure dbo.CalcVirtualFlowRaise
(@pCalc_Date DateTime)
With Encryption As
Begin
	Set NoCount On

	Declare @value Varchar(255)

	Select @pCalc_Date = dbo.GetDateDay(@pCalc_Date)

	Exec dbo.GetSystemSetting
		@iSetting_Id = 'CALC_VIRTUAL_FLOW',
		@iValue = @value Output

	-- check if the setting is active
	If Coalesce(@value, 'FALSE') = 'TRUE'
	Begin
		Insert Into CalcVirtualFlowQueue
		 (Calc_Date, Added_DateTime)
		Values (@pCalc_Date, GetDate())
	End
End

GO


/*
<TAG Name="Data Dictionary" ProcedureName="CalcVirtualFlowRaise">
 <Procedure>
	Raises a Calc Virtual Flow event.
	Inserts a record for the specified @pCalc_Date into the CalcVirtualFlowQueue table.
	First checks that the system setting 'CALC_VIRTUAL_FLOW' is set to active.
	No errors are raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveActivateBlocks.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveActivateBlocks') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveActivateBlocks  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveActivateBlocks
(
    @iHaulageRawId INT 
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here
	DECLARE @SourceCursor CURSOR
	DECLARE @DigblockId VARCHAR(31)
	DECLARE @HaulageDate DATETIME
	DECLARE @HaulageShift CHAR(1)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveActivateBlocks',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SELECT @HaulageDate = H.Haulage_Date,
			@HaulageShift = H.Haulage_Shift
		FROM dbo.HaulageRaw AS H
		WHERE H.Haulage_Raw_Id = @iHaulageRawId

		SET @SourceCursor = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
		SELECT R.Digblock_Id
		FROM dbo.#ResolutionSource AS R
			INNER JOIN dbo.Digblock AS D
				ON (D.Digblock_Id = R.Digblock_Id)
		WHERE D.Auto_Activate_Haulage = 1

		OPEN @SourceCursor
		FETCH NEXT FROM @SourceCursor INTO @DigblockId

		WHILE @@Fetch_Status = 0
		BEGIN
			--This procedure will auto activate the block for haulage
			--If it is not activated.
			EXEC dbo.CorrectDigblockDateRange
				@iDigblock_Id = @DigblockId,
				@iDate = @HaulageDate,
				@iShift = @HaulageShift,
				@iHaulage_Raw_Resolve_All = 0

			FETCH NEXT FROM @SourceCursor INTO @DigblockId
		END

		CLOSE @SourceCursor

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO


/*
<TAG Name="Data Dictionary" ProcedureName="dbo.HaulageRawResolveActivateBlocks">
 <Procedure>
	For each haulage recode for a given Haulage_Raw_Id activate the block by 
	resetting it's date range for any blocks using auto activation.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveBasicResolve.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveBasicResolve') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveBasicResolve  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveBasicResolve 
(
	@iHaulageRawId INT,
	@iHaulageDate DATETIME,
	@iHaulageShift CHAR(1),
	@iResolutionTarget VARCHAR(11),
	@oResolved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @DigblockId VARCHAR(31)
	DECLARE @StockpileId INT
	DECLARE @BuildId INT
	DECLARE @ComponentId INT
	DECLARE @CrusherId VARCHAR(31)
	DECLARE @MillId VARCHAR(31)
	DECLARE @HaulageResolveBasicId INT
	DECLARE @LocationResolved BIT
	DECLARE @Code VARCHAR(63)
	DECLARE @Resolved BIT
	DECLARE @ResolvedLocations TABLE
	(
		LocationId INT
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveBasicResolve',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- uses the basic resolution methods to resolve the record
		-- this is achieved by the following steps:
		-- 1. Attempt to map through HaulageResolveBasic (based on rules)
		-- 2. Attempt to map directly to Digblock
		-- 3. Attempt to map directly to Stockpile
		-- 4. Attempt to map directly to Crusher

		-- iResolution_Target is either SOURCE or DESTINATION

		SET @LocationResolved = 1

		-- determine the CODE we need to target
		IF @iResolutionTarget = 'SOURCE'
		BEGIN
			SELECT @Code = Source
			FROM dbo.HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId
		END
		ELSE
		BEGIN
			SELECT @Code = Destination
			FROM dbo.HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId
		END

		SET @Resolved = 0

		-- clear all variables
		SET @DigblockId = NULL
		SET @StockpileId = NULL
		SET @BuildId = NULL
		SET @ComponentId = NULL
		SET @CrusherId = NULL
		SET @MillId = NULL
		SET @HaulageResolveBasicId = NULL

		-- attempt to map through HaulageResolveBasic
		SET @HaulageResolveBasicId = NULL

		SELECT @HaulageResolveBasicId = Haulage_Resolve_Basic_Id
		FROM dbo.HaulageResolveBasic HRB
		WHERE Code = @Code
			AND EXISTS
				(
					SELECT TOP 1 1
					FROM dbo.HaulageRaw
					WHERE Haulage_Raw_Id = @iHaulageRawId
						AND dbo.CompareDateShift(HRB.Resolve_From_Date, HRB.Resolve_From_Shift, '<=', Haulage_Date, Haulage_Shift) = 1
						AND
							(
								dbo.CompareDateShift(HRB.Resolve_To_Date, HRB.Resolve_To_Shift, '>=', Haulage_Date, Haulage_Shift) = 1
								OR HRB.Resolve_To_Date IS NULL
							)
				)
			AND
				(
					HRB.Haulage_Direction = 'B'
					OR (HRB.Haulage_Direction =  'S' AND @iResolutionTarget = 'SOURCE')
					OR (HRB.Haulage_Direction =  'D' AND @iResolutionTarget = 'DESTINATION')
				)

		IF @HaulageResolveBasicId Is Not Null
		BEGIN
			SELECT @DigblockId = Digblock_Id,
				@StockpileId = Stockpile_Id,
				@BuildId = Build_Id,
				@ComponentId = Component_Id,
				@CrusherId = Crusher_Id
			FROM dbo.HaulageResolveBasic
			WHERE Haulage_Resolve_Basic_Id = @HaulageResolveBasicId
			SET @Resolved = 1
		END

		-- If the 'resolved' source was a crusher, eliminate it, the system doesnt handle this yet
		IF @iResolutionTarget = 'SOURCE' AND @CrusherId IS NOT NULL AND @Resolved = 1
		BEGIN
			SET @CrusherId = NULL
			SET @Resolved = 0
		END

		-- attempt to map directly to Digblock
		-- note: a digblock can only be a source
		--       this may be changed in future releases
		IF @iResolutionTarget = 'SOURCE'
		BEGIN
			IF @Resolved = 0
			BEGIN
				SELECT @DigblockId = Digblock_Id
				FROM dbo.Digblock
				WHERE Digblock_Id = Left(@Code, 31)

				IF @DigblockId IS NOT NULL
				BEGIN
					SET @Resolved = 1
				END
			END
		END

		-- attempt to map directly to Stockpile
		IF @Resolved = 0
		BEGIN
			SELECT @StockpileId = Stockpile_Id
			FROM dbo.Stockpile
			WHERE Stockpile_Name = Left(@Code, 31)

			IF @StockpileId IS NOT NULL
			BEGIN
				SET @Resolved = 1
			END
		END

		-- attempt to map directly to Crusher
		-- note: a crusher can only be a destination
		--       this may be changed in future releases
		IF @iResolutionTarget = 'DESTINATION'
		BEGIN
			IF @Resolved = 0
			BEGIN
				SELECT @CrusherId = Crusher_Id
				FROM dbo.Crusher
				WHERE Crusher_Id = Left(@Code, 31)

				IF @CrusherId IS NOT NULL
				BEGIN
					SET @Resolved = 1
				END
			END
		END
		ELSE
		BEGIN
			SET @CrusherId = NULL
		END

		-- attempt to map directly to Mill
		-- note: the old system will not allow transactions to/from Mill
		--       this is available for any future extensions
		SET @MillId = NULL
		
		-- based on the stockpile resolution, attempt to fill in the "missing picture" for build
		-- note: if the component is not specified,
		-- the Recalc will fill in this information (it will pro-rata out against all components)
		IF
			(
				@Resolved = 1
				AND @StockpileId IS NOT NULL
				AND @BuildId IS NULL
			)
		BEGIN
			IF @iResolutionTarget = 'SOURCE'
			BEGIN
				SET @BuildId = dbo.GetReclaimableStockpileBuild(@StockpileId, @iHaulageDate, @iHaulageShift)
			END			
			ELSE
			BEGIN			
				SET @BuildId = dbo.GetBuildableStockpileBuild(@StockpileId, @iHaulageDate, @iHaulageShift)
			END
		END

		IF @DigblockId IS NOT NULL
		BEGIN
			INSERT INTO @ResolvedLocations
			(
				LocationId
			)
			SELECT Location_Id
			FROM dbo.DigblockLocation
			WHERE Digblock_Id = @DigblockId
		END
		IF @StockpileId IS NOT NULL
		BEGIN			
			INSERT INTO @ResolvedLocations
			(
				LocationId
			)
			SELECT Location_Id
			FROM dbo.StockpileLocation
			WHERE Stockpile_Id = @StockpileId
		END
		IF @CrusherId IS NOT NULL
		BEGIN
			INSERT INTO @ResolvedLocations
			(
				LocationId
			)
			SELECT Location_Id
			FROM dbo.CrusherLocation
			WHERE Crusher_Id = @CrusherId
		END
		IF @MillId IS NOT NULL
		BEGIN
			INSERT INTO @ResolvedLocations
			(
				LocationId
			)
			SELECT Location_Id
			FROM dbo.MillLocation
			WHERE Mill_Id = @MillId
		END
		
		IF 
			(
				@iResolutionTarget = 'SOURCE' 
				AND EXISTS
					(
						SELECT TOP 1 1 
						FROM dbo.#SourceLocationTree
					)
			)
		BEGIN
			SET @LocationResolved = 0
			IF EXISTS 
				(
					SELECT TOP 1 1 
					FROM dbo.#SourceLocationTree AS t
						INNER JOIN @ResolvedLocations AS r
							ON t.Location_Id = r.LocationId
				)
			BEGIN
				SET @LocationResolved = 1
			END
		END
		ELSE IF
			(
				@iResolutionTarget = 'DESTINATION' 
				AND EXISTS
					(
						SELECT TOP 1 1 
						FROM dbo.#DestinationLocationTree
					)
			)
		BEGIN
			SET @LocationResolved = 0
			IF EXISTS
				(
					SELECT TOP 1 1 
					FROM dbo.#DestinationLocationTree AS t
						INNER JOIN @ResolvedLocations AS r
							ON t.Location_Id = r.LocationId
				)
			BEGIN
				SET @LocationResolved = 1
			END
		END
			
		-- write the results
		IF @iResolutionTarget = 'SOURCE'
		BEGIN
			
			INSERT INTO dbo.#ResolutionSource
			(
				Haulage_Resolve_Basic_Id, Digblock_Id, Stockpile_Id, Build_Id, Component_Id,
				Crusher_Id, Mill_Id, Ratio, Location_Resolved
			)
			SELECT @HaulageResolveBasicId, @DigblockId, @StockpileId, @BuildId, @ComponentId,
				@CrusherId, @MillId, 1.0, @LocationResolved
			WHERE @DigblockId IS NOT NULL
				OR @StockpileId IS NOT NULL
				OR @CrusherId IS NOT NULL
				OR @MillId IS NOT NULL
		END
		ELSE
		BEGIN
			INSERT INTO dbo.#ResolutionDestination
			(
				Haulage_Resolve_Basic_Id, Digblock_Id, Stockpile_Id, Build_Id, Component_Id,
				Crusher_Id, Mill_Id, Ratio, Location_Resolved
			)
			SELECT @HaulageResolveBasicId, @DigblockId, @StockpileId, @BuildId, @ComponentId,
				@CrusherId, @MillId, 1.0, @LocationResolved
			WHERE @DigblockId IS NOT NULL
				OR @StockpileId IS NOT NULL
				OR @CrusherId IS NOT NULL
				OR @MillId IS NOT NULL
		END
		
		SET @oResolved = @Resolved

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="HaulageRawResolveBasicResolve">
 <Procedure>
	Uses the basic resolution methods to resolve the record.
	This is achieved by the following steps:
	1. Attempt to map through HaulageResolveBasic (based on rules).
	2. Attempt to map directly to Digblock.
	3. Attempt to map directly to Stockpile.
	4. Attempt to map directly to Crusher.
	5. Attempt to map directly to Mill.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveSplitResolve.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveSplitResolve') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveSplitResolve  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveSplitResolve
(
	@iHaulageRawId INT,
	@iResolutionTarget VARCHAR(11),
	@oResolved BIT = 0 OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)		
	DECLARE @HaulageResolveSplitId INT
	DECLARE @CallFunction VARCHAR(255)
	DECLARE @CRLF CHAR(2)
	DECLARE @Code VARCHAR(63)
	DECLARE @Resolved BIT
	DECLARE @LocationResolved BIT
	DECLARE @CursorDigblock CURSOR
	DECLARE @DigblockId VARCHAR(31)
	DECLARE @ResolvedLocations TABLE
	(
		LocationId INT
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveSplitResolve',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- uses the basic resolution methods to resolve the record
		-- this is achieved by the following steps:
		-- 1. Attempt to map through HaulageResolveSplit (based on rules)

		-- iResolution_Target is either SOURCE or DESTINATION

		SET @LocationResolved = Null
		
		SET @CRLF = Char(10) + Char(13)

		-- determine the CODE we need to target
		IF @iResolutionTarget = 'SOURCE'
		BEGIN
			SELECT @Code = Source
			FROM dbo.HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId
		END
		ELSE
		BEGIN
			SELECT @Code = Destination
			FROM dbo.HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId
		END

		SET @Resolved = 0

		-- attempt to map through HaulageResolveSplit
		SET @HaulageResolveSplitId = Null

		SELECT @HaulageResolveSplitId = Haulage_Resolve_Split_Id
		FROM dbo.HaulageResolveSplit HRS
		WHERE Code = @Code
			AND EXISTS 
				(	
					SELECT 1
					FROM dbo.HaulageRaw
					WHERE Haulage_Raw_Id = @iHaulageRawId
						AND dbo.CompareDateShift(HRS.Resolve_From_Date, HRS.Resolve_From_Shift, '<=', Haulage_Date, Haulage_Shift) = 1
						AND
							(
								dbo.CompareDateShift(HRS.Resolve_To_Date, HRS.Resolve_To_Shift, '>=', Haulage_Date, Haulage_Shift) = 1
								OR HRS.Resolve_To_Date IS NULL
							)
				)

		IF @HaulageResolveSplitId IS NOT NULL
		BEGIN
			-- a mapping has been found
			-- determine the "Call Function" required to decode the split
			SELECT @CallFunction = Call_Function
			FROM dbo.HaulageResolveSplit HRS
				INNER JOIN dbo.HaulageResolveSplitType AS HRST
				ON (HRS.Haulage_Resolve_Split_Type_Id = HRST.Haulage_Resolve_Split_Type_Id)
			WHERE Haulage_Resolve_Split_Id = @HaulageResolveSplitId

			SET @CallFunction = @CallFunction + '(' + Convert(VARCHAR, @HaulageResolveSplitId) + ')'

			CREATE TABLE #CALL_FUNCTION_RESULT
			(
				Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
				Ratio FLOAT NOT NULL
			)

			EXEC (	'Insert Into #CALL_FUNCTION_RESULT' + @CRLF +
					'	(Digblock_Id, Ratio)' + @CRLF + 
					'Select Digblock_Id, Ratio' + @CRLF + 
					'From ' + @CallFunction)


			SET @CursorDigblock = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
			SELECT Digblock_Id
			FROM dbo.#CALL_FUNCTION_RESULT

			OPEN @CursorDigblock
			FETCH NEXT FROM @CursorDigblock INTO @DigblockId
			WHILE @@Fetch_Status = 0
			BEGIN
					
				--Assume code is a digblock and attempt to resolve.
				INSERT INTO @ResolvedLocations
				(
					LocationId
				)
				SELECT Location_Id
				FROM dbo.DigblockLocation
				WHERE Digblock_Id = @Code
				
				--If a location was specified for the haulage raw location
				--then run the location resolved check.
				IF EXISTS 
					(
						SELECT TOP 1 1 
						FROM dbo.#SourceLocationTree
					)
				BEGIN
					SET @LocationResolved = 0
					IF EXISTS
						(
							SELECT TOP 1 1 
							FROM dbo.#SourceLocationTree AS t
								INNER JOIN @ResolvedLocations AS r
									ON t.Location_Id = r.LocationId
						)
					BEGIN
						SET @LocationResolved = 1
					END
				END	
			
				IF @iResolutionTarget = 'SOURCE'
				BEGIN
					INSERT INTO dbo.#ResolutionSource
					(
						Haulage_Resolve_Split_Id, Digblock_Id, Stockpile_Id, Build_Id, Component_Id, Ratio, Location_Resolved
					)
					SELECT @HaulageResolveSplitId, Digblock_Id, Null, Null, Null, Ratio, @LocationResolved
					FROM dbo.#CALL_FUNCTION_RESULT
					ORDER BY Ratio, Digblock_Id DESC
				END
				ELSE
				BEGIN
					RAISERROR ('Error: Cannot split-resolve on destinations.', 16, 1)
				END

				FETCH NEXT FROM @CursorDigblock INTO @DigblockId
			END
			CLOSE @CursorDigblock
			
			DROP TABLE dbo.#CALL_FUNCTION_RESULT

			SET @Resolved = 1
		END

		SET @oResolved = @Resolved

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="HaulageRawResolveSplitResolve">
 <Procedure>
	Uses the basic resolution methods to resolve the record.
	This is achieved by the following steps:
	1. Attempt to map through HaulageResolveSplit (based on rules).
	Errors are raised if:
		Error: Cannot split-resolve on destinations.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveTruckResolve.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveTruckResolve') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveTruckResolve  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveTruckResolve 
(
	@iHaulageRawId Int,
	@oResolved Bit = 0 Output
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @TruckId VARCHAR(31)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveTruckResolve',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	

		SET @TruckId = NULL

		SELECT @TruckId = Truck_Id
		FROM dbo.Truck
		WHERE Truck_Id = 
			(	
				SELECT Truck
				FROM dbo.HaulageRaw
				WHERE Haulage_Raw_Id = @iHaulageRawId
			)

		IF @TruckId IS NULL
		BEGIN
			SET @oResolved = 0
		END
		ELSE
		BEGIN
			INSERT INTO dbo.#ResolutionTruck
			(
				Truck_Id
			)
			SELECT @TruckId
			SET @oResolved = 1
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="HaulageRawResolveTruckResolve">
 <Procedure>
	Resolve the truck, relies on the pre-existing table: #ResolutionTruck.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveValidate.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveValidate') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveValidate  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveValidate
(
	@iHaulageRawId INT,
	@oValidates BIT = 0 OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @HaulageDate DATETIME
	DECLARE @HaulageShift CHAR(1)
	DECLARE @Validates BIT
	DECLARE @IsDigblockActive BIT
	DECLARE @IsDigblockAutoActivate BIT
	DECLARE @Source CURSOR
	DECLARE @Destination CURSOR
	DECLARE @DigblockId VARCHAR(31)
	DECLARE @StockpileId INT
	DECLARE @BuildId INT
	DECLARE @ComponentId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveValidate',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		SELECT @HaulageDate = Haulage_Date,
			@HaulageShift = Haulage_Shift
		FROM dbo.HaulageRaw
		WHERE Haulage_Raw_Id = @iHaulageRawId

		SET @Validates = 1
		
		DELETE
		FROM dbo.HaulageRawError
		WHERE Haulage_Raw_Id = @iHaulageRawId
		
		IF EXISTS
			(
				SELECT 1 
				FROM dbo.#ResolutionSource 
				WHERE Location_Resolved = 0
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_SOURCE_LOCATION')
			SET @Validates = 0
		END
		
		IF EXISTS 
			(
				SELECT 1 
				FROM dbo.#ResolutionDestination 
				WHERE Location_Resolved = 0
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_DESTINATION_LOCATION')
			SET @Validates = 0
		END

		-- could we resolve the truck?
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.#ResolutionTruck
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_TRUCK')
			SET @Validates = 0
		END

		-- could we resolve the source?
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.#ResolutionSource
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_SOURCE')
			SET @Validates = 0
		END
		-- could we, based on the current limitations of the core, resolve the source?
		-- valid sources: stockpile_id, digblock_id
		ELSE IF EXISTS 
			(
				SELECT 1
				FROM dbo.#ResolutionSource
				WHERE Digblock_Id Is Null
					AND Stockpile_Id Is Null
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_SOURCE')
			SET @Validates = 0
		END
		
		-- could we resolve the destination?
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.#ResolutionDestination
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_DESTINATION')
			SET @Validates = 0
		END
		-- could we, based on the current limitations of the core, resolve the destination?
		-- valid destinations: stockpile_id, crusher_id
		ELSE IF EXISTS
			(
				SELECT 1
				FROM dbo.#ResolutionDestination
				WHERE Stockpile_Id IS NULL
					AND Crusher_Id IS NULL
			)
		BEGIN
			INSERT INTO dbo.HaulageRawError
				(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
			VALUES
				(@iHaulageRawId, 'INVALID_DESTINATION')
			SET @Validates = 0
		END

		-- perform the two checks:
		-- 1. is the digblock active?  are we able to automatically correct the date range on this digblock?
		-- 2. is the digblock involved in an approved pit depletion for this transaction?
		IF @Validates = 1
		BEGIN
			-- perform the checks for each digblock

			SET @Source = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
				SELECT Digblock_Id
				FROM dbo.#ResolutionSource
				WHERE Digblock_Id Is Not Null
				ORDER BY Digblock_Id

			OPEN @Source
			FETCH NEXT FROM @Source INTO @DigblockId
			WHILE @@Fetch_Status = 0 And @Validates = 1
			BEGIN
				SET @IsDigblockActive = dbo.IsDigblockActive(@DigblockId, @HaulageDate, @HaulageShift)
				SET @IsDigblockAutoActivate = 
					(
						SELECT Auto_Activate_Haulage
						FROM dbo.Digblock
						WHERE Digblock_Id = @DigblockId
					)
				IF 
					(
						@IsDigblockActive = 0 
						AND @IsDigblockAutoActivate = 0
					)
				BEGIN
					INSERT INTO dbo.HaulageRawError
						(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
					VALUES
						(@iHaulageRawId, 'INACTIVE_SOURCE')
					SET @Validates = 0
				END
							-- does the haulage record falls within an approved depletion period?
				IF @Validates = 1
				BEGIN
					IF dbo.IsInApprovedDigblockSurveyPeriod(@HaulageDate, @HaulageShift, @DigblockId) = 1
					BEGIN
						INSERT INTO dbo.HaulageRawError
							(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
						VALUES
							(@iHaulageRawId, 'APPROVED_DEPLETION_PERIOD')

						SET @Validates = 0
					END
				END

				FETCH NEXT FROM @Source INTO @DigblockId
			END
			CLOSE @Source
		END

		-- can the source stockpile build be hauled from for this date?
		IF @Validates = 1
		BEGIN
			SET @Destination = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
				SELECT Stockpile_Id, Build_Id, Component_Id
				FROM dbo.#ResolutionDestination
				WHERE Stockpile_Id Is Not Null
				ORDER BY Stockpile_Id, Build_Id, Component_Id

			OPEN @Destination
			FETCH NEXT FROM @Destination INTO @StockpileId, @BuildId, @ComponentId
			WHILE @@Fetch_Status = 0 and @Validates = 1
			BEGIN

				IF 
					(
						@BuildId IS NULL
						OR dbo.IsStockpileBuildBuildable(@StockpileId, @BuildId, @HaulageDate, @HaulageShift) = 0
					)
				BEGIN
					INSERT INTO dbo.HaulageRawError
						(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
					VALUES
						(@iHaulageRawId, 'DEST_STK_BUILD_NA')
					SET @Validates = 0
				END

				FETCH NEXT FROM @Destination INTO @StockpileId, @BuildId, @ComponentId
			END

			CLOSE @Destination
		END

		-- can the destination stockpile build be haulage to for this date?
		IF @Validates = 1
		BEGIN
			SET @Source = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
				SELECT Stockpile_Id, Build_Id, Component_Id
				FROM dbo.#ResolutionSource
				WHERE Stockpile_Id Is Not Null
				ORDER BY Stockpile_Id, Build_Id, Component_Id

			OPEN @Source
			FETCH NEXT FROM @Source INTO @StockpileId, @BuildId, @ComponentId
			WHILE @@Fetch_Status = 0 AND @Validates = 1
			BEGIN
				IF
					(
						@BuildId IS NULL
						OR dbo.IsStockpileBuildReclaimable(@StockpileId, @BuildId, @HaulageDate, @HaulageShift) = 0
					)
				BEGIN
					INSERT INTO dbo.HaulageRawError
						(Haulage_Raw_Id, Haulage_Raw_Error_Type_Id)
					VALUES
						(@iHaulageRawId, 'SOURCE_STK_BUILD_NA')
					SET @Validates = 0
				END

				FETCH NEXT FROM @Source INTO @StockpileId, @BuildId, @ComponentId
			END

			CLOSE @Source		
		END

		-- return the results
		SET @oValidates = @Validates

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="HaulageRawResolveValidate">
 <Procedure>
	Validation of the HaulageRawResolve.
	Could we resolve the truck?
	Could we resolve the source?
	Could we resolve the destination?
	Perform the two checks:
	1. Is the digblock active?  Are we able to automatically correct the date range on this digblock?
	2. Is the digblock involved in an approved pit depletion for this transaction?
	Can the source stockpile build be hauled from for this date?
	Can the destination stockpile build be haulage to for this date?
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolve.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolve') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolve  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolve
(
	@iHaulageRawId INT,
	@oIsResolved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here
	DECLARE @Validates BIT
	DECLARE @SourceResolved BIT
	DECLARE @DestinationResolved BIT
	DECLARE @TruckResolved BIT
	DECLARE @LocationId INT
	DECLARE @RatioSourceTotal FLOAT
	DECLARE @RatioSourceCount INT
	DECLARE @HaulageDate DATETIME
	DECLARE @HaulageShift CHAR(1)
	DECLARE @HaulageRawStateId CHAR(1)
	DECLARE @SourceLocationValid BIT
	DECLARE @DestinationLocationValid BIT


	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolve',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		-- code goes here
		SELECT @HaulageDate = Haulage_Date,
			@HaulageShift = Haulage_Shift,
			@HaulageRawStateId = Haulage_Raw_State_Id
		FROM dbo.HaulageRaw
		WHERE Haulage_Raw_Id = @iHaulageRawId

		-- set the default to failure
		SET @oIsResolved = 0

		IF @HaulageRawStateId IN ('A', 'E')
		BEGIN
			-- create temporary tables for the resolution routines
			CREATE TABLE dbo.#ResolutionSource
			(
				Haulage_Resolve_Basic_Id INT NULL,
				Haulage_Resolve_Split_Id INT NULL,
				Digblock_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Stockpile_Id INT NULL,
				Build_Id INT NULL,
				Component_Id INT NULL,
				Crusher_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Mill_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Ratio FLOAT NOT NULL,
				Location_Resolved BIT NULL
			)

			CREATE TABLE dbo.#ResolutionDestination
			(
				Haulage_Resolve_Basic_Id INT NULL,
				Haulage_Resolve_Split_Id INT NULL,
				Digblock_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Stockpile_Id INT NULL,
				Build_Id INT NULL,
				Component_Id INT NULL,
				Crusher_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Mill_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
				Ratio FLOAT NOT NULL,
				Location_Resolved BIT NULL
			)

			CREATE TABLE dbo.#ResolutionTruck
			(
				Truck_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NULL
			)
			
			CREATE TABLE dbo.#SourceLocationTree
			(
				Location_Id INT PRIMARY KEY CLUSTERED
			)
			
			CREATE TABLE dbo.#DestinationLocationTree
			(
				Location_Id INT PRIMARY KEY CLUSTERED
			)
			
			SET @LocationId =
				(
					Select SourceLocationId
					From dbo.HaulageRawLocation
					Where HaulageRawId = @iHaulageRawId		
				)
			
			IF @LocationId IS NOT NULL
			BEGIN
			INSERT INTO dbo.#SourceLocationTree
			(
				Location_Id
			)
			SELECT Location_Id
			FROM dbo.GetLocationSubtree(@LocationId)
			END
			
			SET @LocationId =
				(
					Select DestinationLocationId
					From dbo.HaulageRawLocation
					Where HaulageRawId = @iHaulageRawId		
				)
			
			IF @LocationId IS NOT NULL
			BEGIN
				INSERT INTO #DestinationLocationTree
				(
					Location_Id
				)
				SELECT Location_Id
				FROM GetLocationSubtree(@LocationId)
			END
			
			----------------------------------
			-- Source / Destination Resolution

			-- attempt a Source resolution
			EXEC dbo.HaulageRawResolveBasicResolve
				@iHaulageRawId = @iHaulageRawId,
				@iHaulageDate = @HaulageDate,
				@iHaulageShift = @HaulageShift,
				@iResolutionTarget = 'SOURCE',
				@oResolved = @SourceResolved OUTPUT

			EXEC dbo.HaulageRawResolveSplitResolve
				@iHaulageRawId = @iHaulageRawId,
				@iResolutionTarget = 'SOURCE',
				@oResolved = @SourceResolved OUTPUT
				
			-- attempt a Destination resolution
			EXEC dbo.HaulageRawResolveBasicResolve
				@iHaulageRawId = @iHaulageRawId,
				@iHaulageDate = @HaulageDate,
				@iHaulageShift = @HaulageShift,
				@iResolutionTarget = 'DESTINATION',
				@oResolved = @DestinationResolved OUTPUT

			-- attempt a Truck resolution
			EXEC dbo.HaulageRawResolveTruckResolve
				@iHaulageRawId = @iHaulageRawId,
				@oResolved = @TruckResolved OUTPUT

			-------------
			-- Validation

			EXEC dbo.HaulageRawResolveValidate
				@iHaulageRawId = @iHaulageRawId,
				@oValidates = @Validates OUTPUT

			-- if the record validates, perform the promotion
			-- otherwise, return indicating failure
			IF @Validates = 0
			BEGIN
				-- set the Haulage error state
				UPDATE dbo.HaulageRaw
				SET Haulage_Raw_State_Id = 'E'
				WHERE Haulage_Raw_Id = @iHaulageRawId

				SET @oIsResolved = 0
			END
			ELSE
			BEGIN
				-------------
				-- Resolution

				-- Record the HAULAGE_RESOLVE details
				INSERT INTO	dbo.HaulageRawResolution
					(Haulage_Raw_Id, Is_Source_Flag, Is_Destination_Flag, Haulage_Resolve_Split_Id, Haulage_Resolve_Basic_Id)
				SELECT DISTINCT @iHaulageRawId, 1, 0, Haulage_Resolve_Split_Id, Haulage_Resolve_Basic_Id
				FROM dbo.#ResolutionSource

				INSERT INTO dbo.HaulageRawResolution
					(Haulage_Raw_Id, Is_Source_Flag, Is_Destination_Flag, Haulage_Resolve_Split_Id, Haulage_Resolve_Basic_Id)
				SELECT DISTINCT @iHaulageRawId, 0, 1, Haulage_Resolve_Split_Id, Haulage_Resolve_Basic_Id
				FROM dbo.#ResolutionDestination

				-- remove existing records
				-- note: these records will only exist in invalid conditions where records have been added incorrectly
				-- usually due to people hacking!
				IF EXISTS
					(
						SELECT 1
						FROM dbo.Haulage
						WHERE Haulage_Raw_Id = @iHaulageRawId
					)
				BEGIN
					EXEC dbo.DeleteHaulageByHaulageRaw
						@iHaulage_Raw_Id = @iHaulageRawId
				END

				-- Create Haulage records
				SELECT @RatioSourceTotal = Sum(Ratio),
					@RatioSourceCount = Count(*)
				FROM dbo.#ResolutionSource

				INSERT INTO dbo.Haulage
				(
					Haulage_Date, Haulage_Shift,
					Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
					Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id,
					Source_Mill_Id,	Destination_Mill_Id,
					Tonnes,
					Loads,
					Truck_Id,
					Haulage_State_Id, Haulage_Raw_Id
				)
				SELECT hr.Haulage_Date, hr.Haulage_Shift,
					rs.Digblock_Id, rs.Stockpile_Id, rs.Build_Id, rs.Component_Id,
					rd.Stockpile_Id, rd.Build_Id, rd.Component_Id, rd.Crusher_Id,
					rs.Mill_Id, rd.Mill_Id,
					hr.Tonnes * (rs.Ratio / @RatioSourceTotal),
					hr.Loads * (rs.Ratio / @RatioSourceTotal),
					rt.Truck_Id,
					'N', @iHaulageRawId
				FROM dbo.HaulageRaw AS hr
					CROSS JOIN dbo.#ResolutionSource AS rs
					CROSS JOIN dbo.#ResolutionDestination AS rd
					CROSS JOIN dbo.#ResolutionTruck AS rt
				WHERE hr.Haulage_Raw_Id = @iHaulageRawId

				-- Create HaulageGrade records
				INSERT INTO dbo.HaulageGrade
					(Haulage_Id, Grade_Id, Grade_Value)
				SELECT h.Haulage_Id, hrg.Grade_Id, hrg.Grade_Value
				FROM dbo.Haulage AS h
					INNER JOIN dbo.HaulageRaw AS hr
						ON (h.Haulage_Raw_Id = hr.Haulage_Raw_Id)
					INNER JOIN HaulageRawGrade AS hrg
						ON (hr.Haulage_Raw_Id = hrg.Haulage_Raw_Id)
				WHERE hr.Haulage_Raw_Id = @iHaulageRawId
				ORDER BY hrg.Grade_Id

				-- Create HaulageValue records
				-- only insert values for fields that exist in both HaulageField and HaulageRawField
				INSERT INTO dbo.HaulageValue
					(Haulage_Id, Haulage_Field_Id, Field_Value)
				SELECT h.Haulage_Id, hrv.Haulage_Raw_Field_Id, hrv.Field_Value
				FROM dbo.Haulage AS h
					INNER JOIN dbo.HaulageRaw AS hr
						ON (h.Haulage_Raw_Id = hr.Haulage_Raw_Id)
					INNER JOIN dbo.HaulageRawValue AS hrv
						ON (hr.Haulage_Raw_Id = hrv.Haulage_Raw_Id)
				WHERE hr.Haulage_Raw_Id = @iHaulageRawId
					AND HRV.Haulage_Raw_Field_Id IN
						(
							SELECT Haulage_Raw_Field_Id
							FROM dbo.HaulageRawField AS hrf
								INNER JOIN dbo.HaulageField As hf
									ON (hrf.Haulage_Raw_Field_Id = hf.Haulage_Field_Id)
							WHERE hrf.Has_Value = 1
								AND hf.Has_Value = 1
						)
				ORDER BY hrv.Haulage_Raw_Field_Id

				-- Create HaulageNotes records
				-- only insert notes for fields that exist in both HaulageField and HaulageRawField
				INSERT INTO dbo.HaulageNotes
					(Haulage_Id, Haulage_Field_Id, Notes)
				SELECT H.Haulage_Id, HRN.Haulage_Raw_Field_Id, HRN.Notes
				FROM dbo.Haulage AS h
					INNER JOIN dbo.HaulageRaw AS hr
						ON (h.Haulage_Raw_Id = hr.Haulage_Raw_Id)
					INNER JOIN dbo.HaulageRawNotes AS hrn
						ON (hr.Haulage_Raw_Id = hrn.Haulage_Raw_Id)
				WHERE hr.Haulage_Raw_Id = @iHaulageRawId
					AND hrn.Haulage_Raw_Field_Id IN
						(
							SELECT Haulage_Raw_Field_Id
							FROM dbo.HaulageRawField AS hrf
								INNER JOIN dbo.HaulageField AS hf
									ON (hrf.Haulage_Raw_Field_Id = hf.Haulage_Field_Id)
							WHERE hrf.Has_Notes = 1
								AND hf.Has_Notes = 1
						)
				ORDER BY hrn.Haulage_Raw_Field_Id

				-- Activate the Block for Haulage
				-- (if the block is not active, but can be automatically activated)
				EXEC dbo.HaulageRawResolveActivateBlocks
					@iHaulageRawId = @iHaulageRawId

				-- Raise Level-1 Recalc & CVF
				EXEC dbo.RecalcL1Raise
					@pDate = @HaulageDate

				EXEC dbo.CalcVirtualFlowRaise
					@pCalc_Date = @HaulageDate

				-- set the record's status
				DELETE
				FROM dbo.HaulageRawError
				WHERE Haulage_Raw_Id = @iHaulageRawId

				UPDATE dbo.HaulageRaw
				SET Haulage_Raw_State_Id = 'C'
				WHERE Haulage_Raw_Id = @iHaulageRawId

				-- indicate success
				SET @oIsResolved = 1
			END

			-- clean up
			DROP TABLE dbo.#ResolutionSource
			DROP TABLE dbo.#ResolutionDestination
			DROP TABLE dbo.#ResolutionTruck
			DROP TABLE dbo.#SourceLocationTree
			DROP TABLE dbo.#DestinationLocationTree

		END		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END

	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.HaulageRawResolve TO CoreHaulageManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="HaulageRawResolve">
 <Procedure>
	Attempts to resolve a record from the HaulageRaw table to the Haulage table.
	Optionally returns whether the promotion was successful.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.HaulageRawResolveAll.prc'
GO

IF OBJECT_ID('dbo.HaulageRawResolveAll') IS NOT NULL
     DROP PROCEDURE dbo.HaulageRawResolveAll  
GO 
  
CREATE PROCEDURE dbo.HaulageRawResolveAll
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'HaulageRawResolveAll',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		
		INSERT INTO dbo.HaulageResolutionQueue
		(
			HaulageRawId
		)
		SELECT Haulage_Raw_Id
		FROM dbo.HaulageRaw AS hr
			LEFT JOIN dbo.HaulageResolutionQueue AS hrq
				ON hr.Haulage_Raw_Id = hrq.HaulageRawId
		WHERE Haulage_Raw_State_Id IN ('A','E')
			AND hrq.HaulageRawId IS NULL
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.HaulageRawResolveAll TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.HaulageRawResolveAll">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ActivateDigblock.prc'
GO

IF OBJECT_ID('dbo.ActivateDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.ActivateDigblock 
GO 
  
CREATE PROCEDURE dbo.ActivateDigblock 
( 
    @iDigblock_Id VARCHAR(31),
	@iStart_Date DATETIME = NULL,
	@iStart_Shift CHAR(1) = NULL, 
	@iHaulage_Raw_Resolve_All BIT = 1
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
	
	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'ActivateDigblock',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY
		--Check digblock is in the Reconcilor
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.Digblock AS D
				WHERE D.Digblock_Id = @iDigblock_Id
			)
		BEGIN
			Raiserror ('The digblock does not exist', 16, 1)
		END

		--Get Start and End Dates
		--Default start date to todays date if none is provided
		--Default start shift to first shift if none is provided
		SELECT @StartDate = dbo.GetDateDay(Coalesce(@iStart_Date, getdate())),
			@StartShift = Coalesce(@iStart_Shift, dbo.GetFirstShiftType()),
			@EndDate = D.End_Date
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id 

		--Check haulage so that we dont recreate haulage errors
		IF EXISTS
		(
			SELECT 1
			FROM dbo.Haulage AS H
				INNER JOIN dbo.ShiftType AS HST
					ON (H.Haulage_Shift = HST.Shift)
			WHERE H.Source_Digblock_Id = @iDigblock_Id
				AND dbo.GetDateShiftAsInt(H.Haulage_Date, HST.Order_No) < 
					dbo.GetDateShiftAsInt(@StartDate, dbo.GetShiftTypeOrderNo(@StartShift))
		)
		BEGIN
			Raiserror ('There are haulage records for this digblock before the given start date', 16, 1)
		END

		--If block was closed reopen it
		IF @EndDate IS NOT NULL
		BEGIN
			UPDATE D
			SET End_Date = NULL,
				End_Shift = NULL
			FROM dbo.Digblock AS D
			WHERE D.Digblock_Id = @iDigblock_Id
		END

		UPDATE D
		SET	Start_Date = @StartDate,
			Start_Shift = @StartShift
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id
		
		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXEC dbo.HaulageRawResolveAll
		END

		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.ActivateDigblock TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="ActivateDigblock">
 <Procedure>
	Activates a Digblock by setting the Start_Date and Start_Shift values in the Digblock table.
	If the Digblock was previously closed the End_Date and End_Shift are removed from the Digblock table.
	If the start date is not provided then it will default to todays date. If the start shift is not provided
	it will default to the first shift.
	
	Errors are raised if 	
		The specified digblock does not exist 
		There is haulage associated with the digblock before the specified start date and shift
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.CloseDigblock.prc'
GO

IF OBJECT_ID('dbo.CloseDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.CloseDigblock 
GO 
  
CREATE PROCEDURE dbo.CloseDigblock 
( 
    @iDigblock_Id VARCHAR(31),
	@iClose_Date DATETIME,
	@iClose_Shift CHAR(1) = null,
	@iHaulage_Raw_Resolve_All BIT = 1,
	@iAuto_Open_Digblock BIT = 0 
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1) 
		
	SELECT @TransactionName = 'CloseDigblock',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END 
	
    BEGIN TRY
		--Check digblock is in the Reconcilor
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.Digblock AS D
				WHERE D.Digblock_Id = @iDigblock_Id
			)
		BEGIN
			Raiserror ('The digblock does not exist', 16, 1)
		END

		--Get Start and end Dates
		--Default end date to todays date if none is provided
		--Default end shift to last shift if none is provided
		SELECT @StartDate = D.Start_Date,
			@StartShift = D.Start_Shift,
			@EndDate = dbo.GetDateDay(Coalesce(@iClose_Date, getDate())),
			@EndShift = Coalesce(@iClose_Shift, dbo.GetLastShiftType())
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id 

		IF @iAuto_Open_Digblock = 0 AND @StartDate IS NULL
		BEGIN
			Raiserror ('The digblock has not been activated.', 16, 1)
		END
		ELSE IF @StartDate IS NULL
		BEGIN
			--Default to shift prior
			EXEC dbo.GetPreviousDateShift	
				@Date = @iClose_Date,
				@Shift = @iClose_Shift,
				@Previous_Date = @StartDate OUTPUT,
				@Previous_Shift = @StartShift OUTPUT
		
			--Open the block
			EXEC dbo.ActivateDigblock
				@iDigblock_Id = @iDigblock_Id,
				@iStart_Date = @StartDate,
				@iStart_Shift = @StartShift,
				@iHaulage_Raw_Resolve_All = 0
		END

		IF dbo.GetDateShiftAsInt(@EndDate, dbo.GetShiftTypeOrderNo(@EndShift)) <=
			dbo.GetDateShiftAsInt(@StartDate, dbo.GetShiftTypeOrderNo(@StartShift))
		BEGIN
			Raiserror ('The digblock can not be closed before or on it''s activation date.', 16, 1)		
		END

		--Check haulage so that we dont recreate haulage errors
		IF EXISTS
		(
			SELECT 1
			FROM dbo.Haulage AS H
				INNER JOIN dbo.ShiftType AS HST
					ON (H.Haulage_Shift = HST.Shift)
			WHERE H.Source_Digblock_Id = @iDigblock_Id
				AND dbo.GetDateShiftAsInt(H.Haulage_Date, HST.Order_No) > 
					dbo.GetDateShiftAsInt(@EndDate, dbo.GetShiftTypeOrderNo(@EndShift))
		)
		BEGIN
			Raiserror ('There are haulage records for this digblock after the given end date', 16, 1)
		END

		--Check DSA so that any reallocations arent going to be void
		IF EXISTS
		(
			SELECT 1
			FROM dbo.DigblockSurveyActual AS DSA
				INNER JOIN dbo.DigblockSurvey As DS 
					ON (DSA.Digblock_Survey_Id = DS.Digblock_Survey_Id)
				INNER JOIN dbo.ShiftType AS ST
					ON (DS.Digblock_Survey_Shift = ST.Shift)
			WHERE DSA.Assigned_Digblock_Id = @iDigblock_Id
				AND dbo.GetDateShiftAsInt(DS.Digblock_Survey_Date, ST.Order_No) >
					dbo.GetDateShiftAsInt(@EndDate, dbo.GetShiftTypeOrderNo(@EndShift))
				AND DS.Is_Approved = 1
		)
		BEGIN
			Raiserror ('There are haulage records reassigned for this digblock after the given end date', 16, 1)
		END

		UPDATE D
		SET End_Date = @EndDate,
			End_Shift = @EndShift
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id
	
		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXEC dbo.HaulageRawResolveAll
		END

		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.CloseDigblock TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="CloseDigblock">
 <Procedure>
	Activates a Digblock by setting the End_Date and End_Shift values in the Digblock table.
	If @iAuto_Open_Digblock is set to true and the block has not yet been opened, the digblock will be
	activated for the previous shift for the dates provided.
	If the end date is not provided then it will default to todays date. If the end shift is not provided
	it will default to the end shift.	

	Errors are raised if 	
		The specified digblock does not exist 
		There is haulage associated with the digblock after the specified end date and shift
		There are haulage records reassigned for this digblock before the given end date
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.CorrectDigblockDateRange.prc'
GO

IF OBJECT_ID('dbo.CorrectDigblockDateRange') IS NOT NULL 
     DROP PROCEDURE dbo.CorrectDigblockDateRange 
GO 
  
CREATE PROCEDURE dbo.CorrectDigblockDateRange 
( 
    @iDigblock_Id VARCHAR(31),
	@iDate DATETIME,
	@iShift CHAR(1),
	@iHaulage_Raw_Resolve_All BIT = 1 
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @StartDate DATETIME
	DECLARE @StartShiftOrderNo INT
	DECLARE @EndDate DATETIME
	DECLARE @EndShiftOrderNo INT
	DECLARE @ShiftOrderNo INT

	SELECT @TransactionName = 'CorrectDigblockDateRange',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.Digblock AS D
				WHERE D.Digblock_Id = @iDigblock_Id
			)
		BEGIN
			Raiserror('The given digblock does not exist', 16, 1)	
		END

		SELECT @StartDate = Start_Date, @StartShiftOrderNo = dbo.GetShiftTypeOrderNo(Start_Shift),
			@EndDate = End_Date, @EndShiftOrderNo = dbo.GetShiftTypeOrderNo(End_Shift),
			@ShiftOrderNo = dbo.GetShiftTypeOrderNo(@iShift) 
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id

		--Activate digblock for this records date shift, if it has not been activated yet
		--or it was activated after this records date shift.
		IF @StartDate IS NULL 
			OR dbo.GetDateShiftAsInt(@StartDate, @StartShiftOrderNo) > 
				dbo.GetDateShiftAsInt(@iDate, @ShiftOrderNo)
		BEGIN
			EXEC dbo.ActivateDigblock	
				@iDigblock_Id = @iDigblock_Id,
				@iStart_Date = @iDate,
				@iStart_Shift = @iShift,
				@iHaulage_Raw_Resolve_All = 0
		END

		--If the digblock has been closed and it is earlier than 
		--the record's date then shift the end date
		IF @EndDate IS NOT NULL
			AND dbo.GetDateShiftAsInt(@EndDate, @EndShiftOrderNo) < 
				dbo.GetDateShiftAsInt(@iDate, @ShiftOrderNo)
		BEGIN
			EXEC CloseDigblock	
				@iDigblock_Id = @iDigblock_Id,
				@iClose_Date = @iDate,
				@iClose_Shift = @iShift,
				@iHaulage_Raw_Resolve_All = 0,
				@iAuto_Open_Digblock = 1
		END

		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXEC dbo.HaulageRawResolveAll
		END

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH		
END 
GO 

/*
<TAG Name="Data Dictionary" ProcedureName="CorrectDigblockDateRange">
 <Procedure>
	Updates the dates that the @Digblock_Id is active to ensure that it is active on the specified date and shift.
	ActivateDigblock is called if the Start date and shift has to be modified.
	CloseDigblock procedure is called if the End date and shift has to be modified.
	Errors are raised if:
		The digblock does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockSurvey.prc'
GO

If Object_Id('dbo.AddDigblockSurvey') Is Not Null 
     Drop Procedure dbo.AddDigblockSurvey 
Go 

Create Procedure dbo.AddDigblockSurvey
(
	@iDigblock_Survey_Date Datetime,
	@iDigblock_Survey_Shift Char(1) = Null,
	@iAdjust_Haulage Bit = 1,
	@iInclude_Previous_Digblocks Bit = 0,
	@iDigblock_Survey_Type_Id Int = Null,
	@iIs_Entire_Digblock Bit = 0,
	@oDigblock_Survey_Id Int = Null Output
)

With Encryption 
As

Begin
	Set Nocount On
	
	Declare @Count Int
	Declare @Digblock_Survey_Type_Id Int

	--If a digblock survey type was not given
	If (@iDigblock_Survey_Type_Id Is Null)
	Begin
		-- If there is only one available
		If ((Select Count(*) From DigblockSurveyType Where Is_Depletion_Process_Default = 1) = 1)
		Begin
			-- Use that one
			Select @Digblock_Survey_Type_Id	= Digblock_Survey_Type_Id
			From DigblockSurveyType
			Where Is_Depletion_Process_Default = 1
		End
		Else
		Begin
			-- Otherwise, throw an error
			Raiserror ('A valid digblock survey type was not specified', 16, 1)
			Return
		End
	End
	Else
	Begin
		Set @Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id
	End

	Set @iDigblock_Survey_Date = dbo.GetDateDay (@iDigblock_Survey_Date)

	-- If the shift is not given, use the last shift for the day by default
	If (@iDigblock_Survey_Shift Is Null)
	Begin
		Set @iDigblock_Survey_Shift = dbo.GetLastShiftType()
	End

	-- If the digblock survey is not in the database
	If (dbo.DoesDigblockSurveyExist (@iDigblock_Survey_Date, @iDigblock_Survey_Shift, @Digblock_Survey_Type_Id) = 0)
	Begin
		Select @Count = Count(*)
		From DigblockSurvey
		Where Is_Approved = 1
			And Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id
			And ((Digblock_Survey_Date > @iDigblock_Survey_Date)
			Or (Digblock_Survey_Date = @iDigblock_Survey_Date
			And dbo.GetShiftTypeOrderNo(Digblock_Survey_Shift) > dbo.GetShiftTypeOrderNo(@iDigblock_Survey_Shift)))

		-- If the digblock survey does not fall before a digblock survey which is already approved
		If (@Count = 0)
		Begin
			-- Create it in the database
			Insert Into DigblockSurvey
			(
				Digblock_Survey_Date, Digblock_Survey_Shift, Digblock_Survey_Type_Id,
				Is_Approved, Is_Processing, Adjust_Haulage,
				Include_Previous_Digblocks, Is_Entire_Digblock
			)
			Values
			(
				@iDigblock_Survey_Date, @iDigblock_Survey_Shift, @Digblock_Survey_Type_Id,
				0, 0, @iAdjust_Haulage,
				@iInclude_Previous_Digblocks, @iIs_Entire_Digblock
			)

			Set @oDigblock_Survey_Id = Scope_Identity()
		End
		Else
		Begin
			Raiserror ('An approved digblock survey exists after this date and shift', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('A digblock survey already exists for this date, shift and type', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.AddDigblockSurvey TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblockSurvey">
 <Procedure>
	Adds a record into the DigblockSurvey table.
	If Digblock_Survey_Type is not specified and there is only 1 Digblock_Survey_Type in the DigblockSurveyType
	table, then this value is used.
	The Digblock_Survey_Date is modified to removed the time component.
	Errors are raised if:
		An approved digblock survey exists after this date and shift
		A digblock survey already exists for this date and shift
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblock.prc'
GO

If Object_Id('dbo.AddDigblock') Is Not Null 
     Drop Procedure dbo.AddDigblock 
Go 
  
Create Procedure dbo.AddDigblock 
( 
	@iDigblock_Id Varchar(31),
	@iDescription Varchar(63) = Null,
	@iMaterial_Type_Id Int,
	@iCreation_Datetime DateTime = Null,
	@iStart_Date DateTime = Null,
	@iStart_Shift Char(1) = Null,
	@iIs_In_Pit_Depletion Bit = 1,
	@iIs_Visible Bit = 1,
	@iStart_Tonnes Float,
	@iX Float = Null,
	@iY Float = Null,
	@iZ Float = Null,
	@iNotes Varchar(1023) = Null,
	@iAuto_Activate_Haulage Bit = 0,
	@iHaulage_Raw_Resolve_All Bit = 1,
	@iAuto_Validate_Depletion_Tonnes Bit = 0,
	@iBlast_Block_Id Int = Null,
	@iEnd_Date DateTime = Null,
	@iEnd_Shift Char(1) = Null
) 
With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		Declare @Count Int
		Declare @Exists Bit
		Declare @Is_Approved Bit
		Declare @AllowZeroTonnes VARCHAR(7)

		Set @iStart_Date = dbo.GetDateDay (@iStart_Date)

		/* Clean up the date/shift pairs */
		If ((@iStart_Date Is Null) And (@iStart_Shift Is Not Null))
		Begin
			Select @iStart_Date = Null
		End

		If (@iStart_Date Is Null)
		Begin
			Select @iStart_Shift = Null
		End
		Else
		Begin
			If (@iStart_Shift Is Null)
			Begin
				Select @iStart_Shift = dbo.GetFirstShiftType ()
			End
		End
		
				
		-- Default to false for backward compat
		Set @AllowZeroTonnes  = 'FALSE'
		
		Select @AllowZeroTonnes = Value
		From dbo.Setting
		Where Setting_Id = 'ALLOW_ZERO_TONNE_DIGBLOCKS'
		
		IF IsNull(@iStart_Tonnes, 0) <= 0 And @AllowZeroTonnes = 'FALSE'
		BEGIN
			Raiserror ('The start tonnes must be greater than 0.', 16, 1)	
		END

		/* If a digblock with this name does not already exist */
		If (dbo.DoesDigblockExist (@iDigblock_Id) = 0)
		Begin
			/* If the material type exists */
			If (dbo.DoesMaterialTypeExist (@iMaterial_Type_Id) = 1)
			Begin
				/* If for both shifts, each is either null or valid */
				If (@iStart_Shift Is Null Or (dbo.DoesShiftTypeExist (@iStart_Shift) = 1))
				Begin
					/* If the digblock start date does not fall in an approved month */
					If ((dbo.IsInApprovedMonth (@iStart_Date) = 0) Or (@iStart_Date Is Null))
					Begin
						/* Insert a new digblock record */
						Insert Into Digblock
						(
							Digblock_Id, Description, Notes, Material_Type_Id,
							Creation_Datetime, Start_Date, Start_Shift,End_Date,End_Shift, X, Y, Z,
							Auto_Activate_Haulage, Auto_Validate_Depletion_Tonnes,
							Is_In_Pit_Depletion, Is_Visible, Start_Tonnes, Blast_Block_Id
						)
						Values
						(
							@iDigblock_Id, @iDescription, @iNotes, @iMaterial_Type_Id,
							Coalesce(@iCreation_Datetime, GetDate()), @iStart_Date, @iStart_Shift,@iEnd_Date,@iEnd_Shift, @iX, @iY, @iZ,
							@iAuto_Activate_Haulage, @iAuto_Validate_Depletion_Tonnes,
							@iIs_In_Pit_Depletion, @iIs_Visible, @iStart_Tonnes, @iBlast_Block_Id
						)
						
						/* Correct any related haulage errors */
						If @iHaulage_Raw_Resolve_All = 1
							Exec dbo.HaulageRawResolveAll
					End
					Else
					Begin
						Raiserror ('The start date of the digblock falls in an approved month', 16, 1)
					End
				End
				Else
				Begin
					Raiserror ('The shift(s) given are not valid', 16, 1)
				End
			End
			Else
			Begin
				Raiserror ('The Material Type does not exist', 16, 1)
			End
		End
		Else
		Begin
			Raiserror ('A Digblock with that ID already exists', 16, 1)
		End 
  
    Commit Transaction 
End 
Go		
GRANT EXECUTE ON dbo.AddDigblock TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblock">
 <Procedure>
	Adds a record into the Digblock table, raises a Recalc record and optionally resolves Haulage errors.
	Errors are raised if:
		The Digblock already exists
		The specified Material Type does not exist
		The Shift(s) given are not valid
		The start date of the digblock falls in an approved month
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockPolygon.prc'
GO

If object_id('dbo.AddDigblockPolygon') is Not NULL
	Drop Procedure dbo.AddDigblockPolygon
Go

Create Procedure dbo.AddDigblockPolygon
(
	@iDigblock_Id VarChar(31),
	@iX Float,
	@iY Float,
	@iZ Float,
	@iOrder_No Int,
	@iIs_Final Int = 0
)
/*--------------------------------------------------------
--	Written By:		Jennifer Claughton
--	Created Date:	22-June-2007
--
--	Description: 
--		Add a new Digblock polygon point
--		Checking:
--			That the Digblock_Id exists
--			That the order_no is for the Digblock_Polygon 
--				is not already entered
----------------------------------------------------------*/
With Encryption 
As

Begin

	Set NoCount On

	Declare @Found bit
	Declare @Digblock_Id Varchar(31)
	Declare @Range Int

	Create Table #FOUND_DIGBLOCK
	(
		Digblock_Id VarChar(31)
	)

	--Check that the Digblock Exists
	If Not Exists (Select 1 from Digblock Where Digblock_Id = @iDigblock_Id)
	Begin
		Raiserror ('The Digblock does not exist', 16, 1)
	End
	Else
	Begin
		--Check that the Order_No for that Digblock does not already exist
		If Exists (Select 1 
				   From DigblockPolygon DP
				   Where DP.Digblock_Id = @iDigblock_Id 
						And DP.Order_No = @iOrder_No)
		Begin
			Raiserror ('A Digblock Polygon with this Order No already exists', 16, 1)
		End
		Else
		Begin
			--If point is Valid add it to DigblockPolygon
			Insert Into DigblockPolygon
			(
				Digblock_Id, Order_No, X, Y, Z
			)
			Select @iDigblock_Id, @iOrder_No, @iX, @iY, @iZ
		End
	End
End
Go
GRANT EXECUTE ON dbo.AddDigblockPolygon TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblockPolygon">
 <Procedure>
	Adds a record into the DigblockPolygon table.
	Errors are raised if:
		A Digblock Polygon with this Order No already exists
		The Digblock does
 not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetPreviousDigblockSurveyDate.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPreviousDigblockSurveyDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetPreviousDigblockSurveyDate]
Go

Create Procedure [dbo].[GetPreviousDigblockSurveyDate]

(
	@Survey_Date Datetime,
	@Survey_Shift Char(1),
	@Digblock_Survey_Type_Id Int = Null,
	@Previous_Survey_Date Datetime Output,
	@Previous_Survey_Shift Char(1) Output
)

With Encryption As

	Set Nocount On

	/* If a digblock survey type was not given */
	If (@Digblock_Survey_Type_Id Is Null)
	Begin
		/* If there is only one available */
		If ((Select Count(*) From DigblockSurveyType Where Is_Depletion_Process_Default = 1) = 1)
		Begin
			/* Use that one */
			Select @Digblock_Survey_Type_Id = Digblock_Survey_Type_Id
			From DigblockSurveyType
			Where Is_Depletion_Process_Default = 1
		End
	End

	Select @Previous_Survey_Date = Null

	/* Get the last survey date before the given survey date and shift */
	Select Distinct @Previous_Survey_Date = S1.Digblock_Survey_Date,
	 @Previous_Survey_Shift = S1.Digblock_Survey_Shift
	From DigblockSurvey S1
	Where S1.Digblock_Survey_Date = 	(Select Max(S2.Digblock_Survey_Date)
						From DigblockSurvey S2
						Where (S2.Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id Or @Digblock_Survey_Type_Id Is Null)
						And ((S2.Digblock_Survey_Date < @Survey_Date)
						Or (S2.Digblock_Survey_Date = @Survey_Date)
						And (dbo.GetShiftTypeOrderNo(S2.Digblock_Survey_Shift) < dbo.GetShiftTypeOrderNo(@Survey_Shift))))
	And S1.Digblock_Survey_Shift = 		(Select Max(S2.Digblock_Survey_Shift)
						From DigblockSurvey S2
						Where S2.Digblock_Survey_Date = 	(Select Max(S3.Digblock_Survey_Date)
											From DigblockSurvey S3
											Where (S3.Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id Or @Digblock_Survey_Type_Id Is Null)
											And ((S3.Digblock_Survey_Date < @Survey_Date)
											Or (S3.Digblock_Survey_Date = @Survey_Date)
											And (dbo.GetShiftTypeOrderNo(S3.Digblock_Survey_Shift) < dbo.GetShiftTypeOrderNo(@Survey_Shift))))
						And (S2.Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id Or @Digblock_Survey_Type_Id Is Null)
						And ((S2.Digblock_Survey_Date < @Survey_Date)
						Or (S2.Digblock_Survey_Date = @Survey_Date)
						And (dbo.GetShiftTypeOrderNo(S2.Digblock_Survey_Shift) < dbo.GetShiftTypeOrderNo(@Survey_Shift))))



	/* If one was not found */
	If (@Previous_Survey_Date Is Null)
	Begin
		/* Get the day before the earliest haulage record */
		Select @Previous_Survey_Date = Dateadd(day, -1, Min(Haulage_Date))
		From Haulage

		Select @Previous_Survey_Shift = dbo.GetLastShiftType ()
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetPreviousDigblockSurveyDate">
 <Procedure>
	Returns the previous digblock survey date.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockSurveyActual.prc'
GO

IF OBJECT_ID('dbo.AddDigblockSurveyActual') IS NOT NULL 
     DROP PROCEDURE dbo.AddDigblockSurveyActual 
GO 
  
CREATE PROCEDURE dbo.AddDigblockSurveyActual 
( 
    @iDigblock_Survey_Summary_Id INT,
	@iTonnes FLOAT,
	@iDescription VARCHAR(63),
	@iIs_Rill BIT = 0,
	@iAssigned_Digblock_Id VARCHAR(31),
	@oDigblock_Survey_Actual_Id INT = NULL OUTPUT 
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
	DECLARE @Digblock_Survey_Date Datetime,
		@Digblock_Survey_Shift CHAR(1),
		@Digblock_Survey_Type_Id INT,
		@Prev_Survey_Date DATETIME,
		@Prev_Survey_Shift CHAR(1),
		@Digblock_Id VARCHAR(31),
		@EXISTS BIT,
		@Is_Active BIT,
		@Haulage_Date DATETIME,
		@Haulage_Shift CHAR(1),
		@Error_Description VARCHAR(63),
		@Total_Assigned_Tonnes FLOAT,
		@Digblock_Tonnes FLOAT,
		@Auto_Validate_Depletion_Tonnes BIT,
		@Error_Message VARCHAR(1023),
		@Digblock_Survey_Id INT

	DECLARE @HaulageDates TABLE	
	(
		Haulage_Date Datetime,
		Haulage_Shift CHAR(1),
		Order_No INT
	)

	BEGIN TRY
		-- Get the details of the digblock survey summary record
		SELECT @Digblock_Survey_Id = DS.Digblock_Survey_Id,
			@Digblock_Id = DS.Digblock_Id
		FROM dbo.DigblockSurveySummary AS DS
		WHERE DS.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

		-- Get the details of the digblock survey record
		SELECT @Digblock_Survey_Date = Digblock_Survey_Date,
			@Digblock_Survey_Shift = Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id
		FROM dbo.DigblockSurvey
		WHERE Digblock_Survey_Id = @Digblock_Survey_Id
	
		--Get Assigned Digblock Details
		SELECT @Digblock_Tonnes = D.Start_Tonnes,
			@Auto_Validate_Depletion_Tonnes = D.Auto_Validate_Depletion_Tonnes
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iAssigned_Digblock_Id

		-- If the record does not exists
		IF @Digblock_Id IS NULL
		BEGIN
			Raiserror ('The related digblock survey summary record does not exist', 16, 1)
		END

		-- If the tonnes of the actual record are not ok
		IF @iTonnes <= 0
		BEGIN
			Raiserror ('The tonnes must be greater than zero', 16, 1)
		END

		IF dbo.DoesDigblockExist(@iAssigned_Digblock_Id) <> 1
		BEGIN
			Raiserror ('The assigned digblock does not exist', 16, 1)
		END

		-- If the assigned digblock already has a record for this DigblockSurveySummary record
		IF EXISTS
			(
				SELECT 1
				FROM dbo.DigblockSurveyActual
				WHERE Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
					AND Assigned_Digblock_Id = @iAssigned_Digblock_Id
			)
		BEGIN
			Raiserror ('The assigned digblock has already been assigned to this digblock in this depletion period', 16, 1)
		END
	
		-- Get the details of the last survey date
		EXEC dbo.GetPreviousDigblockSurveyDate
			@Survey_Date = @Digblock_Survey_Date,
			@Survey_Shift = @Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id,
			@Previous_Survey_Date = @Prev_Survey_Date OUTPUT,
			@Previous_Survey_Shift = @Prev_Survey_Shift OUTPUT

		-- If the new assigned digblock is active on all the haulage dates for which it will have
		-- haulage records assigned to it at the end of this process
		INSERT @HaulageDates
		(
			Haulage_Date, Haulage_Shift, Order_No
		)
		SELECT H.Haulage_Date, H.Haulage_Shift, ST.Order_No
		FROM dbo.Haulage AS H
			INNER JOIN dbo.ShiftType AS ST
				ON (H.Haulage_Shift = ST.Shift)
			INNER JOIN dbo.Digblock AS D
				ON (H.Source_Digblock_Id = D.Digblock_Id)
		WHERE H.Source_Digblock_Id = @Digblock_Id
			AND H.Haulage_State_Id = 'N'
			AND H.Child_Haulage_Id IS NULL
			AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
				>= dbo.GetDateShiftAsInt(@Prev_Survey_Date, dbo.GetShiftTypeOrderNo(@Prev_Survey_Shift))
			AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
				<= dbo.GetDateShiftAsInt(@Digblock_Survey_Date, dbo.GetShiftTypeOrderNo(@Digblock_Survey_Shift))
		GROUP BY H.Haulage_Date, H.Haulage_Shift, ST.Order_No
	
		IF EXISTS
		(
			SELECT 1
			FROM @HaulageDates AS HD
				INNER JOIN dbo.Digblock AS D
					ON (D.Digblock_Id = @iAssigned_Digblock_Id)
				INNER JOIN dbo.ShiftType AS ST
					ON (D.Start_Shift = ST.Shift)
			WHERE (D.Start_Date IS NULL
					OR (D.Start_Date IS NOT NULL
						AND dbo.GetDateShiftAsInt(HD.Haulage_Date, HD.Order_No)
						< dbo.GetDateShiftAsInt(D.Start_Date, ST.Order_No)))
			UNION
			SELECT 1
			FROM @HaulageDates AS HD
				INNER JOIN dbo.Digblock AS D
					ON (D.Digblock_Id = @iAssigned_Digblock_Id)
				INNER JOIN dbo.ShiftType AS ST
					ON (D.End_Shift = ST.Shift)
			WHERE D.End_Date IS NOT NULL
				AND dbo.GetDateShiftAsInt(HD.Haulage_Date, HD.Order_No)
					> dbo.GetDateShiftAsInt(D.End_Date, ST.Order_No)		
		)
		BEGIN
			Raiserror ('The assigned digblock is not active on one or more of the haulage dates', 16, 1)
		END

		-- If the flag to automatically validate total depleted tonnes for the digblock is set to true
		IF (@Auto_Validate_Depletion_Tonnes = 1)
		BEGIN
			-- Also get the total tonnes depleted FROM the assigned digblock so far
			-- according to the manually entered depletion records
			SELECT @Total_Assigned_Tonnes = Sum(Tonnes)
			FROM dbo.DigblockSurveyActual
			WHERE Assigned_Digblock_Id = @iAssigned_Digblock_Id

			SET @Total_Assigned_Tonnes = Coalesce(@Total_Assigned_Tonnes, 0)

			-- IF the current total depleted tonnes for the assigned digblock plus this new value
			--  exceed the tonnes given BY grade control
			IF (@Total_Assigned_Tonnes + @iTonnes > @Digblock_Tonnes)
			BEGIN
				SET @Error_Message = 'Adding this record would cause total approved depleted tonnes to exceed grade control tonnes BY '
					+ Cast(Round(@Total_Assigned_Tonnes + @iTonnes - @Digblock_Tonnes, 0) AS VARCHAR) + ' tonnes'

				Raiserror (@Error_Message, 16, 1)
			END
		END	

		-- INSERT the new record into the digblock survey actual table
		INSERT INTO dbo.DigblockSurveyActual
		(
			Digblock_Survey_Id, Digblock_Id,
			Tonnes, Description, Is_Rill, Assigned_Digblock_Id,
			Digblock_Survey_Summary_Id
		)
		SELECT @Digblock_Survey_Id, @Digblock_Id,
			@iTonnes, @iDescription, @iIs_Rill, @iAssigned_Digblock_Id,
			@iDigblock_Survey_Summary_Id

		SET @oDigblock_Survey_Actual_Id = Scope_Identity()

		--If block is not in the summary table add it
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.DigblockSurveySummary	
				WHERE Digblock_Survey_Id = @Digblock_Survey_Id
					AND Digblock_Id = @iAssigned_Digblock_Id
			)
		BEGIN
			EXEC dbo.AddDigblockSurveySummary
				@iDigblock_Survey_Id = @Digblock_Survey_Id,
				@iDigblock_Id = @iAssigned_Digblock_Id,
				@iHaulage_Tonnes = 0,
				@iSurvey_Tonnes = 0,
				@iDigblock_Approved_Removed_Tonnes = 0,
				@iDigblock_Unapproved_Removed_Tonnes = 0
		END
		
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	 
END 
GO 
GRANT EXECUTE ON dbo.AddDigblockSurveyActual TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblockSurveyActual">
 <Procedure>
	Adds a record to the DigblockSurveyActual table. 
	Checks are performed to determine that the assigned digblock is active on all dates 
	when there are haulage records associated with the Digblock record specified in the 
	DigblockSurveySummary table
	Errors are raised if:
		Adding this record would cause total approved depleted tonnes to exceed grade control tonnes
		The assigned digblock is not active on one or more of the haulage dates
		The assigned digblock does not exist
		The tonnes are not greater than zero
		The related digblock survey summary record does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDrill.prc'
GO

If Object_Id('dbo.AddDrill') Is Not Null 
     Drop Procedure dbo.AddDrill 
Go 

Create Procedure dbo.AddDrill
(
	@iDrill_Id Varchar(31),
	@iDescription Varchar(255) = Null
)

With Encryption 
As

Begin
	Set Nocount On
	
	Declare @Count Int
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the drill exists */
	Select @Count = Count(*)
	From Drill
	Where Drill_Id = @iDrill_Id

	/* If one does not exist */
	If (@Count = 0)
	Begin
		Insert Into Drill
		(
			Drill_Id, Description
		)
		Values 
		(
			@iDrill_Id, @iDescription
		)

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror('This drill already exists', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
End
GO
GRANT EXECUTE ON dbo.AddDrill TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddDrill">
 <Procedure>
	Adds a record into the Drill table.
	Errors are raised if:
		This drill already exists
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulage.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.AddHaulage'))
	Drop Procedure dbo.AddHaulage
Go

Create Procedure dbo.AddHaulage
(
	@iHaulage_Date DateTime,
	@iHaulage_Shift Char(1),
	@iSource_Digblock_Id VarChar(31) = Null,
	@iSource_Stockpile_Id Int = Null,
	@iSource_Build_Id Int = Null,
	@iSource_Component_Id Int = Null,
	@iDestination_Stockpile_Id Int = Null,
	@iDestination_Build_Id Int = Null,
	@iDestination_Component_Id Int = Null,
	@iDestination_Crusher_Id VarChar(31) = Null,
	@iTonnes Float,
	@iLoads Int,
	@iTruck_Id VarChar(31),
	@oHaulage_Id Int = Null Output
)

With Encryption
As

Begin
	Declare @Source_Build_Id Int
	Declare @Destination_Build_Id Int
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- assumes the build provided is valid

	-- determine the source & destination builds
	If @iSource_Stockpile_Id Is Not Null
	Begin
		If @iSource_Build_Id Is Null
			Set @Source_Build_Id = dbo.GetReclaimableStockpileBuild(@iSource_Stockpile_Id, @iHaulage_Date, @iHaulage_Shift)
		Else
			Set @Source_Build_Id = @iSource_Build_Id
	End

	If @iDestination_Stockpile_Id Is Not Null
	Begin
		If @iDestination_Build_Id Is Null
			Set @Destination_Build_Id = dbo.GetBuildableStockpileBuild(@iDestination_Stockpile_Id, @iHaulage_Date, @iHaulage_Shift)
		Else
			Set @Destination_Build_Id = @iDestination_Build_Id
	End

	If (@iSource_Digblock_Id Is Null
		And @iSource_Stockpile_Id Is Null)
	Begin
		RaisError('At least one source must be specified.', 16, 1)
	End
	Else If (	@iDestination_Stockpile_Id Is Null
				And @iDestination_Crusher_Id Is Null)
	Begin
		RaisError('At least one destination must be specified.', 16, 1)
	End
	Else If (@iDestination_Stockpile_Id Is Not Null And @Destination_Build_Id Is Null)
	Begin
		RaisError('Unable to determine the destination stockpile build.', 16, 1)
	End
	Else If (@iSource_Stockpile_Id Is Not Null And @Source_Build_Id Is Null)
	Begin
		RaisError('Unable to determine the source stockpile build.', 16, 1)
	End
	-- If the digblock depletion falls in an approved depletion period
	Else If (@iSource_Digblock_Id is Not NULL) 
		And (dbo.IsInApprovedDigblockSurveyPeriod (@iHaulage_Date, @iHaulage_Shift, @iSource_Digblock_Id) = 1)
	Begin
		RaisError('Digblock falls in an already approved digblock survey period', 16, 1)
	End
	Else
	Begin
		Insert Into dbo.Haulage
		(
			Haulage_Date, Haulage_Shift, Source_Digblock_Id,
			Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
			Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id,
			Source_Mill_Id, Destination_Mill_Id,
			Tonnes, Loads, Truck_Id, Haulage_State_Id,
			Haulage_Raw_Id, Child_Haulage_Id, Parent_Haulage_Id, Added_DateTime
		)
		Values
		(
			@iHaulage_Date, @iHaulage_Shift, @iSource_Digblock_Id,
			@iSource_Stockpile_Id, @iSource_Build_Id, @iSource_Component_Id,
			@iDestination_Stockpile_Id, @iDestination_Build_Id, @iDestination_Component_Id, @iDestination_Crusher_Id,
			Null, Null,  -- these fields are not yet supported
			@iTonnes, @iLoads, @iTruck_Id, 'N',
			Null, Null, Null, GetDate()
		)

		Set @Haulage_Id = Scope_Identity()

		-- raise the L1 & CVF
		Exec dbo.RecalcL1RaiseByHaulage
			@iHaulage_Id = @Haulage_Id
			
		Exec dbo.CalcVirtualFlowRaise
			@pCalc_Date = @iHaulage_Date

		Set @oHaulage_Id = @Haulage_Id
	End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddHaulage TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulage">
 <Procedure>
	Adds a record into the Haulage table and returns the key to the inserted record in an output parameter.
	Raises Recalc and Virtual Flow events for the Haulage date.
	If the source or destination builds are not specified they are determined by calling the function
	GetBuildableStockpileBuild.	
	Errors are raised if:
		No source is specified
		No destination is specified
		The source is a stockpile but the stockpile build cannot be determined
		The destination build cannot be determined
		The source is a digblock which falls in an already approved digblock survey period
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageCorrectionResolutionBasic.prc'
GO

If Object_Id('dbo.AddHaulageCorrectionResolutionBasic') Is Not Null 
     Drop Procedure dbo.AddHaulageCorrectionResolutionBasic 
Go 

Create Procedure dbo.AddHaulageCorrectionResolutionBasic
(
	@iCode Varchar(63),
	@iResolve_From_Date Datetime,
	@iResolve_From_Shift Char(1),
	@iResolve_To_Date Datetime = Null,
	@iResolve_To_Shift Char(1) = Null,
	@iStockpile Varchar(31) = Null,
	@iBuild_Id Int = Null,
	@iComponent_Id Int = Null,
	@iDigblock_Id Varchar(31) = Null,
	@iCrusher_Id Varchar(31) = Null,
	@iMill_Id Varchar(31) = Null,
	@iDescription Varchar(255) = Null
)

With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: AddHaulageCorrectionResolutionBasic
--  Purpose: Adds a resolution basic record.
--  Parameters: @iCode - Code to add.
--				@iResolve_From_Date - Resolves from date.
--				@iResolve_From_Shift - Resolves from shift.
--				@iResolve_To_Date - Resolves to date.
--				@iResolve_To_Shift - Resolves to shift.
--				@iStockpile - Resolves to: Stockpile.
--				@iBuild_Id - Resolves to Stockpile ID.
--				@iComponent_Id - Resolves to component ID.
--				@iDigblock_Id - Resolves to digblock.
--				@iCrusher_Id - Resolves to crusher.
--				@iMill_Id - Resolves to Mill.
--				@iDescription - Description.
-- 
--  Comments: Adds to HaulageRawResolution.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Insert Into HaulageResolveBasic
	(
		Code, Resolve_From_Date, Resolve_From_Shift, Resolve_To_Date, Resolve_To_Shift, 
		Stockpile_Id, Build_Id, Component_Id, Digblock_Id, Crusher_Id, Mill_Id, Description
	)
	Values
	(
		@iCode, @iResolve_From_Date, @iResolve_From_Shift, @iResolve_To_Date, @iResolve_To_Shift,
		@iStockpile, @iBuild_Id, @iComponent_Id, @iDigblock_Id, @iCrusher_Id, @iMill_Id, @iDescription
		)

End
GO
GRANT EXECUTE ON dbo.AddHaulageCorrectionResolutionBasic TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageCorrectionResolutionBasic">
 <Procedure>
	Adds a resolution basic record.
	Errors are raised if:
		This code already exists for the given start date and shift.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddLocationType.prc'
GO

If object_id('dbo.AddLocationType') Is Not Null 
     Drop Procedure dbo.AddLocationType 
Go 
  
Create Procedure dbo.AddLocationType 
( 
	@iParent_Location_Type_Id TINYINT = Null,
	@iDescription Varchar(255) = Null,
	@iDefines_3d_Point Bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
	declare
		@children int
		
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		-- If a location type with the same name already exists
		If Exists
			(
				Select 1
				From dbo.LocationType 
				Where Description = @iDescription
			)
		Begin
			RaisError('A location type with the same name already exists', 16, 1)
		End

		--Check that the parent does not already have a child
		select @children = coalesce(count(location_type_id), 0)
		from dbo.LocationType
		where Parent_Location_Type_Id = @iParent_Location_Type_Id
				
		If @children > 0
		Begin
			RaisError('The parent location already has a child location type. Multiple children is currently not suppported.', 16, 1)
		End

		-- Insert the new record
		Insert Into dbo.LocationType
		(
			Parent_Location_Type_Id, Description, Defines_3d_Point
		)
		Select @iParent_Location_Type_Id, @iDescription, @iDefines_3d_Point
		
		 Commit Transaction 
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 
GRANT EXECUTE ON dbo.AddLocationType TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="AddLocationType">
 <Procedure>
	Adds a record to the LocationType table.
	Errors raised if:
		An existing location type has the same parent location type
		A location type with the same name already exists
		Parent location type already has a child
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddLocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
-- Mark Holst 15-Jul-2008

IF OBJECT_ID('dbo.AddLocation') IS NOT NULL
     DROP PROCEDURE dbo.AddLocation  
GO 
  
CREATE PROCEDURE dbo.AddLocation
(
	@iName VARCHAR(31),
	@iLocation_Type_Id TINYINT,
	@iParent_Location_Id INT = NULL,
	@iDescription VARCHAR(255) = NULL,
	@oLocation_Id INT = NULL OUTPUT
) 
WITH ENCRYPTION AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @Parent_Location_Type_Id TINYINT
	DECLARE @Message VARCHAR(255)

	-- Two potential scenarios:
	--  1. Independant: The location type is independant of other location types. In this case, no parent need be defined and the location
	--     name can only occur once within the location group
	--  2. Hierarchical: The location type is a child of another location type. In this case, a parent location must be given and the location
	--     only needs to be distinct within the parent location. This means that the same name can be repeated within a location group,
	--     AS long AS it IS distinct within the parent location.

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.LocationType
				WHERE Location_Type_Id = @iLocation_Type_Id
			)
		BEGIN
			Raiserror ('The given location type does not exist', 16, 1)
		END
	
		-- Get the details of the location type
		SELECT @Parent_Location_Type_Id = Parent_Location_Type_Id
		FROM dbo.LocationType
		WHERE Location_Type_Id = @iLocation_Type_Id


		-- If the location type does not have a parent location type, or a parent location is defined
		IF @Parent_Location_Type_Id IS NOT NULL
		BEGIN
			IF @iParent_Location_Id IS NULL
			BEGIN
				Raiserror ('The given record requires that a parent location ID.', 16, 1)
			END
			
			IF NOT EXISTS
				(
					SELECT 1
					FROM dbo.Location
					WHERE Location_Id = @iParent_Location_Id
				)
			BEGIN
				Raiserror ('The given parent location does not exist', 16, 1)
			END

			IF NOT EXISTS
				(
					SELECT 1
					FROM dbo.Location
					WHERE Location_Id = @iParent_Location_Id
						AND Location_Type_Id = @Parent_Location_Type_Id
				)
			BEGIN
				Raiserror ('The parent location ID is not a valid parent for the new record.', 16, 1)
			END	
		END
		ELSE IF @iParent_Location_Id IS NOT NULL
		BEGIN
			Raiserror ('This new location record cannot have a parent location.', 16, 1)
		END

		IF EXISTS
			(
				SELECT 1 
				FROM dbo.Location 
				WHERE Name = @iName
					AND Location_Type_Id = @iLocation_Type_Id
					AND Coalesce(Parent_Location_Id,-1) = Coalesce(@iParent_Location_Id,-1)
			)
		BEGIN
			Raiserror ('New location record already exists in the heirarchy.', 16, 1)
		END

		-- Add the location to the system
		INSERT INTO dbo.Location
		(
			Name, Location_Type_Id, Parent_Location_Id, Description
		)
		SELECT @iName, @iLocation_Type_Id, @iParent_Location_Id, @iDescription

		-- Save the id of this new location
		SET @oLocation_Id = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddLocation TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddLocation">
 <Procedure>
	Adds a record to the Location table and returns the key of the added record in an output variable.
	Two potential scenarios:
	  1. Independant: The location type is independant of other location types. In this case, no parent need be defined and the location
	     name can only occur once within the location group
	  2. Hierarchical: The location type is a child of another location type. In this case, a parent location must be given and the location
	     only needs to be distinct within the parent location. This means that the same name can be repeated within a location group,
	     as long as it is distinct within the parent location.
	Errors raised if:
		There is already a record with this name and location type associated with the parent record
		There is already a record with this name and location type
		The given parent record does not exist
		The given Location_Type_Id requires that a parent is given but none was
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMaterialTypeGroup.prc'
GO

If Object_Id('dbo.AddMaterialTypeGroup') Is Not Null 
     Drop Procedure dbo.AddMaterialTypeGroup 
Go 

Create Procedure dbo.AddMaterialTypeGroup
(
	@iName Varchar(63),
	@iDescription Varchar(255),
	@iOrder_No Int,
	@iIs_Digblock_Group Bit,
	@iIs_Stockpile_Group Bit
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @Count Int
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1

	/* Get the number of material type groups with the same name */
	Select @Count = Count(*)
	From MaterialTypeGroup
	Where Name = @iName

	/* If there are not any with the same */
	If (@Count = 0)
	Begin
		/* If an order no was not provided */
		If (@iOrder_No Is Null)
		Begin
			Select @iOrder_No = Max(Order_No)
			From MaterialTypeGroup

			If (@iOrder_No Is Null)
			Begin
				Set @iOrder_No = 1
			End
			Else
			Begin
				Set @iOrder_No = @iOrder_No + 1
			End
		End
		/* Insert the new material type group */
		Insert Into MaterialTypeGroup
		(
			Name, Description, Order_No, Is_Digblock_Group, Is_Stockpile_Group
		)
		Values 
		(
			@iName, @iDescription, @iOrder_No, @iIs_Digblock_Group, @iIs_Stockpile_Group
		)

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0

	End
	Else
	Begin
		Raiserror ('A material type group with the same name already exists', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
End
Go
GRANT EXECUTE ON dbo.AddMaterialTypeGroup TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddMaterialTypeGroup">
 <Procedure>
	Adds a record to the MaterialTypeGroup table
	Errors raised if:
		A material type group with the same name already exists
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMaterialType.prc'
GO

IF OBJECT_ID('dbo.AddMaterialType') IS NOT NULL
     DROP PROCEDURE dbo.AddMaterialType  
GO 
  
CREATE PROCEDURE dbo.AddMaterialType
(
	@iDescription VARCHAR(63), 
	@iAbbreviation VARCHAR(15),
	@iIs_Waste BIT = 0,
	@iDensity_Conversion_Factor REAL = 1,
	@iMaterial_Type_Group_Id INT = NULL,
	@iOrder_No INT = NULL,
	@iParent_Material_Type_Id INT = NULL,
	@iMaterial_Category_Id VARCHAR(31) = NULL,
	@oMaterial_Type_Id INT = NULL OUTPUT
)

AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @ParentMaterialCategoryId VARCHAR(31)
	DECLARE @Message VARCHAR(255)
	DECLARE @OrderNo Int
	DECLARE @MaterialTypeSetting VARCHAR(255)
	DECLARE @MaterialTypeGroupId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddMaterialType',
		@TransactionCount = @@TranCount 

	-- IF there are no transactions available THEN start a new one
	-- IF there IS already a TRANSACTION THEN only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		SELECT @MaterialTypeSetting = Value
		FROM dbo.Setting
		WHERE Setting_Id = 'MaterialTypeGrouping'

		IF @iAbbreviation IS NULL
		BEGIN
			RaisError ('The abbreviation can not be empty',16,1)
		END

		IF @iDensity_Conversion_Factor IS NULL
		BEGIN
			RaisError ('The density conversion factor can not be empty',16,1)
		END

		IF @MaterialTypeSetting = 'HIERARCHY'
		BEGIN
		
			IF @iMaterial_Type_Group_Id IS NOT NULL
			BEGIN
				RaisError('A material type group may not be specified using the hierarchy setting',16,1)
			END

			IF (SELECT Count(*) FROM dbo.MaterialTypeGroup) <> 1
			BEGIN
				RaisError('Only one material type group may be present when using the hierarchy setting',16,1)
			END
			
			SELECT @MaterialTypeGroupId = Material_Type_Group_Id
			FROM dbo.MaterialTypeGroup

			-- Check if a material category id was supplied and it isn't null.
			IF @iMaterial_Category_Id IS NULL
			BEGIN
				RaisError('A material category must be specified',16,1)
			END
			
			--Check to see if the material category exists.
			IF NOT EXISTS 
				(
					SELECT TOP 1 1 
					FROM MaterialCategory 
					WHERE MaterialCategoryId = @iMaterial_Category_Id
				)
			BEGIN
				Raiserror('The given material category does not exist', 16, 1)
			END
					
			-- Get the parent material category of the material category.
			SELECT @ParentMaterialCategoryId = ParentMaterialCategoryId
			FROM dbo.MaterialCategory
			WHERE MaterialCategoryId = @iMaterial_Category_Id

			-- IF the parent material category IS NULL, OR IF a parent material type id has been
			-- supplied without a parent material category being present in the hierarchy THEN
			-- throw an error.
			IF ((@ParentMaterialCategoryId IS NOT NULL) AND (@iParent_Material_Type_Id IS NULL))
			BEGIN
				SET @Message = 'The given ' + Coalesce(@iMaterial_Category_Id,'')
								+ ' requires that a parent ' 
								+ Coalesce(@ParentMaterialCategoryId,'') + ' is given'
				Raiserror (@Message, 16, 1)
			END
			
			IF ((@ParentMaterialCategoryId IS NULL) AND (@iParent_Material_Type_Id IS NOT NULL))
			BEGIN
				SET @Message = 'The given material category does not support a parent'
				Raiserror (@Message, 16, 1)
			END
					
			-- Check to see IF the parent provided EXISTS in this category 
			IF NOT EXISTS 
				(
					SELECT 1 
					FROM dbo.MaterialType
					WHERE Material_Type_Id = @iParent_Material_Type_Id 
						AND Material_Category_Id = @ParentMaterialCategoryId
				) AND @iParent_Material_Type_Id IS NOT NULL
			BEGIN
				SET @Message = 'The given parent ' +
							 @ParentMaterialCategoryId + ' does not exist'
				Raiserror (@Message, 16, 1)
			END
					
			-- If it is at the top level and there are no parents then sure this is the only
			-- material type in this level with the same abbreviation.
			IF @ParentMaterialCategoryId IS NULL AND 
				EXISTS
				(
				SELECT Top 1 1 
				FROM dbo.MaterialType 
				WHERE Abbreviation = @iAbbreviation
					AND Material_Category_Id = @iMaterial_Category_Id
				)
			BEGIN
				SET @Message = 'There is already a ' +
							 @iMaterial_Category_Id + ' with this abbreviation'
				Raiserror (@Message, 16, 1)
			END
			
			-- Ensure that the abbreviation does not appear multiple times in the same category.
			IF EXISTS 
				(
					SELECT Top 1 1 
					FROM dbo.MaterialType 
					WHERE Abbreviation = @iAbbreviation 
						AND Parent_Material_Type_Id = @iParent_Material_Type_Id
				)
			BEGIN
				SET @Message = 'There is already a ' + 
								@iMaterial_Category_Id + ' with this name within the parent ' 
								+ CAST(@iParent_Material_Type_Id AS VARCHAR)
				Raiserror (@Message, 16, 1)
			END
			
		END
				
		IF @MaterialTypeSetting = 'GROUPING'
		BEGIN
		
			SELECT @MaterialTypeGroupId = @iMaterial_Type_Group_Id
		
			IF @iMaterial_Type_Group_Id IS NULL
			BEGIN
				RaisError('Material type group must be specified',16,1)
			END
		
			IF NOT EXISTS 
				(
					SELECT TOP 1 1 
					FROM MaterialTypeGroup
					WHERE Material_Type_Group_Id = @iMaterial_Type_Group_Id
				)
			BEGIN
				Raiserror('The given material type group does not exist', 16, 1)
			END

			--Unique artificial constraint on abbreviation and group.
			IF EXISTS
			(
				SELECT Top 1 1 
				FROM dbo.MaterialType 
				WHERE Abbreviation = @iAbbreviation
					AND (Material_Type_Group_Id = @iMaterial_Type_Group_Id)
			)
			BEGIN
				Raiserror ('A material type with the same abbreviation already exists in this group', 16, 1)
			END
			
		END

		--Determine order no.
		SELECT @OrderNo = @iOrder_No
		IF @OrderNo IS NOT NULL
		BEGIN
			IF EXISTS
			(
				SELECT TOP 1 1 FROM dbo.MaterialType WHERE Order_No = @OrderNo
			)
			BEGIN
				RaisError ('A material type already has this order number specified',16,1)
			END
		END		
		ELSE IF (@OrderNo IS NULL)
		BEGIN
			SELECT @OrderNo = 1
			SELECT @OrderNo = Coalesce(Max(Order_No)+1,1)
			FROM MaterialType
		END
				
		--insert new material type
		INSERT INTO MaterialType
		(
			Description, Order_No, Abbreviation, Is_Waste, 
			Density_Conversion_Factor, Material_Type_Group_Id, Parent_Material_Type_Id, Material_Category_Id
		)
		VALUES 
		(
			@iDescription, @OrderNo, @iAbbreviation, @iIs_Waste, 
			@iDensity_Conversion_Factor, @MaterialTypeGroupId, @iParent_Material_Type_Id, @iMaterial_Category_Id
		)

		SET @oMaterial_Type_Id = Scope_Identity()
	
		-- IF we started a new transaction that IS still valid THEN COMMIT the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- IF we started a TRANSACTION THEN roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- IF we are part of an existing TRANSACTION AND 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddMaterialType TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddMaterialType">
 <Procedure>
	Adds a record to the MaterialType table and returns the key of the added record in @Material_Type_Id output variable.
	If no Order_No is specified it is calculated by incrementing the current maximum value.
	Errors are raised if:
		Another material type with the same abbreviation already exists with the same parent or in the same material type group
		The parent is not valid
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMaterialTypeWasteTypePeriod.prc'
GO

If Object_Id('dbo.AddMaterialTypeWasteTypePeriod') Is Not Null 
     Drop Procedure dbo.AddMaterialTypeWasteTypePeriod 
Go 

Create Procedure dbo.AddMaterialTypeWasteTypePeriod
(
	@iMaterial_Type_Id Int,
	@iWaste_Type_Id Varchar(31),
	@iIs_Waste Bit,
	@iStart_Date Datetime
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @Previous_Period_End_Date Datetime
	Declare @Current_Is_Waste Bit
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1

	-- Get the end date of the last record before this start date

	-- Work out the new end date for the previous period, based on the start date provided for this new period
	If (@iStart_Date Is Not Null)
	Begin
		Set @Previous_Period_End_Date = dbo.GetDateDay(DateAdd(Day, -1, @iStart_Date))
	End
	Else
	Begin
		Set @Previous_Period_End_Date = Null
	End

	-- If a record with the same details as this does not already exist
	If Not Exists (Select 1
					From MaterialTypeWasteTypePeriod
					Where Material_Type_Id = @iMaterial_Type_Id
						And Waste_Type_Id = @iWaste_Type_Id
						And (End_Date = @Previous_Period_End_Date
						Or (@Previous_Period_End_Date Is Null
						And End_Date Is Null)))
	Begin
	
		-- If there are no records in the table for this material type and waste type which have an end date which is the after this previous period end date
		If Not Exists (Select 1
						From MaterialTypeWasteTypePeriod
						Where Material_Type_Id = @iMaterial_Type_Id
							And Waste_Type_Id = @iWaste_Type_Id
							And End_Date > @Previous_Period_End_Date)
		Begin
		
			-- Get the current last period's waste flag
			Select @Current_Is_Waste = Is_Waste
			From MaterialTypeWasteTypePeriod MTWTP
			Where Material_Type_Id = @iMaterial_Type_Id
				And Waste_Type_Id = @iWaste_Type_Id
				And End_Date Is Null

			-- If this does not exist, or is different from the new is waste value
			If ((@Current_Is_Waste Is Null) Or (@Current_Is_Waste <> @iIs_Waste))
			Begin
			
				-- Set the current last record's end date to the given previous period end date, if one exists
				Update MTWTP
				Set	End_Date = @Previous_Period_End_Date
				From MaterialTypeWasteTypePeriod MTWTP
				Where Material_Type_Id = @iMaterial_Type_Id
					And Waste_Type_Id = @iWaste_Type_Id
					And End_Date Is Null
	
				-- Insert the new record
				Insert Into MaterialTypeWasteTypePeriod
				(
					Material_Type_Id, Waste_Type_Id, Is_Waste, End_Date
				)
				Values 
				(
					@iMaterial_Type_Id, @iWaste_Type_Id, @iIs_Waste, Null
				)

				Set @ELC_Proc_Is_Error = 0
			End
		End
		Else
		Begin
			Raiserror ('The given period falls in an existing defined period for this material type waste type', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('A record already exists for this material type waste type period', 16, 1)
	End

	-- Event_Logging_Placeholder
	
End
Go
GRANT EXECUTE ON dbo.AddMaterialTypeWasteTypePeriod TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddMaterialTypeWasteTypePeriod">
 <Procedure>
	Adds a record to the MaterialTypeWasteTypePeriod table
	Sets the current last record's end date to the given previous period end date, if one exists
	Errors raised if:
		The given period falls in an existing defined period for this material type waste type
		A record already exists for this material type waste type period
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddObjectNotes.prc'
GO

If Object_Id('dbo.AddObjectNotes') Is Not Null 
     Drop Procedure dbo.AddObjectNotes 
Go 

Create Procedure dbo.AddObjectNotes
(
	@iObject_Id Varchar(31),
	@iDescription Varchar(255) = Null,
	@iNotes Varchar(8000)
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the object notes value exists */
	If Not Exists (Select 1 From ObjectNotes Where Object_Id = @iObject_Id)
	Begin
		/* Update it's details */
		Insert into ObjectNotes
		(
			Object_Id, Description, Notes
		)
		Values 
		(
			@iObject_Id, @iDescription, @iNotes
		)

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
	Raiserror ('The given object already exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.AddObjectNotes TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddObjectNotes">
 <Procedure>
	Adds object to the ObjectNotes table.
	Errors raised if:
		The given object already exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockValue.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockValue') Is Not Null 
     Drop Procedure dbo.AddOrUpdateDigblockValue 
Go 

Create Procedure dbo.AddOrUpdateDigblockValue
(
	@iDigblock_Id Varchar(31),
	@iDigblock_Field_Id Varchar(31) = Null,
	@iField_Value Float,
	@iOrder_No Int = Null
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock exists */
	If Exists (Select 1 From Digblock Where Digblock_Id = @iDigblock_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@iDigblock_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @iDigblock_Field_Id = Digblock_Field_Id
			From DigblockField
			Where Order_No = @iOrder_No
		End

		/* If the digblock field exists */
		If Exists (Select 1 From DigblockField Where Digblock_Field_Id = @iDigblock_Field_Id)
		Begin
			/* If the value is not null */
			If (@iField_Value Is Not Null)
			Begin
				/* If this forecast field is not already populated */
				If Not Exists (Select 1 From DigblockValue Where Digblock_Id = @iDigblock_Id And Digblock_Field_Id = @iDigblock_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into DigblockValue
					(
						Digblock_Id, Digblock_Field_Id, Field_Value
					)
					Values 
					(
						@iDigblock_Id, @iDigblock_Field_Id, @iField_Value
					)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockValue
					Set	Field_Value = @iField_Value
					Where Digblock_Id = @iDigblock_Id
						And Digblock_Field_Id = @iDigblock_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From DigblockValue
				Where Digblock_Id = @iDigblock_Id
				And Digblock_Field_Id = @iDigblock_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateDigblockValue TO CoreDigblockManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockValue">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockValue table if the @iField_Value value is specified.
	If no @iField_Value is specified the record exists in the DigblockValue table the record is deleted.
	If the @iDigblock_Field_Id is not specified but the @iOrder_No is specified the @iDigblock_Field_Id is determined
	from the DigblockField table
	Errors raised if:
		The given digblock survey sample does not exist
		The given digblock survey sample field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockNotes.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockNotes') Is Not Null 
     Drop Procedure dbo.AddOrUpdateDigblockNotes 
Go 

Create Procedure dbo.AddOrUpdateDigblockNotes
(
	@iDigblock_Id Varchar(31),
	@iDigblock_Field_Id Varchar(31) = Null,
	@iNotes Varchar(1023),
	@iOrder_No Int = Null
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock exists */
	If Exists (Select 1 From Digblock Where Digblock_Id = @iDigblock_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@iDigblock_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @iDigblock_Field_Id = Digblock_Field_Id
			From DigblockField
			Where Order_No = @iOrder_No
		End

		/* If the digblock field exists */
		If Exists (Select 1 From DigblockField Where Digblock_Field_Id = @iDigblock_Field_Id)
		Begin
			/* If the value is not null */
			If (@iNotes Is Not Null)
			Begin
				/* If this forecast field is not already populated */
				If Not Exists (Select 1 From DigblockNotes Where Digblock_Id = @iDigblock_Id And Digblock_Field_Id = @iDigblock_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into DigblockNotes
					(
						Digblock_Id, Digblock_Field_Id, Notes
					)
					Values 
					(
						@iDigblock_Id, @iDigblock_Field_Id, @iNotes
					)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockNotes
					Set	Notes = @iNotes
					Where Digblock_Id = @iDigblock_Id
						And Digblock_Field_Id = @iDigblock_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From DigblockNotes
				Where Digblock_Id = @iDigblock_Id
				And Digblock_Field_Id = @iDigblock_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
Go
GRANT EXECUTE ON dbo.AddOrUpdateDigblockNotes TO CoreDigblockManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockNotes">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockNotes table if the @iNotes value is specified.
	Deletes a record in the DigblockNotes table if there is a record for the specified @iDigblock_Id and @iDigblock_Field_Id
	but the @iNotes value is not specified
	Errors raised if:
		The given digblock does not exist
		The given digblock field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockLocation.prc'
GO

If object_id('dbo.AddOrUpdateDigblockLocation') Is Not Null 
     Drop Procedure dbo.AddOrUpdateDigblockLocation 
Go 

Create Procedure dbo.AddOrUpdateDigblockLocation
(
	@iDigblock_Id VarChar(31),
	@iLocation_Type_Id TINYINT = Null,
	@iLocation_Id Int
)
With Encryption 
As
Begin
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Begin Try
		--Check the location id exists
		If Not Exists
			(
				Select 1
				From dbo.Location As L
				Where Location_Id = @iLocation_Id
			)
		Begin
			RaisError('The location id specified does not exist.', 16, 1)
		End

		--If a null location type id was passed in, or it wasn't passed in at all
		--look up the type from the location table.
		If @iLocation_Type_Id Is Null
		Begin
			Select @iLocation_Type_Id = Location_Type_Id
			From dbo.Location As L
			Where Location_Id = @iLocation_Id
		End

		--Check the location type exists
		If Not Exists
			(
				Select 1 
				From dbo.LocationType As LT
					Inner Join dbo.Location As L
						On (L.Location_Type_Id = LT.Location_Type_Id)
				Where LT.Location_Type_Id = @iLocation_Type_Id
					And L.Location_Id = @iLocation_Id
			)
		Begin
			RaisError('The location type id specified does not exist or is not valid for the specified location id.', 16, 1)
		End

		--Check digblock Exists
		If Not Exists
			(	
				Select 1
				From dbo.Digblock 
				Where Digblock_Id = @iDigblock_Id
			)
		Begin
			RaisError('The digblock id specified does not exist.', 16, 1)
		End

		--Ensure that only locations that belong to the lowest teir make it into this table
		If Exists
			(
				Select 1 
				From dbo.LocationType As LT
				Where Parent_Location_Type_Id = @iLocation_Type_Id
			)
		Begin
			RaisError('A digblock''s location can only be specified at the lowest point in a location heirarchy.', 16, 1)
		End

		--Update/Insert
		If Exists
			(
				Select 1
				From dbo.DigblockLocation As DL
				Where Digblock_Id = @iDigblock_Id
					And Location_Type_Id = @iLocation_Type_Id
			)
		Begin
			Update L
			Set Location_Id = @iLocation_Id
			From dbo.DigblockLocation As L
			Where Digblock_Id = @iDigblock_Id
				And Location_Type_Id = @iLocation_Type_Id
		End
		Else
		Begin
			Insert Into dbo.DigblockLocation
			(
				Digblock_Id, Location_Type_Id, Location_Id
			)
			Select @iDigblock_Id, @iLocation_Type_Id, @iLocation_Id
		End
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateDigblockLocation TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockLocation">
 <Procedure>
	Adds a new record or updates and existing record in the DigblockLocation table.
	Errors raised:
		The location id specified does not exist
		The location type id specified does not exist or is not valid for the specified location id
		The digblock id specified does not exist
		A digblock's location can only be specified at the lowest point in a location heirarchy
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.RecalcGetNextValidStartDate.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[RecalcGetNextValidStartDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[RecalcGetNextValidStartDate]
GO

CREATE Procedure dbo.RecalcGetNextValidStartDate 

(@Start_Date DateTime,
@Start_Shift Char(1),
@Valid_Start_Date DateTime Output,
@Valid_Start_Shift Char(1) Output)

With Encryption As

Declare @Is_Approved Bit
Declare @NoFutureMonthsApproved Int
Declare @Count Int
Declare @Was_Changed Bit

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 0

	Select @Valid_Start_Date = @Start_Date
	Select @Valid_Start_Shift = @Start_Shift
	Set @Was_Changed = 0

	/* Find out whether the month in which the date currently falls is set as processed */
	Select @Count = Count(*)
	From MonthlyApproval
	Where Month(Monthly_Approval_Month) = Month(@Valid_Start_Date)
	And Year(Monthly_Approval_Month) = Year(@Valid_Start_Date)

	If ((@Count > 0) And (@Count Is Not Null))
	Begin
		Select @Is_Approved =  Is_Approved
		From MonthlyApproval
		Where Month(Monthly_Approval_Month) = Month(@Valid_Start_Date)
		And Year(Monthly_Approval_Month) = Year(@Valid_Start_Date)
	End
	Else
	Begin
		Select @Is_Approved = 0
	End

	/* Get the number of months which are processed and are after the month in which this date falls */
	Select @NoFutureMonthsApproved = Count(*)
	From MonthlyApproval
	Where Monthly_Approval_Month > @Valid_Start_Date
	And Is_Approved = 1

	/* While the month in which the date falls is processed and there are months in the future which are processed */
	While ((@Is_Approved = 1) Or (@NoFutureMonthsApproved > 0))
	Begin
		/* Increment the date */
		Select @Valid_Start_Date = DateAdd (Day, 1, @Valid_Start_Date)
		Select @Valid_Start_Shift = dbo.GetFirstShiftType ()
		Set @Was_Changed = 1

		/* Find out whether the month in which the date currently falls is set as processed */
		Select @Count = Count(*)
		From MonthlyApproval
		Where Month(Monthly_Approval_Month) = Month(@Valid_Start_Date)
		And Year(Monthly_Approval_Month) = Year(@Valid_Start_Date)

		If ((@Count > 0) And (@Count Is Not Null))
		Begin
			Select @Is_Approved =  Is_Approved
			From MonthlyApproval
			Where Month(Monthly_Approval_Month) = Month(@Valid_Start_Date)
			And Year(Monthly_Approval_Month) = Year(@Valid_Start_Date)
		End
		Else
		Begin
			Select @Is_Approved = 0
		End

		/* Get the number of months which are processed and are after the month in which this date falls */
		Select @NoFutureMonthsApproved = Count(*)
		From MonthlyApproval
		Where Monthly_Approval_Month > @Valid_Start_Date
		And Is_Approved = 1
	End

	/* If the start date initially fell in an approved month and was moved forward */
	If (@Was_Changed = 1)
	Begin
		/* Reduce the start shift by one shift to allow for a range of situations, including stockpile adjustments on the end of approved months */
		Select @Valid_Start_Date = DateAdd (Day, -1, @Valid_Start_Date)
		Select @Valid_Start_Shift = dbo.GetLastShiftType ()
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="RecalcGetNextValidStartDate">
 <Procedure>
	Find out whether the month in which the date currently falls is set as processed 
	in table MonthlyApproval. Get the number of months which are processed and are 
	after the month in which this date falls. While the month in which the date falls 
	is processed and there are months in the future which are processed
	Log the event via the event logging stored procedure.
	Record the stored procedure name acronymn via Event_Type_Id.
	Is_Error states if the event is an error or not.
	Parameters is an XML list of the parameters that were passed into the stored procedure.
	(Please ensure these do not get modified during the stored procedure)
	Description is currently unused, kept for when deemed necessary.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockGrade.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockGrade') Is Not Null 
     Drop Procedure dbo.AddOrUpdateDigblockGrade 
Go 

Create Procedure dbo.AddOrUpdateDigblockGrade
(
	@iDigblock_Id Varchar(31),
	@iGrade_Id Int,
	@iGrade_Value Real
)
With Encryption 
As 

Begin
	Set Nocount On

	Begin Transaction

	Declare @Recalc_Start_Date Datetime
	Declare @Recalc_End_Date Datetime
	Declare @Valid_Start_Date Datetime
	Declare @Valid_Start_Shift Char(1)
	Declare @Shift Char(1)

    --Check for a valid grade value	
	If @iGrade_Value < 0
	Begin
		RaisError('Grade value specified is less than 0',16,1)
	End
	Else
	Begin
		If @iGrade_Value Is Null
		Begin
				Delete From DigblockGrade
				Where Digblock_Id = @iDigblock_Id
					And Grade_Id = @iGrade_Id
		End
		Else If Exists 
			(
			Select Top 1 1 
			From dbo.DigblockGrade 
			Where Grade_Id = @iGrade_Id
				And Digblock_Id = @iDigblock_Id
			) 
		Begin
			Update DigblockGrade
			Set Grade_Value = @iGrade_Value
			Where Digblock_Id = @iDigblock_Id
				And Grade_Id = @iGrade_Id
		End
		Else
		Begin
			Insert Into DigblockGrade
			(
				Digblock_Id,
				Grade_Id,
				Grade_Value
			)
			Values
			(
				@iDigblock_Id,
				@iGrade_Id,
				@iGrade_Value
			)
		End
	End

	/* Work out when this digblock was first hauled from */
	Select @Recalc_Start_Date = Min(Haulage_Date), 
		@Recalc_End_Date = Max(Haulage_Date)
	From Haulage
	Where Source_Digblock_Id = @iDigblock_Id

	If (@Recalc_Start_Date Is Not Null)
	Begin
		/* Work out when to recalc from */
		Set @Shift = dbo.GetFirstShiftType ()
		Exec RecalcGetNextValidStartDate 
			@Recalc_Start_Date, 
			@Shift, 
			@Valid_Start_Date Output, 
			@Valid_Start_Shift Output
	End

	If (@Valid_Start_Date Is Not Null)
	Begin
		/* Recalculate the transaction tonnes period for this digblock */
		Exec RecalcL1RaisePeriod 
			@iStart_Date=@Valid_Start_Date,
			@iEnd_Date=@Recalc_End_Date
	End

	Commit Transaction

End
Go
GRANT EXECUTE ON dbo.AddOrUpdateDigblockGrade TO CoreDigblockManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockGrade">
 <Procedure>
	Adds a new record to digblock grade, or updates an existing record, or deletes a record if the value supplied is null.
	Raises a recalc if appropriate.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageGrade.prc'
GO

If Object_Id('dbo.AddOrUpdateHaulageGrade') Is Not Null 
     Drop Procedure dbo.AddOrUpdateHaulageGrade 
Go 

Create Procedure dbo.AddOrUpdateHaulageGrade
(
	@iHaulage_Id Int,
	@iGrade_Id Int,
	@iGrade_Value Real
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

		-- do not allow the changing of a record that is not at the end of a chain
		If (Select Child_Haulage_Id
			From Haulage
			Where Haulage_Id = @iHaulage_Id) Is Not Null
		Begin
			RaisError('AddOrUpdateHaulageGrade: Haulage has been modified and cannot be updated.', 16, 1)
		End
		Else
		Begin
			If Exists (	Select 1
						From HaulageGrade
						Where Haulage_Id = @iHaulage_Id
							And Grade_Id = @iGrade_Id)
			Begin
				If @iGrade_Value Is Null
				Begin
					Delete
					From HaulageGrade
					Where Haulage_Id = @iHaulage_Id
						And Grade_Id = @iGrade_Id
				End
				Else
				Begin
					Update HaulageGrade
					Set Grade_Value = @iGrade_Value
					Where Haulage_Id = @iHaulage_Id
						And Grade_Id = @iGrade_Id
				End
			End
			Else
			Begin
				If @iGrade_Value Is Not Null
				Begin
					Insert Into HaulageGrade
					(
						Haulage_Id, Grade_Id, Grade_Value
					)
					Values
					(
						@iHaulage_Id, @iGrade_Id, @iGrade_Value
					)
				End
			End
		End

		Exec RecalcL1RaiseByHaulage
			@iHaulage_Id = @iHaulage_Id

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateHaulageGrade TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageGrade">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageGrade table if the @iGrade_Value value is specified.
	If no @iGrade_Value value is specified and the record exists in the HaulageGrade table the record is deleted.
	Raises a recalc record for the associated Haulage record.
	Errors raised if:
		Haulage has been modified and cannot be updated
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageNotes.prc'
GO

If Object_Id('dbo.AddOrUpdateHaulageNotes') Is Not Null 
     Drop Procedure dbo.AddOrUpdateHaulageNotes 
Go 


Create Procedure dbo.AddOrUpdateHaulageNotes
(
	@iHaulage_Id Int,
	@iHaulage_Field_Id VarChar(31),
	@iNotes Varchar(1023)
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

		-- do not allow the changing of a record that is not at the end of a chain
		If (Select Child_Haulage_Id
			From Haulage
			Where Haulage_Id = @iHaulage_Id) Is Not Null
		Begin
			RaisError('AddOrUpdateHaulageNotes: Haulage has been modified and cannot be updated.', 16, 1)
		End
		Else
		Begin
			If Exists (	Select 1
						From HaulageNotes
						Where Haulage_Id = @iHaulage_Id
							And Haulage_Field_Id = @iHaulage_Field_Id)
			Begin
				If @iNotes Is Null
				Begin
					Delete
					From HaulageNotes
					Where Haulage_Id = @iHaulage_Id
						And Haulage_Field_Id = @iHaulage_Field_Id
				End
				Else
				Begin
					Update HaulageNotes
					Set Notes = @iNotes
					Where Haulage_Id = @iHaulage_Id
						And Haulage_Field_Id = @iHaulage_Field_Id
				End
			End
			Else
			Begin
				If @iNotes Is Not Null
				Begin
					Insert Into HaulageNotes
					(
						Haulage_Id, Haulage_Field_Id, Notes
					)
					Values
					(
						@iHaulage_Id, @iHaulage_Field_Id, @iNotes
					)
				End
			End
		End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateHaulageNotes TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageNotes">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageNotes table if the @iNotes value is specified.
	If no @iNotes value is specified and the record exists in the HaulageNotes table the record is deleted.
	Raises a recalc record for the associated Haulage record.
	Errors raised if:
		Haulage has been modified and cannot be updated
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageValue.prc'
GO

If Object_Id('dbo.AddOrUpdateHaulageValue') Is Not Null 
     Drop Procedure dbo.AddOrUpdateHaulageValue 
Go 

Create Procedure dbo.AddOrUpdateHaulageValue
(
	@iHaulage_Id Int,
	@iHaulage_Field_Id VarChar(31),
	@iField_Value Real
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

		-- do not allow the changing of a record that is not at the end of a chain
		If (Select Child_Haulage_Id
			From Haulage
			Where Haulage_Id = @iHaulage_Id) Is Not Null
		Begin
			RaisError('AddOrUpdateHaulageValue: Haulage has been modified and cannot be updated.', 16, 1)
		End
		Else
		Begin
			If Exists (	Select 1
						From HaulageValue
						Where Haulage_Id = @iHaulage_Id
							And Haulage_Field_Id = @iHaulage_Field_Id)
			Begin
				If @iField_Value Is Null
				Begin
					Delete
					From HaulageValue
					Where Haulage_Id = @iHaulage_Id
						And Haulage_Field_Id = @iHaulage_Field_Id
				End
				Else
				Begin
					Update HaulageValue
					Set Field_Value = @iField_Value
					Where Haulage_Id = @iHaulage_Id
						And Haulage_Field_Id = @iHaulage_Field_Id
				End
			End
			Else
			Begin
				If @iField_Value Is Not Null
				Begin
					Insert Into HaulageValue
					(
						Haulage_Id, Haulage_Field_Id, Field_Value
					)
					Values
					(
						@iHaulage_Id, @iHaulage_Field_Id, @iField_Value
					)
				End
			End
		End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateHaulageValue TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageValue">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageValue table if the @iField_Value value is specified.
	If no @iField_Value value is specified and the record exists in the HaulageValue table the record is deleted.
	Errors raised if:
		Haulage has been modified and cannot be updated
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateReport.prc'
GO

If Object_Id('dbo.AddOrUpdateReport') Is Not Null 
     Drop Procedure dbo.AddOrUpdateReport 
Go 

Create Procedure dbo.AddOrUpdateReport
(
	@ioReport_Id int output,
	@iName varchar(255),
	@iDescription varchar(1023),
	@iReport_Path varchar(1023) = Null,
	@iReport_Group_Id int = Null
)
With Encryption
As
Begin
	Set Nocount On

	If Not Exists 
		(
			Select *
			From Report
			Where Report_Id = @ioReport_Id
		)
	Begin
		Insert Into Report
		(
			[Name], Description, Report_Path, Report_Group_Id
		)
		Select @iName, @iDescription, IsNull(@iReport_Path, ''), @iReport_Group_Id
		
		Set @ioReport_Id = @@Identity
	End
	Else
	Begin
		Update Report
		Set [Name] = @iName,
			Description = @iDescription,
			Report_Path = IsNull(@iReport_Path, Report_Path),
			Report_Group_Id = @iReport_Group_Id
		Where Report_Id = @ioReport_Id
	End
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateReport TO CoreReportManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateReport">
 <Procedure>
	Adds a new record or updates an existing record in the Report table.
	Errors not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateReportGroup.prc'
GO

If Object_Id('dbo.AddOrUpdateReportGroup') Is Not Null 
     Drop Procedure dbo.AddOrUpdateReportGroup 
Go 

Create Procedure dbo.AddOrUpdateReportGroup
(
	@ioReport_Group_Id int output,
	@iName varchar(63),
	@iDescription varchar(1023)
)
With Encryption
As
Begin
	Set Nocount On

	If Not Exists 
		(
			Select *
			From ReportGroup
			Where Report_Group_Id = @ioReport_Group_Id
		)
	Begin
		Insert Into ReportGroup
		(
			[Name], Description
		)
		Select @iName, @iDescription

		Set @ioReport_Group_Id = @@Identity
	End
	Else
	Begin
		Update ReportGroup
		Set [Name] = @iName,
			Description = @iDescription
		Where Report_Group_Id = @ioReport_Group_Id
	End
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateReportGroup TO CoreReportManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateReportGroup">
 <Procedure>
	Adds a new record or updates an existing record in the ReportGroup table.
	Errors not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileNotes.prc'
GO

If Object_Id('dbo.AddOrUpdateStockpileNotes') Is Not Null 
     Drop Procedure dbo.AddOrUpdateStockpileNotes 
Go 

Create Procedure dbo.AddOrUpdateStockpileNotes
(
	@iStockpile_Id Int,
	@iStockpile_Field_Id Varchar(31) = Null,
	@iNotes VarChar(1023),
	@iOrder_No Int = Null
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

		/* If the stockpile exists */
		If Exists (Select 1 From Stockpile Where Stockpile_Id = @iStockpile_Id)
		Begin
			/* If the order no for the field was given instead of the actual name */
			If (@iStockpile_Field_Id Is Null)
			Begin
				/* Get the field name */
				Select @iStockpile_Field_Id = Stockpile_Field_Id
				From StockpileField
				Where Order_No = @iOrder_No
			End

			/* If the stockpile field exists */
			If Exists (Select 1 From StockpileField Where Stockpile_Field_Id = @iStockpile_Field_Id)
			Begin
				/* If the notes is not null */
				If (@iNotes Is Not Null)
				Begin
					/* If this field is not already populated */
					If Not Exists (Select 1 From StockpileNotes Where Stockpile_Id = @iStockpile_Id And Stockpile_Field_Id = @iStockpile_Field_Id)
					Begin
						/* Insert a new notes for the field */
						Insert Into StockpileNotes
						(
							Stockpile_Id, Stockpile_Field_Id, Notes
						)
						Values 
						(
							@iStockpile_Id, @iStockpile_Field_Id, @iNotes
						)
					End
					Else
					Begin
						/* Otherwise, update the field */
						Update StockpileNotes
						Set	Notes = @iNotes
						Where Stockpile_Id = @iStockpile_Id
							And Stockpile_Field_Id = @iStockpile_Field_Id
					End
				End
				Else
				Begin
					/* Delete any existing notes */
					Delete From StockpileNotes
					Where Stockpile_Id = @iStockpile_Id
						And Stockpile_Field_Id = @iStockpile_Field_Id
				End

				If @@Error = 0
					Set @ELC_Proc_Is_Error = 0
			End
			Else
			Begin
				Raiserror('The given stockpile field does not exist', 16, 1)
			End
		End
		Else
		Begin
			Raiserror('The given stockpile does not exist', 16, 1)
		End

	Commit Transaction


	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
Go
GRANT EXECUTE ON dbo.AddOrUpdateStockpileNotes TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileNotes">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileNotes table if @iNotes is specified.
	If the @iNotes value is not specified and the record exists in the StockpileNotes table the record is deleted.
	If the @iStockpile_Field_Id field is not specified it is determined from the StockpileField table using the @iOrder_No value.
	Errors raised if:
		The given stockpile group does not exist
		The given stockpile group field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileValue.prc'
GO

If Object_Id('dbo.AddOrUpdateStockpileValue') Is Not Null 
     Drop Procedure dbo.AddOrUpdateStockpileValue 
Go 

Create Procedure dbo.AddOrUpdateStockpileValue
(
	@iStockpile_Id Int,
	@iStockpile_Field_Id Varchar(31) = Null,
	@iField_Value Float,
	@iOrder_No Int = Null
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the stockpile exists */
	If Exists (Select 1 From Stockpile Where Stockpile_Id = @iStockpile_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@iStockpile_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @iStockpile_Field_Id = Stockpile_Field_Id
			From StockpileField
			Where Order_No = @iOrder_No
		End

		/* If the stockpile field exists */
		If Exists (Select 1 From StockpileField Where Stockpile_Field_Id = @iStockpile_Field_Id)
		Begin
			/* If the value is not null */
			If (@iField_Value Is Not Null)
			Begin
				/* If this field is not already populated */
				If Not Exists (Select 1 From StockpileValue Where Stockpile_Id = @iStockpile_Id And Stockpile_Field_Id = @iStockpile_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into StockpileValue
					(
						Stockpile_Id, Stockpile_Field_Id, Field_Value
					)
					Values 
					(
						@iStockpile_Id, @iStockpile_Field_Id, @iField_Value
					)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update StockpileValue
					Set	Field_Value = @iField_Value
					Where Stockpile_Id = @iStockpile_Id
						And Stockpile_Field_Id = @iStockpile_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From StockpileValue
				Where Stockpile_Id = @iStockpile_Id
					And Stockpile_Field_Id = @iStockpile_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given stockpile field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given stockpile does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
Go
GRANT EXECUTE ON dbo.AddOrUpdateStockpileValue TO CoreStockpileManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileValue">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileValue table if @iField_Value is specified.
	If the @iField_Value value is not specified and the record exists in the StockpileValue table the record is deleted.
	Errors raised if:
		The given stockpile does not exist
		The given stockpile field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileLocation.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateStockpileLocation') IS NOT NULL 
     DROP PROCEDURE dbo.AddOrUpdateStockpileLocation 
GO 

CREATE PROCEDURE dbo.AddOrUpdateStockpileLocation
(
	@iStockpile_Id INT,
	@iLocation_Type_Id TINYINT = NULL,
	@iLocationId INT
)
WITH ENCRYPTION 
AS
BEGIN
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 

	BEGIN TRY
		--Check the location id exists
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.Location 
				WHERE Location_Id = @iLocationId
			)
		BEGIN
			RaisError('The location id specified does not exist.', 16, 1)
		END

		--IF a NULL location type id was passed in, OR it wasn't passed in at ALL
		--look up the type FROM the location TABLE.
		IF @iLocation_Type_Id IS NULL
		BEGIN
			SELECT @iLocation_Type_Id = Location_Type_Id
			FROM dbo.Location 
			WHERE Location_Id = @iLocationId
		END

		--Check the location type EXISTS
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.LocationType AS lt
					INNER JOIN dbo.Location AS l
						ON (l.Location_Type_Id = lt.Location_Type_Id)
				WHERE lt.Location_Type_Id = @iLocation_Type_Id
					AND l.Location_Id = @iLocationId
			)
		BEGIN
			RaisError('The location type id specified does not exist or is not valid for the specified location id.', 16, 1)
		END

		--Check stockpile EXISTS
		IF NOT EXISTS
			(	
				SELECT 1
				FROM dbo.Stockpile 
				WHERE Stockpile_Id = @iStockpile_Id
			)
		BEGIN
			RaisError('The stockpile id specified does not exist.', 16, 1)
		END

		--UPDATE/INSERT
		-- DELETE first if record exists
		IF EXISTS
		(
			SELECT 1
			FROM dbo.StockpileLocation
			WHERE Stockpile_Id = @iStockpile_Id
		)
		BEGIN
			DELETE dbo.StockpileLocation 
			WHERE Stockpile_Id = @iStockpile_Id
		END

		INSERT INTO dbo.StockpileLocation
		(
			Stockpile_Id, Location_Type_Id, Location_Id
		)
		SELECT @iStockpile_Id, @iLocation_Type_Id, @iLocationId
	
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	
END
GO
GRANT EXECUTE ON dbo.AddOrUpdateStockpileLocation TO CoreStockpileManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileLocation">
 <Procedure>
	Adds a new record or updates and existing record in the StockpileLocation table.
	Errors raised:
		The location id specified does not exist
		The location type id specified does not exist or is not valid for the specified location id
		The stockpile id specified does not exist
		A stockpile's location can only be specified at the lowest point in a location heirarchy
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileBuildComponentGrade.prc'
GO

If Object_Id('dbo.AddOrUpdateStockpileBuildComponentGrade') Is Not Null
	Drop Procedure dbo.AddOrUpdateStockpileBuildComponentGrade
Go

CREATE Procedure dbo.AddOrUpdateStockpileBuildComponentGrade
(
	@iStockpile_Id Int,
	@iBuild_Id Int,
	@iComponent_Id Int,
	@iGrade_Id SmallInt,
	@iGrade_Value Real
)

With Encryption
As

Begin

	Declare @Build_Start_Date Datetime
	Declare @Build_Start_Shift Char(1)

	-- Determine dates for which to raise L2 Recalcs
	Select @Build_Start_Date = Start_Date,
		@Build_Start_Shift = Start_Shift
	From StockpileBuild
	Where Stockpile_Id = @iStockpile_Id
		And Build_Id = @iBuild_Id
	
	Begin Transaction
	If Exists (	Select 1
				From StockpileBuildComponentGrade
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
					And Component_Id = @iComponent_Id
					And Grade_Id = @iGrade_Id)
	Begin
		If @iGrade_Value Is Null
		Begin
			Delete From StockpileBuildComponentGrade
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id
				And Component_Id = @iComponent_Id
				And Grade_Id = @iGrade_Id
		End
		Else
		Begin	
			Update StockpileBuildComponentGrade
			Set Grade_Value = @iGrade_Value
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id
				And Component_Id = @iComponent_Id
				And Grade_Id = @iGrade_Id
		End
	End
	Else
	Begin
		-- insert default grades (these are mandatory, and a requirement for the recalc)
		Insert Into StockpileBuildComponentGrade
		(
			Stockpile_Id, Build_Id, Component_Id, Grade_Id, Grade_Value
		)
		Values
		(
			@iStockpile_Id, @iBuild_Id, @iComponent_Id, @iGrade_Id, @iGrade_Value
		)

	End

	-- flag the L2 to recalculate from the beginning of the stockpile
	Exec RecalcL2Raise	
		@pDate=@Build_Start_Date,
		@pShift=@Build_Start_Shift


	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateStockpileBuildComponentGrade TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileBuildComponentGrade">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileBuildComponentGrade table.
	Raises a 2nd Level recalc for the date that the adjustment occurred.
	Errors not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateUserInterfaceListingField.prc'
GO

If object_id('dbo.AddOrUpdateUserInterfaceListingField') is not Null 
     Drop Procedure dbo.AddOrUpdateUserInterfaceListingField 
Go 
  
Create Procedure dbo.AddOrUpdateUserInterfaceListingField 
( 
    @iUser_Interface_Listing_Id Int,
	@iField_Name Varchar(255),
	@iDisplay_Name Varchar(63),
	@iPixel_Width Int = Null,
	@iIs_Visible Bit,
	@iSum_Field Bit,
	@iOrder_No Int = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @User_Interface_Listing_Field_Id Int

    Begin Try
		--Validate the @iUser_Interface_Listing_Id value
		If Not Exists 
			(
				Select 1 
				From UserInterfaceListing 
				Where User_Interface_Listing_Id = @iUser_Interface_Listing_Id
			)
		Begin
			Raiserror('The given User Interface Listing ID does not exist', 16, 1)
		End

		Set @User_Interface_Listing_Field_Id = 
			(
				Select Top 1 User_Interface_Listing_Field_Id 
				From UserInterfaceListingField 
				Where User_Interface_Listing_Id = @iUser_Interface_Listing_Id 
					And Field_Name = @iField_Name
			)

		-- If User_Interface_Listing_Field_Id does not exist add it
		If @User_Interface_Listing_Field_Id Is Null
		Begin
			Insert Into UserInterfaceListingField
			(
				User_Interface_Listing_Id, Field_Name, Display_Name,
				Pixel_Width, Is_Visible, Sum_Field, Order_No
			)
			Select @iUser_Interface_Listing_Id, @iField_Name, @iDisplay_Name,
				@iPixel_Width, @iIs_Visible, @iSum_Field, 
				 Case When @iIs_Visible = 1 Then @iOrder_No Else Null End

			Set @User_Interface_Listing_Field_Id = @@Identity
		End	
		Else
		Begin
			Declare @Orig_IsVisible bit,
				@Order_No Int

			Select @Orig_IsVisible = Is_Visible
			From UserInterfaceListingField
			Where User_Interface_Listing_Field_Id = @User_Interface_Listing_Field_Id

			If @iIs_Visible = 1 
			Begin
				Set @Order_No = @iOrder_No

				If @Orig_IsVisible = 0
				Begin
					--Get a max order number if this has come from not being visible to visible
					Select @Order_No = IsNull(Max(Order_No) + 1, 0)
					From UserInterfaceListingField
					Where Is_Visible = 1
						And User_Interface_Listing_Id = @iUser_Interface_Listing_Id  
				End
			End
			Else
			Begin
				Set @Order_No = NULL
			End 
			

			Update UserInterfaceListingField
				Set Display_Name = @iDisplay_Name,
					Pixel_Width = @iPixel_Width,
					Is_Visible = @iIs_Visible,
					Sum_Field = @iSum_Field,
					Order_No = @Order_No
			Where User_Interface_Listing_Field_Id = @User_Interface_Listing_Field_Id
		End

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.AddOrUpdateUserInterfaceListingField TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateUserInterfaceListingField">
 <Procedure>
	If the field name does exist for this User listing then it adds the field otherwise
	it updates its details.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateWeightometerSampleGrade.prc'
GO

IF object_id('dbo.AddOrUpdateWeightometerSampleGrade') IS NOT NULL 
     DROP PROCEDURE dbo.AddOrUpdateWeightometerSampleGrade 
GO 

CREATE PROCEDURE dbo.AddOrUpdateWeightometerSampleGrade
(
	@iWeightometer_Sample_Id INT,
	@iGrade_Id INT,
	@iGrade_Value FLOAT = NULL
)
WITH ENCRYPTION AS 
BEGIN 
	SET NOCOUNT ON

	DECLARE @RecalcDate DATETIME
	DECLARE @CVFDate DATETIME

	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION

	IF @iGrade_Value IS NULL
	BEGIN
		DELETE 
		FROM dbo.WeightometerSampleGrade
		WHERE Weightometer_Sample_Id = @iWeightometer_Sample_Id
			AND Grade_Id = @iGrade_Id
	END
	ELSE IF EXISTS
		(	
			SELECT 1 
			FROM dbo.WeightometerSampleGrade
			WHERE Weightometer_Sample_Id = @iWeightometer_Sample_Id
				AND Grade_Id = @iGrade_Id
		)
	BEGIN	
		UPDATE dbo.WeightometerSampleGrade
		SET Grade_Value = @iGrade_Value
		WHERE Weightometer_Sample_Id = @iWeightometer_Sample_Id
			AND Grade_Id = @iGrade_Id
	END
	ELSE
	BEGIN
		INSERT INTO dbo.WeightometerSampleGrade
		(
			Weightometer_Sample_Id, Grade_Id, Grade_Value
		)
		SELECT @iWeightometer_Sample_Id, @iGrade_Id, @iGrade_Value
	END

	SELECT @RecalcDate = CASE WHEN W.Weightometer_Type_Id LIKE '%L1%' THEN Weightometer_Sample_Date ELSE NULL END,
		@CVFDate = CASE WHEN W.Weightometer_Type_Id LIKE '%CVF%' THEN Weightometer_Sample_Date ELSE NULL END
	FROM dbo.WeightometerSample AS WS
		INNER JOIN dbo.Weightometer AS W
			ON (W.Weightometer_Id = WS.Weightometer_Id)
	WHERE WS.Weightometer_Sample_Id = @iWeightometer_Sample_Id

	IF @RecalcDate IS NOT NULL
	BEGIN
		EXEC RecalcL1Raise 
			@pDate = @RecalcDate
	END

	IF @CVFDate IS NOT NULL
	BEGIN
		EXEC CalcVirtualFlowRaise 
			@pCalc_Date = @CVFDate
	END

	COMMIT TRANSACTION
END
GO
GRANT EXECUTE ON dbo.AddOrUpdateWeightometerSampleGrade TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateWeightometerSampleGrade">
 <Procedure>
	Adds a new record or updates an existing record in the WeightometerSampleGrade table 
	If @iRecalc_Data = 1 a Level 1 Recalc record is raised for the Weightometer_Sample_Date.
	Errors not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileGroup.prc'
GO

If object_id('dbo.AddStockpileGroup') is not Null 
     Drop Procedure dbo.AddStockpileGroup 
Go 
  
Create Procedure dbo.AddStockpileGroup 
( 
    @iStockpile_Group_Id Varchar(31),
	@iDescription Varchar(255) = Null,
	@iOrder_No Int = Null
) 
With Encryption As 
Begin 
    Set NoCount On 

    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @Order_No Int

	Begin Try
		--Does the group already exist
		If Exists
			(
				Select 1 
				From StockpileGroup 
				Where Stockpile_Group_Id = @iStockpile_Group_Id
			)
		Begin
			Raiserror ('A stockpile group with that name already exists', 16 ,1)
		End

	    If @iOrder_No < 0	
		Begin
			Raiserror ('Order number must not be negative.', 16 ,1)
		End 

		Set @Order_No = @iOrder_No

		--If no order number was passed then get max order number + 1
		--however if there is no records currently default to 0
		If @Order_No Is Null
		Begin
			Select @Order_No = IsNull(Max(Order_No) + 1, 0)	
			From StockpileGroup			
		End

		--Add the stockpile group
		Insert Into StockpileGroup
		(
			Stockpile_Group_Id, Description, Order_No
		)
		Select @iStockpile_Group_Id, @iDescription, @Order_No
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go	
GRANT EXECUTE ON dbo.AddStockpileGroup TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileGroup">
 <Procedure>
	Adds a new record in the StockpileGroup table.
	Errors are raised if:
		A stockpile group with that name already exists.
		A negative stockpile order number is passed.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileGroupStockpile.prc'
GO

If Object_Id('dbo.AddStockpileGroupStockpile') Is Not Null 
     Drop Procedure dbo.AddStockpileGroupStockpile 
Go 

Create Procedure dbo.AddStockpileGroupStockpile
(
	@iStockpile_Group_Id Varchar(31),
	@iStockpile_Id Int
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the stockpile group exists */
	If Exists (Select 1 From StockpileGroup Where Stockpile_Group_Id = @iStockpile_Group_Id)
	Begin
		/* If the stockpile exists */
		If Exists (Select 1 From Stockpile Where Stockpile_Id = @iStockpile_Id)
		Begin
			/* If the stockpile is not already selected for the group */
			If Not Exists (Select 1 From StockpileGroupStockpile Where Stockpile_Group_Id = @iStockpile_Group_Id And Stockpile_Id = @iStockpile_Id)
			Begin
				/* Add the stockpile to the group */
				Insert Into StockpileGroupStockpile
				(
					Stockpile_Group_Id, Stockpile_Id
				)
				Values 
				(
					@iStockpile_Group_Id, @iStockpile_Id
				)

				Set @ELC_Proc_Is_Error = 0
			End
--			Else
--			Begin
--				Raiserror ('The stockpile already belongs to this group', 16 ,1)
--			End
		End
		Else
		Begin
			Raiserror ('The given stockpile does not exist', 16 ,1)
		End
	End
	Else
	Begin
		Raiserror ('The given stockpile group does not exist', 16 ,1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
Go
GRANT EXECUTE ON dbo.AddStockpileGroupStockpile TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileGroupStockpile">
 <Procedure>
	Adds a new record in the StockpileGroupStockpile table.
	Errors are raised if:
		The given stockpile group does not exist
		The given stockpile does not exist
		The stockpile already belongs to this group
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileBuildComponent.prc'
GO

IF OBJECT_ID('dbo.AddStockpileBuildComponent') IS NOT NULL 
     DROP PROCEDURE dbo.AddStockpileBuildComponent 
GO 
  
CREATE PROCEDURE dbo.AddStockpileBuildComponent 
( 
    @iStockpile_Id INT,
	@iBuild_Id INT,
	@iLayer INT = NULL,
	@iStart_Tonnes FLOAT = 0,
	@oComponent_Id INT = NULL OUTPUT,
	@iHaulage_Raw_Resolve_All BIT = 1,
	@iName VARCHAR(31) = NULL 
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @Layer INT
	DECLARE @IsMultiComponent BIT
	DECLARE @BuildStartDate DATETIME
	DECLARE @BuildStartShift CHAR(1)
	
	SELECT @TransactionName = 'AddStockpileBuildComponent',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END 

    BEGIN TRY
		--Get Multi component flag
		SELECT @IsMultiComponent = Is_Multi_Component
		FROM dbo.Stockpile
		WHERE Stockpile_Id = @iStockpile_Id

		--Check build exists
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.StockpileBuild
				WHERE Stockpile_Id = @iStockpile_Id
					AND Build_Id = @iBuild_Id
			)
		BEGIN
			Raiserror ('The stockpile build does not exist', 16, 1)	
		END

		--Validate that if it is single component that we do not already have a component
		IF @IsMultiComponent = 0 
			AND EXISTS 
				(
					SELECT 1 
					FROM dbo.StockpileBuildComponent
					WHERE Stockpile_Id = @iStockpile_Id 
						AND Build_Id = @iBuild_Id
				)
		BEGIN
			Raiserror ('The stockpile build is not allowed any more components', 16, 1)	
		END

		--Work out component id & layer
		SELECT @oComponent_Id = IsNull(@oComponent_Id, IsNull(Max(Component_Id), 0) + 1),
			@Layer = IsNull(@iLayer, IsNull(Max(Layer), 0) + 1)
		FROM dbo.StockpileBuildComponent AS SBC
		WHERE Stockpile_Id = @iStockpile_Id
			AND Build_Id = @iBuild_Id

		--Insert the component
		INSERT INTO dbo.StockpileBuildComponent
		(
			Stockpile_Id, Build_Id, Component_Id, Creation_Datetime, 
			Layer, Name, Start_Tonnes
		)
		SELECT @iStockpile_Id, @iBuild_Id, @oComponent_Id, GetDate(), 
			@Layer, @iName, @iStart_Tonnes
		
		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXECUTE dbo.HaulageRawResolveAll
		END

		SELECT @BuildStartDate = Start_Date,
			@BuildStartShift = Start_Shift
		FROM dbo.StockpileBuild
		WHERE Stockpile_Id = @iStockpile_Id
			AND Build_Id = @iBuild_Id
	
		--Only need to recalc if the stockpile was active
		IF @BuildStartDate IS NOT NULL
		BEGIN
			EXEC dbo.RecalcL2Raise
				@pDate = @BuildStartDate,
				@pShift = @BuildStartShift
		END

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO 
GRANT EXECUTE ON dbo.AddStockpileBuildComponent TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileBuildComponent">
 <Procedure>
	Adds a new record in the StockpileBuildComponent table.
	Raise a Level 2 Recalc for all dates when the associated StockpileBuild record is active.
	If @iHaulage_Raw_Resolve_All = 1 checks if addition of stockpile has resolved haulage errors relating to this stockpile 
	by calling HaulageRawResolveAll
	Errors are raised if:
		The stockpile build does not exist
		The stockpile build is not allowed any more components
		The stockpile build already has a layer with this number
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ValidateStockpileStateChange.prc'
GO

If Object_Id('dbo.ValidateStockpileStateChange') Is Not Null
	Drop Procedure dbo.ValidateStockpileStateChange
Go

CREATE Procedure dbo.ValidateStockpileStateChange
(
	@iStockpile_Id Int,
	@iBuild_Id Int,
	@iStockpile_State_Id Char(10),
	@iStart_Date Datetime,
	@iStart_Shift Char(1),
	@iReclaim_Start_Date Datetime,
	@iReclaim_Start_Shift Char(1),
	@iEnd_Date Datetime,
	@iEnd_Shift Char(1),
	@iCompletion_Description VarChar(255) = Null,
	@iNew_Build Bit = 0
)

With Encryption 
As

Begin

	Declare @Is_Multi_Component Bit
	Declare @Is_Multi_Build Bit
	Declare @Current_Build_Id Int
	Declare @Current_Start_Date Datetime
	Declare @Current_Start_Shift Char(1)
	Declare @Current_Reclaim_Start_Date Datetime
	Declare @Current_Reclaim_Start_Shift Char(1)
	Declare @Current_End_Date Datetime
	Declare @Current_End_Shift Char(1)
	Declare @Current_Stockpile_State_Id Char(10)
	Declare @Previous_Build_Id Int
	Declare @Previous_Start_Date Datetime
	Declare @Previous_Start_Shift Char(1)
	Declare @Previous_Reclaim_Start_Date Datetime
	Declare @Previous_Reclaim_Start_Shift Char(1)
	Declare @Previous_End_Date Datetime
	Declare @Previous_End_Shift Char(1)
	Declare @Previous_Stockpile_State_Id Char(10)
	Declare @Rules_Level Varchar(31)
	Declare @Rules_Historic Bit
	Declare @Count Int
	Declare @oIs_Error Bit
	Declare @oError_Description Varchar(255)

	Declare @CALC_STOCKPILE_STATE_TEST Table
	(
		Build_Id Int,
		Start_Date Datetime,
		Start_Shift Char(1) Collate Database_Default,
		Reclaim_Start_Date Datetime,
		Reclaim_Start_Shift Char(1),
		End_Date Datetime,
		End_Shift Char(1) Collate Database_Default,
		Stockpile_State_Id Char(10) Collate Database_Default,
		Primary Key (Build_Id)
	)

	Declare @Build_Curs Cursor

	Set Nocount On

	Set @oIs_Error = 0
	Set @oError_Description = Null

	/* Get some details about the stockpile */
	Select @Is_Multi_Component = Is_Multi_Component,
		@Is_Multi_Build = Is_Multi_Build
	From dbo.Stockpile
	Where Stockpile_Id = @iStockpile_Id

	/* If the stockpile does not exist */
	If Not Exists (	Select 1
					From dbo.Stockpile
					Where Stockpile_Id = @iStockpile_Id)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The stockpile does not exist'
	End
	/* If the given build does not exist */
	Else If (@iNew_Build = 0
			And	Not Exists (Select 1
							From StockpileBuild
							Where Stockpile_Id = @iStockpile_Id
								And Build_Id = @iBuild_Id)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The given stockpile build does not exist'
	End
	/* If the stockpile state is not valid */
	Else If Not Exists (Select 1
						From dbo.StockpileState
						Where Stockpile_State_Id = @iStockpile_State_Id)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The given stockpile state is not valid'
	End	
	/* If no start date/shift can be determined cannot determine which dates to recalculate*/
	Else If (@iStart_Date Is Null
			Or @iStart_Shift Is Null)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'Start Date/Shift can not be determined'
	End 	

	/* If the start shift is invalid - previous check ensures start shift is given*/
	Else If Not Exists (	Select *
							From dbo.ShiftType
							Where Shift = @iStart_Shift)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The start shift is not valid'
	End
	/* If the reclaim start shift is invalid */
	Else If (	@iReclaim_Start_Shift Is Not Null
		And Not Exists (	Select *
							From dbo.ShiftType
							Where Shift = @iReclaim_Start_Shift)
		)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The reclaim start shift is not valid'
	End
	/* If the end shift is invalid */
	Else If (	@iEnd_Shift Is Not Null
		And Not Exists (	Select *
							From dbo.ShiftType
							Where Shift = @iEnd_Shift)
		)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The end shift is not valid'
	End
	/* If Start Date is specified and Start Shift is not specified or vice versa*/
	Else If (	(@iStart_Date Is Not Null 
				And @iStart_Shift Is Null)
			Or	(@iStart_Shift Is Not Null 
				And @iStart_Date Is Null)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If Start Date is set Start Shift must also be provided, and vice versa'
	End
	/* If Reclaim Start Date is specified and Reclaim Start Shift is not specified */
	Else If (	(@iReclaim_Start_Date Is Not Null 
				And @iReclaim_Start_Shift Is Null)
			Or	(@iReclaim_Start_Shift Is Not Null 
				And @iReclaim_Start_Date Is Null)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If Reclaim Start Date is set Reclaim Start Shift must also be provided, and vice versa'
	End
	/* If End Date is specified and End Shift is not specified */
	Else If (	(@iEnd_Date Is Not Null 
				And @iEnd_Shift Is Null)
			Or	(@iEnd_Shift Is Not Null 
				And @iEnd_Date Is Null)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If End Date is set End Shift must also be provided, and vice versa'
	End
	/* If Reclaim Start Date/Shift is specified it must be after Start Date Shift */
	Else If (	(@iReclaim_Start_Date Is Not Null)				
				And (dbo.CompareDateShift(@iReclaim_Start_Date, 
												@iReclaim_Start_Shift, 
												'>', 
												@iStart_Date, 
												@iStart_Shift) = 0)  
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If Reclaim Start Date is specified it must be after start date and shift'
	End
	/* If End Date/Shift is specified it must be after Start Date Shift */
	Else If (	(@iEnd_Date Is Not Null)
				And (dbo.CompareDateShift(@iEnd_Date, 
												@iEnd_Shift, 
												'>', 
												@iStart_Date, 
												@iStart_Shift) = 0)  
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If End Date/Shift is specified it must be after Start Date/Shift'
	End
	/* If End Date/Shift is specified it must be after Reclaim Date Shift if Specified */
	Else If (	@iEnd_Date Is Not Null
				And @iReclaim_Start_Date Is Not Null
				And (dbo.CompareDateShift(@iEnd_Date, 
												@iEnd_Shift, 
												'>', 
												@iReclaim_Start_Date, 
												@iReclaim_Start_Shift) = 0)  
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'End Date/Shift must be after Reclaim Start Date/Shift'
	End
	/* If the start date is in an approved month */
	Else If (dbo.IsInApprovedMonth (@iStart_Date) = 1) 
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The stockpile build start date falls in an already approved month'
	End
	/* If Completion Description is specified and End Date/Shift is not specified */
	Else If (	@iCompletion_Description Is Not Null 
			And (@iEnd_Date Is Null 
				Or @iEnd_Shift Is Null)
		)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If Completion Description is specified, End Date/Shift must be specified'
	End
	/* If Completion Description is specified and Stockpile_State_Id is not CLOSED */
	Else If (	@iStockpile_State_Id <> 'CLOSED'
				And @iCompletion_Description Is Not Null)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If Completion Description is specified, Stockpile State must be closed'
	End
	/* If Stockpile_State_Id is NORMAL or BUILDING reclaim/end dates and shifts cannot be specified  */
	Else If (	@iStockpile_State_Id In ('NORMAL', 'BUILDING')
				And (@iReclaim_Start_Date Is Not Null
					Or @iEnd_Date Is Not Null)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If BUILDING or NORMAL state cannot have a reclaim or end date specified'
	End
	/* If the stockpile is single build and already has a build */
	Else If (	@Is_Multi_Build = 0
				And @iNew_Build = 1
				And Exists	(	Select 1
								From dbo.StockpileBuild
								Where Stockpile_Id = @iStockpile_Id)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'The stockpile is not allowed any more builds'
	End
	/* If Stockpile is building and already has removals from it */
	Else If (@iStockpile_State_Id = 'BUILDING'
			And	(Exists	(	Select 1
							From dbo.Haulage
							Where Source_Stockpile_Id = @iStockpile_Id
								And Source_Build_Id = @iBuild_Id
								And Haulage_State_Id In ('N', 'A')
						)
				Or Exists (	Select 1
							From dbo.WeightometerSample WS
							Where WS.Source_Stockpile_Id = @iStockpile_Id
								Or dbo.GetWeightometerSourceStockpile(WS.Weightometer_Id, WS.Weightometer_Sample_Date) = @iStockpile_Id
							)
				)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'Stockpile can not enter build mode as it already has removals from it'
	End
	/* If Normal or building check to see if there are any transactions involving this stockpile before the given start date/shift */
	Else If (	(@iStockpile_State_Id = 'NORMAL'
				Or @iStockpile_State_Id = 'BUILDING')
			/* If Stockpile is Single Build only need to match on Stockpile_Id */
            /* otherwise need to match on Stockpile_Id and Build_Id  */
			And	(	Exists (	Select 1
								From dbo.Haulage
								Where	Destination_Stockpile_Id = @iStockpile_Id
									And (	Destination_Build_Id = @iBuild_Id
										Or @Is_Multi_Build = 0)
									And Haulage_Date < @iStart_Date
									And Haulage_State_Id In ('N', 'A')
									And dbo.CompareDateShift(Haulage_Date, 
																	Haulage_Shift,	
																	'<', 
																	@iStart_Date, 
																	@iStart_Shift) = 1)
				Or Exists (	Select 1
							From dbo.WeightometerSample WS
							Where	(WS.Destination_Stockpile_Id = @iStockpile_Id
									Or dbo.GetWeightometerDestinationStockpile(WS.Weightometer_Id, WS.Weightometer_Sample_Date) = @iStockpile_Id
									)
							And WS.Weightometer_Sample_Date < @iStart_Date
							And dbo.CompareDateShift(WS.Weightometer_Sample_Date, 
															WS.Weightometer_Sample_Shift, 
															'<', 
															@iStart_Date, 
															@iStart_Shift) = 1
						)
				)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'This start date can not be used as there are transactions involving this stockpile before this date'
	End
	/* If reclaiming check to see if there are any transactions to this stockpile after the given reclaim date /shift */
	Else If (	@iStockpile_State_Id = 'RECLAIMING'
			/* If Stockpile is Single Build only need to match on Stockpile_Id */
			/* otherwise need to match on Stockpile_Id and Build_Id  */
			And	(	Exists (	Select 1
								From dbo.Haulage
								Where	Destination_Stockpile_Id = @iStockpile_Id
									And (Destination_Build_Id = @iBuild_Id
										Or @Is_Multi_Build = 0)
									And Haulage_Date > @iReclaim_Start_Date
									And Haulage_State_Id In ('N', 'A')
									And dbo.CompareDateShift(Haulage_Date, 
																	Haulage_Shift, 
																	'>=', 
																	@iReclaim_Start_Date, 
																	@iReclaim_Start_Shift) = 1)
				Or Exists (	Select 1
							From dbo.WeightometerSample WS
							Where	(	WS.Destination_Stockpile_Id = @iStockpile_Id
									Or dbo.GetWeightometerDestinationStockpile(WS.Weightometer_Id, WS.Weightometer_Sample_Date) = @iStockpile_Id
									)
							And WS.Weightometer_Sample_Date > @iReclaim_Start_Date
							And dbo.CompareDateShift(WS.Weightometer_Sample_Date, 
															WS.Weightometer_Sample_Shift, 
															'>=', 
															@iReclaim_Start_Date, 
															@iReclaim_Start_Shift) = 1
						)
				)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'Stockpile can not enter reclaim mode after this date as there are additions to it after this date'
	End
	/* If closing check to see if there are any transactions involving this stockpile after the given end date/shift */
	Else If (	@iStockpile_State_Id = 'CLOSED'
			And	(	Exists (	Select 1
								From dbo.Haulage
								Where	(	(Destination_Stockpile_Id = @iStockpile_Id
											And (	Destination_Build_Id = @iBuild_Id
												Or @Is_Multi_Build = 0)
											)
										Or	(Source_Stockpile_Id = @iStockpile_Id
											And (	Source_Build_Id = @iBuild_Id
												Or @Is_Multi_Build = 0)
											)
										)
									And Haulage_Date > @iEnd_Date
									And Haulage_State_Id In ('N', 'A')
									And dbo.CompareDateShift(Haulage_Date, 
																	Haulage_Shift, 
																	'>', 
																	@iEnd_Date, 
																	@iEnd_Shift) = 1)
				Or Exists (	Select 1
							From dbo.WeightometerSample WS
							Where	(	WS.Source_Stockpile_Id = @iStockpile_Id
								Or WS.Destination_Stockpile_Id = @iStockpile_Id
								Or dbo.GetWeightometerSourceStockpile(WS.Weightometer_Id, WS.Weightometer_Sample_Date) = @iStockpile_Id
								Or dbo.GetWeightometerDestinationStockpile(WS.Weightometer_Id, WS.Weightometer_Sample_Date) = @iStockpile_Id
								)
							And WS.Weightometer_Sample_Date > @iEnd_Date
							And dbo.CompareDateShift(WS.Weightometer_Sample_Date, 
															WS.Weightometer_Sample_Shift, 
															'>', 
															@iEnd_Date, 
															@iEnd_Shift) = 1
						)
				)
			)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'Stockpile can not be closed on this date as there are transactions involving it after this date'
	End
	/* If Stockpile State is NORMAL or Building check Reclaim and End dates and shifts not set*/
	Else If (	@iStockpile_State_Id In ('NORMAL', 'BUILDING')
			And	(@iReclaim_Start_Date Is Not Null
				Or @iEnd_Date Is Not Null)
			) 
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If BUILDING or NORMAL cannot have Reclaim or End dates specified'
	End
	/* If Stockpile State is RECLAIMING check End dates not set*/
	Else If (	@iStockpile_State_Id = 'RECLAIMING'
			And	@iEnd_Date Is Not Null)
	Begin
		Set @oIs_Error = 1
		Set @oError_Description = 'If RECLAIMING cannot have End dates specified'
	End
	Else
	Begin
		Declare @reclaimRules Varchar(255),
			@historicReclaimRules Varchar(255)

		Exec dbo.GetSystemSetting
			@iSetting_Id = 'STOCKPILE_RECLAIM_RULES_LEVEL',
			@iValue = @reclaimRules Output

		Exec dbo.GetSystemSetting
			@iSetting_Id = 'STOCKPILE_RECLAIM_RULES_HISTORIC',
			@iValue = @historicReclaimRules Output

		/* Get the rule settings for stockpile state changes */
		Select @Rules_Level = Left(@reclaimRules, 31)
		Select @Rules_Historic = 	Case When @historicReclaimRules = 'TRUE' Then
										1
									Else
										0
									End
		Begin Transaction

		/* Populate the table to hold all the details about all the builds of this stockpile in terms of dates and states */
		Insert Into @CALC_STOCKPILE_STATE_TEST
		(
			Build_Id,Start_Date,Start_Shift,Reclaim_Start_Date,Reclaim_Start_Shift,
			End_Date,End_Shift,Stockpile_State_Id
		)
		Select Build_Id, Start_Date, Start_Shift, Reclaim_Start_Date, Reclaim_Start_Shift,
			End_Date, End_Shift, Stockpile_State_Id
		From dbo.StockpileBuild
		Where Stockpile_Id = @iStockpile_Id

		Select @Count = Count(*)
		From @CALC_STOCKPILE_STATE_TEST
		Where Build_Id = @iBuild_Id

		If (@Count = 0)
		Begin
			Insert Into @CALC_STOCKPILE_STATE_TEST
			(
				Build_Id,Start_Date,Start_Shift,Reclaim_Start_Date,Reclaim_Start_Shift,
				End_Date,End_Shift,Stockpile_State_Id
			)
			Values
			(
				@iBuild_Id, @iStart_Date, @iStart_Shift, @iReclaim_Start_Date, @iReclaim_Start_Shift,
				@iEnd_Date,@iEnd_Shift,@iStockpile_State_Id
			)
		End
		Else 
		Begin
			Update @CALC_STOCKPILE_STATE_TEST
			Set	Start_Date = @iStart_Date,
				Start_Shift = @iStart_Shift,
				Reclaim_Start_Date = @iReclaim_Start_Date,
				Reclaim_Start_Shift = Reclaim_Start_Shift,
				End_Date = @iEnd_Date,
				End_Shift = @iEnd_Shift,
				Stockpile_State_Id = @iStockpile_State_Id
			Where Build_Id = @iBuild_Id
		End

		/* Get a cursor of each build */
		Set @Build_Curs = Cursor Local Fast_Forward Read_Only For
			Select Build_Id, Start_Date, Start_Shift, Reclaim_Start_Date, Reclaim_Start_Shift,
				End_Date, End_Shift, Stockpile_State_Id
			From @CALC_STOCKPILE_STATE_TEST
			Order By Start_Date, dbo.GetShiftTypeOrderNo(Start_Shift)

		Open @Build_Curs

		Fetch Next From @Build_Curs Into
			@Current_Build_Id, @Current_Start_Date, @Current_Start_Shift, @Current_Reclaim_Start_Date, @Current_Reclaim_Start_Shift,
			@Current_End_Date, @Current_End_Shift, @Current_Stockpile_State_Id

		/* For each build and while there are no errors */
		While ((@@Fetch_Status = 0) And (@oIs_Error = 0))
		Begin
			/* If the reclaim date/shift has been set for this stockpile and it is on or before the start date/shift */
			If (	(@Current_Reclaim_Start_Date Is Not Null)
				And (	(@Current_Reclaim_Start_Date < @Current_Start_Date)
					Or	(@Current_Reclaim_Start_Date = @Current_Start_Date
						And dbo.GetShiftTypeOrderNo(@Current_Reclaim_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Current_Start_Shift))
					)
				)
			Begin
				If (@oIs_Error = 0)
				Begin
					Set @oIs_Error = 1
					Set @oError_Description = 'The reclaim start date/shift for build ' + Cast(@Current_Build_Id As Varchar) + ' falls on or before it''s start date/shift'
				End
			End

			/* If the end date/shift has been set for this stockpile and it is on or before the start date/shift */
			If (	(@Current_End_Date Is Not Null)
				And (	(@Current_End_Date < @Current_Start_Date)
					Or	(@Current_End_Date = @Current_Start_Date
						And dbo.GetShiftTypeOrderNo(@Current_End_Shift) <= dbo.GetShiftTypeOrderNo(@Current_Start_Shift))
					)
				)
			Begin
				If (@oIs_Error = 0)
				Begin
					Set @oIs_Error = 1
					Set @oError_Description = 'The end date/shift for build ' + Cast(@Current_Build_Id As Varchar) + ' falls on or before it''s start date/shift'
				End
			End

			/* If the end date/shift and reclaim start date/shift has been set for this stockpile and it is on or before the start date/shift */
			If (	(@Current_End_Date Is Not Null) 
				And (@Current_Reclaim_Start_Date Is Not Null)
				And (	(@Current_Reclaim_Start_Date > @Current_End_Date)
					Or	(@Current_Reclaim_Start_Date = @Current_End_Date
						And dbo.GetShiftTypeOrderNo(@Current_Reclaim_Start_Shift) >= dbo.GetShiftTypeOrderNo(@Current_End_Shift))
					)
				)
			Begin
				If (@oIs_Error = 0)
				Begin
					Set @oIs_Error = 1
					Set @oError_Description = 'The reclaim start date/shift for build ' + Cast(@Current_Build_Id As Varchar) + ' falls on or after it''s end date/shift'
				End
			End

			/* If this is not the first build */
			If (@Previous_Build_Id Is Not Null)
			Begin
				/* If the rules level is set to level 2 */
				If (@Rules_Level = 'EXCLUSIVE')
				Begin
					/* If the previous build is open, or is closed but has it's close date/shift on or after the start of the current builds start date/shift, */
					/*  and the current stockpile build is still open or historical data is to be checked */
					If	(	(	(@Previous_End_Date Is Null)  
							Or	(	(@Previous_End_Date > @Current_Start_Date)
								Or	(@Previous_End_Date = @Current_Start_Date
									And dbo.GetShiftTypeOrderNo(@Previous_End_Shift) >= dbo.GetShiftTypeOrderNo(@Current_Start_Shift))
								)
							)
							And	(@Current_End_Date Is Null 
								Or @Rules_Historic = 1)
						)
					Begin
						If (@oIs_Error = 0)
						Begin
							Set @oIs_Error = 1
							Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + ' is opened before build '
											+ Cast(@Previous_Build_Id As Varchar) + ' is closed'
						End
					End
				End

				/* Otherwise, if the rules level is set to level 1 */
				If (@Rules_Level = 'RECLAIMABLE')
				Begin
					/* If the previous build was 'NORMAL' */
					If (@Previous_Stockpile_State_Id = 'NORMAL')
					Begin
						If (@oIs_Error = 0)
						Begin
							Set @oIs_Error = 1
							Set @oError_Description = 'Build ' + Cast(@Previous_Build_Id As Varchar) + ' is in NORMAL state with other builds following it'
						End
					End

					/* Otherwise, if the previous build was 'BUILDING' */
					If (@Previous_Stockpile_State_Id = 'BUILDING')
					Begin
						If (@oIs_Error = 0)
						Begin
							Set @oIs_Error = 1
							Set @oError_Description = 'Build ' + Cast(@Previous_Build_Id As Varchar) + ' is in BUILDING state with other builds following it'
						End
					End
		
					/* Otherwise, if the previous build was 'RECLAIMING' */
					If (@Previous_Stockpile_State_Id = 'RECLAIMING')
					Begin
						/* If this build is 'NORMAL' */
						If (@Current_Stockpile_State_Id = 'NORMAL')
						Begin
							If (@oIs_Error = 0)
							Begin
								Set @oIs_Error = 1
								Set @oError_Description = 'Build ' + Cast(@Previous_Build_Id As Varchar) + ' is in RECLAIMING state while build '
												+ Cast(@Current_Build_Id As Varchar) + ' is already in NORMAL state'

							End
						End
		
						/* Otherwise, if this build is 'RECLAIMING' */
						If (@Current_Stockpile_State_Id = 'RECLAIMING')
						Begin
							If (@oIs_Error = 0)
							Begin
								Set @oIs_Error = 1
								Set @oError_Description = 'Build ' + Cast(@Previous_Build_Id As Varchar) + ' is in RECLAIMING state while build '
												+ Cast(@Current_Build_Id As Varchar) + ' is already in RECLAIMING state'
							End
						End
		
						/* Otherwise, if this build is 'BUILDING' */
						If (@Current_Stockpile_State_Id = 'BUILDING')
						Begin
							/* Check to make sure that the start date of this build does not fall before the reclaim start date of the previous build */
							If	(	(@oIs_Error = 0)
								And	(	(@Current_Start_Date < @Previous_Reclaim_Start_Date)
									Or	(	(@Current_Start_Date = @Previous_Reclaim_Start_Date)
										And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) < dbo.GetShiftTypeOrderNo(@Previous_Reclaim_Start_Shift))
										)
									)
								)
							Begin
								Set @oIs_Error = 1
								Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls before build '
												+ Cast(@Previous_Build_Id As Varchar) + '''s reclaim start date/shift'
							End
						End
		
						/* Otherwise, if this build is 'CLOSED' */
						If (@Current_Stockpile_State_Id = 'CLOSED')
						Begin
							If (@oIs_Error = 0)
							Begin
								Set @oIs_Error = 1
								Set @oError_Description = 'Build ' + Cast(@Previous_Build_Id As Varchar) + ' is in RECLAIMING state while build '
												+ Cast(@Current_Build_Id As Varchar) + ' is already in CLOSED state'
							End
						End
					End
		
					/* Otherwise, if the previous build was 'CLOSED' */
					If (@Previous_Stockpile_State_Id = 'CLOSED')
					Begin
						/* If this build is 'NORMAL' */
						If (@Current_Stockpile_State_Id = 'NORMAL')
						Begin
							/* Check to make sure that the start date of this build does not fall on or before the end date of the previous build */
							If	(	(@oIs_Error = 0)
								And	(	(@Current_Start_Date < @Previous_End_Date)
									Or	(	(@Current_Start_Date = @Previous_End_Date)
										And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Previous_End_Shift))
										)
									)
								)
							Begin
								Set @oIs_Error = 1
								Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls on or before build '
												+ Cast(@Previous_Build_Id As Varchar) + '''s end date/shift'
							End
						End
		
						/* Otherwise, if this build is 'BUILDING' */
						If (@Current_Stockpile_State_Id = 'BUILDING')
						Begin
							/* If the previous build had a reclaiming period */
							If (@Previous_Reclaim_Start_Date Is Not Null)
							Begin
								/* Check to make sure that the start date of this build does not fall before the reclaim start date of the previous build */
								If	(	(@oIs_Error = 0)
									And	(	(@Current_Start_Date < @Previous_Reclaim_Start_Date)
										Or	(	(@Current_Start_Date = @Previous_Reclaim_Start_Date)
											And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) < dbo.GetShiftTypeOrderNo(@Previous_Reclaim_Start_Shift))
											)
										)
									)
								Begin
									Set @oIs_Error = 1
									Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls before build '
													+ Cast(@Previous_Build_Id As Varchar) + '''s reclaim start date/shift'
								End
							End
							Else
							Begin
								/* Check to make sure that the start date of this build does not fall on or before the end date of the previous build */
								If	(	(@oIs_Error = 0)
									And	(	(@Current_Start_Date < @Previous_End_Date)
											Or (	(@Current_Start_Date = @Previous_End_Date)
												And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Previous_End_Shift))
												)
										)
									)
								Begin
									Set @oIs_Error = 1
									Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls on or before build '
													+ Cast(@Previous_Build_Id As Varchar) + '''s end date/shift'
								End
							End
						End
		
						/* Otherwise, if this build is 'RECLAIMING' */
						If (@Current_Stockpile_State_Id = 'RECLAIMING')
						Begin
							/* If the previous build had a reclaiming period */
							If (@Previous_Reclaim_Start_Date Is Not Null)
							Begin
								/* Check to make sure that the start date of this build does not fall before the reclaim start date of the previous build */
								If	(	(@oIs_Error = 0)
										And (	(@Current_Start_Date < @Previous_Reclaim_Start_Date)
											Or	(	(@Current_Start_Date = @Previous_Reclaim_Start_Date)
												And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) < dbo.GetShiftTypeOrderNo(@Previous_Reclaim_Start_Shift))
												)
											)
									)
								Begin
									Set @oIs_Error = 1
									Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls before build '
													+ Cast(@Previous_Build_Id As Varchar) + '''s reclaim start date/shift'
								End
							End
							Else
							Begin
								/* Check to make sure that the start date of this build does not fall on or before the end date of the previous build */
								If	(	(@oIs_Error = 0)
									And (	(@Current_Start_Date < @Previous_End_Date)
										Or	(	(@Current_Start_Date = @Previous_End_Date)
											And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Previous_End_Shift))
											)
										)
									)
								Begin
									Set @oIs_Error = 1
									Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls on or before build '
													+ Cast(@Previous_Build_Id As Varchar) + '''s end date/shift'
								End
							End
						End
		
						/* Otherwise, if this build is 'CLOSED' */
						If (@Current_Stockpile_State_Id = 'CLOSED')
						Begin
							/* If the option to check historical data is set */
							If (@Rules_Historic = 1)
							Begin
								/* If the previous build had a reclaiming period */
								If (@Previous_Reclaim_Start_Date Is Not Null)
								Begin
									/* Check to make sure that the start date of this build does not fall before the reclaim start date of the previous build */
									If	(	(@oIs_Error = 0)
										And (	(@Current_Start_Date < @Previous_Reclaim_Start_Date)
											Or	(	(@Current_Start_Date = @Previous_Reclaim_Start_Date)
												And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) < dbo.GetShiftTypeOrderNo(@Previous_Reclaim_Start_Shift))
												)
											)
										)
									Begin
										Set @oIs_Error = 1
										Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls before build '
														+ Cast(@Previous_Build_Id As Varchar) + '''s reclaim start date/shift'
									End
								End
								Else
								Begin
									/* Check to make sure that the start date of this build does not fall on or before the end date of the previous build */
									If	(	(@oIs_Error = 0)
										And (	(@Current_Start_Date < @Previous_End_Date)
											Or	(	(@Current_Start_Date = @Previous_End_Date)
												And (dbo.GetShiftTypeOrderNo(@Current_Start_Shift) <= dbo.GetShiftTypeOrderNo(@Previous_End_Shift))
												)
											)
										)
									Begin
										Set @oIs_Error = 1
										Set @oError_Description = 'Build ' + Cast(@Current_Build_Id As Varchar) + '''s start date/shift falls on or before build '
														+ Cast(@Previous_Build_Id As Varchar) + '''s end date/shift'
									End
								End
							End
						End
					End
				End
			End

			/* Populate the temporary values */
			Set @Previous_Build_Id = @Current_Build_Id
			Set @Previous_Start_Date = @Current_Start_Date
			Set @Previous_Start_Shift = @Current_Start_Shift
			Set @Previous_Reclaim_Start_Date = @Current_Reclaim_Start_Date
			Set @Previous_Reclaim_Start_Shift = @Current_Reclaim_Start_Shift
			Set @Previous_End_Date = @Current_End_Date
			Set @Previous_End_Shift = @Current_End_Shift

			Set @Previous_Stockpile_State_Id = @Current_Stockpile_State_Id
			Fetch Next From @Build_Curs Into
				@Current_Build_Id, @Current_Start_Date, @Current_Start_Shift, @Current_Reclaim_Start_Date, @Current_Reclaim_Start_Shift,
				@Current_End_Date, @Current_End_Shift, @Current_Stockpile_State_Id
		End

		Close @Build_Curs

		Commit Transaction
	End
	
	If @oIs_Error = 1
	Begin
		RaisError(@oError_Description, 16, 1)
	End
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="ValidateStockpileStateChange">
 <Procedure>
		Validation of change of state for a Stockpile record.
	Errors are raised if:
		The reclaim start date/shift for current Build_Id falls on or before it's start date/shift.
		The end date/shift for current Build_Id falls on or before it's start date/shift.
		The reclaim start date/shift for current Build_Id falls on or after it's end date/shift.
		The current Build_Id is opened before th previous Build_Id is closed.
		The previous Build_Id is in NORMAL state with other builds following it.
		The previous Build_Id is in BUILDING state with other builds following it.
		The previous Build_Id is in RECLAIMING state while the current Build_Id is already in NORMAL state.
		The previous Build_Id is in RECLAIMING state while the current Build_Id is already in RECLAIMING state.
		The previous Build_Id is in RECLAIMING state while the current Build_Id is already in CLOSED state.
		The current Build_Id start date/shift falls on or before the previous Build_Id end date/shift.
		The current Build_Id start date/shift falls before the previous Build_Id reclaim start date/shift.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileBuild.prc'
GO

IF OBJECT_ID('dbo.AddStockpileBuild') IS NOT NULL 
     DROP PROCEDURE dbo.AddStockpileBuild 
GO 
  
CREATE PROCEDURE dbo.AddStockpileBuild 
( 
    @iStockpile_Id INT,
	@iBuild_Id INT = NULL,
	@iStart_Date DATETIME,
	@iStart_Shift CHAR(1),
	@iHaulage_Raw_Resolve_All BIT = 1,
	@iReclaim_Start_Date DATETIME = NULL,
	@iReclaim_Start_Shift CHAR(1) = NULL,
	@iEnd_Date DATETIME = NULL,
	@iEnd_Shift CHAR(1) = NULL,
	@iCompletion_Description VARCHAR(255) = NULL,
	@iStockpile_State_Id VARCHAR(10) = 'NORMAL',
	@iStart_Tonnes FLOAT = 0,
	@oBuild_Id INT = NULL OUTPUT,
	@oComponent_Id INT = NULL OUTPUT
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
	
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1)
		
	SELECT @TransactionName = 'AddStockpileBuild',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY
		SELECT @StartDate = dbo.GetDateDay(@iStart_Date),
			@EndDate =  dbo.GetDateDay(@iEnd_Date),
			@StartShift = 
				CASE WHEN @iStart_Date IS NULL THEN
					NULL
				ELSE
					IsNull(@iStart_Shift, dbo.GetFirstShiftType())
				END,
			@EndShift = 
				CASE WHEN @iEnd_Date IS NULL THEN
					NULL
				ELSE
					IsNull(@iEnd_Shift, dbo.GetLastShiftType())
				END

		--Work out build number if not provided
		SELECT @oBuild_Id = IsNull(@iBuild_Id, IsNull(Max(Build_Id), 0) + 1)
		FROM dbo.StockpileBuild
		WHERE Stockpile_Id = @iStockpile_Id

		--Check to see if this change creates any conflicts with other builds
		EXEC dbo.ValidateStockpileStateChange 
			@iStockpile_Id = @iStockpile_Id, 
			@iBuild_Id = @oBuild_Id, 
			@iStockpile_State_Id = @iStockpile_State_Id, 
			@iStart_Date = @StartDate, 
			@iStart_Shift = @StartShift,
			@iReclaim_Start_Date = @iReclaim_Start_Date, 
			@iReclaim_Start_Shift = @iReclaim_Start_Shift,
			@iEnd_Date = @EndDate, 
			@iEnd_Shift = @EndShift,
			@iCompletion_Description = @iCompletion_Description,
			@iNew_Build = 1

		INSERT INTO dbo.StockpileBuild
		(
			Stockpile_Id, Build_Id, Creation_Datetime, 
			Start_Date, Start_Shift, Stockpile_State_Id,
			Reclaim_Start_Date, Reclaim_Start_Shift,
			End_Date, End_Shift, Completion_Description	
		)
		SELECT @iStockpile_Id, @oBuild_Id, GetDate(), 
			@StartDate, @StartShift, @iStockpile_State_Id,
			@iReclaim_Start_Date, @iReclaim_Start_Shift,
			@EndDate, @EndShift, @iCompletion_Description	

		--Add default component
		--Recalc Raise & Haulage Resolution done in this step 
		--since nothing can be recalced or resolved to until this step.
		EXEC dbo.AddStockpileBuildComponent
			@iStockpile_Id = @iStockpile_Id,
			@iBuild_Id = @oBuild_Id,
			@iStart_Tonnes = @iStart_Tonnes,
			@iHaulage_Raw_Resolve_All = @iHaulage_Raw_Resolve_All,
			@oComponent_Id = @oComponent_Id OUTPUT

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	 
END 
GO 
GRANT EXECUTE ON dbo.AddStockpileBuild TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileBuild">
 <Procedure>
	Adds a stockpile build to the stockpile build table. It will validate all details using ValidateStockpileBuildStateChange.
	Once the build has been added it will also add a default component to the build.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileStockpileTypePeriod.prc'
GO

If Object_Id('dbo.AddStockpileStockpileTypePeriod') Is Not Null
	Drop Procedure dbo.AddStockpileStockpileTypePeriod
Go

Create Procedure dbo.AddStockpileStockpileTypePeriod
(
	@iStockpile_Id Int,
	@iStockpile_Type_Id VarChar(31),
	@iStart_Date Datetime
)

With Encryption 
As

Begin

	Declare @Previous_Period_End_Date Datetime

	Set Nocount On

	-- Work out the new end date for the previous period, based on the start date provided for this new period
	If (@iStart_Date Is Not Null)
	Begin
		Set @Previous_Period_End_Date = dbo.GetDateDay(DateAdd(Day, -1, @iStart_Date))
	End
	Else
	Begin
		Set @Previous_Period_End_Date = Null
	End

	-- If a record with the same details as this already exists
	If Exists (	Select 1
				From dbo.StockpileStockpileTypePeriod SSTP
				Where SSTP.Stockpile_Id = @iStockpile_Id 
					And (	End_Date = @Previous_Period_End_Date
						Or (@Previous_Period_End_Date Is Null
							And End_Date Is Null)
						)
				)
	Begin
		Raiserror ('A record already exists for this Stockpile Stockpile_Type period', 16, 1)
	End

	-- If there are records in the table for this Stockpile/Stockpile type which have an end date 
	-- which is after this previous period end date
	Else If Exists (Select 1
					From dbo.StockpileStockpileTypePeriod SSTP
					Where SSTP.Stockpile_Id = @iStockpile_Id 
						And End_Date > @Previous_Period_End_Date)
	Begin
		Raiserror ('The given period falls in an existing defined period for this Stockpile Stockpile_Type factor period', 16, 1)
	End
	Else
	Begin

		Begin Transaction

		-- Set the current last record's end date to the given previous period end date, if one exists
		Update SSTP
		Set	End_Date = @Previous_Period_End_Date
		From dbo.StockpileStockpileTypePeriod SSTP
		Where SSTP.Stockpile_Id = @iStockpile_Id 
			And End_Date Is Null

		-- Insert the new record
		Insert Into dbo.StockpileStockpileTypePeriod
		(
			Stockpile_Id, Stockpile_Type_Id, End_Date
		)
		Values 
		(
			@iStockpile_Id, @iStockpile_Type_Id, Null
		)

		Commit Transaction

	End

End
GO
GRANT EXECUTE ON dbo.AddStockpileStockpileTypePeriod TO CoreStockpileManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileStockpileTypePeriod">
 <Procedure>
	Adds a new record in the StockpileStockpileTypePeriod table and updates the end date of the 
	previous record for the @iStockpile_Id to be the date before @iStart_Date
	
	Errors are raised if:
		A record already exists for this Stockpile Stockpile_Type period
		The given period falls in an existing defined period for this Stockpile Stockpile_Type factor period
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpile.prc'
GO

IF OBJECT_ID('dbo.AddStockpile') IS NOT NULL 
     DROP PROCEDURE dbo.AddStockpile 
GO 
  
CREATE PROCEDURE dbo.AddStockpile 
( 
	@iStockpile_Name VARCHAR(31),
	@iDescription VARCHAR(255) = NULL,
	@iStart_Date DATETIME = NULL,
	@iStart_Shift CHAR(1) = NULL,
	@iIs_Multi_Build BIT = 0,
	@iIs_Multi_Component BIT = 0,
	@iStockpile_Type_Id VARCHAR(31) = 'AVERAGE',
	@iMaterial_Type_Id INT,
	@iIs_In_Reports BIT = 1,
	@iMax_Tonnes FLOAT = 0,
	@iIs_Visible BIT = 1,
	@iHaulage_Raw_Resolve_All BIT = 1,
	@iReclaim_Start_Date DATETIME = NULL,
	@iReclaim_Start_Shift CHAR(1) = NULL,
	@iEnd_Date DATETIME = NULL,
	@iEnd_Shift CHAR(1) = NULL,
	@iCompletion_Description VARCHAR(255) = NULL,
	@iStockpile_State_Id VARCHAR(10) = 'NORMAL',
	@iNotes VARCHAR(4095) = NULL,
	@iOpening_Tonnes FLOAT = 0,
	@oStockpile_Id INT = NULL OUTPUT,
	@oBuild_Id INT = NULL OUTPUT,
	@oComponent_Id INT = NULL OUTPUT
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'AddStockpile',
		@TransactionCount = @@TRANCOUNT

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
    BEGIN TRY
		--Shifts and Dates are validated in ValidateStockpileBuildChange so these checks
		--have been removed from this proc
		
		--Validate name is unique
		IF EXISTS
			(
				SELECT 1
				FROM dbo.Stockpile AS S
				WHERE S.Stockpile_Name = @iStockpile_Name
			)
		BEGIN
			Raiserror ('A stockpile with the same name already exists', 16, 1)
		END
		
		--Validate modelling algorithm
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.StockpileType
				WHERE Stockpile_Type_Id = @iStockpile_Type_Id
			)
		BEGIN
			Raiserror ('The stockpile type is not valid', 16, 1)	
		END

		--Validate Material Type
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.MaterialType 
				WHERE Material_Type_Id = @iMaterial_Type_Id
			)
		BEGIN
			Raiserror ('The material type is not valid', 16, 1)	
		END

		--Validate composition flags
		IF @iIs_Multi_Build = 0 AND @iIs_Multi_Component = 1
		BEGIN
			Raiserror ('A stockpile can not be both single build and multi component', 16, 1)
		END

		--Limit on recalc, small change to fix in future if requirement ever appears
		IF @iIs_Multi_Component = 1 AND @iStockpile_Type_Id <> 'AVERAGE'
		BEGIN
			Raiserror ('A stockpile with this stockpile type can not be multi component', 16, 1)	
		END

		--Add New Stockpile
		INSERT INTO dbo.Stockpile
		(
			Stockpile_Name, Description, Creation_Datetime, 
			Material_Type_Id, Is_Multi_Build, Is_Multi_Component,
			Is_Visible, Is_In_Reports, Max_Tonnes, Notes
		)
		SELECT @iStockpile_Name, @iDescription, GetDate(), 
			@iMaterial_Type_Id, @iIs_Multi_Build, @iIs_Multi_Component,
			@iIs_Visible, @iIs_In_Reports, @iMax_Tonnes, @iNotes

		SET @oStockpile_Id = Scope_Identity()

		--Add the stockpile type period
		INSERT INTO dbo.StockpileStockpileTypePeriod
		(
			Stockpile_Id, Stockpile_Type_Id
		)	
		SELECT @oStockpile_Id, @iStockpile_Type_Id
	
		--Build Specific validation is in here
		--Recalc raised in here. Its not raised outside
		--because without a build we cant resolve anything.
		--Haulage Resolution always in here.
		EXEC dbo.AddStockpileBuild 
			@iStockpile_Id = @oStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iStart_Shift = @iStart_Shift,
			@iHaulage_Raw_Resolve_All = @iHaulage_Raw_Resolve_All,
			@iReclaim_Start_Date = @iReclaim_Start_Date,
			@iReclaim_Start_Shift = @iReclaim_Start_Shift,
			@iEnd_Date = @iEnd_Date,
			@iEnd_Shift = @iEnd_Shift,
			@iCompletion_Description = @iCompletion_Description,
			@iStockpile_State_Id = @iStockpile_State_Id,
			@iStart_Tonnes = @iOpening_Tonnes,
			@oBuild_Id = @oBuild_Id OUTPUT,
			@oComponent_ID = @oComponent_Id OUTPUT
	
		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO 
GRANT EXECUTE ON dbo.AddStockpile TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpile">
 <Procedure>
	Adds a new stockpile to Reconcilor and populates the initial stockpile type period
	information. This will also create the default build and component for the stockpile.

	Errors are raised if:
		A stockpile with the same ID already exists
		The stockpile type is not valid
		The material type is not valid
		The stockpile is multi component but stockpiles with this stockpile type can not be multi component		
		The stockpile is both single build and multi component
		The start date for the stockpile falls in an approved month
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddTruckTypeFactorPeriod.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddTruckTypeFactorPeriod'))
	Drop Procedure dbo.AddTruckTypeFactorPeriod
Go

Create Procedure dbo.AddTruckTypeFactorPeriod
(
	@iTruck_Type_Id Int,
	@iStart_Date DateTime,
	@iMax_Tonnes Real,
	@iAve_Tonnes Real,
	@iMin_Tonnes Real 
)

With Encryption 
As

Begin

	Declare @Previous_Period_End_Date Datetime
	Declare @Current_Is_Waste Bit

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	-- Get the end date of the last record before this start date

	-- Work out the new end date for the previous period, based on the start date provided for this new period
	If (@iStart_Date Is Not Null)
	Begin
		Set @Previous_Period_End_Date = dbo.GetDateDay(DateAdd(Day, -1, @iStart_Date))
	End
	Else
	Begin
		Set @Previous_Period_End_Date = Null
	End

	If @iMin_Tonnes > @iMax_Tonnes
	Begin
		Raiserror('The minimum tonnes can not be greater than the maximum tonnes.',16,1)
	End
	
	If @iAve_Tonnes < @iMin_Tonnes Or @iAve_Tonnes > @iMax_Tonnes
	Begin
		Raiserror('The average tonnes must be between the minimum and maximum tonnes.',16,1)
	End

	-- If a record with the same details as this does not already exist
	If Not Exists (Select 1
		From TruckTypeFactorPeriod TTP
		Where TTP.Truck_Type_Id = @iTruck_Type_Id
			And (End_Date = @Previous_Period_End_Date
				Or (@Previous_Period_End_Date Is Null
					And End_Date Is Null
					)
				)
		)
	Begin

		-- If there are no records in the table for this truck type which have an end date 
		-- which is after this previous period end date
		If Not Exists (Select 1
			From TruckTypeFactorPeriod TTP
			Where TTP.Truck_Type_Id = @iTruck_Type_Id
				And End_Date > @Previous_Period_End_Date)
		Begin

			-- Set the current last record's end date to the given previous period end date, if one exists
			Update TTP
			Set	End_Date = @Previous_Period_End_Date
			From TruckTypeFactorPeriod TTP
			Where TTP.Truck_Type_Id = @iTruck_Type_Id
				And End_Date Is Null

			-- Insert the new record
			Insert Into TruckTypeFactorPeriod
			(
				Truck_Type_Id, End_Date, Max_Tonnes, Ave_Tonnes, Min_Tonnes
			)
			Values (@iTruck_Type_Id, null, @iMax_Tonnes, @iAve_Tonnes, @iMin_Tonnes)

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given period falls in an existing defined period for this truck type factor period', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('A record already exists for this truck type factor period', 16, 1)
	End

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.AddTruckTypeFactorPeriod TO CoreUtilityManager



/*
<TAG Name="Data Dictionary" ProcedureName="AddTruckTypeFactorPeriod">
 <Procedure>
	Adds a new record in the TruckTypeFactorPeriod table. 
	Errors are raised if:
		A record already exists for this truck type factor period
		The given period falls in an existing defined period for this truck type factor period
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddTruckType.prc'
GO

If Object_Id('dbo.AddTruckType') Is Not Null 
     Drop Procedure dbo.AddTruckType 
Go 
  
Create Procedure dbo.AddTruckType 
( 
    @iName Varchar(63),
	@iDescription Varchar(255),
	@iIs_Default Bit = 0, 
	@iMax_Tonnes Real,
	@iAve_Tonnes Real,
	@iMin_Tonnes Real,
	@oTruck_Type_Id int = Null Output
) 

With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		If Exists
			(
				Select 1
				From TruckType 
				Where [Name] = @iName
			)
		Begin
			Raiserror('A truck type with this name already exists', 16, 1)
		End	
		
		If @iMin_Tonnes > @iMax_Tonnes
		Begin
			Raiserror('The minimum tonnes can not be greater than the maximum tonnes.',16,1)
		End
		
		If @iAve_Tonnes < @iMin_Tonnes Or @iAve_Tonnes > @iMax_Tonnes
		Begin
			Raiserror('The average tonnes must be between the minimum and maximum tonnes.',16,1)
		End
		
		--If theres no records then make it the default if no default specified
		Select @iIs_Default = 1 
		From TruckType
		Where @iIs_Default = 0
		Having Count(*) = 0

		--Turn defaults off if this new one is the new default
		Update TruckType
		Set Is_Default = 0
		Where @iIs_Default = 1 
			And Is_Default = 1

		Insert Into TruckType
		(
			[Name], Description, Is_Default
		)
		Select @iName, @iDescription, @iIs_Default

		Set @oTruck_Type_Id = @@Identity

		Exec AddTruckTypeFactorPeriod 
			@iTruck_Type_Id = @oTruck_Type_Id,
			@iStart_Date = NULL,
			@iMax_Tonnes = @iMax_Tonnes,
			@iAve_Tonnes = @iAve_Tonnes,
			@iMin_Tonnes = @iMin_Tonnes
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.AddTruckType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddTruckType">
 <Procedure>
	Adds a new record in the TruckType table. If this is the only record in the TruckType table it is set to be the default.
	Errors are raised if:
		A truck type with this name already exists
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddTruck.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddTruck'))
	Drop Procedure dbo.AddTruck
Go

CREATE Procedure dbo.AddTruck
(
	@iTruck_Id Varchar(31),
	@iTruck_Type_Id Int,
	@iDescription Varchar(255) = Null
)

With Encryption 
As

Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If a truck with this name does not already exist */
	If (dbo.DoesTruckExist (@iTruck_Id) = 0)
	Begin
		/* If the given truck type exists */
		If Exists (Select * From TruckType Where Truck_Type_Id = @iTruck_Type_Id)
		Begin
			Insert Into Truck
			 (Truck_Id, Truck_Type_Id, Description)
			Values (@iTruck_Id, @iTruck_Type_Id, @iDescription)

			/* Correct any haulage errors which may be fixed by this addition */
			Exec HaulageRawResolveAll

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given truck type does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('A truck with this name already exists', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
GO
GRANT EXECUTE ON dbo.AddTruck TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddTruck">
 <Procedure>
	Adds a new record in the Truck table.
	Errors are raised if:
		A truck with this name already exists
		The given truck type does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddWasteType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddWasteType'))
	Drop Procedure dbo.AddWasteType
Go

CREATE Procedure dbo.AddWasteType
(
	@iWaste_Type_Id Varchar(31),
	@iDescription Varchar(255) = Null
)

With Encryption 
As

Begin

	Declare @Count Int

	Set Nocount On
	
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the waste type exists */
	Select @Count = Count(*)
	From WasteType
	Where Waste_Type_Id = @iWaste_Type_Id

	/* If one does not exist */
	If (@Count = 0)
	Begin
		Insert Into WasteType
			(Waste_Type_Id, Description)
		Values (@iWaste_Type_Id, @iDescription)

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror('This waste type already exists', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
End
GO
GRANT EXECUTE ON dbo.AddWasteType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddWasteType">
 <Procedure>
	Adds a new record in the WasteType table. 
	Errors are raised if:
		This waste type already exists
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddWeightometerSample.prc'
GO

If Object_Id('dbo.AddWeightometerSample') Is Not Null
	Drop Procedure dbo.AddWeightometerSample
Go

Create Procedure dbo.AddWeightometerSample
(
	@iWeightometer_Id VarChar(31),
	@iWeightometer_Sample_Date DateTime,
	@iWeightometer_Sample_Shift Char(1) = Null,
	@iOrder_No Int = Null,
	@iTonnes Float = Null,
	@iCorrected_Tonnes Float = Null,
	@iSource_Stockpile_Id Int = Null,
	@iDestination_Stockpile_Id Int = Null,
	@oWeightometer_Sample_Id Int Output
)

With Encryption
As

Begin
	Declare @Weightometer_Sample_Id Int
	Declare @Default_Source_Stockpile_Id Int
	Declare @Default_Destination_Stockpile_Id Int
	Declare @Source_Stockpile_Id Int
	Declare @Destination_Stockpile_Id Int
	Declare @Weightometer_Type_Id VarChar(31)
	Declare @Is_Source_Stockpile_Valid Bit
	Declare @Is_Destination_Stockpile_Valid Bit
	Declare @Shift_Order_No Int

	-- replacement for AddOrUpdateWeightometerSample

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- default the output
	Set @oWeightometer_Sample_Id = Null

	-- retrieve the weightometer flow period record
	Select @Default_Source_Stockpile_Id = Null,
		@Default_Destination_Stockpile_Id = Null

	Select Top 1
		@Default_Source_Stockpile_Id = Source_Stockpile_Id,
		@Default_Destination_Stockpile_Id = Destination_Stockpile_Id
	From dbo.WeightometerFlowPeriod
	Where Weightometer_Id = @iWeightometer_Id
		And (	End_Date Is Null
				Or End_Date <= @iWeightometer_Sample_Date)
	Order By End_Date Desc

	-- determine the true target source/destination
	Set @Source_Stockpile_Id = Coalesce(@iSource_Stockpile_Id, @Default_Source_Stockpile_Id)
	Set @Destination_Stockpile_Id = Coalesce(@iDestination_Stockpile_Id, @Default_Destination_Stockpile_Id)

	-- check whether the source stockpile is valid
	Set @Is_Source_Stockpile_Valid = 1
	If (@Source_Stockpile_Id Is Not Null)
	Begin
		-- check that there is a reclaimable build for the specified stockpile
		If Not (@iWeightometer_Sample_Shift Is Null)
		Begin
			-- check for the particular shift
			If dbo.GetReclaimableStockpileBuild(@Source_Stockpile_Id, @iWeightometer_Sample_Date, @iWeightometer_Sample_Shift) Is Null
			Begin
				Set @Is_Source_Stockpile_Valid = 0
			End
		End
		Else
		Begin
			-- if the shift has not been provided, check all shifts on the day
			Set @Shift_Order_No = (Select Min(Order_No) From dbo.ShiftType)
			While @Shift_Order_No <= dbo.GetShiftTypeOrderNo(dbo.GetLastShiftType())
					And @Is_Source_Stockpile_Valid = 1
			Begin
				If dbo.GetReclaimableStockpileBuild(@Source_Stockpile_Id, @iWeightometer_Sample_Date, dbo.GetShiftTypeOrderNo(@Shift_Order_No)) Is Null
				Begin
					Set @Is_Source_Stockpile_Valid = 0
				End
				
				Set @Shift_Order_No = @Shift_Order_No + 1
			End
		End
	End

	-- check whether the destination stockpile is valid
	Set @Is_Destination_Stockpile_Valid = 1
	If (@Destination_Stockpile_Id Is Not Null)
	Begin
		-- check that there is a buildable build for the specified stockpile
		If Not (@iWeightometer_Sample_Shift Is Null)
		Begin
			-- check for the particular shift
			If dbo.GetBuildableStockpileBuild(@Destination_Stockpile_Id, @iWeightometer_Sample_Date, @iWeightometer_Sample_Shift) Is Null
			Begin
				Set @Is_Destination_Stockpile_Valid = 0
			End
		End
		Else
		Begin
			-- if the shift has not been provided, check all shifts on the day
			Set @Shift_Order_No = (Select Min(Order_No) From dbo.ShiftType)
			While @Shift_Order_No <= dbo.GetShiftTypeOrderNo(dbo.GetLastShiftType())
					And @Is_Destination_Stockpile_Valid = 1
			Begin
				If dbo.GetBuildableStockpileBuild(@Destination_Stockpile_Id, @iWeightometer_Sample_Date, dbo.GetShiftTypeOrderNo(@Shift_Order_No)) Is Null
				Begin
					Set @Is_Destination_Stockpile_Valid = 0
				End
				
				Set @Shift_Order_No = @Shift_Order_No + 1
			End
		End
	End

	-- perform regular checks
	If Coalesce(@iTonnes, 0.0) < 0.0
	Begin
		RaisError('dbo.AddWeightometerSample: Tonnes cannot be less than zero.', 16, 1)
	End
	Else If Coalesce(@iCorrected_Tonnes, 0.0) < 0.0
	Begin
		RaisError('dbo.AddWeightometerSample: Corrected_Tonnes cannot be less than zero.', 16, 1)
	End
	Else If @Is_Source_Stockpile_Valid = 0
	Begin
		RaisError('dbo.AddWeightometerSample: The source stockpile specified cannot be reclaimed from.', 16, 1)
	End
	Else If @Is_Destination_Stockpile_Valid = 0
	Begin
		RaisError('dbo.AddWeightometerSample: The destination stockpile specified cannot be built to.', 16, 1)
	End
	Else
	Begin
		-- insert the record
		Insert Into dbo.WeightometerSample
		(
			Weightometer_Id, Weightometer_Sample_Date, Weightometer_Sample_Shift, Order_No,
			Source_Stockpile_Id, Destination_Stockpile_Id, Tonnes, Corrected_Tonnes
		)
		Values
		(
			@iWeightometer_Id, @iWeightometer_Sample_Date, @iWeightometer_Sample_Shift, @iOrder_No,
			@Source_Stockpile_Id, @Destination_Stockpile_Id, @iTonnes, @iCorrected_Tonnes
		)

		Set @Weightometer_Sample_Id = Scope_Identity()

		-- determine if a recalc is required
		Select @Weightometer_Type_Id = Weightometer_Type_Id
		From dbo.Weightometer
		Where Weightometer_Id = @iWeightometer_Id

		If @Weightometer_Type_Id = 'CVF'
		Begin
			Exec dbo.CalcVirtualFlowRaise
				@pCalc_Date = @iWeightometer_Sample_Date
		End
		Else If @Weightometer_Type_Id = 'L1'
		Begin
			Exec dbo.RecalcL1Raise
				@pDate = @iWeightometer_Sample_Date
		End
		Else If @Weightometer_Type_Id = 'CVF+L1'
		Begin
			Exec dbo.CalcVirtualFlowRaise
				@pCalc_Date = @iWeightometer_Sample_Date

			Exec dbo.RecalcL1Raise
				@pDate = @iWeightometer_Sample_Date
		End

		-- return the result
		Set @oWeightometer_Sample_Id = @Weightometer_Sample_Id
	End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddWeightometerSample TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddWeightometerSample">
 <Procedure>
	Adds a new record in the WeightometerSample table. 
	Raises Virtual Flow and Level 1 Recalcs depending upon the @Weightometer_Type_Id value.
	Errors are raised if:
		Tonnes are less than zero
		Corrected Tonnes are less than zero
		The source stockpile specified cannot be reclaimed from
		The destination stockpile specified cannot be built to		
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetNextDateShift.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetNextDateShift]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetNextDateShift]
GO

CREATE Procedure [dbo].[GetNextDateShift]

(@Date Datetime,
@Shift Char(1),
@Next_Date Datetime Output,
@Next_Shift Char(1) Output)

With Encryption As

Declare @Order_No Int
Declare @Max_Order_No Int

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set @Date = dbo.GetDateDay (@Date)

	Select @Order_No = Order_No
	From ShiftType
	Where Shift = @Shift

	Select @Max_Order_No = Max(Order_No)
	From ShiftType

	If (@Order_No = @Max_Order_No)
	Begin
		Select @Next_Shift = Shift
		From ShiftType
		Where Order_No = 	(Select Min(Order_No)
					From ShiftType)

		Set @Next_Date = DateAdd (Day, 1, @Date)
	End
	Else
	Begin
		Select @Next_Shift = Shift
		From ShiftType
		Where Order_No = 	(Select Min(Order_No)
					From ShiftType
					Where Order_No > @Order_No)

		Set @Next_Date = @Date
	End

	/* If no value was found */
	If (@Next_Shift Is Null)
	Begin
		/* There must be only one shift, so use it */
		Select @Next_Shift = Min(Shift)
		From ShiftType

		Set @Next_Date = DateAdd (Day, 1, @Date)
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetNextDateShift">
 <Procedure>
	Returns the next shift date.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageLast.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageLast'))
	Drop Procedure dbo.DeleteHaulageLast
Go

Create Procedure dbo.DeleteHaulageLast
(
	@iHaulage_Id Int = Null
)

With Encryption
As

Begin
	-- internal use only

	-- deletes the specified haulage record
	-- the record must be the last in the chain, or an error will be thrown
	-- when deleting the last haulage record, it sets the HaulageRaw
	-- back to "A"waiting approval.

	Declare @Haulage_Raw_Id Int
	Declare @Haulage_State_Id Char(1)
	Declare @Parent_Haulage_Id Int
	Declare @New_Child_Haulage_Id Int

	Declare @Haulage_Date Datetime
	Declare @Digblock_Id Varchar(31)
	Declare @Haulage_Shift Varchar(1)

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- ascertain the haulage record's details
	Select @Haulage_Date = Haulage_Date,
		@Haulage_Shift = Haulage_Shift,
		@Digblock_Id = Source_Digblock_Id
	From Haulage
	Where Haulage_Id = @iHaulage_Id

	-- The Haulage record can only be deleted if it is at the end of the chain
	If (Select Child_Haulage_Id
		From Haulage
		Where Haulage_Id = @iHaulage_Id) Is Not Null
	Begin
		RaisError('DeleteHaulageLast: Only the last haulage record in the chain can be deleted.', 16, 1)
	End
	-- If the digblock depletion falls in an approved depletion period
	Else If (@Digblock_Id Is Not Null) 
		And (dbo.IsInApprovedDigblockSurveyPeriod (@Haulage_Date, @Haulage_Shift, @Digblock_Id) = 1)
	Begin
		RaisError('DeleteHaulageLast: Digblock falls in an already approved digblock survey period', 16, 1)
	End
	Else
	Begin
		-- the record is to be physically deleted

		--------------------------------
		-- modify the old Haulage record

		Select @Haulage_State_Id = Haulage_State_Id,
			@Parent_Haulage_Id = Parent_Haulage_Id
		From Haulage
		Where Haulage_Id = @iHaulage_Id
		
		If @Haulage_State_Id In ('N', 'D')
		Begin
			-- always set the previous haulage record to 'Unapproved'
			Update Haulage
			Set Haulage_State_Id = 'N',
				Child_Haulage_Id = Null
			Where Haulage_Id = @Parent_Haulage_Id
		End
		Else If @Haulage_State_Id = 'A'
		Begin
			-- as we are deleting an Approved record,
			-- we need to check if this is the *last* approved record
			-- if so, we need to clear the Child_Id
			-- otherwise, we need to link the Child_Id to the next approved record
						
			If (Select Count(*)
				From Haulage
				Where Haulage_Id = @Parent_Haulage_Id) = 1
			Begin
				-- this is the last record
				Update Haulage
				Set Child_Haulage_Id = Null
				Where Haulage_Id = @Parent_Haulage_Id
			End
			Else
			Begin
				-- this is not the last record
				-- of all the current referencing records,
				-- determine the new child
				Select @New_Child_Haulage_Id = Min(Haulage_Id)
				From Haulage
				Where Haulage_State_Id = 'A'
					And Parent_Haulage_Id = @Parent_Haulage_Id
					And Haulage_Id <> @iHaulage_Id

				Update Haulage
				Set Child_Haulage_Id = @New_Child_Haulage_Id
				Where Haulage_Id = @Parent_Haulage_Id
			End
		End
		Else
		Begin
			-- raise an error - the chain appears to be broken
			RaisError('DeleteHaulageLast: An unexpected error has occurred.  Please check the haulage linkage.', 16, 1)
		End

		-- if the Haulage record that we are deleting is the last associated record,
		-- set the HaulageRaw record back to the "Awaiting Correction" state
		Set @Haulage_Raw_Id = (	Select Haulage_Raw_Id
								From Haulage
								Where Haulage_Id = @iHaulage_Id)

		If (Select Count(*)
			From Haulage
			Where Haulage_Id <> @iHaulage_Id
				And Haulage_Raw_Id = @Haulage_Raw_Id) = 0
		Begin
			Update HaulageRaw
			Set Haulage_Raw_State_Id = 'A'
			Where Haulage_Raw_Id = @Haulage_Raw_Id
			
			-- clear the resolution details
			Delete
			From HaulageRawResolution
			Where Haulage_Raw_Id = @Haulage_Raw_Id
		End

		----------------------------
		-- delete the Haulage record

		-- HaulageGrade
		Delete
		From HaulageGrade
		Where Haulage_Id = @iHaulage_Id

		-- HaulageValue
		Delete
		From HaulageValue
		Where Haulage_Id = @iHaulage_Id

		-- HaulageNotes
		Delete
		From HaulageNotes
		Where Haulage_Id = @iHaulage_Id

		-- Haulage
		Delete
		From Haulage
		Where Haulage_Id = @iHaulage_Id

		Exec dbo.RecalcL1Raise
			@pDate = @Haulage_Date
			
		Exec dbo.CalcVirtualFlowRaise
			@pCalc_Date = @Haulage_Date
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageLast">
 <Procedure>
	Intended for internal use only.

	Deletes the specified haulage record the record must be the last in the chain, 
	or an error will be thrown when deleting the last haulage record, 
	it sets the HaulageRaw back to "A"waiting approval.

	Deletes from the following tables:
		HaulageGrade
		HaulageValue
		HaulageNotes
		Haulage
		
	Raises Level 1 Recalcs and Calc Virtual Flow records for the Haulage_Date
	Errors are raised if:
		The record is not the last record in the chain
		The Digblock falls in an already approved digblock survey period
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageCorrectionResolutionBasic.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[DeleteHaulageCorrectionResolutionBasic]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[DeleteHaulageCorrectionResolutionBasic]
GO

CREATE Procedure [dbo].[DeleteHaulageCorrectionResolutionBasic]
(
	@iHaulage_Resolve_Basic_Id Int
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: DeleteHaulageCorrectionResolutionBasic
--  Purpose: Deletes a Resolution_Basic record.
--  Parameters: @iHaulage_Resolve_Basic_Id - ID to delete.
-- 
--  Comments: Deletes from HaulageRawResolution only if it has no attached 
--			  haulage records.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Row_Num Int

	Select @Row_Num = Count(*) 
	From HaulageRawResolution
	Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id

	If Exists (	Select 1
				From HaulageResolveBasic
				Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id)
	Begin
		If @Row_Num = 0
		Begin
			Delete
			From HaulageResolveBasic
			Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id
		End
		Else
		Begin
			Raiserror ('Cannot delete the resolution code is it is currently in use.', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The Name Resolution does not exist.', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.DeleteHaulageCorrectionResolutionBasic TO CoreHaulageManager



/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageCorrectionResolutionBasic">
 <Procedure>
	Deletes a record from the HaulageResolveBasic table for the specified @iHaulage_Resolve_Basic_Id.
	Errors are raised if:
		The Name Resolution does not exist
		The resolution code is it is currently in use
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageChain.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageChain'))
	Drop Procedure dbo.DeleteHaulageChain
Go

Create Procedure dbo.DeleteHaulageChain
(
	@iHaulage_Id Int = Null
)

With Encryption
As

Begin
	-- internal use only

	-- deletes the entire chain of records
	-- calls the "DeleteHaulageLast" routine
	
	Declare @curHAULAGE Cursor
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- ascertain the full chain of records
	Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
		Select Haulage_Id
		From dbo.GetHaulageHierarchy(@iHaulage_Id)
		Order By Level Desc, Haulage_Id Desc

	Open @curHAULAGE
	Fetch Next From @curHAULAGE Into @Haulage_Id
	While @@Fetch_Status = 0
	Begin
		-- delete the haulage record individually
		Exec dbo.DeleteHaulageLast
			@iHaulage_Id = @Haulage_Id

		Fetch Next From @curHAULAGE Into @Haulage_Id
	End
	Close @curHAULAGE
	
	Commit Transaction
End
Go
 
/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageChain">
 <Procedure>
	Deletes records from the Haulage table returned by the dbo.GetHaulageHierarchy function for @iHaulage_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulage.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateHaulage'))
	Drop Procedure dbo.UpdateHaulage
Go

Create Procedure dbo.UpdateHaulage
(
	@iHaulage_Id Int,
	@iUpdate_Source_Digblock_Id Bit = 0,
	@iSource_Digblock_Id VarChar(31) = Null,
	@iUpdate_Source_Stockpile_Id Bit = 0,
	@iSource_Stockpile_Id Int = Null,
	@iUpdate_Source_Build_Id Bit = 0,
	@iSource_Build_Id Int = Null,
	@iUpdate_Source_Component_Id Bit = 0,
	@iSource_Component_Id Int = Null,
	@iUpdate_Destination_Stockpile_Id Bit = 0,
	@iDestination_Stockpile_Id Int = Null,
	@iUpdate_Destination_Build_Id Bit = 0,
	@iDestination_Build_Id Int = Null,
	@iUpdate_Destination_Component_Id Bit = 0,
	@iDestination_Component_Id Int = Null,
	@iUpdate_Destination_Crusher_Id Bit = 0,
	@iDestination_Crusher_Id VarChar(31) = Null,
	@iUpdate_Source_Mill_Id Bit = 0,
	@iSource_Mill_Id VarChar(31) = Null,
	@iUpdate_Destination_Mill_Id Bit = 0,
	@iDestination_Mill_Id VarChar(31) = Null,
	@iUpdate_Tonnes Bit = 0,
	@iTonnes Float = Null,
	@iUpdate_Loads Bit = 0,
	@iLoads Int = Null,
	@iUpdate_Truck_Id Bit = 0,
	@iTruck_Id VarChar(31) = Null,
	@iCreate_Audit_Child Bit = 1,
	@oHaulage_Id Int = Null Output
)

With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: UpdateHaulage
-- 
--  To Do: Validation checks should be placed in this stored procedure to
--			ensure the integrity of the haulage table. Checks for Digblock 
--			start/end dates, valid source/destination, only one source and 
--			destination, etc.
--
------------------------------------------------------------------------------*/

Begin
	Declare @Haulage_Id Int
	Declare @Haulage_Date DateTime

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If (Select Child_Haulage_Id
		From Haulage
		Where Haulage_Id = @iHaulage_Id) Is Not Null
	Begin
		RaisError('UpdateHaulage: Only the last haulage record in the chain can be modified.', 16, 1)
	End	
	Else If (@iCreate_Audit_Child = 1)
			And (	Select Haulage_State_Id
					From Haulage
					Where Haulage_Id = @iHaulage_Id) = 'A'
	Begin
		-- the haulage record cannot have an audit trail extended for approved records
		RaisError('UpdateHaulage: An approved haulage record cannot carry an audit trail.', 16, 1)
	End
	Else
	Begin
		-- if we are creating a new copy of the Haulage record,
		-- copy the existing record prior to updating the values
		If @iCreate_Audit_Child = 1
		Begin
			------------------------------------------------
			--  create a copy of the existing Haulage record

			-- Haulage
			-- note: we are preserving the state
			--
			Insert Into dbo.Haulage
			(
				Haulage_Date, Haulage_Shift, Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id, Destination_Stockpile_Id,
				Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Source_Mill_Id, Destination_Mill_Id, Tonnes, Loads,
				Truck_Id, Haulage_State_Id, Haulage_Raw_Id, Parent_Haulage_Id, Added_DateTime
			)
			Select Haulage_Date, Haulage_Shift, Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id, Destination_Stockpile_Id,
				Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Source_Mill_Id, Destination_Mill_Id, Tonnes, Loads,
				Truck_Id, Haulage_State_Id, Haulage_Raw_Id, Haulage_Id, GetDate()
			From Haulage
			Where Haulage_Id = @iHaulage_Id

			Set @Haulage_Id = Scope_Identity()

			-- HaulageGrade
			Insert Into dbo.HaulageGrade
			(
				Haulage_Id, Grade_Id, Grade_Value
			)
			Select @Haulage_Id, Grade_Id, Grade_Value
			From HaulageGrade
			Where Haulage_Id = @iHaulage_Id

			-- HaulageValue
			Insert Into dbo.HaulageValue
			(
				Haulage_Id, Haulage_Field_Id, Field_Value
			)
			Select @Haulage_Id, Haulage_Field_Id, Field_Value
			From HaulageValue
			Where Haulage_Id = @iHaulage_Id

			-- HaulageNotes
			Insert into dbo.HaulageNotes
			(
				Haulage_Id, Haulage_Field_Id, Notes
			)
			Select @Haulage_Id, Haulage_Field_Id, Notes
			From HaulageNotes
			Where Haulage_Id = @iHaulage_Id

			--------------------------------
			-- modify the old Haulage record

			Update Haulage
			Set Haulage_State_Id = 'M',
				Child_Haulage_Id = @Haulage_Id
			Where Haulage_Id = @iHaulage_Id
		End
		Else
		Begin
			Set @Haulage_Id = @iHaulage_Id
		End

		-- update the appropriate Haulage record
		Update dbo.Haulage
		Set	Source_Digblock_Id = (Case When @iUpdate_Source_Digblock_Id = 1 Then @iSource_Digblock_Id Else Source_Digblock_Id End),
			Source_Stockpile_Id = (Case When @iUpdate_Source_Stockpile_Id = 1 Then @iSource_Stockpile_Id Else Source_Stockpile_Id End),
			Source_Build_Id = (Case When @iUpdate_Source_Build_Id = 1 Then @iSource_Build_Id Else Source_Build_Id End),
			Source_Component_Id = (Case When @iUpdate_Source_Component_Id = 1 Then @iSource_Component_Id Else Source_Component_Id End),
			Destination_Stockpile_Id = (Case When @iUpdate_Destination_Stockpile_Id = 1
											Then @iDestination_Stockpile_Id
											Else Destination_Stockpile_Id
										End),
			Destination_Build_Id = (Case When @iUpdate_Destination_Build_Id = 1
										Then @iDestination_Build_Id
										Else Destination_Build_Id
									End),
			Destination_Component_Id = (Case When @iUpdate_Destination_Component_Id = 1
											Then @iDestination_Component_Id
											Else Destination_Component_Id
										End),
			Destination_Crusher_Id = (	Case When @iUpdate_Destination_Crusher_Id = 1
											Then @iDestination_Crusher_Id
											Else Destination_Crusher_Id
										End),
			Source_Mill_Id = (Case When @iUpdate_Source_Mill_Id = 1 Then @iSource_Mill_Id Else Source_Mill_Id End),
			Destination_Mill_Id = (Case When @iUpdate_Destination_Mill_Id = 1 Then @iDestination_Mill_Id Else Destination_Mill_Id End),
			Tonnes = (Case When @iUpdate_Tonnes = 1 Then @iTonnes Else Tonnes End),
			Loads = (Case When @iUpdate_Loads = 1 Then @iLoads Else Loads End),
			Truck_Id = (Case When @iUpdate_Truck_Id = 1 Then @iTruck_Id Else Truck_Id End)
		Where Haulage_Id = @Haulage_Id

		-- raise the L1 Recalc & CVF
		Exec dbo.RecalcL1RaiseByHaulage
			@iHaulage_Id = @Haulage_Id

		Set @Haulage_Date =
			(
				Select Haulage_Date
				From dbo.Haulage
				Where Haulage_Id = @Haulage_Id
			)

		Exec dbo.CalcVirtualFlowRaise
			@pCalc_Date = @Haulage_Date

		-- return the appropriate Haulage_Id
		Set @oHaulage_Id = @Haulage_Id
	End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.UpdateHaulage TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulage">
 <Procedure>
	If we are creating a new copy of the Haulage record,
	copy the existing record prior to updating the values
	Insert into tables Haulage, HaulageGrade, HaulageValue, HaulageNotes.
	Modify the old Haulage record and update the appropriate Haulage record
	Execute RecalcL1RaiseByHaulage and execute CalcVirtualFlowRaise.
	Errors are raised if:
		UpdateHaulage: Only the last haulage record in the chain can be modified.
		UpdateHaulage: An approved haulage record cannot carry an audit trail.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageState.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageState'))
	Drop Procedure dbo.DeleteHaulageState
Go

Create Procedure dbo.DeleteHaulageState
(
	@iHaulage_Id Int = Null
)

With Encryption
As

Begin
	-- internal use only
	
	-- sets the record to the "D"eleted state
	
	Declare @Haulage_Raw_Id Int
	Declare @Haulage_State_Id Char(1)
	Declare @Parent_Haulage_Id Int
	Declare @New_Haulage_Id Int

	Declare @Haulage_Date Datetime
	Declare @Digblock_Id Varchar(31)
	Declare @Haulage_Shift Varchar(1)

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- ascertain the haulage record's details
	Select @Haulage_Date = Haulage_Date,
		@Haulage_Shift = Haulage_Shift,
		@Digblock_Id = Source_Digblock_Id
	From Haulage
	Where Haulage_Id = @iHaulage_Id

	-- The Haulage record can only be deleted if it is at the end of the chain
	If (Select Child_Haulage_Id
		From Haulage
		Where Haulage_Id = @iHaulage_Id) Is Not Null
	Begin
		RaisError('DeleteHaulageState: Only the last haulage record in the chain can be deleted.', 16, 1)
	End
	-- If the digblock depletion falls in an approved depletion period
	Else If (@Digblock_Id Is Not Null) 
		And (dbo.IsInApprovedDigblockSurveyPeriod (@Haulage_Date, @Haulage_Shift, @Digblock_Id) = 1)
	Begin
		RaisError('DeleteHaulageState: Digblock falls in an already approved digblock survey period', 16, 1)
	End
	Else If (	Select Haulage_State_Id
				From Haulage
				Where Haulage_Id = @iHaulage_Id) <> 'N'
		RaisError('DeleteHaulageState: Only not-approved haulage can be set to the deleted state.', 16, 1)
	Else
	Begin
		-- the record is to be set to the deleted state

		Exec dbo.UpdateHaulage
			@iHaulage_Id = @iHaulage_Id,
			@oHaulage_Id = @New_Haulage_Id Output

		Update Haulage
		Set Haulage_State_Id = 'D'
		Where Haulage_Id = @New_Haulage_Id

		Exec dbo.RecalcL1Raise
			@pDate = @Haulage_Date
			
		Exec dbo.CalcVirtualFlowRaise
			@pCalc_Date = @Haulage_Date
	End

	Commit Transaction
End
Go


 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageState">
 <Procedure>
	Sets a record in the Haulage table to the Deleted state.
	Raises a Level 1 Recalc event.
	Raises a Calc_Virtual_Flow event.	
	Errors are raised if:
		the haulage record is not the last record in the chain
		the Digblock falls in an already approved digblock survey period
		the haulage is approved
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulage.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulage'))
	Drop Procedure dbo.DeleteHaulage
Go

Create Procedure dbo.DeleteHaulage
(
	@iHaulage_Id Int = Null,
	@iAction VarChar(5) = 'LAST'
)

With Encryption
As

Begin
	-- deletes haulage, based on the specified action

	-- @iAction:
	--
	-- 'CHAIN' - deletes the entire chain of Haulage records
	--           when deleting the last haulage record, it sets the HaulageRaw
	--           back to "A"waiting approval.
	-- 'LAST'  - deletes the last record in the chain
	--           when deleting the last haulage record, it sets the HaulageRaw
	--           back to "A"waiting approval.
	-- 'STATE' - changes the record state to "D"eleted. 

	If @iAction = 'LAST'
	Begin
		Exec dbo.DeleteHaulageLast
			@iHaulage_Id = @iHaulage_Id
	End
	Else If @iAction = 'CHAIN'
	Begin
		Exec dbo.DeleteHaulageChain
			@iHaulage_Id = @iHaulage_Id
	End
	Else If @iAction = 'STATE'
	Begin
		Exec dbo.DeleteHaulageState
			@iHaulage_Id = @iHaulage_Id
	End
End

GO
GRANT EXECUTE ON dbo.DeleteHaulage TO CoreHaulageManager



/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulage">
 <Procedure>
	Deletes haulage, based on the specified action
	CHAIN - deletes the entire chain of Haulage records
	        when deleting the last haulage record, it sets the HaulageRaw
	        back to "A"waiting approval.
	LAST - deletes the last record in the chain
	       when deleting the last haulage record, it sets the HaulageRaw
	       back to "A"waiting approval.
	STATE - changes the record state to "D"eleted. 
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageBySurveyDigblock.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageBySurveyDigblock'))
	Drop Procedure dbo.DeleteHaulageBySurveyDigblock
Go

Create Procedure dbo.DeleteHaulageBySurveyDigblock
(
	@iDigblock_Id VarChar(31)
)

With Encryption
As

Begin
	Declare @curHAULAGE Cursor
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- delete the existing haulage records
	Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
		Select Haulage_Id
		From Haulage
		Where Haulage_State_Id = 'A'
			And Source_Digblock_Id = @iDigblock_Id

	Open @curHAULAGE
	Fetch Next From @curHAULAGE Into @Haulage_Id
	While @@Fetch_Status = 0
	Begin
		Exec DeleteHaulage
			@iHaulage_Id = @Haulage_Id

		Fetch Next From @curHAULAGE Into @Haulage_Id
	End

	Commit Transaction
End
Go
 
 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageBySurveyDigblock">
 <Procedure>
	Deletes records from the Haulage table related to @iDigblock_Id.  Loops calling DeleteHaulage
	procedure for each of the Haulage records with a Source_Digblock_Id = @iDigblock_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageBySurveyEntireDigblock.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddHaulageBySurveyEntireDigblock'))
	Drop Procedure dbo.AddHaulageBySurveyEntireDigblock
Go

Create Procedure dbo.AddHaulageBySurveyEntireDigblock
(
	@iDigblock_Id VarChar(31),
	@iScaling_Factor Float
)

With Encryption
As

Begin
	Declare @curHAULAGE Cursor
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- create approved haulage for each non-approved digblock
	Insert Into Haulage
	(
		Haulage_Date, Haulage_Shift, Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
		Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Source_Mill_Id, Destination_Mill_Id,
		Tonnes, Loads, Truck_Id, Haulage_State_Id, Haulage_Raw_Id, Child_Haulage_Id, Parent_Haulage_Id, Added_DateTime
	)
	Select Haulage_Date, Haulage_Shift, Source_Digblock_Id, Null, Null, Null,
		Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Null, Destination_Mill_Id,
		Tonnes * @iScaling_Factor, Loads, Truck_Id, 'A', Haulage_Raw_Id, Null, Haulage_Id, GetDate()
	From Haulage
	Where Source_Digblock_Id = @iDigblock_Id
		And Haulage_State_Id = 'N'

	-- for each new "A" record created, also copy the HaulageGrade, HaulageNotes, HaulageValue tables
	-- do this based on the A record's parent N record
	Insert into HaulageGrade
	(
		Haulage_Id, Grade_Id, Grade_Value	
	)	
	Select H.Haulage_Id, PHG.Grade_Id, PHG.Grade_Value
	From Haulage H
		join Haulage PH
			On H.Parent_Haulage_Id = PH.Haulage_Id
		join HaulageGrade PHG
			On PH.Haulage_Id = PHG.Haulage_Id
	Where H.Source_Digblock_Id = @iDigblock_Id
		And H.Haulage_State_Id = 'A' 
		
	
	Insert into HaulageNotes
	(
		Haulage_Id, Haulage_Field_Id, Notes
	)	
	Select H.Haulage_Id, PHN.Haulage_Field_Id, PHN.Notes
	From Haulage H
		join Haulage PH
			On H.Parent_Haulage_Id = PH.Haulage_Id
		join HaulageNotes PHN
			On PH.Haulage_Id = PHN.Haulage_Id
	Where H.Source_Digblock_Id = @iDigblock_Id
		And H.Haulage_State_Id = 'A' 
	
	Insert into HaulageValue
	(
		Haulage_Id, Haulage_Field_Id, Field_Value
	)	
	Select H.Haulage_Id, PHV.Haulage_Field_Id, PHV.Field_Value
	From Haulage H
		join Haulage PH
			On H.Parent_Haulage_Id = PH.Haulage_Id
		join HaulageValue PHV
			On PH.Haulage_Id = PHV.Haulage_Id
	Where H.Source_Digblock_Id = @iDigblock_Id
		And H.Haulage_State_Id = 'A' 
	
	-- point the "N" record to the first "A" record
	-- this will denote that the "N" record has now been over-ridden
	-- note that this is not a *true* indication of parent/child linkage,
	
	Update HN
	Set Child_Haulage_Id = HA.First_Haulage_Id
	From Haulage As HN
		Inner Join
		(
			Select Parent_Haulage_Id,
				Min(Haulage_Id) As First_Haulage_Id
			From Haulage
			Where Haulage_State_Id = 'A'
			Group By Parent_Haulage_Id
		) As HA
		On (HA.Parent_Haulage_Id = HN.Haulage_Id)
	Where HN.Haulage_State_Id = 'N'
		And HN.Child_Haulage_Id Is Null

	Commit Transaction
End
Go
 
/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageBySurveyEntireDigblock">
 <Procedure>
	Copies non-approved haulage records for the specified digblock and inserts these records as approved haulage records.
	Adds related records to 
		HaulageGrade
		HaulageNotes
		HaulageValue
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageBySurveyPeriod.prc'
GO

If Object_Id('dbo.DeleteHaulageBySurveyPeriod') Is Not Null
	Drop Procedure dbo.DeleteHaulageBySurveyPeriod
Go

Create Procedure dbo.DeleteHaulageBySurveyPeriod
(
	@iDigblock_Survey_Id Int
)

With Encryption
As

Begin
	Declare @curHAULAGE Cursor
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- delete the existing haulage records, regardless of digblock membership

	Create Table dbo.#DELETE_HAULAGE_BATCH_LIST
	(
		Haulage_Id Int Not Null,
		Constraint PK_DELETE_HAULAGE_BATCH_LIST Primary Key Clustered (Haulage_Id)
	)

	Insert Into dbo.#DELETE_HAULAGE_BATCH_LIST
	(
		Haulage_Id
	)
	Select H.Haulage_Id
	From Haulage As H
		Inner Join DigblockSurveyActual As DSA
			On (DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
				And DSA.Digblock_Survey_Actual_Id = H.Digblock_Survey_Actual_Id)
		Inner Join dbo.GetDigblockSurveyPeriodDetails() DSPD
			On DSA.Digblock_Survey_Id = DSPD.Digblock_Survey_Id
	Where H.Haulage_State_Id = 'A'
		And dbo.CompareDateShift(H.Haulage_Date, H.Haulage_Shift, '>=', DSPD.Start_Date, DSPD.Start_Shift) = 1
		And dbo.CompareDateShift(H.Haulage_Date, H.Haulage_Shift, '<=', DSPD.Digblock_Survey_Date, DSPD.Digblock_Survey_Shift) = 1
		-- these are for index performance purposes
		And H.Haulage_Date >= DSPD.Start_Date
		And H.Haulage_Date <= DSPD.Digblock_Survey_Date

	Exec dbo.DeleteHaulageBatch
		@iAction = 'LAST'

	Commit Transaction
End
Go

 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageBySurveyPeriod">
 <Procedure>
	Deletes records from the Haulage table related to the survey period provided. Uses the Delete Haulage batch 
	to quickly delete any of the approved haulage relating to the survey period.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageBySurveyDigblockPeriod.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddHaulageBySurveyDigblockPeriod'))
	Drop Procedure dbo.AddHaulageBySurveyDigblockPeriod
Go

Create Procedure dbo.AddHaulageBySurveyDigblockPeriod
(
	@iStart_Date DateTime,
	@iStart_Shift Char(1),
	@iEnd_Date DateTime,
	@iEnd_Shift Char(1),
	@iDigblock_Id VarChar(31),
	@iDigblock_Survey_Actual_Id Int,
	@iScaling_Factor Float,
	@iActual_Scaling_Factor Float
)

With Encryption
As

Begin
	Declare @Haulage Table
	(
		Haulage_Id Int Not Null,
		Primary Key (Haulage_Id)
	)
	Declare @Assigned_Digblock_Id VarChar(31)

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
	
	Select @Assigned_Digblock_Id = Assigned_Digblock_Id
	From DigblockSurveyActual
	Where Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id
	
	Insert Into @Haulage
		(Haulage_Id)
	Select Haulage_Id
	From Haulage
	Where Source_Digblock_Id = @iDigblock_Id
		And dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>=', @iStart_Date, @iStart_Shift) = 1
		And dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '<=', @iEnd_Date, @iEnd_Shift) = 1
		And Haulage_Date >= @iStart_Date
		And Haulage_Date <= @iEnd_Date
		And Haulage_State_Id = 'N'

	-- create approved haulage for each non-approved digblock
	Insert Into Haulage
	(
		Haulage_Date, Haulage_Shift, Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
		Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Source_Mill_Id, Destination_Mill_Id,
		Tonnes, Loads, Truck_Id, Haulage_State_Id, Haulage_Raw_Id, Digblock_Survey_Actual_Id,
		Child_Haulage_Id, Parent_Haulage_Id, Added_DateTime
	)
	Select Haulage_Date, Haulage_Shift, @Assigned_Digblock_Id, Null, Null, Null,
		Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Null, Destination_Mill_Id,
		Tonnes * @iScaling_Factor * @iActual_Scaling_Factor, Loads, Truck_Id, 'A', Haulage_Raw_Id, @iDigblock_Survey_Actual_Id,
		Null, Haulage_Id, GetDate()
	From Haulage
	Where Haulage_Id In (Select Haulage_Id From @Haulage)	
	
	-- for each new "A" record created, also copy the HaulageGrade, HaulageNotes, HaulageValue tables
	-- do this based on the A record's parent N record
	Insert Into HaulageGrade
		(Haulage_Id, Grade_Id, Grade_Value)	
	Select H.Haulage_Id, PHG.Grade_Id, PHG.Grade_Value
	From Haulage H
		Inner Join Haulage PH
		On (H.Parent_Haulage_Id = PH.Haulage_Id)
		Inner Join HaulageGrade PHG
		On (PH.Haulage_Id = PHG.Haulage_Id)
	Where PH.Haulage_Id In (Select Haulage_Id From @Haulage)
		And H.Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id

	
	Insert Into HaulageNotes
		(Haulage_Id, Haulage_Field_Id, Notes)	
	Select H.Haulage_Id, PHN.Haulage_Field_Id, PHN.Notes
	From Haulage H
		Inner Join Haulage PH
		On (H.Parent_Haulage_Id = PH.Haulage_Id)
		Inner Join HaulageNotes PHN
		On (PH.Haulage_Id = PHN.Haulage_Id)
	Where PH.Haulage_Id In (Select Haulage_Id From @Haulage)
		And H.Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id
	
	
	Insert Into HaulageValue
		(Haulage_Id, Haulage_Field_Id, Field_Value)	
	Select H.Haulage_Id, PHV.Haulage_Field_Id, PHV.Field_Value
	From Haulage H
		Inner Join Haulage PH
		On (H.Parent_Haulage_Id = PH.Haulage_Id)
		Inner Join HaulageValue PHV
		On (PH.Haulage_Id = PHV.Haulage_Id)
	Where PH.Haulage_Id In (Select Haulage_Id From @Haulage)
		And H.Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id


	-- point the "N" record to the first "A" record
	-- this will denote that the "N" record has now been over-ridden
	-- note that this is not a *true* indication of parent/child linkage,
	
	Update HN
	Set Child_Haulage_Id = HA.First_Haulage_Id
	From Haulage As HN
		Inner Join
		(
			Select Parent_Haulage_Id,
				Min(Haulage_Id) As First_Haulage_Id
			From Haulage
			Where Haulage_State_Id = 'A'
				Group By Parent_Haulage_Id
		) As HA
		On (HA.Parent_Haulage_Id = HN.Haulage_Id)
	Where HN.Haulage_State_Id = 'N'
		And Haulage_Id In (Select Haulage_Id From @Haulage)
		
	Commit Transaction
End
Go
 
/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageBySurveyDigblockPeriod">
 <Procedure>
	Adds haulage records for the Assigned_Digblock_Id specified in the DigblockSurveyActual record, the haulage records
	are selected for the specified Digblock_Id if Haulage_State_Id = 'N' and the Digblock is active on the haulage date
	Records are inserted into the following tables:
		Haulage
		HaulageGrade
		HaulageNotes
		HaulageValue

 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ApproveDigblockSurvey.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[ApproveDigblockSurvey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure dbo.ApproveDigblockSurvey
GO

CREATE Procedure dbo.ApproveDigblockSurvey
(
	@iDigblock_Survey_Id Int
)

With Encryption
As

Begin

	Declare @Digblock_Survey_Date Datetime
	Declare @Digblock_Survey_Shift Char(1)
	Declare @Digblock_Survey_Type_Id Int
	Declare @Prev_Survey_Date Datetime
	Declare @Prev_Survey_Shift Char(1)
	Declare @Digblock_Survey_Summary_Id Int
	Declare @Digblock_Survey_Actual_Id Int
	Declare @Digblock_Id Varchar(31)
	Declare @Version_Id Int
	Declare @Haulage_Tonnes Float
	Declare @Scaling_Factor Real
	Declare @Actual_Scaling_Factor Real
	Declare @Actual_Tonnes Float
	Declare @Assigned_Digblock_Id Varchar(31)
	Declare @Assigned_Version_Id Int
	Declare @Total_Actual_Tonnes Float
	Declare @Start_Date Datetime
	Declare @Start_Shift Char(1)
	Declare @Adjust_Haulage Bit
	Declare @Is_Entire_Digblock Bit
	Declare @End_Date Datetime
	Declare @End_Shift Char(1)
	Declare @Min_Haulage_Date Datetime
	Declare @Temp_Min_Haulage_Date Datetime
	Declare @Depleted_Tonnes Float
	Declare @curSUMMARY Cursor
	Declare @curACTUAL Cursor

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	/* Check to see if the digblock survey exists */
	Select @Digblock_Survey_Date = Digblock_Survey_Date,
		@Digblock_Survey_Shift = Digblock_Survey_Shift,
		@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id,
		@Adjust_Haulage = Adjust_Haulage,
		@Is_Entire_Digblock = Is_Entire_Digblock
	From DigblockSurvey
	Where Digblock_Survey_Id = @iDigblock_Survey_Id

	/* If it does */
	If (@Adjust_Haulage Is Not Null)
	Begin
		/* Get the last survey date */
		Exec GetPreviousDigblockSurveyDate
			@Survey_Date = @Digblock_Survey_Date,
			@Survey_Shift = @Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id,
			@Previous_Survey_Date = @Prev_Survey_Date Output,
			@Previous_Survey_Shift = @Prev_Survey_Shift Output
			
		Execute GetNextDateShift
			@Date = @Prev_Survey_Date,
			@Shift = @Prev_Survey_Shift,
			@Next_Date = @Start_Date Output,
			@Next_Shift = @Start_Shift Output

		/* If for this survey period, the option is to adjust the haulage based on the depletion number */
		If (@Adjust_Haulage = 1)
		Begin
			/* If the period relates to the entire related digblock */
			If (@Is_Entire_Digblock = 1)
			Begin
				Set @Min_Haulage_Date = Null

				/* Create a cursor for all the digblock survey sanple records related to this survey */
				Declare Sample_Curs Cursor For
				Select Digblock_Id, Depleted_Tonnes
				From DigblockSurveySample
				Where Digblock_Survey_Id = @iDigblock_Survey_Id

				Open Sample_Curs
		
				Fetch Next From Sample_Curs Into @Digblock_Id, @Depleted_Tonnes
		
				/* For each summary record */
				While (@@Fetch_Status = 0)
				Begin
					Exec dbo.DeleteHaulageBySurveyDigblock
						@iDigblock_Id = @Digblock_Id

					/* Also get the total haulage tonnes for scaling purposes */
					Set @Temp_Min_Haulage_Date = Null
					Select @Haulage_Tonnes = Sum(Tonnes),
					 @Temp_Min_Haulage_Date = Min(Haulage_Date)
					From Haulage
					Where Source_Digblock_Id = @Digblock_Id
						And Haulage_State_Id = 'N'

					/* If the haulage date for this digblock is not null and is less than the current minimum */
					If ((@Temp_Min_Haulage_Date Is Not Null)
					And ((@Temp_Min_Haulage_Date < @Min_Haulage_Date) Or (@Min_Haulage_Date Is Null)))
					Begin
						/* Set it as the new minimum haulage date */
						Set @Min_Haulage_Date = @Temp_Min_Haulage_Date
					End
	
					/* Calculate the factor by which all the existing haulage records will be scaled up or down */
					If (@Haulage_Tonnes <> 0)
					Begin
						Select @Scaling_Factor = @Depleted_Tonnes / @Haulage_Tonnes
					End
					Else
					Begin
						Select @Scaling_Factor = 0
					End
	
					/* Insert a new haulage record for each haulage record related to this sample record */
					Exec dbo.AddHaulageBySurveyEntireDigblock
						@iDigblock_Id = @Digblock_Id,
						@iScaling_Factor = @Scaling_Factor
					
					Fetch Next From Sample_Curs Into @Digblock_Id, @Depleted_Tonnes
				End
		
				/* Clean up the cursor */
				Close Sample_Curs
				Deallocate Sample_Curs
			End
			Else
			Begin
				Exec DeleteHaulageBySurveyPeriod
					@iDigblock_Survey_Id = @iDigblock_Survey_Id

				/* Create a cursor for all the digblock survey summary records related to this survey */
				Set @curSUMMARY = Cursor Local Fast_Forward Read_Only For
					Select Digblock_Survey_Summary_Id, Digblock_Id, Haulage_Tonnes
					From DigblockSurveySummary
					Where Digblock_Survey_Id = @iDigblock_Survey_Id
	
				Open @curSUMMARY
		
				Fetch Next From @curSUMMARY Into @Digblock_Survey_Summary_Id, @Digblock_Id, @Haulage_Tonnes
		
				/* For each summary record */
				While ((@@Fetch_Status = 0))
				Begin
					/* Get the total tonnes assigned to digblock during the process which were related to this record */
					Select @Total_Actual_Tonnes = Sum(Tonnes)
					From DigblockSurveyActual
					Where Digblock_Survey_Summary_Id = @Digblock_Survey_Summary_Id
		
					/* Calculate the factor by which all the existing haulage records will be scaled up or down */
					If (@Haulage_Tonnes <> 0)
					Begin
						Select @Scaling_Factor = @Total_Actual_Tonnes / @Haulage_Tonnes
					End
					Else
					Begin
						Select @Scaling_Factor = 0
					End
	
					/* Get a cursor of all the digblock survey actual records related to this summary record */
					Set @curACTUAL = Cursor Local Fast_Forward Read_Only For
						Select Digblock_Survey_Actual_Id, Tonnes
						From DigblockSurveyActual
						Where Digblock_Survey_Summary_Id = @Digblock_Survey_Summary_Id
		
					Open @curACTUAL
		
					Fetch Next From @curACTUAL Into @Digblock_Survey_Actual_Id, @Actual_Tonnes
					
					/* For each actual record related to this summary record */
					While (@@Fetch_Status = 0)
					Begin
						/* Work out the scaling factor for this actual record */
						If (@Total_Actual_Tonnes <> 0)
						Begin
							Set @Actual_Scaling_Factor = @Actual_Tonnes / @Total_Actual_Tonnes
						End
						Else
						Begin
							Set @Actual_Scaling_Factor = 0
						End
		
						Exec dbo.AddHaulageBySurveyDigblockPeriod
							@iStart_Date = @Start_Date,
							@iStart_Shift = @Start_Shift,
							@iEnd_Date = @Digblock_Survey_Date,
							@iEnd_Shift = @Digblock_Survey_Shift,
							@iDigblock_Id = @Digblock_Id,
							@iDigblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id,
							@iScaling_Factor = @Scaling_Factor,
							@iActual_Scaling_Factor = @Actual_Scaling_Factor
		
						Fetch Next From @curACTUAL Into @Digblock_Survey_Actual_Id, @Actual_Tonnes
					End
		
					/* Clean up the cursor */
					Close @curACTUAL
		
					Fetch Next From @curSUMMARY Into @Digblock_Survey_Summary_Id, @Digblock_Id, @Haulage_Tonnes
				End
		
				/* Clean up the cursor */
				Close @curSUMMARY
			End
		End

		/* Update the depletion record */
		Update DigblockSurvey
		Set	Is_Processing = 0,
			Is_Approved = 1
		Where Digblock_Survey_Id = @iDigblock_Survey_Id

		/* If all went OK */
		/* Make sure each date in the range is recalculated */
		If (@Is_Entire_Digblock = 1)
		Begin
			Exec RecalcL1RaisePeriod
				@iStart_Date = @Min_Haulage_Date,
				@iEnd_Date = @Digblock_Survey_Date
		End
		Else
		Begin
			Exec RecalcL1RaisePeriod
				@iStart_Date = @Start_Date,
				@iEnd_Date = @Digblock_Survey_Date
		End				

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The digblock survey does not exist', 16, 1)
	End

	Commit Transaction

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.ApproveDigblockSurvey TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="ApproveDigblockSurvey">
 <Procedure>
	Approves the Digblock Survey Period and creates approved haulage.
	Errors are raised if:
		The digblock survey does not exist
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockSurvey.prc'
GO

If object_Id('dbo.DeleteDigblockSurvey') Is Not Null 
     Drop Procedure dbo.DeleteDigblockSurvey 
Go 
  
Create Procedure dbo.DeleteDigblockSurvey 
( 
	@Idigblock_Survey_Id Int 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		If Not Exists
			(
				Select 1
				From dbo.DigblockSurvey
				Where Digblock_Survey_Id = @Idigblock_Survey_Id
			)
		Begin
			Raiserror ('The digblock survey does not exist', 16, 1)
		End

		If Exists
			(
				Select 1
				From dbo.DigblockSurvey
				Where Digblock_Survey_Id = @Idigblock_Survey_Id
					And Is_Approved = 1
			)
		Begin
			Raiserror ('The survey must be unapproved before it can be deleted', 16, 1)
		End

		--Get the next survey period after this one and ensure its not approved.
		If Exists
			(
				Select 1 
				From
					(
						Select Top 1 NDS.Is_Approved
						From dbo.DigblockSurvey As DS
							Inner Join dbo.ShiftType As ST
								On (DS.Digblock_Survey_Shift = ST.Shift)
							Inner Join dbo.DigblockSurvey As NDS --Get surveys after this one
								On (NDS.Digblock_Survey_Date >= DS.Digblock_Survey_Date)
							Inner Join dbo.ShiftType As NST
								On (NDS.Digblock_Survey_Shift = NST.Shift)
						Where DS.Digblock_Survey_Id  = @Idigblock_Survey_Id
							And dbo.GetDateShiftAsInt(NDS.Digblock_Survey_Date, NST.Order_No) > dbo.GetDateShiftAsInt(DS.Digblock_Survey_Date, ST.Order_No)
						Order by NDS.Digblock_Survey_Date Asc, NST.Order_No Asc
					) As A
				Where A.Is_Approved = 1
			)
		Begin
			Raiserror ('Can not delete a digblock survey period that is directly after an approved survey period.', 16, 1)	
		End
			
		-- Delete Survey Actuals entered 
		Delete V
		From dbo.DigblockSurveyActualValue As V
			Inner Join dbo.DigblockSurveyActual As A
				On (V.Digblock_Survey_Actual_Id = A.Digblock_Survey_Actual_Id)
		Where A.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete N
		From dbo.DigblockSurveyActualNotes As N
		Inner Join dbo.DigblockSurveyActual As A
				On (N.Digblock_Survey_Actual_Id = A.Digblock_Survey_Actual_Id)
		Where A.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete A
		From dbo.DigblockSurveyActual As A
		Where A.Digblock_Survey_Id = @Idigblock_Survey_Id

		--Delete Survey Summary entries created by process		
		Delete N
		From dbo.DigblockSurveySummaryNotes As N
			Inner Join dbo.DigblockSurveySummary As S
				On (N.Digblock_Survey_Summary_Id = S.Digblock_Survey_Summary_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id
		
		Delete V
		From dbo.DigblockSurveySummaryValue As V
			Inner Join dbo.DigblockSurveySummary As S
				On (V.Digblock_Survey_Summary_Id = S.Digblock_Survey_Summary_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete S
		From dbo.DigblockSurveySummary As S
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		--Delete Survey Samples imported/entered
		Delete F
		From dbo.DigblockSurveySample As S 
			Inner Join DigblockSurveySampleFormula As F
				On (S.Digblock_Survey_Sample_Id = F.Digblock_Survey_Sample_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete N
		From dbo.DigblockSurveySample As S 
			Inner Join DigblockSurveySampleNotes As N
				On (S.Digblock_Survey_Sample_Id = N.Digblock_Survey_Sample_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete V
		From dbo.DigblockSurveySample As S 
			Inner Join DigblockSurveySampleValue As V
				On (S.Digblock_Survey_Sample_Id = V.Digblock_Survey_Sample_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete G
		From dbo.DigblockSurveySample As S 
			Inner Join DigblockSurveySampleGrade As G
				On (S.Digblock_Survey_Sample_Id = G.Digblock_Survey_Sample_Id)
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		Delete S
		From dbo.DigblockSurveySample As S 
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id

		--Delete the Digblock Survey
		Delete S
		From dbo.DigblockSurvey As S
		Where S.Digblock_Survey_Id = @Idigblock_Survey_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 
GRANT EXECUTE ON dbo.DeleteDigblockSurvey TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockSurvey">
 <Procedure>
	Deletes records with the specified @Digblock_Survey_Date, @Digblock_Survey_Shift and @Digblock_Survey_Type_Id from the following tables:
		DigblockSurveyActualValue
		DigblockSurveyActualNotes
		DigblockSurveyActual
		DigblockSurveySummary
		DigblockSurveySampleFormula
		DigblockSurveySampleNotes
		DigblockSurveySampleValue
		DigblockSurveySampleGrade
		DigblockSurveySample
		DigblockSurvey
	Errors are raised if:
		The digblock survey does not exist
		The survey must be unapproved before it can be deleted
		The digblock survey details could not be deleted for some other reason
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblock.prc'
GO

IF OBJECT_ID('dbo.DeleteDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.DeleteDigblock 
GO 
  
CREATE PROCEDURE dbo.DeleteDigblock 
( 
    @iDigblock_Id VARCHAR(31) 
) 
WITH ENCRYPTION 
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.DeleteDigblock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS 
			(
				SELECT 1
				FROM dbo.Digblock
				WHERE Digblock_Id = @iDigblock_Id
			)
		BEGIN
			RAISERROR('The digblock does not exist.', 16, 1)	
		END

		IF EXISTS 
			(
				SELECT 1
				FROM dbo.Haulage
				WHERE Source_Digblock_Id = @iDigblock_Id
					AND Haulage_State_Id IN ('N', 'A')
			)
		BEGIN
			RAISERROR('There are existing haulage records related to this digblock.', 16, 1)	
		END
		
		IF EXISTS
			(
				SELECT 1
				FROM dbo.DigblockSurveySample
				WHERE Digblock_Id = @iDigblock_Id
			)
		BEGIN
			RAISERROR('There are existing digblock depletions related to this digblock.', 16, 1)
		END
		
		-- unlink existing haulage records that are Modified/Deleted
		UPDATE dbo.Haulage
		SET Source_Digblock_Id = NULL
		WHERE Source_Digblock_Id = @iDigblock_Id
			AND Haulage_State_Id IN ('M', 'D')
		
		DELETE
		FROM dbo.DigblockSurveySummary
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockModelBlock
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockSurveyActual
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockValue
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockNotes
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockMaterialType
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockLocation
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM DigblockGrade
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.DigblockPolygon
		WHERE Digblock_Id = @iDigblock_Id

		DELETE
		FROM dbo.Digblock
		WHERE Digblock_Id = @iDigblock_Id

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteDigblock TO CoreDigblockManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblock">
 <Procedure>
	Deletes records with the specified @Digblock_Id from the following tables:
		DigblockSurveySummary
		DigblockModelBlock
		DigblockSurveyActual
		DigblockValue
		DigblockNotes
		DigblockMaterialType
		DigblockLocation
		DigblockGrade
		DigblockPolygon
		Digblock

	Errors are raised if:
		The digblock does not exist
		There are existing haulage records related to this digblock
		There are existing digblock depletions related to this digblock
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockSurveyActual.prc'
GO

If object_id('dbo.DeleteDigblockSurveyActual') is not NULL
	Drop Procedure dbo.DeleteDigblockSurveyActual
Go

CREATE Procedure dbo.DeleteDigblockSurveyActual
(
	@iDigblock_Survey_Actual_Id Int
)

With Encryption 
As

Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Delete From DigblockSurveyActualValue
	Where Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id

	Delete From DigblockSurveyActualNotes
	Where Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id

	Delete From DigblockSurveyActual
	Where Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id

	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.DeleteDigblockSurveyActual TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockSurveyActual">
 <Procedure>
	Deletes records with the specified @Digblock_Survey_Actual_Id from the following tables:
		DigblockSurveyActualValue
		DigblockSurveyActualNotes
		DigblockSurveyActual
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockPolygon.prc'
GO

If object_id('dbo.DeleteDigblockPolygon') is Not NULL
	Drop Procedure dbo.DeleteDigblockPolygon
Go

Create Procedure dbo.DeleteDigblockPolygon
(
	@iDigblock_Id VarChar(31)
)
With Encryption 
As

Begin

	Set NoCount On

	--Delete all DigblockPolygon records for a selected Digblock_Id
	Delete From DigblockPolygon
	Where Digblock_Id = @iDigblock_Id

End
Go
GRANT EXECUTE ON dbo.DeleteDigblockPolygon TO CoreDigblockManager
/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockPolygon">
 <Procedure>
	Deletes all polygons from DigblockPolygon for the digblock.
	Errors are not raised.

 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDrill.prc'
GO

IF OBJECT_ID('dbo.DeleteDrill') IS NOT NULL
	DROP PROCEDURE dbo.DeleteDrill
GO

CREATE PROCEDURE dbo.DeleteDrill
(
	@iDrill_Id VARCHAR(31)
)
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON

	DELETE Drill
	WHERE Drill_Id = @iDrill_Id
END
GO
GRANT EXECUTE ON dbo.DeleteDrill TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDrill">
 <Procedure>
	Deletes a record from the Drill table.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageRaw.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageRaw'))
	Drop Procedure dbo.DeleteHaulageRaw
Go

Create Procedure dbo.DeleteHaulageRaw
(
	@iHaulage_Raw_Id Int
)

With Encryption
As

Begin
	DECLARE @FirstHaulageRawId INT
	Declare @Haulage_Raw_Id Int
	Declare @Order_No Int
	Declare @RAW_DELETE_QUEUE Table
	(
		Haulage_Raw_Id Int,
		Order_No Int
	)
	Declare @curRAW_DELETE_QUEUE Cursor

	Declare @Haulage_Id Int
	Declare @curDELETE_QUEUE Cursor

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- The HaulageRaw record can only be deleted if there is no conflict
	-- (that is, the original record has been end-User modified or approved)
	If dbo.GetHaulageRawConflictFlag(@iHaulage_Raw_Id) = 1
	Begin
		RaisError('DeleteHaulageRaw: The Haulage record has been modified or approved.', 16, 1)
	End
	Else If Not Exists (Select 1 From HaulageRaw Where Haulage_Raw_Id = @iHaulage_Raw_Id)
	Begin
		RaisError('DeleteHaulageRaw: The Haulage record does not exist.', 16, 1)
	End
	Else
	Begin
		SET @FirstHaulageRawId = dbo.GetFirstHaulageRawId(@iHaulage_Raw_Id)

		-- delete the record, and all children
		Set @Haulage_Raw_Id = @FirstHaulageRawId
		Set @Order_No = 1
		While @Haulage_Raw_Id Is Not Null
		Begin
			Insert Into @RAW_DELETE_QUEUE
				(Haulage_Raw_Id, Order_No)
			Values
				(@Haulage_Raw_Id, @Order_No)

			Select @Haulage_Raw_Id = Child_Haulage_Raw_Id
			From HaulageRaw
			Where Haulage_Raw_Id = @Haulage_Raw_Id

			Set @Order_No = @Order_No + 1
		End

		Set @curRAW_DELETE_QUEUE = Cursor Local Fast_Forward Read_Only For
			Select Haulage_Raw_Id
			From @RAW_DELETE_QUEUE
			Order By Order_No Desc

		Open @curRAW_DELETE_QUEUE
		Fetch Next From @curRAW_DELETE_QUEUE Into @Haulage_Raw_Id
		While @@Fetch_Status = 0
		Begin	
			-- loop through each Haulage record that references HaulageRaw
			-- attempt to delete this record
			-- note: there is no chain to consider, as this is part of the Conflict check

			Set @curDELETE_QUEUE = Cursor Local Fast_Forward Read_Only For
				Select Haulage_Id
				From Haulage
				Where Haulage_Raw_Id = @Haulage_Raw_Id

			Open @curDELETE_QUEUE
			Fetch Next From @curDELETE_QUEUE Into @Haulage_Id
			While @@Fetch_Status = 0
			Begin
				Exec dbo.DeleteHaulage
					@iHaulage_Id = @Haulage_Id

				Fetch Next From @curDELETE_QUEUE Into @Haulage_Id
			End
			Close @curDELETE_QUEUE

			-- unlink any references to this record
			-- (as it may not be at the start of the chain)
			Update HaulageRaw
			Set Haulage_Raw_State_Id = 'A',
				Child_Haulage_Raw_Id = Null
			Where Parent_Haulage_Raw_Id = @FirstHaulageRawId

			-- delete the HaulageRaw records...
			Delete
			From HaulageRawGrade
			Where Haulage_Raw_Id = @Haulage_Raw_Id

			Delete
			From HaulageRawNotes
			Where Haulage_Raw_Id = @Haulage_Raw_Id

			Delete
			From HaulageRawValue
			Where Haulage_Raw_Id = @Haulage_Raw_Id

			Delete
			From HaulageRawError
			Where Haulage_Raw_Id = @Haulage_Raw_Id
			
			Delete
			From HaulageRawLocation
			Where HaulageRawId = @Haulage_Raw_Id

			Delete
			From HaulageRaw
			Where Haulage_Raw_Id = @Haulage_Raw_Id

			Fetch Next From @curRAW_DELETE_QUEUE Into @Haulage_Raw_Id
		End
		Close @curRAW_DELETE_QUEUE
	End

	Commit Transaction
End
Go
  GRANT EXECUTE ON dbo.DeleteHaulageRaw TO CoreHaulageManager

 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageRaw">
 <Procedure>
	Deletes records from the HaulageRaw tables after first deleting associated Haulage records.
	
	Deletes from the following HaulageRaw tables:
		HaulageRawGrade
		HaulageRawValue
		HaulageRawNotes
		HaulageRawError
		HaulageRaw
		
	Errors are raised if:
		The Haulage record does not exist
		The Haulage record has been modified or approved
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMaterialTypeGroup.prc'
GO

If Object_Id('dbo.DeleteMaterialTypeGroup') Is Not Null 
     Drop Procedure dbo.DeleteMaterialTypeGroup 
Go

Create Procedure dbo.DeleteMaterialTypeGroup
(
	@iMaterial_Type_Group_Id Int
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @Count Int
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the material type group exists */
	Select @Count = Count(*)
	From MaterialTypeGroup
	Where Material_Type_Group_Id = @iMaterial_Type_Group_Id

	/* If it does */
	If (@Count = 1)
	Begin
		/* Check to see if there are any material types associated with this material type group */
		Select @Count = Count(*)
		From MaterialType
		Where Material_Type_Group_Id = @iMaterial_Type_Group_Id

		/* If there are none */
		If (@Count = 0)
		Begin
			Delete From MaterialTypeGroup
			Where Material_Type_Group_Id = @iMaterial_Type_Group_Id

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('There are one or more material types associated with this group', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given material type group does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.DeleteMaterialTypeGroup TO CoreUtilityManager


 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteMaterialTypeGroup">
 <Procedure>
	Deletes a record from teh MaterialTypeGroup table.
	Errors are raised if:
		The given material type group does not exist
		There are one or more material types associated with this group
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMaterialTypeWasteTypePeriod.prc'
GO

If Object_Id('dbo.DeleteMaterialTypeWasteTypePeriod') Is Not Null 
     Drop Procedure dbo.DeleteMaterialTypeWasteTypePeriod 
Go

Create Procedure dbo.DeleteMaterialTypeWasteTypePeriod
(
	@iMaterial_Type_Id Int,
	@iWaste_Type_Id Varchar(31)
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- If the given record exists
	If Exists (Select 1
				From MaterialTypeWasteTypePeriod
				Where Material_Type_Id = @iMaterial_Type_Id
					And Waste_Type_Id = @iWaste_Type_Id
					And End_Date Is Null)
	Begin
	
		-- Delete that record
		Delete From MaterialTypeWasteTypePeriod
		Where Material_Type_Id = @iMaterial_Type_Id
			And Waste_Type_Id = @iWaste_Type_Id
			And End_Date Is Null

		-- If there is now only one period record for this material type and waste type
		If ((Select Count(*) From MaterialTypeWasteTypePeriod Where Material_Type_Id = @iMaterial_Type_Id And Waste_Type_Id = @iWaste_Type_Id) = 1)
		Begin
			-- Ensure that it's end date is set to null so that it covers all time
			Update MaterialTypeWasteTypePeriod
			Set	End_Date = Null
			Where Material_Type_Id = @iMaterial_Type_Id
				And Waste_Type_Id = @iWaste_Type_Id
		End
		Else
		Begin
			-- Update the end date of the last period record to null
			Update MTWTP
			Set	End_Date = Null
			From MaterialTypeWasteTypePeriod MTWTP
			Where Material_Type_Id = @iMaterial_Type_Id
				And Waste_Type_Id = @iWaste_Type_Id
				And End_Date =	(Select Max(MTWTP2.End_Date)
								From MaterialTypeWasteTypePeriod MTWTP2
								Where MTWTP2.Material_Type_Id = @iMaterial_Type_Id
									And MTWTP2.Waste_Type_Id = @iWaste_Type_Id)
		End

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given material type waste type period record does not exist', 16, 1)
	End

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.DeleteMaterialTypeWasteTypePeriod TO CoreUtilityManager


 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteMaterialTypeWasteTypePeriod">
 <Procedure>
	Deletes a record from teh MaterialTypeWasteTypePeriod table for the specified
	@iMaterial_Type_Id and @iWaste_Type_Id values if the record does not have an End_Date specified.
	Sets the End_Date of the previous record to NULL.
	Errors are raised if:
		The given material type waste type period record does not exist
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMaterialType.prc'
GO

IF OBJECT_ID('dbo.DeleteMaterialType') IS NOT NULL
     DROP PROCEDURE dbo.DeleteMaterialType
GO 
  
CREATE PROCEDURE dbo.DeleteMaterialType 
(
	@iMaterial_Type_Id INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Message VARCHAR(255)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteMaterialType',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF EXISTS
		(
			SELECT 1 
			FROM dbo.MaterialType 
			WHERE Parent_Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			SET @Message = 'There are other material types which depend on this material type'
			Raiserror (@Message, 16, 1)
		END
	
		IF EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.Digblock
			WHERE Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			Raiserror ('Material type is associated with at least one digblock', 16, 1)
		END
		
		IF EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.MinePlanPeriod
			WHERE Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			Raiserror ('Material type is associated with at least one mine plan', 16, 1)
		END
		
		IF EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.Stockpile
			WHERE Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			Raiserror ('Material type is associated with at least one stockpile', 16, 1)
		END
		
		IF EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.ModelBlockPartialMaterialType
			WHERE Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			Raiserror ('Material type is associated with block model data', 16, 1)
		END

		DELETE FROM MaterialTypeNotes
		WHERE Material_Type_Id = @iMaterial_Type_Id

		DELETE FROM MaterialTypeWasteTypePeriod
		WHERE Material_Type_Id = @iMaterial_Type_Id
		
		DELETE FROM MaterialTypeLocation
		WHERE Material_Type_Id = @iMaterial_Type_Id

		DELETE FROM MaterialType
		WHERE Material_Type_Id = @iMaterial_Type_Id

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteMaterialType TO CoreUtilityManager
GO

 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteMaterialType">
 <Procedure>
	Deletes records with the specified @Material_Type_Id value from the following tables:
		MaterialTypeNotes
		MaterialTypeWasteTypePeriod
		MaterialType
	Errors are raised if:
		Material type is associated with at least one digblock
		Material type is associated with at least one stockpile
		Material type is associated with at least one mine plan
		Material type is associated with block model data
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteObjectNotes.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteObjectNotes'))
	Drop Procedure dbo.DeleteObjectNotes
Go

CREATE Procedure dbo.DeleteObjectNotes
(
	@iObject_Id Varchar(31)
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the object notes value exists */
	If Exists (Select * From ObjectNotes Where Object_Id = @iObject_Id)
	Begin
		/* Update it's details */
		Delete from ObjectNotes
		Where Object_Id = @iObject_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
	Raiserror ('The given object deos not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.DeleteObjectNotes TO CoreUtilityManager



/*
<TAG Name="Data Dictionary" ProcedureName="DeleteObjectNotes">
 <Procedure>
	Deletes the object from the ObjectNotes table.
	Errors are raised if:
		The given object deos not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteReportGroup.prc'
GO

If Object_Id('dbo.DeleteReportGroup') Is Not Null 
     Drop Procedure dbo.DeleteReportGroup 
Go

Create Procedure dbo.DeleteReportGroup
(
	@iReport_Group_Id int
)

With Encryption
As

Begin
	Set Nocount On
	
	Update Report
	Set Report_Group_Id = Null
	Where Report_Group_Id = @iReport_Group_Id

	Delete
	From ReportGroup
	Where Report_Group_Id = @iReport_Group_Id

End
Go
GRANT EXECUTE ON dbo.DeleteReportGroup TO CoreReportManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteReportGroup">
 <Procedure>
	Deletes the Report_Group table record and changes any report which are grouped to it
	to have a Report_Group_Id of null.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileGroupStockpile.prc'
GO

If Object_Id('dbo.DeleteStockpileGroupStockpile') Is Not Null 
     Drop Procedure dbo.DeleteStockpileGroupStockpile 
Go

Create Procedure dbo.DeleteStockpileGroupStockpile
(
	@iStockpile_Group_Id Varchar(31),
	@iStockpile_Id Int
)

With Encryption 
As

Begin
	Set Nocount On

	/* Add the stockpile to the group */
	Delete From StockpileGroupStockpile
	Where Stockpile_Group_Id = @iStockpile_Group_Id
		And Stockpile_Id = @iStockpile_Id

End
Go
GRANT EXECUTE ON dbo.DeleteStockpileGroupStockpile TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileGroupStockpile">
 <Procedure>
	Deletes a record from the StockpileGroupStockpile table for the specified @iStockpile_Group_Id and @iStockpile_Id.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileGroup.prc'
GO

If object_id('dbo.DeleteStockpileGroup') is not null
	Drop Procedure dbo.DeleteStockpileGroup
GO

Create Procedure dbo.DeleteStockpileGroup
(
	@iStockpile_Group_Id Varchar(31)
)
With Encryption As
Begin
	Set Nocount On

	Declare @Order_No Int

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- If the stockpile group exists
	If Exists 
		(
			Select 1 
			From StockpileGroup 
			Where Stockpile_Group_Id = @iStockpile_Group_Id
		)
	Begin
		-- Delete the stockpile group's associated stockpiles
		Delete 
		From StockpileGroupStockpile
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		--Delete Formulas, Values & Notes
		Delete
		From StockpileGroupNotes
		Where Stockpile_Group_Id = @iStockpile_Group_Id
	
		Delete
		From StockpileGroupFormula
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		Delete
		From StockpileGroupValue
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		-- Get the order number of the stockpile group
		Select @Order_No = Order_No
		From StockpileGroup
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		-- Delete the stockpile group itself
		Delete From StockpileGroup
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		-- Decrement the order number of all the stockpile groups which have an
		--  order number greater than this one
		Update StockpileGroup
		Set	Order_No = Order_No - 1
		Where Order_No > @Order_No

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given stockpile group does not exist', 16 ,1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.DeleteStockpileGroup TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileGroup">
 <Procedure>
	Deletes records with the specified @Stockpile_Group_Id from the following tables:
		StockpileGroupStockpile
		StockpileGroupNotes
		StockpileGroupFormula
		StockpileGroup
	Decrements the Order_No for StockpileGroup records that have an order_no greater than the deleted StockpileGroup record.
	Errors are raised if:
		The given stockpile group does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileBuildComponent.prc'
GO

If object_id('dbo.DeleteStockpileBuildComponent') is not NULL
	Drop Procedure dbo.DeleteStockpileBuildComponent
Go

CREATE Procedure dbo.DeleteStockpileBuildComponent
(
	@iStockpile_Id Int,
	@iBuild_Id Int,
	@iComponent_Id Int
)

With Encryption 
As

Begin

	Declare @Exists Bit
	Declare @Count Int
	Declare @Error Int
	Declare @Start_Date Datetime
	Declare @Shift Char(1)

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the stockpile build component exists */
	If (dbo.DoesStockpileBuildComponentExist (@iStockpile_Id, @iBuild_Id, @iComponent_Id) = 1)
	Begin
		/* Check to see if there are any transactions related to this stockpile build component */
		Select @Count = Count(*)
		From DataTransactionTonnes
		Where (Source_Stockpile_Id = @iStockpile_Id
			And Source_Build_Id = @iBuild_Id
			And Source_Component_Id = @iComponent_Id)
			Or (Destination_Stockpile_Id = @iStockpile_Id
			And Destination_Build_Id = @iBuild_Id
			And Destination_Component_Id = @iComponent_Id)

		/* If there are none */
		If (@Count = 0)
		Begin
			/* Begin the transaction to delete the stockpile build component and all it's related records */
			Set @Error = 0
			Begin Transaction DeleteStockpileBuildComponent

			/* Get the start date of this stockpile build */
			Select @Start_Date = Start_Date
			From StockpileBuild
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id

			-- recalculate from the beginning of the period
			Exec RecalcL1RaisePeriod @iStart_Date=@Start_Date

			-----------------------------------------------------------------------
			-- Delete from the Grade table
			-----------------------------------------------------------------------
			If (@Error = 0 )
			Begin
				Delete From StockpileBuildComponentGrade
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
					And Component_Id = @iComponent_Id

				Set @Error = @@Error
			End

			If (@Error = 0)
			Begin
				Delete From StockpileBuildComponent
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
					And Component_Id = @iComponent_Id

				Set @Error = @@Error
			End


			/* If nothing went wrong */
			If (@Error = 0)
			Begin
				/* Commit the transaction */
				Commit Transaction DeleteStockpileBuildComponent

				If @@Error = 0
					SEt @ELC_Proc_Is_Error = 0
			End
			Else
			Begin
				/* Otherwise, cancel it */
				Rollback Transaction DeleteStockpileBuildComponent

				Raiserror ('Error occured while deleting stockpile build component and related details', 16, 1)
			End					
		End
		Else
		Begin
			Raiserror ('There are one or more transactions in the system related to this stockpile build component', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The stockpile build component does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.DeleteStockpileBuildComponent TO CoreStockpileManager



/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileBuildComponent">
 <Procedure>
	Deletes records with the specified @Stockpile_Id, @Build_Id and @Component_Id from the following tables:
		StockpileBuildComponentGrade
		StockpileBuildComponent
	Level 1 Recalc events are raised from the start date of the StockpileBuild record for the specified @Stockpile_Id and @Build_Id.
	Errors are raised if:
		The stockpile build component does not exist
		There are one or more transactions in the system related to this stockpile build component
		Another error occured while deleting stockpile build component and related details
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileBuild.prc'
GO

If object_id('dbo.DeleteStockpileBuild') is not NULL
	Drop Procedure dbo.DeleteStockpileBuild
Go

CREATE Procedure dbo.DeleteStockpileBuild
(
	@iStockpile_Id Int,
	@iBuild_Id Int
)

With Encryption
As

Begin

	Declare @Exists Bit
	Declare @Count Int
	Declare @Start_Date Datetime
	Declare @Shift Char(1)

	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	/* If the stockpile build exists */
	If (dbo.DoesStockpileBuildExist (@iStockpile_Id, @iBuild_Id) = 1)
	Begin
		/* Check to see if there are any transactions related to this stockpile build */
		Select @Count = Count(*)
		From DataTransactionTonnes
		Where (Source_Stockpile_Id = @iStockpile_Id
			And Source_Build_Id = @iBuild_Id)
			Or (Destination_Stockpile_Id = @iStockpile_Id
			And Destination_Build_Id = @iBuild_Id)

		/* If there are none */
		If (@Count = 0)
		Begin
			/* Get the start date of this stockpile build */
			Select @Start_Date = Start_Date
			From StockpileBuild
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id

			-- recalculate from the start of this period
			Exec RecalcL1RaisePeriod
				@iStart_Date=@Start_Date

			-----------------------------------------------------------------------
			-- Delete from the Grade table
			-----------------------------------------------------------------------
			Delete From StockpileBuildComponentGrade
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id

			Delete From StockpileBuildComponent
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id

			Delete From StockpileBuild
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id
		End
		Else
		Begin
			Raiserror ('There are one or more transactions in the system related to this stockpile build', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The stockpile build does not exist', 16, 1)
	End
	
	Commit Transaction

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.DeleteStockpileBuild TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileBuild">
 <Procedure>
	Deletes records with the specified @Stockpile_Id and @Build_Id from the following tables:
		StockpileBuildComponentGrade
		StockpileBuildComponent
		StockpileBuild
	Level 1 Recalc events are raised from the start date of the StockpileBuild record that is deleted.
	Errors are raised if:
		The stockpile build does not exist
		There are one or more transactions in the system related to this stockpile build
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpile.prc'
GO

If Object_Id('dbo.DeleteStockpile') Is Not Null 
     Drop Procedure dbo.DeleteStockpile 
Go 

CREATE Procedure dbo.DeleteStockpile
(
	@iStockpile_Id Int
)

With Encryption
As

Begin
	Declare @Exists Bit
	Declare @Count Int
	Declare @Start_Date Datetime
	Declare @Shift Char(1)
	Declare @Stockpile_Name VarChar(31)
	Declare @Error Int

	Set Nocount On

	Select @Stockpile_Name = dbo.GetStockpileName(@iStockpile_Id)

	/* If the stockpile exists */
	If (dbo.DoesStockpileExist (@Stockpile_Name) = 1)
	Begin
		/* Check to see if there are any transactions related to this stockpile */
		Select @Count = Count(*)
		From Haulage
		Where (Source_Stockpile_Id = @iStockpile_Id
			Or Destination_Stockpile_Id = @iStockpile_Id)

		/* If there are none */
		If (@Count = 0)
		Begin
			/* Check to see if the stockpile is used by any weightometers */
			Select @Count = Count(*)
			From WeightometerFlowPeriod
			Where Source_Stockpile_Id = @iStockpile_Id
				Or Destination_Stockpile_Id = @iStockpile_Id

			/* If there are none */
			If (@Count = 0)
			Begin
				/* Check to see if the stockpile is used by any weightometer in override circumstances */
				Select @Count = Count(*)
				From WeightometerSample
				Where Source_Stockpile_Id = @iStockpile_Id
					Or Destination_Stockpile_Id = @iStockpile_Id
	
				/* If there are none */
				If (@Count = 0)
				Begin
					/* Check to see if there are any adjustments associated with this stockpile */
					Select @Count = Count(*)
					From StockpileAdjustment
					Where Stockpile_Id = @iStockpile_Id
					
					/* If there are none */
					If @Count = 0
					Begin
						/* Check to see if there are any Mills associated with this stockpile */
						Select @Count = Count(*)
						From Mill
						Where Stockpile_Id = @iStockpile_Id

						/* If there are none */
						If (@Count = 0)
						Begin
							/* Check to see if there are any survey sample data associated with this stockpile */
							Select @Count = Count(*)
							From StockpileSurveySample
							Where Stockpile_Id = @iStockpile_Id

							/* If there are none */
							If (@Count = 0)
							Begin
								/* Check to see if there are any survey sample data associated with this stockpile */
								Select @Count = Count(*)
								From StockpileChildStockpile
								Where Conceptual_Stockpile_Id = @iStockpile_Id

								/* If there are none */
								If @Count = 0
								Begin

									/* Begin the transaction to delete the stockpile and all it's related records */
									Set @Error = 0
									Begin Transaction DeleteStockpile

									/* Get the start date/shift of the earliest starting build for this stockpile, if any */
									Select Top 1 @Start_Date = Start_Date
									From StockpileBuild
									Where Stockpile_Id = @iStockpile_Id
									Order By Start_Date Asc
					
									-- recalc everything from this date onwards
									Exec RecalcL1RaisePeriod
										@iStart_Date=@Start_Date
					
									Delete From StockpileStockpileTypePeriod
									Where Stockpile_Id = @iStockpile_Id
					
									-----------------------------------------------------------------------
									-- Delete from the Grade table
									-----------------------------------------------------------------------
									Delete From StockpileBuildComponentGrade
									Where Stockpile_Id = @iStockpile_Id

									Delete From StockpileBuildComponent
									Where Stockpile_Id = @iStockpile_Id
				
									Delete From StockpileBuild
									Where Stockpile_Id = @iStockpile_Id

									Delete From StockpileGroupStockpile
									Where Stockpile_Id = @iStockpile_Id
					
									Delete From StockpileNotes
									Where Stockpile_Id = @iStockpile_Id

									Delete From StockpileValue
									Where Stockpile_Id = @iStockpile_Id
									
									Delete From StockpileLocation
									Where Stockpile_Id = @iStockpile_Id

									Delete From StockpileChildStockpile
									Where Child_Stockpile_Id = @iStockpile_Id

									Delete From Stockpile
									Where Stockpile_Id = @iStockpile_Id

									Set @Error = @@Error

									If (@Error = 0)
									Begin
										/* Commit the transaction */
										Commit Transaction DeleteStockpile		

									End
									Else
									Begin
										/* Otherwise, cancel it */
										Rollback Transaction DeleteStockpile
										Raiserror ('Error occured while deleting stockpile and related details', 16, 1)
									End
								End
								Else
								Begin
									Raiserror ('There are one or more stockpile child stockpile records in the system related to this stockpile', 16, 1)
								End
							End
							Else
							Begin
								Raiserror ('There are one or more stockpile survey sample records in the system related to this stockpile', 16, 1)
							End
						End
						Else
						Begin
							Raiserror ('There are one or more Mill records in the system related to this stockpile', 16, 1)
						End
					End
					Else
					Begin
						Raiserror ('There are one or more stockpile adjustments in the system related to this stockpile', 16, 1)
					End
				End
				Else
				Begin
					Raiserror ('This stockpile is used in some specific weightometer samples', 16, 1)
				End
			End
			Else
			Begin
				Raiserror ('This stockpile is currently linked to a weightometer', 16, 1)
			End
		End
		Else
		Begin
			Raiserror ('There are one or more transactions in the system related to this stockpile', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The stockpile does not exist', 16, 1)
	End

End
Go
GRANT EXECUTE ON dbo.DeleteStockpile TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpile">
 <Procedure>
	Deletes records with the specified @Stockpile_Id from the following tables:
		StockpileStockpileTypePeriod
		StockpileBuildComponentGrade
		StockpileBuildComponent
		StockpileBuild
		StockpileGroupStockpile
		StockpileNotes
		StockpileValue
		StockpileLocation
		Stockpile
	A Level 1 Recalc events are raised from the start date of the StockpileBuild record
	that is deleted.
	Errors are raised if:
		The stockpile does not exist
		There are one or more transactions in the system related to this stockpile
		This stockpile is currently linked to a weightometer
		This stockpile is used in some specific weightometer samples
		There are one or more stockpile adjustments in the system related to this stockpile
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileGroupStockpileAll.prc'
GO

If Object_Id('dbo.DeleteStockpileGroupStockpileAll') Is Not Null 
     Drop Procedure dbo.DeleteStockpileGroupStockpileAll 
Go

Create Procedure dbo.DeleteStockpileGroupStockpileAll
(
	@iStockpile_Group_Id Varchar(31)
)
With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Delete From StockpileGroupStockpile
	Where Stockpile_Group_Id = @iStockpile_Group_Id

	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0
	
	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.DeleteStockpileGroupStockpileAll TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileGroupStockpileAll">
 <Procedure>
	Deletes the whole group from a StockpileGroupStockpile.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileStockpileTypePeriodAll.prc'
GO

If Object_Id('dbo.DeleteStockpileStockpileTypePeriodAll') Is Not Null
	Drop Procedure dbo.DeleteStockpileStockpileTypePeriodAll
Go

Create Procedure dbo.DeleteStockpileStockpileTypePeriodAll
(
	@iStockpile_Id Int
)

With Encryption 
As

Begin

	Set Nocount On

	-- Delete all records
	Delete From dbo.StockpileStockpileTypePeriod
	Where Stockpile_Id = @iStockpile_Id

End
GO
GRANT EXECUTE ON dbo.DeleteStockpileStockpileTypePeriodAll TO CoreStockpileManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileStockpileTypePeriodAll">
 <Procedure>
	Deletes a all records from the StockpileStockpileTypePeriod table for this @iStockpile_Id
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteTruckType.prc'
GO

If object_id('dbo.DeleteTruckType') is not Null 
     Drop Procedure dbo.DeleteTruckType 
Go 
  
Create Procedure dbo.DeleteTruckType
( 
    @iTruck_Type_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		Declare @First_Rec Int,
			@Is_Default Bit

		If Not Exists 
			(
				Select 1
				From TruckType
				Where Truck_Type_Id = @iTruck_Type_Id
			)
		Begin
			Raiserror ('The given truck type does not exist', 16, 1)
		End

		If Exists 
			(
				Select 1
				From Truck
				Where Truck_Type_Id = @iTruck_Type_Id
			)
		Begin
			Raiserror ('The given truck type has trucks of this type in the system', 16, 1)
		End

		--Delete Truck factor period records
		Delete From TruckTypeFactorPeriod
		Where Truck_Type_Id = @iTruck_Type_Id

		--Delete the truck type
		Delete From TruckType
		Where Truck_Type_Id = @iTruck_Type_Id

		-- If this was the default record 
		If (@Is_Default = 1)
		Begin
			-- Check to see if there are any trucks left in the system
			Select @First_Rec = Min(Truck_Type_Id)
			From TruckType
	
			-- If there are any
			If (@First_Rec Is Not Null)
			Begin
				-- Make the first record the new default record
				Update TruckType
				Set	Is_Default = 1
				Where Truck_Type_Id = @First_Rec
			End
		End

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	  
End 
Go 
GRANT EXECUTE ON dbo.DeleteTruckType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteTruckType">
 <Procedure>
	Deletes a record from the TruckType table. If this was the default truck type set the first
	truck type to be the default.
	Errors are raised if:
		The given truck type does not exist
		The given truck type has trucks of this type in the system
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteTruck.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteTruck'))
	Drop Procedure dbo.DeleteTruck
Go

CREATE Procedure dbo.DeleteTruck
(
	@iTruck_Id Varchar(31)
)

With Encryption 
As

Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If a truck with this name exists */
	If (dbo.DoesTruckExist (@iTruck_Id) = 1)
	Begin
		/* If this truck is not referenced by any haulage records */
		If Not Exists (Select * From Haulage Where Truck_Id = @iTruck_Id)
		Begin
			Delete From Truck
			Where Truck_Id = @iTruck_Id

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given truck is referenced by one or more haulage records', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given truck does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder


End
GO
GRANT EXECUTE ON dbo.DeleteTruck TO CoreUtilityManager




/*
<TAG Name="Data Dictionary" ProcedureName="DeleteTruck">
 <Procedure>
	Deletes a record from the Truck table.
	Errors are raised if:
		The given truck does not exist
		The given truck is referenced by one or more haulage records
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteTruckTypeFactorPeriod.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteTruckTypeFactorPeriod'))
	Drop Procedure dbo.DeleteTruckTypeFactorPeriod
Go

Create Procedure dbo.DeleteTruckTypeFactorPeriod
(
	@iTruck_Type_Id Int
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	-- If the given record exists
	If Exists (Select 1
		From TruckTypeFactorPeriod TTP
		Where TTP.Truck_Type_Id = @iTruck_Type_Id
			And End_Date Is Null)
	Begin

		-- Delete that record
		Delete From TruckTypeFactorPeriod 
		Where Truck_Type_Id = @iTruck_Type_Id
			And End_Date Is Null

		-- If there is now only one period record for this truck type type
		If (
			(Select Count(*) 
			From TruckTypeFactorPeriod TTP
			Where Truck_Type_Id = @iTruck_Type_Id
			) = 1)
		Begin
			-- Ensure that it's end date is set to null so that it covers all time
			Update TruckTypeFactorPeriod 
			Set	End_Date = Null
			Where Truck_Type_Id = @iTruck_Type_Id
		End
		Else
		Begin

			-- Update the end date of the last period record to null
			Update TTP
			Set	End_Date = Null
			From TruckTypeFactorPeriod TTP
			Where TTP.Truck_Type_Id = @iTruck_Type_Id
			And End_Date = (Select Max(TTP2.End_Date)
				From TruckTypeFactorPeriod TTP2
				Where TTP2.Truck_Type_Id = @iTruck_Type_Id)
		End

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given truck type factor period record does not exist', 16, 1)
	End

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.DeleteTruckTypeFactorPeriod TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteTruckTypeFactorPeriod">
 <Procedure>
	Deletes a record from the TruckTypeFactorPeriod table.
	If there is now only one period record for this truck type type then it 
	ensures that it's end date is set to null so that it covers all time otherwise
	Update the end date of the last period record to null.
	Errors are raised if:
		The given truck type factor period record does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteWasteType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteWasteType'))
	Drop Procedure dbo.DeleteWasteType
Go

CREATE Procedure dbo.DeleteWasteType
(
	@iWaste_Type_Id Varchar(31)
)

With Encryption 
As

Begin

	Declare @Count Int

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1



	If not Exists (select * from MaterialTypeWasteTypePeriod where Waste_Type_Id = @iWaste_Type_Id)
	Begin
		/* Check to see if the waste type exists */
		Select @Count = Count(*)
		From WasteType
		Where Waste_Type_Id = @iWaste_Type_Id

		If (@Count <> 0)
		Begin

			Delete From WasteType
			Where Waste_Type_Id = @iWaste_Type_Id

		End
		Else
		Begin
			Raiserror ('The given waste type does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given waste type exists in depend table', 16, 1)
	End
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.DeleteWasteType TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteWasteType">
 <Procedure>
	Deletes a record from the WasteType table.
	Errors raised if:
		The given waste type exists in depend table
		The given waste type does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteWeightometerSample.prc'
GO

If Object_Id('dbo.DeleteWeightometerSample') Is Not Null 
     Drop Procedure dbo.DeleteWeightometerSample 
Go 
  
Create Procedure dbo.DeleteWeightometerSample 
( 
    @iWeightometer_Id Varchar(31) = Null,
	@iWeightometer_Sample_Date Datetime = Null,
	@iWeightometer_Sample_Id Int = Null,
	@iWeightometer_Sample_Shift Char(1) = Null,
	@iOrder_No Int = Null
) 
With Encryption 
As

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		Declare @Count Int

		Set @iWeightometer_Sample_Date = dbo.GetDateDay(@iWeightometer_Sample_Date)

		/* Check to see if a weightometer sample already exists */
		If @iWeightometer_Sample_Id Is Null
		Begin
			Select @iWeightometer_Sample_Id = Weightometer_Sample_Id
			From WeightometerSample
			Where Weightometer_Id = @iWeightometer_Id
				And Weightometer_Sample_Date = @iWeightometer_Sample_Date 
				And ((@iWeightometer_Sample_Shift Is Null And Weightometer_Sample_Shift Is Null) 
					Or (Weightometer_Sample_Shift = @iWeightometer_Sample_Shift))
				And ((Order_No Is Null And @iOrder_No Is Null)
					Or Order_No = @iOrder_No)
		End

		Select @Count = Count(*)
		From WeightometerSample
		Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

		If (@Count > 0)
		Begin
			/* Get the date and shift of the record if it is not already given */
			If (@iWeightometer_Sample_Date Is Null)
			Begin
				Select @iWeightometer_Sample_Date = Weightometer_Sample_Date,
					@iWeightometer_Sample_Shift = Weightometer_Sample_Shift
				From WeightometerSample
				Where Weightometer_Sample_Id = @iWeightometer_Sample_Id
			End

			/* If the weightometer sample does not fall in an already approved month */
			If (dbo.IsInApprovedMonth (@iWeightometer_Sample_Date) = 0)
			Begin
				--Delete Virtual Fields
				Delete From WeightometerSampleValue
				Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

				Delete From WeightometerSampleNotes
				Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

				--Delete Grades
				Delete From WeightometerSampleGrade
				Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

				--Delete Sample
				Delete From WeightometerSample
				Where Weightometer_Sample_Id = @iWeightometer_Sample_Id
			End
			Else
			Begin
				Raiserror ('The sample falls in an already approved month', 16, 1)
			End
		End
		Else
		Begin
			Declare @Error_Message Varchar(255)
			Set @Error_Message = 'The weightometer sample does not exist: ' + Convert(VarChar, @iWeightometer_Sample_Id)
			Raiserror (@Error_Message, 16, 1)
		End
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.DeleteWeightometerSample TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteWeightometerSample">
 <Procedure>
	Deletes records with the specified @iWeightometer_Sample_Id from the following tables:
		WeightometerSampleValue
		WeightometerSampleNotes
		WeightometerSampleGrade
		WeightometerSample
	Level 1 Recalc events are raised for Weightometer_Sample_Date of the deleted WeightometerSample record.	
	Errors raised if:
		The weightometer sample does not exist
		The sample falls in an already approved month
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetApprovedDigblockSurveyList.prc'
GO

If object_id('dbo.GetApprovedDigblockSurveyList') is not NULL
	Drop Procedure dbo.GetApprovedDigblockSurveyList
Go

Create Procedure dbo.GetApprovedDigblockSurveyList
(
	@iDigblock_Survey_Type_Id Int = Null
)
With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select Convert(Varchar, Digblock_Survey_Date, 106) As Digblock_Survey_Date,
		dbo.GetShiftTypeName(S.Digblock_Survey_Shift) As Digblock_Survey_Shift,
		S.Digblock_Survey_Shift As Digblock_Survey_Shift_Id,
		ST.Name As Shift_Name, DST.Name, DST.Digblock_Survey_Type_Id
	From DigblockSurvey S
		Inner Join DigblockSurveyType DST
			On (S.Digblock_Survey_Type_Id = DST.Digblock_Survey_Type_Id
				and IsNull(DST.Is_Visible, 1) = 1)
		Inner Join ShiftType ST
			On S.Digblock_Survey_Shift = ST.Shift
	Where Is_Approved = 1
	And (S.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id or @iDigblock_Survey_Type_Id is NULL)
	Order By Cast(Digblock_Survey_Date As Datetime), dbo.GetShiftTypeOrderNo(Digblock_Survey_Shift)

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder
End
Go
GRANT EXECUTE ON dbo.GetApprovedDigblockSurveyList TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetApprovedDigblockSurveyList">
 <Procedure>
	Returns a list of DigblockSurveyType records for the specified @Digblock_Survey_Type_Id value if:
		DigblockSurveyType record is visible
		DigblockSurvey record is approved
	Resultset is ordered by Date and Shift.	
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetAuditHistoryList.prc'
GO

If object_id('dbo.GetAuditHistoryList') is Not NULL
	Drop Procedure dbo.GetAuditHistoryList
Go

Create Procedure dbo.GetAuditHistoryList
(
	@iFilter_Audit_History_Id Bigint = Null,
	@iFilter_From_Date Datetime = Null,
	@iFilter_To_Date Datetime = Null,
	@iUser_Id Int = Null,
	@iFilter_Audit_Type_Group_Id Int = Null,
	@iFilter_Audit_Type_Id Int = Null,
	@iFilter_Is_Visible Bit = Null
)
With Encryption
As
Begin
	Set NoCount On

	Select	AH.Audit_History_Id, AH.Audit_Type_Id, AH.Audit_History_Datetime,
			AH.Description, AH.Hyperlink, AH.Details, AH.[User_Id],
			U.NTAccountName, U.FirstName, U.LastName,
			AH.Is_Visible, AT.Audit_Type_Group_Id,
			ATG.Name As Audit_Type_Group_Name, AT.Name As Audit_Type_Name
	From	dbo.AuditHistory AH
			Inner Join AuditType AT
				On AH.Audit_Type_Id = AT.Audit_Type_Id
			Inner Join AuditTypeGroup ATG
				On AT.Audit_Type_Group_Id = ATG.Audit_Type_Group_Id
			Left Outer Join dbo.SecurityUser U
				On (AH.[User_Id] = U.UserId)
	Where	(	(@iFilter_Audit_History_Id Is Null)
				Or (AH.Audit_History_Id = @iFilter_Audit_History_Id))
				And (	(@iFilter_From_Date Is Null)
					Or (AH.Audit_History_Datetime >= @iFilter_From_Date))
				And (	(@iFilter_To_Date Is Null)
					Or (AH.Audit_History_Datetime < DateAdd(day,1,@iFilter_To_Date)))
				And (	(@iUser_Id Is Null)
					Or (AH.[User_Id] = @iUser_Id))
				And (	(@iFilter_Audit_Type_Group_Id Is Null)
					Or (AT.Audit_Type_Group_Id = @iFilter_Audit_Type_Group_Id))
				And (	(@iFilter_Audit_Type_Id Is Null)
					Or (AH.Audit_Type_Id = @iFilter_Audit_Type_Id))
				And (	(@iFilter_Is_Visible Is Null)
					Or (AH.Is_Visible = @iFilter_Is_Visible)
			)
	Order By AH.Audit_History_Datetime Desc
End
Go

GRANT EXECUTE ON dbo.GetAuditHistoryList TO CoreEventManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetAuditHistoryList">
 <Procedure>
	Returns a list of all the Audit History.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetAuditTypeGroupList.prc'
GO

If object_id('dbo.GetAuditTypeGroupList') is Not NULL
	Drop Procedure dbo.GetAuditTypeGroupList
Go

Create Procedure dbo.GetAuditTypeGroupList

With Encryption
As

Begin

	Set NoCount On

	Select ATG.Audit_Type_Group_Id,
		ATG.Name, ATG.Description
	From AuditTypeGroup ATG
	Order By ATG.Audit_Type_Group_Id
End
Go
GRANT EXECUTE ON dbo.GetAuditTypeGroupList TO CoreEventManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetAuditTypeGroupList">
 <Procedure>
	Returns a list of all the Audit Type Groups.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetAuditTypeList.prc'
GO

If object_id('dbo.GetAuditTypeList') is Not NULL
	Drop Procedure dbo.GetAuditTypeList
Go

Create Procedure dbo.GetAuditTypeList

(
	@iFilter_Audit_Type_Group_Id As Int = Null
)

With Encryption
As

Begin

	Set NoCount On

	Select AT.Audit_Type_Id, AT.Audit_Type_Group_Id,
		ATG.Name As Audit_Type_Group_Name, AT.Name
	From AuditType AT
		Inner Join AuditTypeGroup ATG
			On AT.Audit_Type_Group_Id = ATG.Audit_Type_Group_Id
	Where ((@iFilter_Audit_Type_Group_Id Is Null)
		Or (@iFilter_Audit_Type_Group_Id = AT.Audit_Type_Group_Id))
	Order By AT.Audit_Type_Group_Id, AT.Name
End
Go
GRANT EXECUTE ON dbo.GetAuditTypeList TO CoreEventManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetAuditTypeList">
 <Procedure>
	Returns a list of all the Audit Types.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetCrusherList.prc'
GO

IF OBJECT_ID('dbo.GetCrusherList') IS NOT NULL
	DROP PROCEDURE dbo.GetCrusherList  
GO 
  
CREATE PROCEDURE dbo.GetCrusherList
(
	@iLocationId INT = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	-- variable declaration here

	SET NOCOUNT ON 

	BEGIN TRY
		SELECT C.Crusher_Id, Description
		FROM dbo.Crusher AS C
			LEFT JOIN dbo.CrusherLocation AS L
				ON (L.Crusher_Id = C.Crusher_Id)
			LEFT JOIN dbo.GetLocationSubtree(@iLocationId) AS LL
				ON (LL.Location_Id = L.Location_Id)
		WHERE (LL.Location_Id IS NOT NULL OR @iLocationId IS NULL)			
		GROUP BY C.Crusher_Id, Description
		ORDER BY C.Crusher_Id
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetCrusherList TO CoreUtilityManager
GO
GRANT EXECUTE ON dbo.GetCrusherList TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetCrusherList">
 <Procedure>
	Returns a list of Crushers in the system, ordered by Crusher_Id.	
	Errors are not raised.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataExceptionTypeList.prc'
GO

If Object_Id('dbo.GetDataExceptionTypeList') Is Not Null 
     Drop Procedure dbo.GetDataExceptionTypeList 
Go 
  
Create Procedure dbo.GetDataExceptionTypeList 
(
	@iData_Exception_Status_Id Varchar(5) = NULL
)

With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	If @iData_Exception_Status_Id is Null
	Begin
		Select Data_Exception_Type_Id, Name, Description, Order_No
		From DataExceptionType
		Order by Order_No Asc
	End
	Else
	Begin
		Select DET.Data_Exception_Type_Id, DET.Name, DET.Description, DET.Order_No
		From DataExceptionType As DET	
			Inner Join DataException As DE
				On DE.Data_Exception_Type_Id = DET.Data_Exception_Type_Id
		Where DE.Data_Exception_Status_Id = @iData_Exception_Status_Id
		Group by DET.Data_Exception_Type_Id, DET.Name, DET.Description, DET.Order_No
		Order by Order_No Asc
	End
  
    Commit Transaction 
End 
Go	
GRANT EXECUTE ON dbo.GetDataExceptionTypeList TO CoreUtilityManager

GRANT EXECUTE ON dbo.GetDataExceptionTypeList TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionTypeList">
 <Procedure>
	Retrieves a list of data exception types. 

	If an Exception status ID is passed in, then it will only return
	a list of types that has exceptions of that status.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataExceptionList.prc'
GO

IF Object_Id('dbo.GetDataExceptionList') IS NOT NULL
     DROP PROCEDURE dbo.GetDataExceptionList
GO 

CREATE PROCEDURE dbo.GetDataExceptionList
( 
    @iData_Exception_Type_Id INT = NULL,
	@iData_Exception_Status_Id VARCHAR(5) = NULL,
	@iExclude_Resolved BIT = 0
) 

WITH ENCRYPTION 
AS 

BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    SELECT Data_Exception_Id, Data_Exception_Type_Id, Data_Exception_Date,
		Data_Exception_Shift, Data_Exception_Status_Id, Short_Description,
		Long_Description, Details_Xml
	FROM dbo.DataException
	WHERE Data_Exception_Type_Id = IsNull(@iData_Exception_Type_Id, Data_Exception_Type_Id)
		AND Data_Exception_Status_Id = IsNull(@iData_Exception_Status_Id, Data_Exception_Status_Id)
		AND (@iExclude_Resolved = 0
			OR Data_Exception_Status_Id <> 'R')
			
	COMMIT TRANSACTION 		
END 
GO
GRANT EXECUTE ON dbo.GetDataExceptionList TO CoreUtilityManager
GRANT EXECUTE ON dbo.GetDataExceptionList TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionList">
 <PROCEDURE>
	Returns a list of data exceptions for the type and/or status specified.
 </PROCEDURE>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataExceptionStatusList.prc'
GO

If Object_Id('dbo.GetDataExceptionStatusList') Is Not Null 
     Drop Procedure dbo.GetDataExceptionStatusList 
Go 
  
Create Procedure dbo.GetDataExceptionStatusList 
( 
    @iData_Exception_Status Varchar(5) = Null 
) 

With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Select Data_Exception_Status_Id, Description
	From DataExceptionStatus
	Where Data_Exception_Status_Id = IsNull(@iData_Exception_Status, Data_Exception_Status_Id)
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDataExceptionStatusList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionStatusList">
 <Procedure>
	Returns the list of data exception statuses. If a status id is passed
	then only its information is returned.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataException.prc'
GO

If Object_Id('dbo.GetDataException') Is Not Null 
     Drop Procedure dbo.GetDataException 
Go 
  
Create Procedure dbo.GetDataException 
( 
    @iData_Exception_Id BigInt
) 

With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select DE.Data_Exception_Id, DE.Data_Exception_Type_Id, DET.Name As Data_Exception_Type_Name,
		DE.Data_Exception_Date, DE.Data_Exception_Shift, ST.Name As Shift_Name,
		DE.Data_Exception_Status_Id, DES.Description As Data_Exception_Status_Name,
		DE.Short_Description, DE.Long_Description,
		DE.Details_XML
	From DataException As DE
		Inner Join ShiftType As ST
			On DE.Data_Exception_Shift = ST.Shift
		Inner Join DataExceptionStatus As DES
			On DE.Data_Exception_Status_Id = DES.Data_Exception_Status_Id
		Inner Join  DataExceptionType As DET
			On DE.Data_Exception_Type_Id = DET.Data_Exception_Type_Id
	Where DE.Data_Exception_Id = @iData_Exception_Id

	--Return Resolutions
	Select DER.Name, DER.Description
	From DataException As DE
		Inner Join DataExceptionResolution As DER
			On DE.Data_Exception_Type_Id = DER.Data_Exception_Type_Id
	Where DE.Data_Exception_Id = @iData_Exception_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDataException TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataException">
 <Procedure>
	Returns the data for the data exception id passed in.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDepletionDigblockTonnesAndGradeSummary.prc'
GO

IF object_id('dbo.GetDepletionDigblockTonnesAndGradeSummary') IS NOT NULL 
     DROP PROCEDURE dbo.GetDepletionDigblockTonnesAndGradeSummary 
GO 
  
CREATE PROCEDURE dbo.GetDepletionDigblockTonnesAndGradeSummary 
(
	@iDigblock_Id VARCHAR(31),
	@iDigblock_Survey_Id INT,
	@iGrade_Visibility Bit = 1
)
WITH Encryption AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 

	--Sorting Constants
	DECLARE @TonnesId INT,
		@GradeControlOrderNo INT,
		@ScheduledOrderNo INT,
		@HaulageOrderNo INT,
		@SurveyOrderNo INT,
		@AssignedOrderNo INT,
		@ReassignedOrderNo INT,
		@GradeControlTerm VARCHAR(255),
		@ScheduledTerm VARCHAR(255),
		@HaulageTerm VARCHAR(255),
		@SurveyTerm VARCHAR(255),
		@AssignedTerm VARCHAR(255),
		@ReassignedTerm VARCHAR(255)

	SELECT @GradeControlOrderNo = 1,
		@ScheduledOrderNo = 2, 
		@HaulageOrderNo = 3,
		@SurveyOrderNo = 4, 
		@AssignedOrderNo = 5,
		@ReassignedOrderNo = 6,
		@TonnesId = -1

	--Load Terms
	SELECT @GradeControlTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Grade Control'
	
	SELECT @ScheduledTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Scheduled'

	SELECT @HaulageTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Haulage'

	SELECT @SurveyTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Survey'

	SELECT @AssignedTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Assigned'

	SELECT @ReassignedTerm = T.Site_Terminology
	FROM dbo.Terminology AS T
	WHERE T.Terminology_Id = 'Reassigned'

	-- Get the details about the depletion period
	DECLARE @Previous_Digblock_Survey_Date DATETIME,
		@Previous_Digblock_Survey_Shift CHAR(1),
		@Start_Date DATETIME,
		@Start_Shift CHAR(1),
		@Start_Shift_Order_No INT,
		@Digblock_Survey_Date Datetime,
		@Digblock_Survey_Shift CHAR(1),
		@Digblock_Survey_Shift_Order_No INT,
		@Digblock_Survey_Type_Id INT

	SELECT @Digblock_Survey_Date = Digblock_Survey_Date,
		@Digblock_Survey_Shift = Digblock_Survey_Shift,
		@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id
	FROM DigblockSurvey
	WHERE Digblock_Survey_Id = @iDigblock_Survey_Id
	
	EXEC GetPreviousDigblockSurveyDate
		@Survey_Date = @Digblock_Survey_Date,
		@Survey_Shift = @Digblock_Survey_Shift,
		@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id,
		@Previous_Survey_Date = @Previous_Digblock_Survey_Date OUTPUT,
		@Previous_Survey_Shift = @Previous_Digblock_Survey_Shift OUTPUT

	EXEC GetNextDateShift
		@Date = @Previous_Digblock_Survey_Date,
		@Shift = @Previous_Digblock_Survey_Shift,
		@Next_Date = @Start_Date OUTPUT,
		@Next_Shift = @Start_Shift OUTPUT

	SELECT @Digblock_Survey_Shift_Order_No = dbo.GetShiftTypeOrderNo(@Digblock_Survey_Shift),
		@Start_Shift_Order_No = dbo.GetShiftTypeOrderNo(@Start_Shift)

    CREATE TABLE #DEPLETION_GRADE
	(
		Grade_Name VARCHAR(255) COLLATE Database_Default,
		Grade_Id INT
	)

	CREATE TABLE #DEPLETION_VALUES
	(
		Grade_Id INT,
		Type VARCHAR(255) COLLATE Database_Default,
		Grade_Value REAL,
		Order_No INT
	)

	--Get Distinct grade list + tonnes
	INSERT INTO #DEPLETION_GRADE
	(
		Grade_Name, Grade_Id
	)
	SELECT 'Tonnes', @tonnesID
	UNION
	SELECT G.Grade_Name, G.Grade_Id
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Populate Values
	--Grade Control
	INSERT INTO #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	SELECT @TonnesId, @GradeControlTerm, @GradeControlOrderNo, D.Start_Tonnes
	FROM dbo.Digblock AS D
	WHERE D.Digblock_Id = @iDigblock_Id
	UNION
	SELECT DG.Grade_Id, @GradeControlTerm, @GradeControlOrderNo, DG.Grade_Value
	FROM dbo.DigblockGrade AS DG
		INNER JOIN dbo.GRADE AS G
			ON (DG.Grade_Id = G.Grade_Id)
	WHERE DG.Digblock_Id = @iDigblock_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Haulage
	INSERT INTO #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	SELECT @TonnesId, @HaulageTerm, @HaulageOrderNo, Sum(H.Tonnes)
	FROM dbo.Haulage AS H
		INNER JOIN dbo.ShiftType AS ST
			ON (H.Haulage_Shift = ST.Shift)
	WHERE H.Source_Digblock_Id = @iDigblock_Id
		AND H.Haulage_State_Id = 'N'
		AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) >=  
			dbo.GetDateShiftAsInt(@Start_Date, @Start_Shift_Order_No)
		AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) <=  
			dbo.GetDateShiftAsInt(@Digblock_Survey_Date, @Digblock_Survey_Shift_Order_No)
	UNION ALL
	SELECT DG.Grade_Id, @HaulageTerm, @HaulageOrderNo,
		Sum(IsNull(HG.Grade_Value, DG.Grade_Value) * H.Tonnes) / NullIf(Sum(H.Tonnes), 0)
	FROM dbo.Haulage AS H
		INNER JOIN dbo.ShiftType AS ST
			ON (H.Haulage_Shift = ST.Shift)
		INNER JOIN dbo.DigblockGrade AS DG
			ON (H.Source_Digblock_Id = DG.Digblock_Id)
		INNER JOIN dbo.GRADE AS G
			ON (DG.Grade_Id = G.Grade_Id)
		LEFT OUTER JOIN dbo.HaulageGrade AS HG
			ON (H.Haulage_Id = HG.Haulage_Id
				AND HG.Grade_Id = DG.Grade_Id)
	WHERE H.Source_Digblock_Id = @iDigblock_Id
		AND H.Haulage_State_Id = 'N'
		AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) >=  
			dbo.GetDateShiftAsInt(@Start_Date, @Start_Shift_Order_No)
		AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) <=  
			dbo.GetDateShiftAsInt(@Digblock_Survey_Date, @Digblock_Survey_Shift_Order_No)
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY DG.Grade_Id

	--Survey Data
	INSERT INTO #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	SELECT @TonnesId, @SurveyTerm, @SurveyOrderNo, DSS.Depleted_Tonnes
	FROM dbo.DigblockSurveySample AS DSS
	WHERE DSS.Digblock_Id = @iDigblock_Id
		AND DSS.Digblock_Survey_Id = @iDigblock_Survey_Id
	UNION All
	SELECT DVH.Grade_Id, @SurveyTerm, @SurveyOrderNo, 
		IsNull(DSSG.Grade_Value, DVH.Grade_Value)
	FROM dbo.DigblockSurveySample AS DSS
		INNER JOIN dbo.#DEPLETION_VALUES AS DVH
			ON (DVH.Type = @HaulageTerm)
		INNER JOIN dbo.GRADE AS G
			ON (DVH.Grade_Id = G.Grade_Id)
		LEFT OUTER JOIN dbo.DigblockSurveySampleGrade AS DSSG
			ON (DSS.Digblock_Survey_Sample_Id = DSSG.Digblock_Survey_Sample_Id
				AND DVH.Grade_Id = DSSG.Grade_Id)
	WHERE DSS.Digblock_Id = @iDigblock_Id
		AND DSS.Digblock_Survey_Id = @iDigblock_Survey_Id
		AND DVH.Grade_Id <> @TonnesId
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Assigned
	INSERT INTO #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	SELECT @TonnesId, @AssignedTerm, @AssignedOrderNo, Sum(DSA.Tonnes)
	FROM dbo.DigblockSurveyActual AS DSA
	WHERE DSA.Assigned_Digblock_Id = @iDigblock_Id
		AND DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
	UNION
	SELECT DG.Grade_Id, @AssignedTerm, @AssignedOrderNo, 
		Sum(DSA.Tonnes * IsNull(DSSG.Grade_Value, DG.Grade_Value)) / NullIf(Sum(DSA.Tonnes), 0)
	FROM dbo.DigblockSurveyActual AS DSA
		INNER JOIN dbo.DigblockGrade AS DG
			ON (DSA.Assigned_Digblock_Id = DG.Digblock_Id)
		INNER JOIN dbo.GRADE AS G
			ON (DG.Grade_Id = G.Grade_Id)
		LEFT OUTER JOIN dbo.DigblockSurveySample AS DSS
			ON (DSS.Digblock_Id = DSA.Assigned_Digblock_Id
				AND DSS.Digblock_Survey_Id = DSA.Digblock_Survey_Id)
		LEFT OUTER JOIN dbo.DigblockSurveySampleGrade AS DSSG
			ON (DSS.Digblock_Survey_Sample_Id = DSSG.Digblock_Survey_Sample_Id
				AND DSSG.Grade_Id = DG.Grade_Id)
	WHERE DSA.Assigned_Digblock_Id = @iDigblock_Id
		AND DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY DG.Grade_Id
	
	--Reassigned
	INSERT INTO #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	SELECT @TonnesId, @ReassignedTerm, @ReassignedOrderNo, Sum(DSA.Tonnes)
	FROM dbo.DigblockSurveyActual AS DSA
	WHERE DSA.Digblock_Id = @iDigblock_Id
		AND DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
	UNION
	SELECT DVH.Grade_Id, @ReassignedTerm, @ReassignedOrderNo, 
		IsNull(DVS.Grade_Value, DVH.Grade_Value)
	FROM #DEPLETION_VALUES AS DVH
		LEFT OUTER JOIN #DEPLETION_VALUES AS DVS
			ON (DVH.Grade_Id = DVS.Grade_Id) 
	WHERE DVS.Type = @SurveyTerm
		AND DVH.Type = @HaulageTerm
		AND DVH.Grade_Id <> @TonnesId

	Insert Into #DEPLETION_VALUES
	(
		Grade_Id, Type, Order_No, Grade_Value
	)
	Select -2, @GradeControlTerm, @GradeControlOrderNo, NULL 
	Union
	--Select -2, @ScheduledTerm, @ScheduledOrderNo, NULL 
	--Union
	Select -2, @HaulageTerm, @HaulageOrderNo, NULL 
	Union
	Select -2, @SurveyTerm, @SurveyOrderNo, NULL 
	Union
	Select -2, @AssignedTerm, @AssignedOrderNo, NULL 
	Union
	Select -2, @ReassignedTerm, @ReassignedOrderNo, NULL 

	--Pivot it all
	EXEC dbo.PivotTable
		@iTargetTable='#DEPLETION_GRADE',
		@iPivotTable='#DEPLETION_VALUES',
		@iJoinColumns='#DEPLETION_GRADE.Grade_Id = #DEPLETION_VALUES.Grade_Id',
		@iPivotColumn='Type',
		@iPivotValue='Grade_Value',
		@iPivotType='REAL',
		@iPivotOrderColumn = 'Order_No',
		@iPivotOrderDirection = 'Asc'

	SELECT DG.*
	FROM #DEPLETION_GRADE AS DG
		LEFT OUTER JOIN dbo.Grade AS G
			ON (DG.Grade_Id = G.Grade_Id)
	ORDER BY G.Order_No ASC

	DROP TABLE #DEPLETION_GRADE
	DROP TABLE #DEPLETION_VALUES
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDepletionDigblockTonnesAndGradeSummary TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDepletionDigblockTonnesAndGradeSummary">
 <Procedure>
	Returns the list of the depletion's tonnes and grade summary.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveySummaryList.prc'
GO

IF OBJECT_ID('dbo.GetDigblockSurveySummaryList') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockSurveySummaryList 
GO 
  
CREATE PROCEDURE dbo.GetDigblockSurveySummaryList 
( 
    @iDigblock_Survey_Id INT = NULL,
	@iNt_Login VARCHAR(255) = NULL,
	@iLocation_Id INT = NULL
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    DECLARE @DepletionList TABLE
	(
		Digblock_Survey_Summary_Id INT NOT NULL,
		Digblock_Survey_Id INT NOT NULL,
		Digblock_Survey_Date DateTime NOT NULL,
		Digblock_Survey_Shift VARCHAR(31) COLLATE Database_Default NOT NULL,
		NT_Login VARCHAR(255) COLLATE Database_Default NULL,
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Start_Tonnes FLOAT NOT NULL,
		Haulage_Tonnes FLOAT NOT NULL,
		Survey_Tonnes FLOAT NOT NULL,
		Assigned_Tonnes FLOAT NOT NULL,
		Reassigned_Tonnes FLOAT NOT NULL,	
	
		PRIMARY KEY (Digblock_Survey_Id, Digblock_Id, Digblock_Survey_Summary_Id)		
	)

	INSERT INTO @DepletionList
	(
		Digblock_Survey_Summary_Id, Digblock_Survey_Id, 
		Digblock_Survey_Date, Digblock_Survey_Shift,
		NT_Login, Digblock_Id, Start_Tonnes, 
		Haulage_Tonnes, Survey_Tonnes,
		Assigned_Tonnes, Reassigned_Tonnes
	)
	SELECT DSS.Digblock_Survey_Summary_Id, DS.Digblock_Survey_Id, 
		DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift,
		DSS.NT_Login, DSS.Digblock_Id, DSS.Digblock_Start_Tonnes, 
		DSS.Haulage_Tonnes, IsNull(DSS.Survey_Tonnes, 0),
		0, 0
	FROM dbo.DigblockSurveySummary AS DSS
		INNER JOIN dbo.DigblockSurvey AS DS
			ON (DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id)
	WHERE DS.Digblock_Survey_Id = IsNull(@iDigblock_Survey_Id, DS.Digblock_Survey_Id)
		AND (DSS.NT_Login = @iNt_Login  --Cant use IsNull() here 
			OR @iNt_Login IS NULL)  --Because Nt_Login can be NULL
		--This filter is faster than temp table spool
		AND (@iLocation_Id IS NULL
			OR DSS.Digblock_Id IN
				(
					--Can potentially speed up by linking back into DSS and reusing filters
					--to cut down blocks to the ones in the depletion period
					SELECT DL.Digblock_Id
					FROM dbo.DigblockLocation AS DL
						INNER JOIN 
							(
								SELECT Location_Id
								FROM dbo.GetLocationChildLocationList(@iLocation_Id)
								UNION
								SELECT @iLocation_Id
							) AS L
							ON (DL.Location_Id = L.Location_Id)		
					GROUP BY DL.Digblock_Id
				)
			)	

	--Update Assigned Tonnes & Reassigned Tonnes
	UPDATE L
	SET Assigned_Tonnes = IsNull(A.Tonnes, 0),
		Reassigned_Tonnes = IsNull(R.Tonnes, 0)
	FROM @DepletionList AS L
		LEFT OUTER JOIN
			(
				SELECT L2.Digblock_Survey_Id, A2.Assigned_Digblock_Id As Digblock_Id, Sum(A2.Tonnes) AS Tonnes
				FROM @DepletionList AS L2
					INNER JOIN dbo.DigblockSurveyActual AS A2
						ON (A2.Digblock_Survey_Summary_Id = L2.Digblock_Survey_Summary_Id)
				GROUP BY L2.Digblock_Survey_Id, A2.Assigned_Digblock_Id
			) AS A
			ON (A.Digblock_Survey_Id = L.Digblock_Survey_Id
				AND A.Digblock_Id = L.Digblock_Id)
		LEFT OUTER JOIN
			(
				SELECT L3.Digblock_Survey_Summary_Id, Sum(A3.Tonnes) AS Tonnes
				FROM @DepletionList AS L3
					INNER JOIN dbo.DigblockSurveyActual AS A3
						ON (A3.Digblock_Survey_Summary_Id = L3.Digblock_Survey_Summary_Id)
				GROUP BY L3.Digblock_Survey_Summary_Id
			) AS R
			ON (R.Digblock_Survey_Summary_Id = L.Digblock_Survey_Summary_Id)
		
	SELECT L.*
	FROM @DepletionList As L
		INNER JOIN dbo.DigblockSurveySummary As DSS
			ON (L.Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id) 
		INNER JOIN dbo.ShiftType As ST
			ON (L.Digblock_Survey_Shift = ST.Shift)
	ORDER BY L.Digblock_Survey_Date, ST.Order_No, DSS.Record_No

    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockSurveySummaryList TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummaryList">
 <Procedure>
		Returns a list of DigblockSurveySummary records with additional related information.
		This related information includes:
			Start Tonnes - The start tonnes entered against a digblock.
			Haulage Tonnes - Tonnes hauled during this period
			Survey Tonnes - Tonnes survey says has been removed from this block during the period.
			Assigned Tonnes - Haulage tonnes that have been assigned to this block by the depletions process.
			Reassigned Tonnes - Total haulage tonnes that were reassigned from this block to this block and/or other blocks.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyList.prc'
GO

If Object_Id('dbo.GetDigblockSurveyList') Is Not Null 
     Drop Procedure dbo.GetDigblockSurveyList 
Go 

Create Procedure dbo.GetDigblockSurveyList
(
	@iDigblock_Survey_Type_Id Int = Null
)
With Encryption 
As
Begin
	Set Nocount On

	Select DS.Digblock_Survey_Id, DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift,
		ST.Name As Digblock_Survey_Shift_Name, ST.Order_No As Digblock_Survey_Shift_Order_No, 
		DS.Digblock_Survey_Type_Id, SPD.Start_Date, SPD.Start_Shift,
		dbo.GetShiftTypeName(SPD.Start_Shift) As Start_Shift_Name, DS.Is_Approved
	From dbo.DigblockSurvey As DS
		Inner Join dbo.GetDigblockSurveyPeriodDetails() As SPD
			On (DS.Digblock_Survey_Date = SPD.Digblock_Survey_Date
				And DS.Digblock_Survey_Shift = SPD.Digblock_Survey_Shift
				And DS.Digblock_Survey_Type_Id = SPD.Digblock_Survey_Type_Id)
		Inner Join dbo.ShiftType As ST
			On (DS.Digblock_Survey_Shift = ST.Shift)
	Where DS.Digblock_Survey_Type_Id = IsNull(@iDigblock_Survey_Type_Id, DS.Digblock_Survey_Type_Id)
	Order By DS.Digblock_Survey_Date Desc, ST.Order_No Desc
End
Go
GRANT EXECUTE ON dbo.GetDigblockSurveyList TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyList">
 <Procedure>
	Returns the following fields from the DigblockSurvey table for the specified @Digblock_Survey_Type_Id:
		Digblock_Survey_Date
		Digblock_Survey_Shift 
		Is_Approved
	If @Digblock_Survey_Type_Id is not specified but there is only 1 entry in the DigblockSurveyType table, this value
	is used instead.  
	Otherwise the count of survey types for each date and shift in the DigblockSurvey table is returned.
	The resultset is ordered according to the @Sort_Desc variable.
		If @Sort_Desc = 1 ordered by Digblock_Survey_Date, Digblock_Survey_Shift Desc
		If @Sort_Desc != 1 ordered by Digblock_Survey_Date, Digblock_Survey_Shift
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockList.prc'
GO

IF OBJECT_ID('dbo.GetDigblockList') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockList  
GO 
  
CREATE PROCEDURE dbo.GetDigblockList 
( 
    @iFilter_No INT = 1,
	@iFilter_Digblock_Id VARCHAR(31) = '',
	@iFilter_Material_Type_Id INT = NULL,
	@iFilter_Start_Date_From DATETIME = NULL,
	@iFilter_Start_Date_To DATETIME = NULL,
	@iFilter_Location_Id_List BIT = 0,
	@iFilter_Exclude_Virtual_Field_Data BIT = 0, 
	@iFilter_Exclude_Grade_Data BIT = 0, 
	@iFilter_Exclude_Location_Data BIT = 0,
	@iGrade_Visibility BIT = 1,
	@iRecordLimit INT = NULL
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 

	DECLARE @AllBlocksFilter INT
	DECLARE @MiningCommencedFilter INT
	DECLARE @MiningNotCommencedFilter INT
	DECLARE @MiningNotCompletedFilter INT
	DECLARE @MiningCompletedFilter INT
	DECLARE @CurrentLocation INT
	DECLARE @LoopLocation INT

	DECLARE @FilteredLocations TABLE
	(
		Location_Id INT NOT NULL,
		
		PRIMARY KEY (Location_Id)
	)

	CREATE TABLE #Digblock
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Description VARCHAR(63) COLLATE Database_Default NULL,
		Notes VARCHAR(1023) COLLATE Database_Default NULL,
		Material_Type_Id INT NOT NULL,
		Material_Type_Name VARCHAR(255) COLLATE Database_Default NULL,
		Blast_Block_Id INT NULL,
		Creation_Datetime DATETIME NOT NULL,
		Start_Date DATETIME NULL,
		Start_Shift CHAR(1) COLLATE Database_Default NULL,
		End_Date DATETIME NULL,
		End_Shift CHAR(1) COLLATE Database_Default NULL,
		Is_In_Pit_Depletion BIT NOT NULL,
		Auto_Activate_Haulage BIT NOT NULL,
		X FLOAT NULL,
		Y FLOAT NULL,
		Z FLOAT NULL,
		Start_Tonnes FLOAT NOT NULL,
		Auto_Validate_Depletion_Tonnes BIT NOT NULL,
		Approved_Removed_Tonnes FLOAT NOT NULL,
		Unapproved_Removed_Tonnes FLOAT NOT NULL,
		Total_Unapproved_Removed_Tonnes FLOAT NOT NULL,
		Remaining_Tonnes FLOAT NOT NULL,
		Is_Active BIT NOT NULL,
		Is_Closed BIT NOT NULL,
		
		--PRIMARY KEY (Digblock_Id)
	)

	CREATE TABLE #PivotValues
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Pivot_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Value FLOAT NULL,
	
		--PRIMARY KEY(Digblock_Id, Pivot_Id)
	)

	CREATE TABLE #PivotStrings
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Pivot_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Value VARCHAR(255) COLLATE Database_Default NULL,
	
		--PRIMARY KEY(Digblock_Id, Pivot_Id)
	)

	SELECT @AllBlocksFilter = 1,
		@MiningNotCompletedFilter = 2,
		@MiningCompletedFilter = 3,
		@MiningCommencedFilter = 4,
		@MiningNotCommencedFilter = 5,
		@iFilter_Digblock_Id = IsNull(@iFilter_Digblock_Id, '') --If someone by mistake passed NULL

	BEGIN TRY
		IF @iFilter_Location_Id_List = 1
		BEGIN	
			--Make sure we've made the temp table in .NET using catch block
			BEGIN TRY
				SELECT TOP 1 @CurrentLocation = Location_Id, @LoopLocation = Location_Id
				FROM #DigblockLocationFilter
				ORDER BY Location_Id

				WHILE @LoopLocation IS NOT NULL
				BEGIN
					INSERT INTO @FilteredLocations
					(
						Location_Id
					)				
					SELECT Location_Id
					FROM dbo.GetLocationSubtree(@CurrentLocation)

					SELECT @LoopLocation = NULL

					SELECT TOP 1 @CurrentLocation = Location_Id, @LoopLocation = Location_Id
					FROM #DigblockLocationFilter
					WHERE Location_Id > @CurrentLocation
					ORDER BY Location_Id
				END
			END TRY
			BEGIN CATCH
				RaisError('Filter by location list was specified but temporary table was not provided.', 16, 1)
			END CATCH
		END

		IF @iRecordLimit IS NOT NULL
		BEGIN
			SET ROWCOUNT @iRecordLimit
		END

		INSERT INTO #Digblock
		(
			Digblock_Id, Description, Notes, Material_Type_Id, Material_Type_Name,
			Blast_Block_Id, Creation_DateTime, Start_Date, Start_Shift, End_Date, End_Shift, Is_In_Pit_Depletion,
			Auto_Activate_Haulage, X, Y, Z, Start_Tonnes, Auto_Validate_Depletion_Tonnes,
			Approved_Removed_Tonnes, Unapproved_Removed_Tonnes, Total_Unapproved_Removed_Tonnes, Remaining_Tonnes, Is_Active, Is_Closed
		)
		SELECT D.Digblock_Id, D.Description, D.Notes, D.Material_Type_Id, MT.Description,
			D.Blast_Block_Id, D.Creation_DateTime, D.Start_Date, D.Start_Shift, D.End_Date, D.End_Shift, D.Is_In_Pit_Depletion,
			D.Auto_Activate_Haulage, D.X, D.Y, D.Z, D.Start_Tonnes, D.Auto_Validate_Depletion_Tonnes,
			0, 0, 0, 0,
			Cast(CASE WHEN D.Start_Date IS NULL THEN 0 ELSE 1 END AS BIT) AS Is_Active,
			Cast(CASE WHEN D.End_Date IS NULL THEN 0 ELSE 1 END AS BIT) AS Is_Closed
		FROM dbo.Digblock AS D
			INNER JOIN dbo.MaterialType AS MT
				ON (D.Material_Type_Id = MT.Material_Type_Id)
		WHERE D.Is_Visible = 1
			AND D.Material_Type_Id = IsNull(@iFilter_Material_Type_Id, D.Material_Type_Id)
			AND (D.Digblock_Id LIKE @iFilter_Digblock_Id + '%'
				OR @iFilter_Digblock_Id = '')
			AND (@iFilter_Start_Date_From IS NULL
				OR D.Start_Date >= @iFilter_Start_Date_From)
			AND (@iFilter_Start_Date_To IS NULL
				OR D.Start_Date <= @iFilter_Start_Date_To)
			AND ((@iFilter_No = @MiningCompletedFilter
					AND D.End_Date IS NOT NULL)
				OR (@iFilter_No = @MiningNotCompletedFilter
					AND D.Start_Date IS NOT NULL
					AND D.End_Date IS NULL)
				OR (@iFilter_No = @MiningCommencedFilter
					AND D.Start_Date IS NOT NULL)
				OR (@iFilter_No = @MiningNotCommencedFilter
					AND D.Start_Date IS NULL)
				OR (@iFilter_No = @AllBlocksFilter))
			AND (@iFilter_Location_Id_List = 0
				OR EXISTS
					(
						SELECT 1
						FROM dbo.DigblockLocation AS DL
							INNER JOIN @FilteredLocations AS F
								ON DL.Location_Id = F.Location_Id
						WHERE DL.Digblock_Id = D.Digblock_Id
					))

		IF @iRecordLimit IS NOT NULL
		BEGIN
			SET ROWCOUNT 0
		END

		UPDATE D
		SET Approved_Removed_Tonnes = Coalesce(H.Approved_Removed_Tonnes, 0.0), 
			Unapproved_Removed_Tonnes = Coalesce(H.Unapproved_Removed_Tonnes, 0.0),
			Total_Unapproved_Removed_Tonnes = Coalesce(H2.Total_Unapproved_Removed_Tonnes, 0.0),
			Remaining_Tonnes = D.Start_Tonnes - Coalesce(H.Total_Removed_Tonnes, 0.0)
		FROM #Digblock AS D
			LEFT OUTER JOIN
				(
					SELECT HA.Source_Digblock_Id, Sum(Tonnes) AS Total_Unapproved_Removed_Tonnes
					FROM dbo.Haulage As HA
					WHERE HA.Haulage_State_Id = 'N'
					GROUP BY HA.Source_Digblock_Id
				) AS H2
				ON (D.Digblock_Id = H2.Source_Digblock_Id)
			LEFT OUTER JOIN
				(
					SELECT DTT.Source_Digblock_Id,
						Sum(Tonnes) AS Total_Removed_Tonnes,
						Sum(CASE WHEN DTT.Is_Approved = 1 THEN Tonnes ELSE 0 END) AS Approved_Removed_Tonnes,
						Sum(CASE WHEN DTT.Is_Approved = 0 THEN Tonnes ELSE 0 END) AS Unapproved_Removed_Tonnes
					FROM dbo.DataTransactionTonnes AS DTT
					GROUP BY DTT.Source_Digblock_Id
				) AS H
				ON (D.Digblock_Id = H.Source_Digblock_Id)

		--Retrieve data for pivoting
		IF @iFilter_Exclude_Virtual_Field_Data = 0
		BEGIN
			INSERT INTO #PivotValues
			(
				Digblock_Id, Pivot_Id, Value
			)
			SELECT '', DF.Digblock_Field_Id, NULL
			FROM dbo.DigblockField AS DF
			WHERE DF.Has_Value = 1
			UNION
			SELECT D.Digblock_Id, DF.Digblock_Field_Id, DV.Field_Value
			FROM #Digblock AS D
				INNER JOIN dbo.DigblockValue AS DV
					ON (DV.Digblock_Id = D.Digblock_Id)
				INNER JOIN dbo.DigblockField AS DF
					ON (DV.Digblock_Field_Id = DF.Digblock_Field_Id)
			WHERE DF.Has_Value = 1

			INSERT INTO #PivotStrings
			(
				Digblock_Id, Pivot_Id, Value
			)
			SELECT '', DF.Digblock_Field_Id + '_Notes', NULL
			FROM dbo.DigblockField AS DF
			WHERE DF.Has_Notes = 1
			UNION
			SELECT D.Digblock_Id, DF.Digblock_Field_Id + '_Notes', DN.Notes
			FROM #Digblock AS D
				INNER JOIN dbo.DigblockNotes AS DN
					ON (DN.Digblock_Id = D.Digblock_Id)
				INNER JOIN dbo.DigblockField AS DF
					ON (DN.Digblock_Field_Id = DF.Digblock_Field_Id)
			WHERE DF.Has_Notes = 1
		END

		IF @iFilter_Exclude_Grade_Data = 0
		BEGIN
			INSERT INTO #PivotValues
			(
				Digblock_Id, Pivot_Id, Value
			)
			SELECT '', G.Grade_Name, NULL
			FROM dbo.Grade AS G
			WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
			UNION
			SELECT D.Digblock_Id, G.Grade_Name, DG.Grade_Value
			FROM #Digblock AS D
				INNER JOIN DigblockGrade AS DG
					ON (DG.Digblock_Id = D.Digblock_Id)
				INNER JOIN Grade AS G	
					ON (DG.Grade_Id = G.Grade_Id)
			WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		END

		IF @iFilter_Exclude_Location_Data = 0
		BEGIN
			INSERT INTO #PivotStrings
			(
				Digblock_Id, Pivot_Id, Value
			)
			SELECT D.Digblock_Id, 'Location_' + LT.Description AS Location,
				dbo.GetLocationTypeLocationName(DL.Location_Id, LT.Location_Type_Id) AS Name
			FROM #Digblock AS D
				INNER JOIN dbo.DigblockLocation AS DL
					ON (D.Digblock_Id = DL.Digblock_Id)
				CROSS JOIN dbo.LocationType AS LT
			WHERE dbo.GetLocationTypeLocationName(DL.Location_Id, LT.Location_Type_Id) IS NOT NULL
		END

		--Pivot Data
		EXEC dbo.PivotTable
			@iTargetTable = '#Digblock',
			@iPivotTable = '#PivotValues',
			@iJoinColumns = '#Digblock.Digblock_Id = #PivotValues.Digblock_Id',
			@iPivotColumn = 'Pivot_Id',
			@iPivotValue = 'Value',
			@iPivotType = 'REAL'

		EXEC dbo.PivotTable
			@iTargetTable = '#Digblock',
			@iPivotTable = '#PivotStrings',
			@iJoinColumns = '#Digblock.Digblock_Id = #PivotStrings.Digblock_Id',
			@iPivotColumn = 'Pivot_Id',
			@iPivotValue = 'Value',
			@iPivotType = 'VARCHAR(255)'

		SELECT *
		FROM #Digblock

		DROP TABLE #Digblock
		DROP TABLE #PivotValues
		DROP TABLE #PivotStrings
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockList TO CoreDigblockManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockList">
 <Procedure>
	Retuns a list of visible Digblock records.
	Returns the total approved and unapproved tonnes if transactions exist for the Digblock.
	The following data can optionally be returned
		Virtual Fields
		Grades
		Location Data
	Errors are not raised:
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockFieldList.prc'
GO

If Object_Id('dbo.GetDigblockFieldList') Is Not Null 
     Drop Procedure dbo.GetDigblockFieldList 
Go 

Create Procedure dbo.GetDigblockFieldList

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Return the list of digblock virtual fields in the system */
	Select Digblock_Field_Id, Description, Order_No, Has_Value, Has_Notes, Has_Formula
	From DigblockField
	Order By Order_No, Digblock_Field_Id


	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetDigblockFieldList TO CoreDigblockManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockFieldList">
 <Procedure>
	Returns the list of digblock virtual fields in the system. ordered by Order_No and Digblock_Field_Id
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveySummaryRecord.prc'
GO

IF object_id('dbo.GetDigblockSurveySummaryRecord') IS NOT NULL
	DROP PROCEDURE dbo.GetDigblockSurveySummaryRecord
GO

CREATE PROCEDURE dbo.GetDigblockSurveySummaryRecord
(
	@iDigblock_Survey_Summary_Id INT,
	@oPrevious_Record_Id INT = NULL OUTPUT,
	@oNext_Record_Id INT = NULL OUTPUT,
	@oNo_Records INT = NULL OUTPUT,
	@oTonnes_Per_Truck FLOAT = NULL OUTPUT,
	@oMax_Tonnes FLOAT = NULL OUTPUT,
	@oAve_Tonnes FLOAT = NULL OUTPUT,
	@oMin_Tonnes FLOAT = NULL OUTPUT,
	@iNT_Login VARCHAR(255) = NULL,
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	DECLARE @Count INT
	DECLARE @Digblock_Survey_Date DATETIME
	DECLARE @Digblock_Survey_Shift CHAR(1)
	DECLARE @Digblock_Survey_Type_Id INT
	DECLARE @Record_No INT
	DECLARE @Prev_Survey_Date DATETIME
	DECLARE @Prev_Survey_Shift CHAR(1)
	DECLARE @Haulage_Tonnes FLOAT
	DECLARE @Actual_Tonnes FLOAT
	DECLARE @Digblock_Survey_Id INT
	
	SET NOCOUNT ON

	CREATE TABLE #DIGBLOCK_SURVEY_DATA
	(
		Digblock_Survey_Summary_Id	INT NOT NULL,
		Digblock_Survey_Id			INT NOT NULL,
		Digblock_Survey_Date		VARCHAR(30) COLLATE Database_Default NULL,
		Digblock_Survey_Shift		VARCHAR(31) COLLATE Database_Default NULL,
		NT_Login					VARCHAR(255) COLLATE Database_Default NULL,
		Digblock_Id					VARCHAR(31) COLLATE Database_Default NOT NULL,
		Haulage_Tonnes				FLOAT NOT NULL,
		Survey_Tonnes				FLOAT NULL,
		Mine						VARCHAR(10) COLLATE Database_Default NULL,
		Pit							VARCHAR(10) COLLATE Database_Default NULL,
		X							FLOAT NULL,
		Y							FLOAT NULL,
		Z							FLOAT NULL,
		Area						VARCHAR(10) COLLATE Database_Default NULL,
		Phase						VARCHAR(10) COLLATE Database_Default NULL,
		Bench_No					VARCHAR(10) COLLATE Database_Default NULL,
		Blast_No					VARCHAR(10) COLLATE Database_Default NULL,
		Start_Date					DATETIME NULL,
		Start_Shift					CHAR(1) COLLATE Database_Default NULL,
		End_Date					DATETIME NULL,
		End_Shift					CHAR(1) COLLATE Database_Default NULL,
		Digblock_Start_Tonnes		FLOAT NOT NULL,
		Digblock_Approved_Removed_Tonnes	FLOAT NULL,
		Digblock_Unapproved_Removed_Tonnes	FLOAT NULL,
		Material_Type_Description	VARCHAR(63) COLLATE Database_Default NOT NULL,
		Material_Type_Abbreviation	VARCHAR(15) COLLATE Database_Default NOT NULL,
		Material_Type_Native_Alternative	VARCHAR(15) COLLATE Database_Default NULL,
		No_Previous_Surveys			INT NULL,
		Digblock_Survey_Sample_Id	INT NULL,
		Depleted_Tonnes				FLOAT NULL,
		Uncovered_Percentage		REAL NULL,
		Available_Percentage		REAL NULL,
		Unavailable_Percentage		REAL NULL,
		Mined_Percentage			REAL NULL,
		Lost_Low_Wall_Percentage	REAL NULL,
		Lost_Roof_Percentage		REAL NULL,
		Lost_Floor_Percentage		REAL NULL,
		Dilution_Low_Wall_Percentage REAL NULL,
		Dilution_Roof_Percentage	REAL NULL,
		Dilution_Floor_Percentage	REAL NULL,
		Is_Error					BIT NULL,
		Error_Description			VARCHAR(63) COLLATE Database_Default NULL,
		Blasted_Date				DATETIME NULL,
		Actual_Tonnes				FLOAT NULL, 
		Record_No					INT NULL
	)

	SELECT @Count = Count(*)
	FROM dbo.DigblockSurveySummary
	WHERE Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

	-- If the digblock survey summary record exists
	IF (@Count > 0)
	BEGIN
		-- Get the relevent details about this record
		SELECT @Digblock_Survey_Id = DS.Digblock_Survey_Id,
			@Digblock_Survey_Date = Digblock_Survey_Date,
			@Digblock_Survey_Shift = Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id,
			@Haulage_Tonnes = Haulage_Tonnes,
			@Record_No = Record_No
		FROM dbo.DigblockSurvey DS
			INNER JOIN dbo.DigblockSurveySummary DSS
				ON (DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id)
		WHERE Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

		-- Get the last survey date and shift before this one
		EXECUTE dbo.GetPreviousDigblockSurveyDate 
			@Survey_Date = @Digblock_Survey_Date,
			@Survey_Shift = @Digblock_Survey_Shift,
			@Previous_Survey_Date = @Prev_Survey_Date OUTPUT,
			@Previous_Survey_Shift = @Prev_Survey_Shift OUTPUT,
			@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id

		-- Return the relevent details about this record
		SET @oPrevious_Record_Id = NULL
		SET @oNext_Record_Id = NULL

		SELECT @oPrevious_Record_Id = Digblock_Survey_Summary_Id
		FROM dbo.DigblockSurveySummary DSS
		WHERE Digblock_Survey_Id = @Digblock_Survey_Id
			AND Record_No =	
				(
					SELECT Max(DSS2.Record_No)
					FROM dbo.DigblockSurveySummary DSS2
					WHERE DSS2.Digblock_Survey_Id = @Digblock_Survey_Id
						AND DSS2.Record_No < @Record_No
						AND (DSS2.NT_Login = @iNT_Login
							OR @iNT_Login IS NULL)
				)

		SELECT @oNext_Record_Id = Digblock_Survey_Summary_Id
		FROM dbo.DigblockSurveySummary DSS
		WHERE Digblock_Survey_Id = @Digblock_Survey_Id
			AND Record_No =	
				(
					SELECT Min(DSS2.Record_No)
					FROM dbo.DigblockSurveySummary DSS2
					WHERE DSS2.Digblock_Survey_Id = @Digblock_Survey_Id
						AND DSS2.Record_No > @Record_No
						AND (DSS2.NT_Login = @iNT_Login 
							OR @iNT_Login IS NULL)
				)

		SELECT @oNo_Records = Count(*)
		FROM dbo.DigblockSurveySummary
		WHERE Digblock_Survey_Id = @Digblock_Survey_Id
			AND (@iNT_Login IS NULL OR NT_Login = @iNT_Login)

		SELECT @oMax_Tonnes = TTP.Max_Tonnes,
			@oAve_Tonnes = TTP.Ave_Tonnes,
			@oMin_Tonnes = TTP.Min_Tonnes
		FROM dbo.TruckType TT
			INNER JOIN dbo.TruckTypeFactorPeriod TTP
				ON (TT.Truck_Type_Id = TTP.Truck_Type_Id)
		WHERE TT.Is_Default = 1
			AND TTP.End_Date IS NULL
		

		SELECT @Actual_Tonnes = Coalesce(Sum(Tonnes), 0)
		FROM dbo.DigblockSurveyActual
		WHERE Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

		-- Get the reconciled tonnes per truck value for this record
		SELECT @oTonnes_Per_Truck = dbo.GetDigblockSurveyReconciledTonnesPerTruck(@Actual_Tonnes, @Haulage_Tonnes, @oAve_Tonnes)


		--Main Data Query
		INSERT INTO #DIGBLOCK_SURVEY_DATA
		(
			Digblock_Survey_Summary_Id, Digblock_Survey_Id, Digblock_Survey_Date, Digblock_Survey_Shift,
			--Digblock_Survey_Summary_Id, Digblock_Survey_Date, Digblock_Survey_Shift,
			NT_Login, Digblock_Id, Haulage_Tonnes, Survey_Tonnes, X, Y, Z,
			Start_Date, Start_Shift, End_Date, End_Shift,
			Digblock_Start_Tonnes, Digblock_Approved_Removed_Tonnes, Digblock_Unapproved_Removed_Tonnes,
			Material_Type_Description, Material_Type_Abbreviation, Material_Type_Native_Alternative,
			No_Previous_Surveys, Digblock_Survey_Sample_Id, Depleted_Tonnes, Uncovered_Percentage,
			Available_Percentage, Unavailable_Percentage, Mined_Percentage, Lost_Low_Wall_Percentage,
			Lost_Roof_Percentage, Lost_Floor_Percentage, Dilution_Low_Wall_Percentage, Dilution_Roof_Percentage,
			Dilution_Floor_Percentage, Is_Error, Error_Description, Blasted_Date, Actual_Tonnes
		)
		SELECT DSSU.Digblock_Survey_Summary_Id, DS.Digblock_Survey_Id, DS.Digblock_Survey_Date,
		--SELECT DSSU.Digblock_Survey_Summary_Id, DS.Digblock_Survey_Date,
			dbo.GetShiftTypeName(DS.Digblock_Survey_Shift) AS Digblock_Survey_Shift, DSSU.NT_Login,
			DSSU.Digblock_Id, DSSU.Haulage_Tonnes, DSSU.Survey_Tonnes,
			D.X, D.Y, D.Z, 
			D.Start_Date, D.Start_Shift, D.End_Date, D.End_Shift,
			DSSU.Digblock_Start_Tonnes,
			DSSU.Digblock_Approved_Removed_Tonnes,
			DSSU.Digblock_Unapproved_Removed_Tonnes,
			M.Description AS Material_Type_Description, M.Abbreviation AS Material_Type_Abbreviation,
			M.Native_Alternative AS Material_Type_Native_Alternative, T.No_Previous_Surveys,
			DSS.Digblock_Survey_Sample_Id, DSS.Depleted_Tonnes,
			DSS.Uncovered_Percentage, DSS.Available_Percentage, DSS.Unavailable_Percentage, DSS.Mined_Percentage,
			DSS.Lost_Low_Wall_Percentage, DSS.Lost_Roof_Percentage, DSS.Lost_Floor_Percentage,
			DSS.Dilution_Low_Wall_Percentage, DSS.Dilution_Roof_Percentage, DSS.Dilution_Floor_Percentage,
			DSS.Is_Error, DSS.Error_Description, BB.Blasted_Date, @Actual_Tonnes AS Actual_Tonnes
		FROM dbo.DigblockSurvey AS DS
			INNER JOIN dbo.DigblockSurveySummary DSSU
				ON (DS.Digblock_Survey_Id = DSSU.Digblock_Survey_Id)
			INNER JOIN dbo.Digblock AS D
				ON (DSSU.Digblock_Id = D.Digblock_Id)
			INNER JOIN dbo.MaterialType AS M 
				ON (D.Material_Type_Id = M.Material_Type_Id)
			LEFT OUTER JOIN dbo.DigblockSurveySample AS DSS
				ON (DSS.Digblock_Id = D.Digblock_Id
					AND DSS.Digblock_Survey_Id = DSSU.Digblock_Survey_Id)
			LEFT OUTER JOIN	
				(
					SELECT DSSP.Digblock_Id, Count(*) AS No_Previous_Surveys
					FROM dbo.DigblockSurveySummary AS DSSP
					WHERE DSSP.Digblock_Survey_Id <> @Digblock_Survey_Id
					GROUP BY DSSP.Digblock_Id
				) T 
				ON (T.Digblock_Id = DSSU.Digblock_Id)
			LEFT OUTER JOIN dbo.BlastBlock AS BB
				ON (D.Blast_Block_Id = BB.Blast_Block_Id)
		WHERE DSSU.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

		IF (@iNT_Login IS NULL)
		BEGIN
			UPDATE D
			SET Record_No = DSS.Record_No
			FROM #DIGBLOCK_SURVEY_DATA AS D
				INNER JOIN dbo.DigblockSurveySummary AS DSS
					ON (D.Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id)
		END
		ELSE
		BEGIN
			UPDATE D
			SET Record_No = dbo.GetDigblockSurveySummaryRecordNo(DSS.Digblock_Survey_Summary_Id, @iNT_Login)
			FROM #DIGBLOCK_SURVEY_DATA AS D
				INNER JOIN dbo.DigblockSurveySummary AS DSS
					ON (D.Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id)
		END	

		-- Pivot Virtual Fields Here
		CREATE TABLE #DigblockSurveySampleNotes
		(
			Digblock_Survey_Sample_Id INT NULL,
			Field_Name VARCHAR(50) COLLATE Database_Default NOT NULL,
			Notes VARCHAR(1023) COLLATE Database_Default NULL,
		)

		CREATE TABLE #DigblockSurveySampleValue
		(
			Digblock_Survey_Sample_Id INT NULL,
			Field_Name VARCHAR(50) COLLATE Database_Default NOT NULL,
			Field_Value REAL NULL,
		)

		CREATE TABLE #DigblockSurveySampleFormula
		(
			Digblock_Survey_Sample_Id INT NULL,
			Field_Name VARCHAR(50) COLLATE Database_Default NOT NULL,
			Formula VARCHAR(255) COLLATE Database_Default NULL,
		)

		CREATE TABLE #DIGBLOCK_SURVEY_DATA_LOCATION
		(
			Digblock_Id VARCHAR(31) NOT NULL,
			Location VARCHAR(50) COLLATE Database_Default NOT NULL,
			Name VARCHAR(31) COLLATE Database_Default NULL,
			PRIMARY KEY (Digblock_Id, Location)
		)

		--Insert VF Data
		INSERT INTO #DigblockSurveySampleNotes
		(
			Digblock_Survey_Sample_Id, Field_Name, Notes
		)
		SELECT DS.Digblock_Survey_Sample_Id, DF.Digblock_Survey_Sample_Field_Id + '_Notes', DN.Notes
		FROM dbo.DigblockSurveySampleField AS DF
			CROSS JOIN #DIGBLOCK_SURVEY_DATA AS DSD
			LEFT OUTER JOIN dbo.DigblockSurveySample DS 
				ON (DS.Digblock_Id = DSD.Digblock_Id
					AND DS.Digblock_Survey_Id = DSD.Digblock_Survey_Id)
			LEFT OUTER JOIN dbo.DigblockSurveySampleNotes AS DN
				ON (DN.Digblock_Survey_Sample_Id = DS.Digblock_Survey_Sample_Id
					AND DN.Digblock_Survey_Sample_Field_Id = DF.Digblock_Survey_Sample_Field_Id)
		WHERE DF.Has_Notes = 1

		INSERT INTO #DigblockSurveySampleValue
		(
			Digblock_Survey_Sample_Id, Field_Name, Field_Value
		)
		SELECT DS.Digblock_Survey_Sample_Id, DF.Digblock_Survey_Sample_Field_Id, DV.Field_Value
		FROM dbo.DigblockSurveySampleField AS DF
			CROSS JOIN #DIGBLOCK_SURVEY_DATA AS DSD
			LEFT OUTER JOIN dbo.DigblockSurveySample AS DS 
				ON (DS.Digblock_Id = DSD.Digblock_Id
					AND DS.Digblock_Survey_Id = DSD.Digblock_Survey_Id)
			LEFT OUTER JOIN dbo.DigblockSurveySampleValue AS DV
				ON (DV.Digblock_Survey_Sample_Id = DS.Digblock_Survey_Sample_Id
					AND DV.Digblock_Survey_Sample_Field_Id = DF.Digblock_Survey_Sample_Field_Id)
		WHERE DF.Has_Value = 1

		INSERT INTO #DigblockSurveySampleFormula
		(
			Digblock_Survey_Sample_Id, Field_Name, Formula
		)
		SELECT DS.Digblock_Survey_Sample_Id, DF.Digblock_Survey_Sample_Field_Id + '_Formula', DFF.Formula
		FROM dbo.DigblockSurveySampleField AS DF
			CROSS JOIN #DIGBLOCK_SURVEY_DATA AS DSD
			LEFT OUTER JOIN dbo.DigblockSurveySample AS DS 
				ON (DS.Digblock_Id = DSD.Digblock_Id
					AND DS.Digblock_Survey_Id = DSD.Digblock_Survey_Id)
			LEFT OUTER JOIN dbo.DigblockSurveySampleFormula AS DFF
				ON (DFF.Digblock_Survey_Sample_Id = DS.Digblock_Survey_Sample_Id
					AND DFF.Digblock_Survey_Sample_Field_Id = DF.Digblock_Survey_Sample_Field_Id)
		WHERE DF.Has_Formula = 1

		INSERT INTO #DIGBLOCK_SURVEY_DATA_LOCATION
			(Digblock_Id, Location, Name)
		SELECT Distinct D.Digblock_Id, 'Location_' + LT.Location_Type_Id AS Location,
			dbo.GetLocationTypeLocationName(DL.Location_Id, LT.Location_Type_Id) AS Name
		FROM dbo.LocationType AS LT
			CROSS JOIN dbo.DigblockLocation AS DL
			INNER JOIN #DIGBLOCK_SURVEY_DATA AS D
				ON (D.Digblock_Id = DL.Digblock_Id)
		WHERE dbo.GetLocationTypeLocationName(DL.Location_Id, LT.Location_Type_Id) IS NOT NULL

		--Pivot VFs ON the END of data TABLE	
		EXEC dbo.PivotTable
			@iTargetTable='#DIGBLOCK_SURVEY_DATA',
			@iPivotTable='#DigblockSurveySampleNotes',
			@iJoinColumns='#DIGBLOCK_SURVEY_DATA.Digblock_Survey_Sample_Id = #DigblockSurveySampleNotes.Digblock_Survey_Sample_Id',
			@iPivotColumn='Field_Name',
			@iPivotValue='Notes',
			@iPivotType='TEXT'	

		EXEC dbo.PivotTable
			@iTargetTable='#DIGBLOCK_SURVEY_DATA',
			@iPivotTable='#DigblockSurveySampleValue',
			@iJoinColumns='#DIGBLOCK_SURVEY_DATA.Digblock_Survey_Sample_Id = #DigblockSurveySampleValue.Digblock_Survey_Sample_Id',
			@iPivotColumn='Field_Name',
			@iPivotValue='Field_Value',
			@iPivotType='FLOAT'

		EXEC dbo.PivotTable
			@iTargetTable='#DIGBLOCK_SURVEY_DATA',
			@iPivotTable='#DigblockSurveySampleFormula',
			@iJoinColumns='#DIGBLOCK_SURVEY_DATA.Digblock_Survey_Sample_Id = #DigblockSurveySampleFormula.Digblock_Survey_Sample_Id',
			@iPivotColumn='Field_Name',
			@iPivotValue='Formula',
			@iPivotType='VARCHAR(255)'

		EXEC dbo.PivotTable
			@iTargetTable='#DIGBLOCK_SURVEY_DATA',
			@iPivotTable='#DIGBLOCK_SURVEY_DATA_LOCATION',
			@iJoinColumns='#DIGBLOCK_SURVEY_DATA.Digblock_Id COLLATE Database_Default = #DIGBLOCK_SURVEY_DATA_LOCATION.Digblock_Id COLLATE Database_Default',
			@iPivotColumn='Location',
			@iPivotValue='Name',
			@iPivotType='VARCHAR(31)'

		CREATE TABLE #SURVEY_GRADES_NORM
		(
			Digblock_Survey_Summary_Id INT,
			Grade_Name	VARCHAR(40),
			Grade_Value	FLOAT
		)

		--Insert all grades to ensure columns are added
		INSERT INTO #SURVEY_GRADES_NORM
		(
			Digblock_Survey_Summary_Id, Grade_Name, Grade_Value
		)
		SELECT NULL, 'Depleted_'+Grade_Name, NULL
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		UNION ALL
		SELECT NULL, Grade_Name, NULL
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		
		INSERT INTO #SURVEY_GRADES_NORM
		(
			Digblock_Survey_Summary_Id, Grade_Name, Grade_Value
		)
		--Insert Depleted Grades
		SELECT DSS.Digblock_Survey_Summary_Id, 'Depleted_'+ G.Grade_Name, DSG.Grade_Value
		FROM #DIGBLOCK_SURVEY_DATA AS D
			INNER JOIN dbo.DigblockSurveySummary AS DSS
				ON (D.Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id)
			INNER JOIN dbo.DigblockSurveySample AS DS 
				ON (DS.Digblock_Id = DSS.Digblock_Id
					AND DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id)
			INNER JOIN dbo.DigblockSurveySampleGrade AS DSG
				ON (DSG.Digblock_Survey_Sample_Id = DS.Digblock_Survey_Sample_Id)
			INNER JOIN dbo.Grade AS G
				ON (DSG.Grade_Id = G.Grade_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		UNION ALL
		--Insert Digblock Grades
		SELECT DSS.Digblock_Survey_Summary_Id, G.Grade_Name, DG.Grade_Value
		FROM #DIGBLOCK_SURVEY_DATA AS D
			INNER JOIN dbo.DigblockSurveySummary AS DSS
				ON (D.Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id)
			INNER JOIN dbo.Digblock AS DB
				ON (DSS.Digblock_Id = DB.Digblock_Id)
			INNER JOIN dbo.DigblockGrade AS DG
				ON (DG.Digblock_Id = DB.Digblock_Id)
			INNER JOIN dbo.Grade AS G
				ON (DG.Grade_Id = G.Grade_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)

		EXEC PivotTable
			@iTargetTable = '#DIGBLOCK_SURVEY_DATA',
			@iPivotTable = '#SURVEY_GRADES_NORM',
			@iJoinColumns = '#DIGBLOCK_SURVEY_DATA.Digblock_Survey_Summary_Id = #SURVEY_GRADES_NORM.Digblock_Survey_Summary_Id',
			@iPivotColumn = 'Grade_Name',
			@iPivotValue = 'Grade_Value',
			@iPivotType = 'REAL'

		--SELECT Results Out
		SELECT * 
		FROM #DIGBLOCK_SURVEY_DATA

		DROP TABLE #SURVEY_GRADES_NORM
		DROP TABLE #DigblockSurveySampleNotes
		DROP TABLE #DigblockSurveySampleValue
		DROP TABLE #DigblockSurveySampleFormula
		DROP TABLE #DIGBLOCK_SURVEY_DATA_LOCATION
	END
	ELSE
	BEGIN
		Raiserror ('The digblock survey summary record does not exist', 16, 1)
	END

	DROP TABLE #DIGBLOCK_SURVEY_DATA
END
GO
GRANT EXECUTE ON dbo.GetDigblockSurveySummaryRecord TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummaryRecord">
 <Procedure>

	Returns Digblock_Survey_Summary  details for the specified @Digblock_Survey_Summary_Id record
	both in a resultset and in the following output variables:
		@Previous_Record_Id
		@Next_Record_Id
		@No_Records
		@Tonnes_Per_Truck
		@Max_Tonnes
		@Ave_Tonnes
		@Min_Tonnes

	Errors are raised if:
		The specified @Digblock_Survey_Summary_Id does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockHaulageList.prc'
GO

IF OBJECT_ID('dbo.GetDigblockHaulageList') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockHaulageList 
GO 
  
CREATE PROCEDURE dbo.GetDigblockHaulageList 
( 
    @iDigblock_Id VARCHAR(31), 
	@iFilter_Start_Date DATETIME = NULL,
	@iFilter_End_Date DATETIME = NULL,
	@iFilter_No INT = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON	
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
	DECLARE @Is_Approved BIT

	IF (@iFilter_Start_Date Is NULL)
	BEGIN
		Select @iFilter_Start_Date = Min(Haulage_Date)
		From Haulage
	END

	IF (@iFilter_END_Date Is NULL)
	BEGIN
		Select @iFilter_End_Date = Max(Haulage_Date)
		From Haulage
	END

	/* Filter No: 1 = All; 2 = Only Unapproved; 3 = Only Approved */
	IF (@iFilter_No = 1)
	BEGIN
		SET @Is_Approved = NULL
	END

	If (@iFilter_No = 2)
	BEGIN
		SET @Is_Approved = 0
	END

	If (@iFilter_No = 3)
	BEGIN
		SET @Is_Approved = 1
	END

	SELECT H.Haulage_Id, H.Haulage_Date, H.Haulage_Shift, ST.Name AS Haulage_Shift_Name,
		H.Tonnes AS Haulage_Tonnes, H.Source_Digblock_Id AS Source,
		ISNULL(DS.Stockpile_Name, H.Destination_Crusher_Id) AS Destination,
		ISNULL(DS.Description, DC.Description) AS Destination_Description,
		H.Haulage_State_Id
	FROM dbo.Haulage AS H
		INNER JOIN dbo.ShiftType AS ST
			ON (ST.Shift = H.Haulage_Shift)
		LEFT OUTER JOIN dbo.Stockpile AS DS
			ON (H.Destination_Stockpile_Id = DS.Stockpile_Id)
		LEFT OUTER JOIN dbo.Crusher As DC 
			ON (H.Destination_Crusher_Id = DC.Crusher_Id)
	WHERE H.Source_Digblock_Id = @iDigblock_Id
		AND Haulage_Date BETWEEN @iFilter_Start_Date AND @iFilter_END_Date
		AND ((@Is_Approved IS NOT NULL 
				AND H.Haulage_State_Id = 
					(
						CASE WHEN @Is_Approved = 1 THEN 
							'A' 
						WHEN @Is_Approved = 0 THEN 
							'N' 
						Else 
							NULL 
						END
					)) 
					OR (@Is_Approved Is NULL))
	ORDER BY Haulage_Date DESC, ST.Order_No DESC

    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockHaulageList TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockHaulageList">
 <Procedure>
	Returns Haulage records for the specified @Digblock_Id along with the approval status and Haulage state.
	The resultset can be filtered by @Filter_No:
		1 = All
		2 = Only Unapproved
		3 = Only Approved
		
	Errors are not raised:
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblock.prc'
GO

IF object_id('dbo.GetDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblock 
GO 
  
CREATE PROCEDURE dbo.GetDigblock 
( 
    @iDigblock_Id VARCHAR(31),
	@iGrade_Visibility Bit = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 

	--Instead of Pivoting an indefinite number of VARCHAR(1023) Notes
	--on to the main table, use a size appropriate for the data within
	DECLARE @Digblock_Notes_DataType VARCHAR(31)
	DECLARE @Digblock_Notes_MaxLength INT

	--Key Record used in Pivoting and Calculated (updated) Fields
	--most digblock fields are retrieved at end by rejoining
	CREATE TABLE dbo.#DIGBLOCK_KEY
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Blast_Block_Id INT NULL,
		Blast_Block_Code VARCHAR(31) COLLATE Database_Default NULL,
		Approved_Removed_Tonnes FLOAT NULL,
		Unapproved_Removed_Tonnes FLOAT NULL,
		Approved_Removed_Percentage FLOAT NULL,
		Unapproved_Removed_Percentage FLOAT NULL,
		Start_Tonnes  FLOAT NULL,

		PRIMARY KEY CLUSTERED
		(
			Digblock_Id 
		)
	)

	CREATE TABLE dbo.#DigblockGrade
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Value REAL

		PRIMARY KEY CLUSTERED
		(
			Digblock_Id, Grade_Name
		)
	)

	--Child Pivot table
	CREATE TABLE dbo.#DigblockNotes
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Digblock_Field_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Notes VARCHAR(1023) NULL,
		PRIMARY KEY CLUSTERED
		(
			Digblock_Id, Digblock_Field_Id
		)
	)

	--Child Pivot table
	CREATE TABLE dbo.#DigblockValue
	(
		Digblock_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Digblock_Field_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Field_Value REAL NULL,
		PRIMARY KEY CLUSTERED
		(
			Digblock_Id, Digblock_Field_Id
		)
	)

	--Create key Record for Pivot, get blast block details if they exist
	INSERT INTO dbo.#DIGBLOCK_KEY
	(
		Digblock_Id, Blast_Block_Id, Blast_Block_Code, Start_Tonnes
	)
	SELECT D.Digblock_Id, BB.Blast_Block_Id, BB.Code, D.Start_Tonnes
	FROM dbo.Digblock AS D
		LEFT OUTER JOIN dbo.BlastBlock AS BB
			ON (D.Blast_Block_Id = BB.Blast_Block_Id)
	WHERE D.Digblock_Id = @iDigblock_Id
	
	--Calculate Approved_Removed Details and Unapproved Details
	--Unapproved will get overwritten IF there IS no survey data
	UPDATE DK
	SET Approved_Removed_Tonnes = T.Approved_Removed_Tonnes,
		Approved_Removed_Percentage = T.Approved_Removed_Tonnes / NullIf(DK.Start_Tonnes, .00) * 100.00,
		Unapproved_Removed_Tonnes = T.Unapproved_Removed_Tonnes,
		Unapproved_Removed_Percentage = T.Unapproved_Removed_Tonnes / NullIf(DK.Start_Tonnes, .00) * 100.00
	FROM dbo.#DIGBLOCK_KEY DK
		INNER JOIN
		(
			SELECT DK.Digblock_Id, 
				Sum(CASE WHEN T.Is_Approved = 1 THEN T.Tonnes ELSE .00 END) AS Approved_Removed_Tonnes,
				Sum(CASE WHEN T.Is_Approved = 1 THEN .00 ELSE T.Tonnes END) AS Unapproved_Removed_Tonnes
			FROM dbo.DataTransactionTonnes AS T 
				INNER JOIN dbo.#DIGBLOCK_KEY AS DK
					ON T.Source_Digblock_Id = DK.Digblock_Id 
			GROUP BY DK.Digblock_Id
		) AS T
		ON DK.Digblock_Id = T.Digblock_Id

	--Retrieve existing grade values
	INSERT INTO dbo.#DigblockGrade
	(
		Digblock_Id, Grade_Name, Grade_Value
	)
	SELECT DK.Digblock_Id, G.Grade_Name, DG.Grade_Value
	FROM dbo.#DIGBLOCK_KEY DK
		INNER JOIN dbo.DigblockGrade DG
			ON DG.Digblock_Id = DK.Digblock_Id
		INNER JOIN dbo.Grade G
			ON DG.Grade_Id = G.Grade_Id
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	UNION ALL
	--Ensure all grades are represented
	SELECT '', G.Grade_Name, NULL
	FROM dbo.Grade G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Retrieve existing Notes values
	INSERT INTO dbo.#DigblockNotes
	(
		Digblock_Id, Digblock_Field_Id, Notes
	)
	SELECT DK.Digblock_Id, DN.Digblock_Field_Id, DN.Notes
	FROM dbo.#DIGBLOCK_KEY DK
		INNER JOIN dbo.DigblockNotes DN
			ON DN.Digblock_Id = DK.Digblock_Id
	UNION ALL
	--Ensure all Notes are represented
	SELECT '', DF.Digblock_Field_Id, NULL
	FROM dbo.DigblockField DF
	WHERE DF.Has_Notes = 1

	--Retrieve existing Value Records
	INSERT INTO dbo.#DigblockValue
	(
		Digblock_Id, Digblock_Field_Id, Field_Value
	)
	SELECT DK.Digblock_Id, DV.Digblock_Field_Id, DV.Field_Value
	FROM dbo.#DIGBLOCK_KEY DK
		INNER JOIN dbo.DigblockValue DV
			ON DV.Digblock_Id = DK.Digblock_Id
	UNION ALL
	--Ensure all values are represented
	SELECT '', DF.Digblock_Field_Id, NULL
	FROM dbo.DigblockField DF
	WHERE DF.Has_Value = 1

	--Pivot Everything
	EXEC dbo.PivotTable
		@iTargetTable = '#DIGBLOCK_KEY',
		@iPivotTable = '#DigblockGrade',
		@iJoinColumns = '#DIGBLOCK_KEY.Digblock_Id = #DigblockGrade.Digblock_Id',
		@iPivotColumn = 'Grade_Name',
		@iPivotValue = 'Grade_Value',
		@iPivotType = 'REAL'

	EXEC dbo.PivotTable
		@iTargetTable = '#DIGBLOCK_KEY',
		@iPivotTable = '#DigblockValue',
		@iJoinColumns = '#DIGBLOCK_KEY.Digblock_Id = #DigblockValue.Digblock_Id',
		@iPivotColumn = 'Digblock_Field_Id',
		@iPivotValue = 'Field_Value',
		@iPivotType = 'FLOAT'
		
	--Keep the notes to a minimum VARCHAR required length (otherwise VARCHAR(1023) IS used)		
	SELECT @Digblock_Notes_MaxLength = Coalesce(Max(Len(Notes)), 1)
	FROM dbo.#DigblockNotes
	
	IF @Digblock_Notes_MaxLength < 1
	BEGIN
		SET @Digblock_Notes_MaxLength = 1
	END

	SET @Digblock_Notes_DataType = 'VARCHAR(' + Cast(@Digblock_Notes_MaxLength AS VARCHAR) + ')'

	EXEC dbo.PivotTable
		@iTargetTable = '#DIGBLOCK_KEY',
		@iPivotTable = '#DigblockNotes',
		@iJoinColumns = '#DIGBLOCK_KEY.Digblock_Id = #DigblockNotes.Digblock_Id',
		@iPivotColumn = 'Digblock_Field_Id',
		@iPivotValue = 'Notes',
		@iPivotType = @Digblock_Notes_DataType

	--Return Final Dataset
	--Result set has following format
	--Digblock Id, Blast_Block_Id, Blast_Block_Code, Approved_Removed_Tonnes, Unapproved_Removed_Tonnes,
	--Approved_Removed_Percentage, Unapproved_Removed_Percentage, Start_Tonnes,
	--Followed by Grades, then Virtual Values, then Virtual Notes
	--Followed by all other data
	SELECT DK.*, D.Description, D.Notes,
		MT.Material_Type_Id, MT.Abbreviation, MT.Description AS Material_Type_Description,
		D.Creation_Datetime, 
		D.Start_Date, SST.Name AS Start_Shift,
		SST.Shift AS Start_Shift_Type,
		D.End_Date, EST.Name AS End_Shift,
		EST.Shift AS End_Shift_Type,
		D.Is_In_Pit_Depletion, D.X, D.Y, D.Z, D.Auto_Activate_Haulage,		
		Cast(CASE WHEN D.Start_Date IS NULL THEN 0 	ELSE 1 	END AS BIT) AS Is_Active	
	FROM dbo.#DIGBLOCK_KEY AS DK
		INNER JOIN dbo.Digblock AS D
			ON D.Digblock_Id = DK.Digblock_Id
		INNER JOIN dbo.MaterialType AS MT
			ON MT.Material_Type_Id = D.Material_Type_Id
		LEFT JOIN dbo.ShiftType AS SST
			ON SST.Shift = D.Start_Shift
		LEFT JOIN dbo.ShiftType AS EST
			ON EST.Shift = D.End_Shift

	DROP TABLE dbo.#DigblockGrade
	DROP TABLE dbo.#DigblockNotes
	DROP TABLE dbo.#DigblockValue
	DROP TABLE dbo.#DIGBLOCK_KEY
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDigblock TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblock">
 <Procedure>
	Returns Digblock information for the specified @iDigblock_Id.
	Errors are raised if:
		The digblock does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyActualList.prc'
GO

IF OBJECT_ID('dbo.GetDigblockSurveyActualList') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockSurveyActualList 
GO 
  
CREATE PROCEDURE dbo.GetDigblockSurveyActualList 
( 
    @iDigblock_Survey_Summary_Id Int
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    --Get the list of digblock survey actual records related to this digblock survey summary record
	SELECT DSA.Digblock_Survey_Actual_Id, DSA.Tonnes, DSA.Description, 
		DSA.Is_Rill, DSA.Assigned_Digblock_Id, 
		DSS.Digblock_Survey_Summary_Id As Assigned_Digblock_Survey_Summary_Id
	FROM dbo.DigblockSurveyActual As DSA	
		LEFT OUTER JOIN dbo.DigblockSurveySummary As DSS
			ON (DSA.Digblock_Survey_Id = DSS.Digblock_Survey_Id
				AND DSA.Assigned_Digblock_Id = DSS.Digblock_Id)
	WHERE DSA.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
	ORDER BY DSA.Assigned_Digblock_Id
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockSurveyActualList TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyActualList">
 <Procedure>
	Returns the list of digblock survey actual records related to this digblock survey summary record .
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockPolygonList.prc'
GO

If object_id('dbo.GetDigblockPolygonList') Is Not Null 
     Drop Procedure dbo.GetDigblockPolygonList 
Go 
  
Create Procedure dbo.GetDigblockPolygonList 
( 
    @iDigblock_Id Varchar(31) = Null,
	@iLocation_Id Int = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    -- Returns the Digblock Polygon co-ordinates for a specified Digblock
	If @iLocation_Id Is Not Null
	Begin
		Select DP.Digblock_Id, DP.Order_No, DP.X, DP.Y, DP.Z
		From dbo.DigblockPolygon As DP	
			Inner Join
				(
					--Eliminate double counting
					Select DL.Digblock_Id
					From dbo.DigblockLocation As DL
						Inner Join dbo.LocationType As LT
							On (LT.Location_Type_Id = DL.Location_Type_Id)
						Inner Join 
							(
								Select *
								From dbo.GetLocationChildLocationList(@iLocation_Id) 
								Union 
								Select @iLocation_Id
							) As L
							On (L.Location_Id = DL.Location_Id)
					Group By DL.Digblock_Id
				) As DL
				On DP.Digblock_Id = DL.Digblock_Id
		Where DP.Digblock_Id = IsNull(@iDigblock_Id, DP.Digblock_Id)
		Order By DP.Digblock_Id, DP.Order_No
	End
	Else
	Begin
		Select DP.Digblock_Id, DP.Order_No, DP.X, DP.Y, DP.Z
		From dbo.DigblockPolygon As DP
		Where DP.Digblock_Id = IsNull(@iDigblock_Id, DP.Digblock_Id)
		Order By DP.Digblock_Id, DP.Order_No
	End
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockPolygonList TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockPolygonList">
 <Procedure>
	Returns the list of polygons for digblocks. Can be filtered to
	a specific digblock id or children of a parent location id.

 </Procedure>
</TAG>
*/ 



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockPolygonWithinRange.prc'
GO


If object_id('dbo.GetDigblockPolygonWithinRange') is not null
	Drop Procedure dbo.GetDigblockPolygonWithinRange
Go

Create Procedure dbo.GetDigblockPolygonWithinRange
(
	@iDigblock_Id Varchar(31) = '',
	@iMaxX float,
	@iMinX float,
	@iMaxY float,
	@iMinY float,
	@iZ int
)

With Encryption 
As

Begin

	set NoCount on

	--Get All Digblocks and fall within the range
	--Return all of the Digblocks records.
	Select Digblock_Id, [Order_No], X, Y, Z
	From DigblockPolygon
	Where Digblock_Id In (Select Distinct Digblock_Id
						  From DigblockPolygon
						  Where X Between @iMinX And @iMaxX
							And Y Between @iMinY And @iMaxY
							And Z = @iZ
						)
		And Digblock_Id <> @iDigblock_Id
	Order By Digblock_Id, [Order_No]


End
Go

GRANT EXECUTE ON dbo.GetDigblockPolygonWithinRange TO CoreDepletionManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockPolygonWithinRange">
 <Procedure>
	Returns the list of polygons assigned to @iDigblock_Id that vall in the range
	Specified by the parameter
s.
	Errors are not raised:
 </Procedure>
</TAG>
*/ 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockLocation.prc'
GO

If Object_Id('dbo.GetDigblockLocation') Is Not Null
	Drop Procedure dbo.GetDigblockLocation
GO

Create Procedure [dbo].[GetDigblockLocation]
(
	@iDigblock_Id Varchar(31)
)
With Encryption As
/*-----------------------------------------------------------------------------
--  Name: GetDigblockLocation
--
--  Purpose: Retrieves a record set of all the locations in all Hierarchies 
--				belonging to a digblock.
--  Parameters: @iDigblock_Id - The digblock
--
--  Comments: 
--  
--  Modified By:		Murray Hipper
--  Modified Date: 		13 February 2007
--
------------------------------------------------------------------------------*/
Begin
	Set Nocount On
		
	Declare @Loop Int
	Declare @LOCATIONSTRUCTURE Table 
	(
		Lvl Int,
		Parent_Location_Id Int,
		Location_Id Int,
		Name Varchar(31),
		Location_Type_Id TINYINT,
		Location_Type_Description Varchar(255) collate Database_Default
	)
	Declare @LOCATION_TYPES Table
	(
		Location_Type_Id TINYINT,
		Location_Level Int,
		Abs_Parent_Location_Id Varchar(31) Collate Database_Default
	)

	Set @Loop = 0

	-- Obtain All the lowest Level heirachies in this digblock location
	Insert Into @LOCATION_TYPES
		(Location_Type_Id, Location_Level, Abs_Parent_Location_Id)
	Select HIER.Location_Type_Id, HIER.Location_Level, HIER.Abs_Parent_Location_Id
	From dbo.DigblockLocation As DL
		Inner Join dbo.GetLocationTypeHierarchy(0) As HIER
			On HIER.Location_Type_Id = DL.Location_Type_Id
	Where Digblock_Id = @iDigblock_Id

	Delete From LT -- Delete the locations which are not of the max location level (bottom child).
	From @LOCATION_TYPES As LT
		Left Join (Select Abs_Parent_Location_Id, Max(Location_Level) As Lvl
					From @LOCATION_TYPES
					Group By Abs_Parent_Location_Id) As LOWEST
			On LT.Abs_Parent_Location_Id = LOWEST.Abs_Parent_Location_Id
				And LOWEST.Lvl = LT.Location_Level
	Where LOWEST.Abs_Parent_Location_Id Is Null


	-- From all the lowest location types, build a list.
	Insert Into @LOCATIONSTRUCTURE
	Select 0, L.Parent_Location_Id, L.Location_Id, L.Name, L.Location_Type_Id, LT.Description
	From dbo.DigblockLocation DL
		Inner Join dbo.Location L
			On DL.Location_Id = L.Location_Id
		Inner Join dbo.LocationType LT
			On L.Location_Type_Id = LT.Location_Type_Id
	Where Digblock_Id = @iDigblock_Id
		And L.Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPES)

	-- Loop through each child and gather information.
	While Exists (Select 1 From @LOCATIONSTRUCTURE Where Lvl = @Loop)
	Begin
		Insert Into @LOCATIONSTRUCTURE
		Select Lvl + 1, L.Parent_Location_Id, L.Location_Id, L.Name, L.Location_Type_Id, LT.Description
		From @LocationStructure LS
			Inner Join dbo.Location L
				On LS.Parent_Location_Id = L.Location_Id
			Inner Join dbo.LocationType LT
				On L.Location_Type_Id = LT.Location_Type_Id
		Where Lvl = @Loop

	Set @Loop = @Loop + 1
	End

	Select *
	From @LocationStructure
	Order By Lvl Desc
End
Go
 GRANT EXECUTE ON dbo.GetDigblockLocation TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockLocation">
 <Procedure>
	Retrieves a record set of all locations in all Hierarchies belonging to the specified @iDigblock_Id

	Errors are not raised:
 </Procedure>
</TAG>
*/ 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyTypeList.prc'
GO

If Object_Id('dbo.GetDigblockSurveyTypeList') Is Not Null 
     Drop Procedure dbo.GetDigblockSurveyTypeList 
Go 

Create Procedure dbo.GetDigblockSurveyTypeList
(
	@iDigblock_Survey_Type_Id Int = Null,
	@iIs_Visible Bit = Null
)

With Encryption
As

Begin
	Set Nocount On
	
	Select Digblock_Survey_Type_Id, [Name], Description, Location_Type_Id, Is_Visible
	From DigblockSurveyType
	Where Digblock_Survey_Type_Id = IsNull(@iDigblock_Survey_Type_Id, Digblock_Survey_Type_Id)
		And Is_Visible = IsNull(@iIs_Visible, Is_Visible)

End
GO
GRANT EXECUTE ON dbo.GetDigblockSurveyTypeList TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyTypeList">
 <Procedure>
	Returns a list of DigblockSurveyType details.  
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockDetailsList.prc'
GO

IF object_id('dbo.GetDigblockDetailList') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockDetailList 
GO 
  
CREATE PROCEDURE dbo.GetDigblockDetailList 
( 
    @iDigblock_Id VARCHAR(31),
	@iIncludeBlockModels BIT = 1,
	@iIncludeMinePlans BIT = 1,
	@iGrade_Visibility Bit = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
	
	CREATE TABLE #Attribute
	(
		Attribute VARCHAR(255) COLLATE Database_Default NOT NULL,
		OrderNo INT NOT NULL,

		PRIMARY KEY (Attribute)
	)  

	CREATE TABLE #Value
	(
		Attribute VARCHAR(255) COLLATE Database_Default NOT NULL,
		Measure VARCHAR(255) COLLATE Database_Default NOT NULL,
		OrderNo INT NOT NULL,
		Value FLOAT NULL,

		--PRIMARY KEY (Attribute, Measure)
	)

	-- All Plans
	DECLARE @MinePlanDates TABLE
	(
		Mine_Plan_Id INT, 
		Mine_Plan_Type_Id INT,
		Start_Date DATETIME,
		End_Date DATETIME 
	)

	DECLARE @GradeControlTerm VARCHAR(255),
		@GCPercentTerm VARCHAR(255),
		@HauledTerm VARCHAR(255),
		@TonnesTerm VARCHAR(255),
		@ReconciledTerm VARCHAR(255),
		@TonnesIndex Integer,
		@GCPercentIndex Integer,
		@GCIndex Integer,
		@BlockModelIndex Integer,
		@MinePlanIndex Integer,
		@HaulageIndex Integer,
		@SurveyIndex Integer,
		@ReconciledIndex Integer

    BEGIN TRY
		--Get all the mine plans that we should use over the life of mine
		INSERT INTO @MinePlanDates
		EXEC GetMinePlansOverRange

		--Check Digblock exists
		IF NOT EXISTS 
			(
				SELECT 1
				FROM dbo.Digblock AS D
				WHERE Digblock_Id = @iDigblock_Id
			)
		BEGIN
			RaisError('Digblock Id does not exist.', 16, 1)
		END

		-- Return the list of terms and their local names for the system
		SELECT @GradeControlTerm = 'Grade Control',
			@HauledTerm = 'Hauled',
			@TonnesTerm = 'Tonnes',
			@ReconciledTerm = 'Reconciled'

		SELECT @GradeControlTerm = Site_Terminology
		FROM dbo.Terminology
		WHERE Terminology_Id = @GradeControlTerm

		SELECT @HauledTerm = Site_Terminology
		FROM dbo.Terminology
		WHERE Terminology_Id = @HauledTerm
		
		SELECT @HauledTerm = Site_Terminology
		FROM dbo.Terminology
		WHERE Terminology_Id = @ReconciledTerm

		SELECT @TonnesTerm = Site_Terminology
		FROM dbo.Terminology
		WHERE Terminology_Id = @TonnesTerm

		SELECT @GCPercentTerm = '% of ' + @GradeControlTerm,
			@TonnesIndex = -2,
			@GCPercentIndex = -1,
			@GCIndex = 1,
			@BlockModelIndex = 2,
			@MinePlanIndex = 3,
			@HaulageIndex = 4,
			@SurveyIndex = 5,
			@ReconciledIndex = 6

		--Populate Attributes
		INSERT INTO #Attribute
		(
			Attribute, OrderNo
		)
		SELECT @TonnesTerm, @TonnesIndex
		UNION All
		SELECT @GCPercentTerm, @GCPercentIndex
		UNION All
		SELECT G.Grade_Name, G.Order_No
		FROM dbo.Grade As G
		WHERE (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)

		--Insert all possible combinations
		INSERT INTO #Value
		(
			Attribute, Measure, OrderNo, Value
		)
		SELECT '', @GradeControlTerm, @GCIndex, NULL
		
		IF @iIncludeBlockModels = 1
		BEGIN
			INSERT INTO #Value
			(
				Attribute, Measure, OrderNo, Value
			)
			SELECT '', Name, @BlockModelIndex, NULL
			FROM dbo.BlockModel AS BM
			WHERE Is_Displayed = 1
		END

		IF @iIncludeMinePlans = 1
		BEGIN
			INSERT INTO #Value
			(
				Attribute, Measure, OrderNo, Value
			)
			SELECT '', Name, @MinePlanIndex, NULL
			FROM dbo.MinePlan AS MP
			WHERE Parent_Mine_Plan_Id IS NULL
				AND Is_Visible = 1 
		END

		INSERT INTO #Value
		(
			Attribute, Measure, OrderNo, Value
		)
		SELECT '', @HauledTerm, @HaulageIndex, NULL
		UNION All
		SELECT '', Name, @SurveyIndex, NULL
		FROM dbo.DigblockSurveyType AS DST
		WHERE Is_Visible = 1
		UNION All
		SELECT '', @ReconciledTerm, @ReconciledIndex, NULL

		--Populate Values
		INSERT INTO #Value
		(
			Attribute, Measure, OrderNo, Value
		)
		--Grade Control AKA Digblock table
		SELECT @TonnesTerm, @GradeControlTerm, @GCIndex, D.Start_Tonnes
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id
		UNION All
		SELECT G.Grade_Name, @GradeControlTerm, @GCIndex, 
			Sum(DG.Grade_Value * D.Start_Tonnes) / NullIf(Sum(D.Start_Tonnes), 0)
		FROM dbo.Digblock AS D
			INNER JOIN dbo.DigblockGrade AS DG
				ON (D.Digblock_Id = DG.Digblock_Id)
			INNER JOIN dbo.Grade AS G
				ON (G.Grade_Id = DG.Grade_Id)
		WHERE D.Digblock_Id = @iDigblock_Id
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		GROUP BY G.Grade_Name
		UNION All
		--Haulage
		SELECT @TonnesTerm, @HauledTerm, @HaulageIndex, Sum(H.Tonnes)
		FROM dbo.Haulage AS H
		WHERE H.Source_Digblock_Id = @iDigblock_Id
			AND H.Haulage_State_Id = 'N'
		UNION All
		SELECT G.Grade_Name, @HauledTerm, @HaulageIndex, 
			Sum(HG.Grade_Value * H.Tonnes) / NullIf(Sum(H.Tonnes), 0)
		FROM dbo.Haulage AS H
			INNER JOIN dbo.HaulageGrade AS HG
				ON (H.Haulage_Id = HG.Haulage_Id)
			INNER JOIN dbo.Grade AS G
				ON (G.Grade_Id = HG.Grade_Id)
		WHERE H.Source_Digblock_Id = @iDigblock_Id
			AND H.Haulage_State_Id = 'N'
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		GROUP BY G.Grade_Name
		UNION All
		--Survey 
		SELECT @TonnesTerm, DST.Name, @SurveyIndex, Sum(DSS.Depleted_Tonnes)
		FROM dbo.DigblockSurveyType AS DST
			INNER JOIN dbo.DigblockSurvey AS DS
				ON (DST.Digblock_Survey_Type_Id = DS.Digblock_Survey_Type_Id)
			INNER JOIN dbo.DigblockSurveySample AS DSS
				ON (DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id)
		WHERE DST.Is_Visible = 1
			AND DSS.Digblock_Id = @iDigblock_Id
		GROUP BY DST.Name
		UNION All
		SELECT G.Grade_Name, DST.Name, @SurveyIndex,
			Sum(DSS.Depleted_Tonnes * DSSG.Grade_Value) / NullIf(Sum(DSS.Depleted_Tonnes), 0)
		FROM dbo.DigblockSurveyType AS DST
			INNER JOIN dbo.DigblockSurvey AS DS
				ON (DST.Digblock_Survey_Type_Id = DS.Digblock_Survey_Type_Id)
			INNER JOIN dbo.DigblockSurveySample AS DSS
				ON (DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id)
			INNER JOIN dbo.DigblockSurveySampleGrade AS DSSG
				ON (DSS.Digblock_Survey_Sample_Id = DSSG.Digblock_Survey_Sample_Id)
			INNER JOIN dbo.Grade AS G
				ON (DSSG.Grade_Id = G.Grade_Id)
		WHERE DST.Is_Visible = 1
			AND DSS.Digblock_Id = @iDigblock_Id
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		GROUP BY DST.Name, G.Grade_Name
		UNION All
		--Reconciled
		SELECT @TonnesTerm, @ReconciledTerm, @ReconciledIndex, Sum(DPT.Tonnes)
		FROM dbo.DataProcessTransaction AS DPT
		WHERE DPT.Source_Digblock_Id = @iDigblock_Id
		UNION All
		SELECT G.Grade_Name, @ReconciledTerm, @ReconciledIndex, 
			Sum(DPT.Tonnes * DPTG.Grade_Value) / NullIf(Sum(DPT.Tonnes), 0)
		FROM dbo.DataProcessTransaction AS DPT
			INNER JOIN dbo.DataProcessTransactionGrade DPTG
				ON (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
			INNER JOIN dbo.Grade G
				ON (DPTG.Grade_Id = G.Grade_Id)
		WHERE DPT.Source_Digblock_Id = @iDigblock_Id
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
		GROUP BY G.Grade_Name

		--Block Models
		IF @iIncludeBlockModels = 1
		BEGIN
			INSERT INTO #Value
			(
				Attribute, Measure, OrderNo, Value
			)
			SELECT @TonnesTerm, BM.Name, @BlockModelIndex, 
				Sum(MBP.Tonnes * Percentage_In_Digblock)
			FROM dbo.BlockModel AS BM
				INNER JOIN dbo.ModelBlock AS MB
					ON (BM.Block_Model_Id = MB.Block_Model_Id)
				INNER JOIN dbo.DigblockModelBlock DMB
					ON (DMB.Model_Block_Id = MB.Model_Block_Id)
				INNER JOIN dbo.ModelBlockPartial MBP
					ON (MBP.Model_Block_Id = MB.Model_Block_Id)
				INNER JOIN dbo.ModelBlockPartialSequence MBPS
					ON (MBP.Sequence_No = MBPS.Sequence_No
						AND MBPS.In_Digblock = 1)
			WHERE BM.Is_Displayed = 1
				AND DMB.Digblock_Id = @iDigblock_Id
			GROUP BY BM.Name
			UNION All
			SELECT G.Grade_Name, BM.Name, @BlockModelIndex, 
				Sum(MBP.Tonnes * Percentage_In_Digblock * MBPG.Grade_Value) / NullIf(Sum(MBP.Tonnes * Percentage_In_Digblock), 0)
			FROM dbo.BlockModel AS BM
				INNER JOIN dbo.ModelBlock AS MB
					ON (BM.Block_Model_Id = MB.Block_Model_Id)
				INNER JOIN dbo.DigblockModelBlock DMB
					ON (DMB.Model_Block_Id = MB.Model_Block_Id)
				INNER JOIN dbo.ModelBlockPartial MBP
					ON (MBP.Model_Block_Id = MB.Model_Block_Id)
				INNER JOIN dbo.ModelBlockPartialSequence MBPS
					ON (MBP.Sequence_No = MBPS.Sequence_No
						AND MBPS.In_Digblock = 1)
				INNER JOIN dbo.ModelBlockPartialGrade AS MBPG	
					ON (MBP.Model_Block_Id = MBPG.Model_Block_Id
						AND MBP.Sequence_No = MBPG.Sequence_No)
				INNER JOIN dbo.Grade AS G
					ON (MBPG.Grade_Id = G.Grade_Id)
			WHERE BM.Is_Displayed = 1
				AND DMB.Digblock_Id = @iDigblock_Id
				AND (G.Is_Visible = @iGrade_Visibility 
					OR @iGrade_Visibility IS NULL)
			GROUP BY BM.Name, G.Grade_Name
		END

		--Mine Plans
		IF @iIncludeMinePlans = 1
		BEGIN
			INSERT INTO #Value
			(
				Attribute, Measure, OrderNo, Value
			)
			SELECT @TonnesTerm, MP.Name, @MinePlanIndex, Sum(MPP.Tonnes)
			FROM dbo.MinePlan AS MP
				INNER JOIN @MinePlanDates AS MPD
					ON (MP.Mine_Plan_Id = MPD.Mine_Plan_Id)
				INNER JOIN dbo.MinePlanPeriod AS MPP
					ON (MPD.Mine_Plan_Id = MPP.Mine_Plan_Id
						AND MPP.End_Date >= MPD.Start_Date
						AND MPP.Start_Date <= MPD.End_Date)
				INNER JOIN 
					(
						--Only return 1 MPL Record based ON Digblocks (Stops double counting)
						SELECT MPL.Mine_Plan_Period_Id
						FROM dbo.DigblockLocation AS DL
							INNER JOIN dbo.LocationType AS LT
								ON (DL.Location_Type_Id = LT.Location_Type_Id)
							INNER JOIN dbo.MinePlanPeriodLocation AS MPL
								ON DL.Location_Id = MPL.Location_Id
							INNER JOIN dbo.MinePlanPeriod AS MPP
								ON (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
							INNER JOIN @MinePlanDates AS MPD
								ON (MPD.Mine_Plan_Id = MPP.Mine_Plan_Id)
						WHERE DL.Digblock_Id = @iDigblock_Id
							AND LT.Defines_3d_Point = 1
						GROUP BY MPL.Mine_Plan_Period_Id
					) AS MPL
				ON (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
			WHERE MP.Parent_Mine_Plan_Id IS NULL
				AND MP.Is_Visible = 1 
				AND MPP.Is_From_Pit = 1
			GROUP BY MP.Name
			UNION All
			SELECT G.Grade_Name, MP.Name, @MinePlanIndex, 
				Sum(MPP.Tonnes * MPPG.Grade_Value) / NullIf(Sum(MPP.Tonnes), 0)
			FROM dbo.MinePlan AS MP
				INNER JOIN @MinePlanDates AS MPD
					ON (MP.Mine_Plan_Id = MPD.Mine_Plan_Id)
				INNER JOIN dbo.MinePlanPeriod AS MPP
					ON (MPD.Mine_Plan_Id = MPP.Mine_Plan_Id
						AND MPP.End_Date >= MPD.Start_Date
						AND MPP.Start_Date <= MPD.End_Date)
				INNER JOIN 
					(
						--Only return 1 MPL Record based on Digblocks (Stops double counting)
						SELECT MPL.Mine_Plan_Period_Id
						FROM dbo.DigblockLocation AS DL
							INNER JOIN dbo.LocationType AS LT
								ON (DL.Location_Type_Id = LT.Location_Type_Id)
							INNER JOIN dbo.MinePlanPeriodLocation AS MPL
								ON DL.Location_Id = MPL.Location_Id
							INNER JOIN dbo.MinePlanPeriod AS MPP
								ON (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
							INNER JOIN @MinePlanDates AS MPD
								ON (MPD.Mine_Plan_Id = MPP.Mine_Plan_Id)
						WHERE DL.Digblock_Id = @iDigblock_Id
							AND LT.Defines_3d_Point = 1
						GROUP BY MPL.Mine_Plan_Period_Id
					) AS MPL
					ON (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
				INNER JOIN dbo.MinePlanPeriodGrade AS MPPG
					ON (MPPG.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
				INNER JOIN dbo.Grade AS G
					ON (MPPG.Grade_Id = G.Grade_Id)
			WHERE MP.Parent_Mine_Plan_Id IS NULL
				AND MP.Is_Visible = 1 
				AND MPP.Is_From_Pit = 1
				AND (G.Is_Visible = @iGrade_Visibility 
					OR @iGrade_Visibility IS NULL)
			GROUP BY MP.Name, G.Grade_Name
		END

		--Use Grade Control for Haulage & Survey Grades when they are NULL
		INSERT INTO #Value
		(
			Attribute, Measure, OrderNo, Value
		)
		SELECT V.Attribute, @HauledTerm, @HaulageIndex,  V.Value
		FROM #Value AS V
			INNER JOIN #Value AS H2 --This check makes sure we got tonnes 
				ON (H2.Attribute = @TonnesTerm
					AND H2.Measure = @HauledTerm)
			LEFT OUTER JOIN #Value AS H
				ON (V.Attribute = H.Attribute
					AND H.Measure = @HauledTerm)
		WHERE V.Measure = @GradeControlTerm
			AND V.Attribute <> @TonnesTerm
		GROUP BY V.Attribute, V.Value
		HAVING Count(H.Attribute) = 0
		UNION ALL
		SELECT V.Attribute, S2.Measure, @SurveyIndex,  V.Value
		FROM #Value AS V
			INNER JOIN #Value AS S2  --This check makes sure we got tonnes 
				ON (S2.Attribute = @TonnesTerm
					AND S2.OrderNo = @SurveyIndex)
			LEFT OUTER JOIN #Value AS S
				ON (V.Attribute = S.Attribute
					AND S2.OrderNo = @SurveyIndex)
		WHERE V.Measure = @GradeControlTerm
			AND V.Attribute <> @TonnesTerm
		GROUP BY V.Attribute, V.Value, S2.Measure
		HAVING Count(S.Attribute) = 0

		--Work out Percentage of Grade Control
		INSERT INTO #Value
		(
			Attribute, Measure, OrderNo, Value
		)
		SELECT @GCPercentTerm, M.Measure, M.OrderNo, 
			(M.Value / NullIf(GC.Value, 0)) * 100
		FROM #Value AS GC
			INNER JOIN #Value AS M
				ON (GC.Attribute = M.Attribute)
		WHERE GC.Measure = @GradeControlTerm
			AND M.Measure <> @GradeControlTerm
			AND GC.Attribute = @TonnesTerm

		--Pivot values against attribute table
		EXEC PivotTable
			@iTargetTable = '#Attribute',
			@iPivotTable = '#Value',
			@iJoinColumns = '#Attribute.Attribute = #Value.Attribute',
			@iPivotColumn = 'Measure',
			@iPivotValue = 'Value',
			@iPivotType = 'FLOAT',
			@iPivotOrderColumn = 'OrderNo',
			@iPivotOrderDirection = 'Asc'

		--Select Final Results
		SELECT *
		FROM #Attribute
		Order BY OrderNo

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	

	DROP TABLE #Attribute
	DROP TABLE #Value
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockDetailList TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockDetailList">
 <Procedure>
	Returns the digblock details for the specified @iDigblock_Id.
	Errors raised:
		Digblock Id does not exist.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetGraphScaleMax.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetGraphScaleMax]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetGraphScaleMax]
GO

CREATE Procedure [dbo].[GetGraphScaleMax]

(@Max_Value Float,
@Scale_Max Float Output)

With Encryption As

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

Declare @Temp_Value Float
Declare @Scale Int

	If (@Max_Value > 0)
	Begin
		Set @Temp_Value = @Max_Value
		Set @Scale = 0
	
		While (@Temp_Value > 10)
		Begin
			Set @Temp_Value = @Temp_Value / 10
			Set @Scale = @Scale + 1
		End
	
		/* Make sure that the maximum value is atleat 95% of the graph scale maximum */
		While ((@Max_Value / NullIf((Round(@Max_Value, - @Scale, 1) + Power(10, @Scale)), 0)) < 0.95)
		Begin
			Set @Scale = @Scale - 1
		End
	
		Select @Scale_Max = Round(@Max_Value, - @Scale, 1) + Power(10, @Scale)
	End
	Else
	Begin
		Set @Scale_Max = 0
	End


	Set @ELC_Proc_Is_Error = 0
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetGraphScaleMax">
 <Procedure>
	Returns maximum scale for graph in @Scale_Max output variable.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDrillList.prc'
GO

If Object_Id('dbo.GetDrillList') Is Not Null 
     Drop Procedure dbo.GetDrillList 
Go 

Create Procedure dbo.GetDrillList

With Encryption 
As

/*--------------------
-- Name: dbo.GetDrillList
-- Author: Ben Hobbs
-- Comments: Obtains the list of drills from the Drill table
--------------------*/
Begin
	Set Nocount On

	-- Get the list of drills
	Select Drill_Id, Description
	From Drill
	Order By Drill_Id
	
End
Go
GRANT EXECUTE ON dbo.GetDrillList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetDrillList">
 <Procedure>
	Returns the list of drills from the Drill table
	Results are ordered by Drill_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDrill.prc'
GO

If Object_Id('dbo.GetDrill') Is Not Null 
     Drop Procedure dbo.GetDrill 
Go 

Create Procedure dbo.GetDrill
(
	@iDrill_Id Varchar(31)
)

With Encryption 
As

Begin
	Set Nocount On

	Select Drill_Id, Description
	From Drill
	Where Drill_Id = @iDrill_Id
	Order By Drill_Id
	
End
Go
GRANT EXECUTE ON dbo.GetDrill TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDrill">
 <Procedure>
	Returns the Drill @iDrill_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetFirstDigblockSurveySummaryRecord.prc'
GO

If Object_Id('dbo.GetFirstDigblockSurveySummaryRecord') Is Not Null 
     Drop Procedure dbo.GetFirstDigblockSurveySummaryRecord 
Go 

Create Procedure dbo.GetFirstDigblockSurveySummaryRecord
(
	@iDigblock_Survey_Date Datetime,
	@iDigblock_Survey_Shift Char(1),
	@oPrevious_Record_Id Int Output,
	@oNext_Record_Id Int Output,
	@oNo_Records Int Output,
	@oTonnes_Per_Truck Float Output,
	@oMax_Tonnes Float Output,
	@oAve_Tonnes Float Output,
	@oMin_Tonnes Float Output,
	@iNT_Login Varchar(255) = Null,
	@iDigblock_Survey_Type_Id Int = Null
)

With Encryption 
As

Begin
	Set NoCount On

	Declare @Count Int
	Declare @Record_No Int
	Declare @Digblock_Survey_Summary_Id Int

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If a digblock survey type was not given */
	If (@iDigblock_Survey_Type_Id Is Null)
	Begin
		/* If there is only one available */
		If ((Select Count(*) From DigblockSurveyType) = 1)
		Begin
			/* Use that one */
			Select @iDigblock_Survey_Type_Id = Digblock_Survey_Type_Id
			From DigblockSurveyType
		End
	End

	Select @Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id
	From DigblockSurveySummary DSS
		Inner Join DigblockSurvey DS
			On DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id
	Where DS.Digblock_Survey_Date = @iDigblock_Survey_Date
		And DS.Digblock_Survey_Shift = @iDigblock_Survey_Shift
		And DS.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id
		And DSS.Record_No =	(Select Min(DSS2.Record_No)
						From DigblockSurveySummary DSS2
							Inner Join DigblockSurvey DS2
								On DSS2.Digblock_Survey_Id = DS2.Digblock_Survey_Id
						Where DS2.Digblock_Survey_Date = @iDigblock_Survey_Date
							And DS2.Digblock_Survey_Shift = @iDigblock_Survey_Shift
							And DS2.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id
							And ((@iNT_Login Is Null) Or (DSS2.NT_Login = @iNT_Login)))

	/* If any digblock survey summary records exist for this depletion period */
	If (@Digblock_Survey_Summary_Id Is Not Null)
	Begin
		/* Get the record and it's details */
		Execute GetDigblockSurveySummaryRecord 	
			@Digblock_Survey_Summary_Id, 
			@oPrevious_Record_Id Output, 
			@oNext_Record_Id Output, 
			@oNo_Records Output,
			@oTonnes_Per_Truck Output, 
			@oMax_Tonnes Output, 
			@oAve_Tonnes Output, 
			@oMin_Tonnes Output,
			@iNT_Login = @iNT_Login

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The digblock survey summary record does not exist', 16, 1)
	End

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetFirstDigblockSurveySummaryRecord TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetFirstDigblockSurveySummaryRecord">
 <Procedure>
	Returns DigblockSurvey records for this depletion period.
	Errors are raised if:
		The digblock survey summary record does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetGrade.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetGrade'))
	Drop Procedure dbo.GetGrade
Go


CREATE Procedure dbo.GetGrade
(
	@iGrade_Id SmallInt
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select *
	From Grade
	Where Grade_Id = @iGrade_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.GetGrade TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetGrade">
 <Procedure>
	Returns the @iGrade_Id grade from the Grade table.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetGradeList.prc'
GO

IF OBJECT_ID('dbo.GetGradeList') IS NOT NULL 
     DROP PROCEDURE dbo.GetGradeList  
GO 
  
CREATE PROCEDURE dbo.GetGradeList 
( 
    @iGrade_Visibility Bit,
	@iGrade_Type_Id Varchar(31) = Null
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	SELECT Grade_Id, Grade_Name, Description, Order_No, 
		Units, Display_Precision, Display_Format, Is_Visible,
		Grade_Type_Id
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND (G.Grade_Type_Id = @iGrade_Type_Id 
			OR @iGrade_Type_Id IS NULL)
	ORDER BY Order_No
END 
GO 

GRANT EXECUTE ON dbo.GetGradeList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetGradeList">
 <Procedure>
	Returns a list of all the grades in the Grade table.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionBulkInvalid.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionBulkInvalid]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionBulkInvalid]
GO

Create Procedure [dbo].[GetHaulageCorrectionBulkInvalid]
(
	@iType Varchar(31) = Null,
	@iInvalid Varchar(63) = Null
)

With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionBulkInvalid
--  Purpose: For the given haulage error type, a list of all the errors in that
--			 type and some additonal information is retrieved.
--  Parameters: @iType - Type of haulage error. If null, all are retrieved.
--					Valid: (Truck | Source | Destination | Null)
--				@iInvalid - Only records with the field type equal to this are returned.
--					Otherwise if it is null, all are returned.
-- 
--  Comments: @iInvalid is used to get the start/end date/shifts of a given type and 
--			  error range.
--  
--  Created By:		Murray Hipper
--  Created Date: 	23 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Invalid Table
	(
		Invalid Varchar(63),
		Error_Count Int,
		Min_Haulage_Date Datetime,
		Min_Haulage_Shift Char(1),
		Max_Haulage_Date Datetime,
		Max_Haulage_Shift Char(1)
	)


	If @iType = 'Truck' Or @iType Is Null
	Begin
		Insert Into @Invalid
		Select Truck, Count(*), 
			dbo.GetDatetimeAsDate(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Date,
			dbo.GetDatetimeAsShift(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Shift,
			dbo.GetDatetimeAsDate(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Date,
			dbo.GetDatetimeAsShift(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Shift
		From HaulageRaw HR
		Inner Join HaulageRawError HRE 
			On HR.Haulage_Raw_Id = HRE.Haulage_Raw_Id
		Inner Join HaulageRawErrorType HRET
			On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
		Inner Join HaulageRawErrorTypeGroup HRETG
			On HRET.Haulage_Raw_Error_Type_Group_Id = HRETG.Haulage_Raw_Error_Type_Group_Id
		Where Haulage_Raw_State_Id = 'E'
			And HRETG.Truck_Error_Flag = 1
			And (HR.Truck = @iInvalid Or @iInvalid Is Null)
		Group By Truck
	End

	If @iType = 'Source' Or @iType Is Null
	Begin
		Insert Into @Invalid
		Select Source, Count(*),
			dbo.GetDatetimeAsDate(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Date,
			dbo.GetDatetimeAsShift(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Shift,
			dbo.GetDatetimeAsDate(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Date,
			dbo.GetDatetimeAsShift(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Shift
		From HaulageRaw HR
		Inner Join HaulageRawError HRE 
			On HR.Haulage_Raw_Id = HRE.Haulage_Raw_Id
		Inner Join HaulageRawErrorType HRET
			On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
		Inner Join HaulageRawErrorTypeGroup HRETG
			On HRET.Haulage_Raw_Error_Type_Group_Id = HRETG.Haulage_Raw_Error_Type_Group_Id
		Where Haulage_Raw_State_Id = 'E'
			And HRETG.Source_Error_Flag = 1
			And (HR.Source = @iInvalid Or @iInvalid Is Null)
		Group By Source
	End


    If @iType = 'Destination' Or @iType Is Null
	Begin
		Insert Into @Invalid
		Select Destination, Count(*),
			dbo.GetDatetimeAsDate(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Date,
			dbo.GetDatetimeAsShift(Min(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Min_Haulage_Shift,
			dbo.GetDatetimeAsDate(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Date,
			dbo.GetDatetimeAsShift(Max(dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift))) As Max_Haulage_Shift
		From HaulageRaw HR
		Inner Join HaulageRawError HRE 
			On HR.Haulage_Raw_Id = HRE.Haulage_Raw_Id
		Inner Join HaulageRawErrorType HRET
			On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
		Inner Join HaulageRawErrorTypeGroup HRETG
			On HRET.Haulage_Raw_Error_Type_Group_Id = HRETG.Haulage_Raw_Error_Type_Group_Id
		Where Haulage_Raw_State_Id = 'E'
			And HRETG.Destination_Error_Flag = 1
			And (HR.Destination = @iInvalid Or @iInvalid Is Null)
		Group By Destination
	End


	Select *
	From @Invalid
	Order by Invalid
End
Go
GRANT EXECUTE ON dbo.GetHaulageCorrectionBulkInvalid TO CoreHaulageManager



/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionBulkInvalid">
 <Procedure>
	Returns list of errors for the specified @iType Haulage Error Type.  If @iType is not specified
	all records are returned.
	@iInvalid is used to get the start/end date/shifts of a given type and error range.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionFix.prc'
GO


If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionFix]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionFix]
GO

Create Procedure [dbo].[GetHaulageCorrectionFix]
(
	@iHaulage_Raw_Id Int = Null
)
With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionFix
--  Purpose: Returns the details of a given haulage raw record for the fix page.
--  Parameters: @iHaulage_Raw_Id - Haulage raw id of the record to retrieve.
-- 
--  Comments: In addition to the HaulageRaw record fields, the number of grades,
--			  attributes, errors, remaining error and the next haulage raw record 
--			  in error are also returned for efficiate UI coding.
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set NoCount On

	Declare @Num_Of_Grades Int
	Declare @Num_Of_Attributes Int
	Declare @Num_Of_Notes Int
	Declare @Num_Of_Errors Int
	Declare @Num_Of_Remaning_Errors Int
	Declare @Next_Haulage_Record Int

	-- Make sure the haulage record is a record.
	If @iHaulage_Raw_Id Is Null Or Not Exists (Select * From HaulageRaw Where Haulage_Raw_Id = @iHaulage_Raw_Id )
	Begin
		Select Top 1 @iHaulage_Raw_Id = Haulage_Raw_Id
		From HaulageRaw
		Where Haulage_Raw_State_Id = 'E'
	End


	-- Get the number of values that will be in the tabs and Misc Data.
	Select @Num_Of_Grades = Count(*)
	From HaulageRawGrade
	Where Haulage_Raw_Id = @iHaulage_Raw_Id

	Select @Num_Of_Notes = Count(*)
	From HaulageRawNotes
	Where Haulage_Raw_Id = @iHaulage_Raw_Id

	Select @Num_Of_Attributes = Count(*) + @Num_Of_Notes
	From HaulageRawValue
	Where Haulage_Raw_Id = @iHaulage_Raw_Id

	Select @Num_Of_Errors = Count(*)
	From HaulageRawError
	Where Haulage_Raw_Id = @iHaulage_Raw_Id

	Select @Num_Of_Remaning_Errors = Count(*)
	From HaulageRaw
	Where Haulage_Raw_State_Id = 'E'

	Select Top 1 @Next_Haulage_Record = Haulage_Raw_Id
	From HaulageRaw
	Where Haulage_Raw_State_Id = 'E' 
		And Haulage_Raw_Id > @iHaulage_Raw_Id

	Select HR.Haulage_Raw_Id, Haulage_Date, Haulage_Shift, dbo.GetShiftTypeName(Haulage_Shift) As Haulage_Shift_Str, 
		Source, Destination, Tonnes, Loads, Truck, Added_DateTime, 
		@Num_Of_Grades As Num_Of_Grades, @Num_Of_Attributes As Num_Of_Attributes,
		@Num_Of_Errors As Num_Of_Errors,
		@Num_Of_Remaning_Errors As Num_Of_Remaning_Errors,
		@Next_Haulage_Record As Next_Haulage_Record
	From HaulageRaw HR
	Where HR.Haulage_Raw_Id = @iHaulage_Raw_Id

End
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionFix TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionFix">
 <Procedure>
	Returns the details of a given haulage raw record for the fix page.
    In addition to the HaulageRaw record fields, the number of grades,
	attributes, errors, remaining error and the next haulage raw record 
	in error are also returned for efficiate UI coding.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionFixErrors.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionFixErrors]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionFixErrors]
GO

Create Procedure [dbo].[GetHaulageCorrectionFixErrors]
(
	@iHaulage_Raw_Id Int
)

With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionFixErrors
--  Purpose: Returns what kind of haulage errors the given haulage raw record has.
--  Parameters: @iHaulage_Raw_Id - Haulage raw id of the record to retrieve the errors.
-- 
--  Comments: The description and error type flags are returned of each error 
--			  that the haulage raw record has.
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set NoCount On

	Select Description, Truck_Error_Flag, Source_Error_Flag, Destination_Error_Flag
	From HaulageRawError HRE
	Inner Join HaulageRawErrorType HRET
		On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
	Inner Join HaulageRawErrorTypeGroup HRETG
		ON HRET.Haulage_Raw_Error_Type_Group_Id = HRETG.Haulage_Raw_Error_Type_Group_Id
	Where Haulage_Raw_Id = @iHaulage_Raw_Id

End

GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionFixErrors TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionFixErrors">
 <Procedure>
	Returns the description and type of Haulage errors that exist for the specified @iHaulage_Raw_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionList.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionList]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionList]
GO

CREATE Procedure [dbo].[GetHaulageCorrectionList]
(
	@iFilter_Source Varchar(63) = Null,
	@iFilter_Destination Varchar(63) = Null,
	@iFilter_Description Varchar(255) = Null,
	@iTop Bit = 0,
	@iRecordLimit Int = Null
)

With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionList
--  Purpose: Returns a list of the haulage in HALUAGE_RAW table with filters applied.
--  Parameters: @iFilter_Source - Returned haulage records must have this source unless null.
--				@iFilter_Destination - Returned haulage records must have this destination unless null.
--				@iFilter_Description - Returned haulage records must have this description unless null.
--				@iTop - If flagged only return the top X number of records.
-- 
--  Comments: The @iTop filter allows only a smaller subset of data to be returned
--			   to the UI to reduce processing and load time.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Haulage_Error_List Table 
	(
		Haulage_Raw_Id Int,
		Haulage_Date Datetime,
		Haulage_Shift_Str Varchar(63), 
		Source Varchar(255),
		Destination Varchar(255),
		Description Varchar(255)
	)

	Declare @Total_Records Int
	Declare @Top_Records Int
	
	/* Get the full list of haulage errors */
	Insert Into @Haulage_Error_List
	Select HR.Haulage_Raw_Id, Haulage_Date,
		dbo.GetShiftTypeName(Haulage_Shift), 
		Source, Destination, HRET.Description
	From HaulageRaw HR
	Inner Join HaulageRawError HRE 
		On HR.Haulage_Raw_Id = HRE.Haulage_Raw_Id
	Inner Join HaulageRawErrorType HRET 
		On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
	Where Haulage_Raw_State_Id = 'E'
		And ((@iFilter_Source Is Null) Or (@iFilter_Source = Source))
		And ((@iFilter_Destination Is Null) Or (@iFilter_Destination = Destination))
		And ((@iFilter_Description Is Null) Or (@iFilter_Description = Description))
	Order By Haulage_Date, dbo.GetShiftTypeOrderNo(Haulage_Shift)
 
	Set @Top_Records = @iRecordLimit
	Select @Total_Records = Count(*) 
	From @Haulage_Error_List

	If @iTop = 1 And @Total_Records > @Top_Records
	Begin

		Set Rowcount @Top_Records
		
		Select * 
		From @Haulage_Error_List
		Union All
		Select -1, 0, '...' + Cast(@Total_Records - @Top_Records As Varchar) + ' more.', '', '', ''
		
		Set Rowcount 0

	End
	Else
	Begin
		Select * 
		From @Haulage_Error_List
	End
	
End
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionList TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionList">
 <Procedure>
	Returns a list of the haulage in HALUAGE_RAW table with filters applied.
	The @iTop filter allows only a smaller subset of data to be returned
	to the UI to reduce processing and load time.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionListFilter.prc'
GO

IF OBJECT_ID('dbo.GetHaulageCorrectionListFilter') IS NOT NULL
	DROP PROCEDURE dbo.GetHaulageCorrectionListFilter
GO
CREATE PROCEDURE dbo.GetHaulageCorrectionListFilter
(
	@iFilter_Type VARCHAR(31)
)

WITH ENCRYPTION 
AS
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionListFilter
--  Purpose: Returns a list of all the Descriptions, Source or Destinations in 
--			 Haulage_Raw.
--  Parameters: @iFilter_Type - Type of filter. 
--					Valid: (Source | Destination | Description) 
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
--  Updated By:		Brian Acedo
--					Coding Standards Applied
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON

	DECLARE @Filter_Table TABLE
	(
		Filter VARCHAR(255)
	)

	IF @iFilter_Type = 'Description'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT hret.Description
		FROM dbo.HaulageRaw AS hr
			INNER JOIN dbo.HaulageRawError AS hre 
				ON hr.Haulage_Raw_Id = hre.Haulage_Raw_Id
			INNER JOIN dbo.HaulageRawErrorType AS hret 
				ON hre.Haulage_Raw_Error_Type_Id = hret.Haulage_Raw_Error_Type_Id
		WHERE Haulage_Raw_State_Id = 'E'
		ORDER BY Description
	END
	Else IF @iFilter_Type = 'Source'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT Source
		FROM dbo.HaulageRaw
		WHERE Haulage_Raw_State_Id = 'E'
		ORDER BY Source
	END
	Else IF @iFilter_Type = 'Destination'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT Destination
		FROM dbo.HaulageRaw
		WHERE Haulage_Raw_State_Id = 'E'
		ORDER BY Destination
	END

	SELECT Filter
	FROM @Filter_Table
END
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionListFilter TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionListFilter">
 <Procedure>
	Returns a list of distinct Error type descriptions, Sources or Destinations for HaulageRaw records
	that are have an error.
	The @iFilter_Type determines which type of information is returned.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionListNormalized.prc'
GO

IF Object_Id('dbo.GetHaulageCorrectionListNormalized') IS NOT NULL
BEGIN
	DROP PROCEDURE dbo.GetHaulageCorrectionListNormalized
END
GO

CREATE PROCEDURE dbo.GetHaulageCorrectionListNormalized
(
	@iHaulage_Raw_Id INT,
	@iNormalized_Type VARCHAR(31),
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	IF @iNormalized_Type = 'Attributes'
	BEGIN
		SELECT Haulage_Raw_Field_Id AS Item, Notes AS Value
		FROM dbo.HaulageRawNotes
		WHERE Haulage_Raw_Id = @iHaulage_Raw_Id
		UNION ALL
		SELECT Haulage_Raw_Field_Id AS Item, Cast(Field_Value AS VARCHAR) AS Value
		FROM dbo.HaulageRawValue
		WHERE Haulage_Raw_Id = @iHaulage_Raw_Id
	END
	ELSE IF @iNormalized_Type = 'Grades'
	BEGIN
		SELECT G.Grade_Name AS Item, HRG.Grade_Value AS Value
		FROM dbo.Grade AS G 
			LEFT OUTER JOIN dbo.HaulageRawGrade AS HRG
				ON (HRG.Grade_Id = G.Grade_Id
					AND Haulage_Raw_Id = @iHaulage_Raw_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	END
END

GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionListNormalized TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionListNormalized">
 <Procedure>
	Returns a list of all the normalized fields/grades of a haulage raw record..
	If @iNormalized_Type = Attributes the HaulageRawNotes and HaulageRawValue records are returned.
	Otherwise @iNormalized_Type = Grades HaulageRawGrade records are returned.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionResolutionBasicList.prc'
GO

IF OBJECT_ID('dbo.GetHaulageCorrectionResolutionBasicList') IS NOT NULL
	DROP PROCEDURE dbo.GetHaulageCorrectionResolutionBasicList
GO

CREATE PROCEDURE dbo.GetHaulageCorrectionResolutionBasicList
(
	@iHaulage_Resolve_Basic_Id INT = NULL,
	@iLocation_Id INT = NULL
)
WITH ENCRYPTION 
AS
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionResolutionBasicList
--  Purpose: Returns the UI list of all the Resolution basic records.
--  Parameters: @iHaulage_Resolve_Basic_Id - If set only this record will be
--				retrieved. If null all records will be retrieved.
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	24 October 2006
--
--  Updated By:		Brian Acedo
--					Added Location filter
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON
	
	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
	
	DECLARE @Location TABLE
	(
		Location_Id INT
	)
	
	CREATE TABLE #HaulageBasic
	(
		Haulage_Resolve_Basic_Id INT,
		Code VARCHAR(63), 
		Resolve_From_Date DATETIME,
		Resolve_From_Shift VARCHAR(10),
		Resolve_From_Shift_Str VARCHAR(10),
		Resolve_To_Date DATETIME,
		Resolve_To_Shift VARCHAR(10),
		Resolve_To_Shift_Str VARCHAR(10),
		Stockpile_Id INT,
		Stockpile_Name VARCHAR(31),
		Build_Id INT, 
		Component_Id INT,
		Digblock_Id VARCHAR(31) COLLATE database_default,
		Crusher_Id VARCHAR(31) COLLATE database_default,
		Mill_Id VARCHAR(31) COLLATE database_default,
		Description VARCHAR(255),
		Row_Num INT
	)

	if @iLocation_Id IS NOT NULL
	BEGIN
		INSERT INTO @Location
		( 
			Location_Id
		)
		SELECT Location_Id
		FROM dbo.GetLocationSubtree(@iLocation_Id)
	END
	
		INSERT INTO #HaulageBasic
		(
			Haulage_Resolve_Basic_Id,
			Code , 
			Resolve_From_Date,
			Resolve_From_Shift,
			Resolve_From_Shift_Str,
			Resolve_To_Date,
			Resolve_To_Shift,
			Resolve_To_Shift_Str,
			Stockpile_Id,
			Stockpile_Name,
			Build_Id, 
			Component_Id,
			Digblock_Id,
			Crusher_Id ,
			Mill_Id ,
			Description,
			Row_Num
		)
		SELECT hrb.Haulage_Resolve_Basic_Id, hrb.Code, hrb.Resolve_From_Date, hrb.Resolve_From_Shift, 
			dbo.GetShiftTypeName(Resolve_From_Shift), 
			hrb.Resolve_To_Date, hrb.Resolve_To_Shift, dbo.GetShiftTypeName(Resolve_To_Shift), hrb.Stockpile_Id, sl.Stockpile_Name, hrb.Build_Id, 
			hrb.Component_Id, hrb.Digblock_Id, hrb.Crusher_Id, hrb.Mill_Id, hrb.Description, Coalesce(Row_Num, 0) 
		FROM HaulageResolveBasic AS hrb 
			LEFT OUTER JOIN 
			(
				SELECT Haulage_Resolve_Basic_Id, Count(*) AS Row_Num
				FROM HaulageRawResolution
				GROUP BY Haulage_Resolve_Basic_Id
			) AS hrr
				ON (hrr.Haulage_Resolve_Basic_Id = hrb.Haulage_Resolve_Basic_Id)
			LEFT OUTER JOIN
			(
				SELECT s.Stockpile_Id, IsNull(l.Location_Id, 0) AS Location_Id, s.Stockpile_Name
				FROM dbo.Stockpile AS s
					LEFT OUTER JOIN dbo.StockpileLocation AS l
						ON (s.Stockpile_Id = l.Stockpile_Id)
			) AS sl
				ON (hrb.Stockpile_Id = sl.Stockpile_Id)
			LEFT OUTER JOIN
			(
				SELECT d.Digblock_Id, IsNull(l.Location_Id, 0) AS Location_Id
				FROM dbo.Digblock AS d
					LEFT OUTER JOIN dbo.DigblockLocation AS l
						ON (d.Digblock_Id = l.Digblock_Id)
			) AS dl
				ON (hrb.Digblock_Id = dl.Digblock_Id)
			LEFT OUTER JOIN
			(
				SELECT c.Crusher_Id, IsNull(l.Location_Id, 0) AS Location_Id
				FROM dbo.Crusher AS c
					LEFT OUTER JOIN dbo.CrusherLocation AS l
						ON (c.Crusher_Id = l.Crusher_Id) 
			) AS cl
				ON (hrb.Crusher_Id = cl.Crusher_Id)
			LEFT OUTER JOIN
			(
				SELECT m.Mill_Id, IsNull(l.Location_Id, 0) AS Location_Id
				FROM dbo.Mill AS m
					LEFT OUTER JOIN dbo.MillLocation AS l
						ON (m.Mill_Id = l.Mill_Id)
			) AS ml
				ON (hrb.Mill_Id = ml.Mill_Id )
		WHERE (hrb.Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id OR @iHaulage_Resolve_Basic_Id IS NULL)
			AND	( sl.Location_Id IS NULL OR sl.Location_Id IN ( SELECT Location_Id from @Location )	OR @iLocation_Id IS NULL)	
			AND ( dl.Location_Id IS NULL OR dl.Location_Id IN ( SELECT Location_Id from @Location ) OR @iLocation_Id IS NULL)
			AND ( cl.Location_Id IS NULL OR cl.Location_Id IN ( SELECT Location_Id from @Location ) OR @iLocation_Id IS NULL)
			AND ( ml.Location_Id IS NULL OR ml.Location_Id IN ( SELECT Location_Id from @Location ) OR @iLocation_Id IS NULL)			
			


	SELECT *
	FROM #HaulageBasic
	ORDER BY Haulage_Resolve_Basic_Id DESC
		
	DROP TABLE #HaulageBasic
	
	COMMIT TRANSACTION
END
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionResolutionBasicList TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionResolutionBasicList">
 <Procedure>
	Returns the UI list of all the Resolution basic records.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageManagementDetail.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageManagementDetail]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageManagementDetail]
GO

Create Procedure [dbo].[GetHaulageManagementDetail]
(
	@iHaulage_Id Int = Null
)
With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageManagementDetail
--  Purpose: Returns all the fields assocated with a haulage record and a
--			 few additional fields.
--  Parameters: @iHaulage_Id - Haulage ID of the details to retrieve.
-- 
--  Comments: In addition to all the fields of a haulage record, The number of
--			  grades, attributes and notes are also retrieved to assist in 
--			  efficent UI execution.
--  
--  Created By:		Murray Hipper
--  Created Date: 	23 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set NoCount On

	Declare @Num_Of_Grades Int
	Declare @Num_Of_Attributes Int
	Declare @Num_Of_Notes Int


	-- Get the number of values that will be in the tabs and Misc Data.
	Select @Num_Of_Grades = Count(*)
	From HaulageGrade
	Where Haulage_Id = @iHaulage_Id

	Select @Num_Of_Notes = Count(*)
	From HaulageNotes
	Where Haulage_Id = @iHaulage_Id

	Select @Num_Of_Attributes = Count(*) + @Num_Of_Notes
	From HaulageValue
	Where Haulage_Id = @iHaulage_Id



	Select Haulage_Id, Haulage_Date, Haulage_Shift, dbo.GetShiftTypeName(Haulage_Shift) As Haulage_Shift_Str,
		Tonnes, Loads, Truck_Id, Added_DateTime, Haulage_State_Id,
		Coalesce(Source_Digblock_Id, SS.Stockpile_Name, Source_Mill_Id) As Source, 
		Coalesce(Destination_Crusher_Id, DS.Stockpile_Name, Destination_Mill_Id) As Destination,
		Source_Digblock_Id, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id, Source_Mill_Id,
		Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id, Destination_Crusher_Id, Destination_Mill_Id,
		Child_Haulage_Id, Parent_Haulage_Id, 
		Case When Haulage_State_Id = 'N' And Child_Haulage_Id Is Null Then 1 Else 0 End As Is_Editable,
		@Num_Of_Grades As Num_Of_Grades, @Num_Of_Notes As Num_Of_Notes, @Num_Of_Attributes As Num_Of_Attributes
	From Haulage As H
		Left Join Stockpile As SS
			On SS.Stockpile_Id = H.Source_Stockpile_Id
		Left Join Stockpile As DS
			On DS.Stockpile_Id = H.Destination_Stockpile_Id
	Where Haulage_State_Id = 'N'
		And Haulage_Id = @iHaulage_Id
End


GO
GRANT EXECUTE ON dbo.GetHaulageManagementDetail TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageManagementDetail">
 <Procedure>
	Returns all the fields assocated with a haulage record and a  few additional fields.
	In addition to all the fields of a haulage record, The number of
	grades, attributes and notes are also retrieved to assist in 
	efficent UI execution.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageManagementDetailNormalized.prc'
GO

IF object_id('dbo.GetHaulageManagementDetailNormalized') IS NOT NULL
	DROP PROCEDURE dbo.GetHaulageManagementDetailNormalized
GO

CREATE PROCEDURE dbo.GetHaulageManagementDetailNormalized
(
	@iHaulage_Id INT = NULL,
	@iNormalized_Type VARCHAR(31),
	@iShow_All BIT = 0,
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	DECLARE @Details TABLE 
	(
		Display_Name VARCHAR(63),
		Item VARCHAR(63),
		Value VARCHAR(1023),
		Data_Type VARCHAR(31)
	)

	IF @iNormalized_Type = 'Attribute' OR @iNormalized_Type = 'Note' OR @iNormalized_Type = 'Value'
	BEGIN
		INSERT INTO @Details
		(
			Display_Name, Item, Value, Data_Type
		)
		SELECT HF.Haulage_Field_Id, HF.Haulage_Field_Id, Coalesce(Coalesce(Cast(HV.Field_Value AS VARCHAR), HN.Notes), ''), 
			CASE WHEN HF.Has_Notes = 1 THEN 'Note' ELSE 'Value' END
		FROM dbo.HaulageField AS HF
			LEFT JOIN dbo.HaulageNotes AS HN
				ON (HN.Haulage_Field_Id = HF.Haulage_Field_Id 
					AND HF.Has_Notes = 1 
					AND HN.Haulage_Id = @iHaulage_Id)
			LEFT JOIN dbo.HaulageValue AS HV
				ON (HV.Haulage_Field_Id = HF.Haulage_Field_Id 
					AND HF.Has_Value = 1 
					AND HV.Haulage_Id = @iHaulage_Id)

		IF @iNormalized_Type = 'Note' OR @iNormalized_Type = 'Value'
		BEGIN
			DELETE FROM @Details
			WHERE Data_Type <> @iNormalized_Type
		END
	END
	ELSE IF @iNormalized_Type = 'Grade'
	BEGIN
		INSERT INTO @Details
		(
			Display_Name, Item, Value, Data_Type
		)
		SELECT G.Grade_Name, G.Grade_Id, Coalesce(Cast(HG.Grade_Value AS VARCHAR), ''), 'Grade'
		FROM dbo.Grade AS G
			LEFT JOIN dbo.HaulageGrade AS HG
				ON (HG.Grade_Id = G.Grade_Id 
					AND HG.Haulage_Id = @iHaulage_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	END

	IF @iShow_All = 0
	BEGIN
		DELETE
		FROM @Details
		WHERE Value = ''
	END

	SELECT *
	FROM @Details
	ORDER BY Item
END
GO
GRANT EXECUTE ON dbo.GetHaulageManagementDetailNormalized TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageManagementDetailNormalized">
 <Procedure>
	Returns a list of all the normalized fields/grades of a haulage record.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageManagementList.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageManagementList]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageManagementList]
GO

CREATE Procedure [dbo].[GetHaulageManagementList]
(
	@iFilter_Start_Date Datetime,
	@iFilter_Start_Shift Char(1) = Null,
	@iFilter_End_Date Datetime,
	@iFilter_End_Shift Char(1) = Null,
	@iFilter_Source Varchar(63) = Null,
	@iFilter_Destination Varchar(63) = Null,
	@iFilter_Truck Varchar(31) = Null,
	@iShowHaulageWithApprovedChild Bit = 1,
	@iTop Bit = 0,
	@iRecordLimit Int = Null,
	@oCountRecords Int = Null Output,
	@oCountSourceStockpile Int = Null Output,
	@oCountSourceDigblock Int = Null Output,
	@oCountSourceMill Int = Null Output,
	@oCountDestinationStockpile Int = Null Output,
	@oCountDestinationCrusher Int = Null Output,
	@oCountDestinationMill Int = Null Output,
	@oSumTonnes Float = Null Output
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageManagementList
--  Purpose: Returns a list of the haulage in HALUAGE table with filters applied.
--  Parameters: @iFilter_Start_Date - Returned haulage records must be after this date inclusive.
--				@iFilter_End_Date - Returned haulage records must be before this date inclusive.
--				@iFilter_Start_Shift - Shift of the Start Date
--				@iFilter_End_Shift - Shift of the End Date
--				@iFilter_Source - Returned haulage records must have this source unless null.
--				@iFilter_Destination - Returned haulage records must have this destination unless null.
--				@iFilter_Truck - Returned haulage records must have this truck id unless it is null.
--				@iTop - If flagged only return the top X number of records.
--				@iShowHaulageWithApprovedChild - Show the Non approved haulage with approved children.
--				@oCountRecords - The total number of records counted by the filter
--				@oCountSourceStockpile - The total number of haulage records with source stockpiles
--				@oCountSourceDigblock - The total number of haulage records with source digblocks
--				@oCountSourceMill - The total number of haulage records with source mills
--				@oCountDestinationStockpile - The total number of haulage records with destination stockpiles
--				@oCountDestinationCrusher - The total number of haulage records with destination crushers
--				@oCountDestinationMill - The total number of haulage records with destination Mills
--				@oSumTonnes - The sum of the tonnes.
-- 
--  Comments: The @iTop filter allows only a smaller subset of data to be returned
--			   to the UI to reduce processing and load time.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 October 2006
--	Altered History:3 Jan 2007 - Murray Hipper - Added Truck to filter and results
--					8 Jan 07 - Murray - Added in Shifts.
--					9 Aug 07 - Murray - Added in @oSumTonnes for v6
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Haulage_List Table 
	(
		Haulage_Id Int,
		Haulage_Date Datetime,
		Haulage_Shift_Str Varchar(63), 
		Source Varchar(255),
		Destination Varchar(255),
		Truck Varchar(31),
		Tonnes Float,
		Editable Bit Default 1
	)

	Declare @Total_Records Int
	Declare @Top_Records Int
	
	-- Get Start and End shifts are null, default them to the min and max shifts respectivly.
	If @iFilter_Start_Shift Is Null And @iFilter_End_Shift Is Null
	Begin
		Select @iFilter_Start_Shift = dbo.GetFirstShiftType()
		Select @iFilter_End_Shift = dbo.GetLastShiftType()
	End
	
	-- Get the haulage count.
	Select @oCountRecords = Count(Haulage_Id),
	@oCountSourceStockpile = Coalesce(Sum(Case When Source_Stockpile_Id Is Null Then 0 Else 1 End),0),
	@oCountSourceDigblock = Coalesce(Sum(Case When Source_Digblock_Id Is Null Then 0 Else 1 End),0),
	@oCountSourceMill = Coalesce(Sum(Case When Source_Mill_Id Is Null Then 0 Else 1 End),0),
	@oCountDestinationStockpile = Coalesce(Sum(Case When Destination_Stockpile_Id Is Null Then 0 Else 1 End),0),
	@oCountDestinationCrusher = Coalesce(Sum(Case When Destination_Crusher_Id Is Null Then 0 Else 1 End),0),
	@oCountDestinationMill = Coalesce(Sum(Case When Destination_Mill_Id Is Null Then 0 Else 1 End),0),
	@oSumTonnes = Coalesce(Sum(Tonnes),0)
	From Haulage As H
		Left Join Stockpile As SS
			On SS.Stockpile_Id = H.Source_Stockpile_Id
		Left Join Stockpile As DS
			On DS.Stockpile_Id = H.Destination_Stockpile_Id
	Where (Coalesce(H.Source_Digblock_Id, Cast(H.Source_Stockpile_Id As Varchar), H.Source_Mill_Id) = @iFilter_Source Or @iFilter_Source Is Null)
		And (Coalesce(H.Destination_Crusher_Id, Cast(H.Destination_Stockpile_Id As Varchar), H.Destination_Mill_Id) = @iFilter_Destination Or @iFilter_Destination Is Null)
		And (Truck_Id = @iFilter_Truck Or @iFilter_Truck Is Null)
		And Haulage_State_Id = 'N'
		And (Child_Haulage_Id Is Null And @iShowHaulageWithApprovedChild = 0 Or @iShowHaulageWithApprovedChild = 1)
		And Haulage_Date >= @iFilter_Start_Date -- For Index Purposes
		And Haulage_Date <= @iFilter_End_Date
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>=', @iFilter_Start_Date, @iFilter_Start_Shift) = 1)
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '<=', @iFilter_End_Date, @iFilter_End_Shift) = 1)
	
	/* Get the full list of haulage */
	Insert Into @Haulage_List
	Select H.Haulage_Id, H.Haulage_Date, dbo.GetShiftTypeName(H.Haulage_Shift), 
		Coalesce(H.Source_Digblock_Id, SS.Stockpile_Name, H.Source_Mill_Id),
		Coalesce(DS.Stockpile_Name, H.Destination_Crusher_Id, H.Destination_Mill_Id),
		Truck_Id, Tonnes,
		Case When H.Haulage_State_Id = 'N' And H.Child_Haulage_Id Is Null Then 1 Else 0 End As Is_Editable
	From Haulage As H
		Left Join Stockpile As SS
			On SS.Stockpile_Id = H.Source_Stockpile_Id
		Left Join Stockpile As DS
			On DS.Stockpile_Id = H.Destination_Stockpile_Id
	Where (Coalesce(H.Source_Digblock_Id, Cast(H.Source_Stockpile_Id As Varchar), H.Source_Mill_Id) = @iFilter_Source Or @iFilter_Source Is Null)
		And (Coalesce(H.Destination_Crusher_Id, Cast(H.Destination_Stockpile_Id As Varchar), H.Destination_Mill_Id) = @iFilter_Destination Or @iFilter_Destination Is Null)
		And (Truck_Id = @iFilter_Truck Or @iFilter_Truck Is Null)
		And Haulage_State_Id = 'N'
		And (Child_Haulage_Id Is Null And @iShowHaulageWithApprovedChild = 0 Or @iShowHaulageWithApprovedChild = 1)
		And Haulage_Date >= @iFilter_Start_Date
		And Haulage_Date <= @iFilter_End_Date
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>=', @iFilter_Start_Date, @iFilter_Start_Shift) = 1)
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '<=', @iFilter_End_Date, @iFilter_End_Shift) = 1)
	Order by H.Haulage_Date Desc, dbo.GetShiftTypeOrderNo(H.Haulage_Shift) Desc

	Set @Top_Records = @iRecordLimit
	Select @Total_Records = Count(*) 
	From @Haulage_List

	If @iTop = 1 And @Total_Records > @Top_Records
	Begin
	
		Set Rowcount @Top_Records
		
		Select * 
		From @Haulage_List
		--Union All
		--Select -1, 0, '...' + Cast(@Total_Records - @Top_Records As Varchar) + ' more.', '', '', '', ''
		
		Set Rowcount 0

	End
	Else
	Begin
		Select * 
		From @Haulage_List
	End
	
End
GO
GRANT EXECUTE ON dbo.GetHaulageManagementList TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageManagementList">
 <Procedure>
	Returns a list of records in the Haulage table both in a resultset and in output parameters.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageManagementListFilter.prc'
GO


IF OBJECT_ID('dbo.GetHaulageManagementListFilter') IS NOT NULL
	DROP PROCEDURE dbo.GetHaulageManagementListFilter
GO

CREATE PROCEDURE dbo.GetHaulageManagementListFilter
(
	@iFilter_Type VARCHAR(31),
	@iLocation_Id INT = NULL
)

WITH ENCRYPTION 
AS
/*-----------------------------------------------------------------------------
--  Name: GetHaulageManagementListFilter
--  Purpose: Returns a list of all the Source or Destinations in Haulage.
--  Parameters: @iFilter_Type - Type of filter. 
--					Valid: (Source | Destination | Truck) 
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
--  Updated By:		Brian Acedo
--					Added Location filter
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON

	DECLARE @Filter_Table TABLE
	(
		Filter_Display VARCHAR(255) COLLATE Database_Default,
		Filter_Value VARCHAR(255) COLLATE Database_Default,
		Location_Id INT
	)

	IF @iFilter_Type = 'Source'
	BEGIN
		-- Digblock	
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(d.Description, h.Source_Digblock_Id) AS Description, h.Source_Digblock_Id, IsNull(dl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Digblock AS d 
					ON h.Source_Digblock_Id = d.Digblock_Id
				LEFT JOIN dbo.DigblockLocation AS dl
					ON d.Digblock_Id = dl.Digblock_Id
						
		-- Stockpile
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(s.Description, h.Source_Stockpile_Id) AS Description, h.Source_Stockpile_Id, IsNull(sl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Stockpile AS s
					ON h.Source_Stockpile_Id = s.Stockpile_Id
				LEFT JOIN dbo.StockpileLocation AS sl
					ON s.Stockpile_Id = sl.Stockpile_Id
		
		-- Mill
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(m.Description, h.Source_Mill_Id) AS Description, h.Source_Mill_Id, IsNull(ml.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Mill AS m
					ON h.Source_Mill_Id = m.Mill_Id
				LEFT JOIN dbo.MillLocation AS ml
					ON m.Mill_Id = ml.Mill_Id
	END
	Else IF @iFilter_Type = 'Destination'
	BEGIN
		-- Crusher	
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(c.Description, h.Destination_Crusher_Id) AS Description, h.Destination_Crusher_Id, IsNull(cl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Crusher AS c 
					ON h.Destination_Crusher_Id = c.Crusher_Id
				LEFT JOIN dbo.CrusherLocation AS cl
					ON c.Crusher_Id = cl.Crusher_Id
						
		-- Stockpile
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(s.Description, h.Destination_Stockpile_Id) AS Description, h.Destination_Stockpile_Id, IsNull(sl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Stockpile AS s
					ON h.Destination_Stockpile_Id = s.Stockpile_Id
				LEFT JOIN dbo.StockpileLocation AS sl
					ON s.Stockpile_Id = sl.Stockpile_Id
		
		-- Mill
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(m.Description, h.Destination_Mill_Id) AS Description, h.Destination_Mill_Id, IsNull(ml.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Mill AS m
					ON h.Destination_Mill_Id = m.Mill_Id
				LEFT JOIN dbo.MillLocation AS ml
					ON m.Mill_Id = ml.Mill_Id
					
	END
	Else IF @iFilter_Type = 'Truck'
	BEGIN
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT H.Truck_Id, H.Truck_Id, Coalesce(@iLocation_Id, 0)
			FROM Haulage AS H
			GROUP BY H.Truck_Id, H.Truck_Id
	END


	SELECT *
	FROM @Filter_Table
	WHERE Location_Id = IsNull(@iLocation_Id, Location_Id)
	ORDER BY Filter_Display
END
GO
GRANT EXECUTE ON dbo.GetHaulageManagementListFilter TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageManagementListFilter">
 <Procedure>
	Returns a list of the given filter type to display in the UI.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageValidHaulagePointList.prc'
GO

IF OBJECT_ID('dbo.GetHaulageValidHaulagePointList') IS NOT NULL 
	DROP PROCEDURE dbo.GetHaulageValidHaulagePointList
GO

CREATE PROCEDURE dbo.GetHaulageValidHaulagePointList
(
	@iStart_Date DATETIME,
	@iStart_Shift CHAR(1) = NULL,
	@iEnd_Date DATETIME = NULL,
	@iEnd_Shift CHAR(1) = NULL,
	@iType VARCHAR(31) = NULL,
	@iActiveDateInclusiveConstraint BIT = 0,
	@iLocation_Id INT = NULL
)
WITH ENCRYPTION 
AS
/*-----------------------------------------------------------------------------
--  Name: GetHaulageValidHaulagePointList
--  Purpose: Gets the valid haulage source/destinations for a given time period.
--  Parameters: @iStart_Date - Start date of the range that the source/destinations 
--								must be be activated on. 
--				@iStart_Shift - Start shift range for the valid source/destinations.
--				@iEnd_Date - End Date range for the valid source/destinations.
--				@iEnd_Shift - End Shift range for the valid source/destinations.
--				@iType - The type of.
--					Valid: (Digblock | Stockpile | Mill | Resolution | 
--						   AdvResolution | Crusher | Null)
--				@iActiveDateInclusiveConstraint -
--					1: it must be activated between both ranges
--					0: it must be active at some point within the date ranges or auto-activated
-- 
--  Comments: This returns the all the valid haulge points of the provided type 
--				that is active at any point between the given range.
--  
--  Created By:		Murray Hipper
--  Created Date: 	22 October 2006
--
--  Updated By:		Brian Acedo
--					Added Location filter
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON

	DECLARE @Point TABLE
	(
		Type VARCHAR(31),
		Point VARCHAR(63),
		Point_Name VARCHAR(63),
		Is_Source BIT,
		Is_Destination BIT,
		Location_Id INT
	)

	-- Get Start AND END shifts are NULL, default them to the min AND max shifts respectivly.
	IF @iStart_Shift IS NULL
	BEGIN
		SELECT @iStart_Shift = dbo.GetFirstShiftType()
	END
	
	IF @iEnd_Date IS NOT NULL AND @iEnd_Shift IS NULL
	BEGIN
		SELECT @iEnd_Shift = dbo.GetLastShiftType()
	END

	-- S/digblock.digblock_id  (filter: active)
	-- SD/stockpile.stockpile_id  (filter: build date/shift, filter: reclaim/normal only)
	-- S/(map) haulage_resolve_split.code  (filter: resolve_from_date/shift -> resolve_to_date/shift)
	-- SD/(map) haulage_resolve_basic.code  (AS above)
	-- D/crusher.crusher_id  (no filters)
	-- SD/Mills

	-- [Source] Digblock 
	IF @iType = 'Digblock' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point
			(Type, Point, Point_Name, Is_Source, Is_Destination, Location_Id)
		SELECT 'Digblock', d.Digblock_Id, d.Digblock_Id, 1, 0, IsNull(dl.Location_Id, 0)
		FROM Digblock AS d
			LEFT JOIN DigblockLocation AS dl
				ON (d.Digblock_Id = dl.Digblock_Id)
		WHERE
			(
				@iActiveDateInclusiveConstraint = 0
				AND						
				(
					Auto_Activate_Haulage = 1
					OR
					(
						(dbo.CompareDateShift(Start_Date, Start_Shift, '<=', @iEnd_Date, @iEnd_Shift) = 1 
							OR (@iEnd_Date IS NULL AND Start_Date IS NOT NULL))
						AND (dbo.CompareDateShift(End_Date, End_Shift, '>=', @iStart_Date, @iStart_Shift) = 1 
							OR End_Date IS NULL)
					)
				)
			)
			OR
			(
				@iActiveDateInclusiveConstraint = 1
				AND (dbo.CompareDateShift(Start_Date, Start_Shift, '<=', @iStart_Date, @iStart_Shift) = 1)
				AND (dbo.CompareDateShift(End_Date, End_Shift, '>=', @iEnd_Date, @iEnd_Shift) = 1 
					OR End_Date IS NULL)
			)
	END

	-- [Source][Destination] Stockpile
	IF @iType = 'Stockpile' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point (Type, Point, Point_Name, Is_Source, Is_Destination, Location_Id)
			SELECT 'Stockpile', s.Stockpile_Id, s.Stockpile_Name, 1, 1, IsNull(sl.Location_Id, 0)
			FROM Stockpile AS s
				INNER JOIN StockpileBuild AS sb
					ON (sb.Stockpile_Id = s.Stockpile_Id)
				LEFT JOIN StockpileLocation AS sl
					ON (s.Stockpile_Id = sl.Stockpile_Id)
			WHERE Stockpile_State_Id In ('NORMAL', 'RECLAIMING')
				AND Is_Visible = 1
				AND (
						(
							@iActiveDateInclusiveConstraint = 0
							AND (dbo.CompareDateShift(Start_Date, Start_Shift, '<=', @iEnd_Date, @iEnd_Shift) = 1 
								OR (@iEnd_Date IS NULL AND Start_Date IS NOT NULL))
							AND (dbo.CompareDateShift(End_Date, End_Shift, '>=', @iStart_Date, @iStart_Shift) = 1 
								OR End_Date IS NULL)
						)
						OR
						(
							@iActiveDateInclusiveConstraint = 1
							AND (dbo.CompareDateShift(Start_Date, Start_Shift, '<=', @iStart_Date, @iStart_Shift) = 1)
							AND (dbo.CompareDateShift(End_Date, End_Shift, '>=', @iEnd_Date, @iEnd_Shift) = 1 
								OR End_Date IS NULL)
						)
					)	
	END

	-- [Source][Destination] Mill
	IF @iType = 'Mill' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point (Type, Point, Point_Name, Is_Source, Is_Destination, Location_Id)
			SELECT 'Mill', m.Mill_Id, m.Mill_Id, 1, 1, IsNull(ml.Location_ID, 0)
			FROM Mill AS m
				LEFT JOIN MillLocation AS ml
					ON m.Mill_Id = ml.Mill_Id			
	END

	-- [Source][Destination] Name Resolution
	IF @iType = 'Resolution' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point (Type, Point, Point_Name, Is_Source, Is_Destination)
		SELECT 'Resolution', hrb.Code, hrb.Code, 1, 1
		FROM HaulageResolveBasic AS hrb
		WHERE 
			(
				(
					@iActiveDateInclusiveConstraint = 0
					AND (dbo.CompareDateShift(Resolve_From_Date, Resolve_From_Shift, '<=', @iEnd_Date, @iEnd_Shift) = 1 
						OR (@iEnd_Date IS NULL AND Resolve_From_Date IS NOT NULL))
					AND (dbo.CompareDateShift(Resolve_To_Date, Resolve_To_Shift, '>=', @iStart_Date, @iStart_Shift) = 1 
						OR Resolve_To_Date IS NULL)
				)
				OR
				(
					@iActiveDateInclusiveConstraint = 1
					AND (dbo.CompareDateShift(Resolve_From_Date, Resolve_From_Shift, '<=', @iStart_Date, @iStart_Shift) = 1)
					AND (dbo.CompareDateShift(Resolve_To_Date, Resolve_To_Shift, '>=', @iEnd_Date, @iEnd_Shift) = 1 
						OR Resolve_To_Date IS NULL)
				)
			)	
	END

	-- [Source] Advanced Name Resolution
	IF @iType = 'AdvResolution' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point (Type, Point, Point_Name, Is_Source, Is_Destination)
		SELECT 'AdvResolution', hrs.Code, hrs.Code, 1, 0
		FROM HaulageResolveSplit AS hrs
		WHERE 
			(
				(
					@iActiveDateInclusiveConstraint = 0
					AND (dbo.CompareDateShift(Resolve_From_Date, Resolve_From_Shift, '<=', @iEnd_Date, @iEnd_Shift) = 1 
						OR (@iEnd_Date IS NULL AND Resolve_From_Date IS NOT NULL))
					AND (dbo.CompareDateShift(Resolve_To_Date, Resolve_To_Shift, '>=', @iStart_Date, @iStart_Shift) = 1 
						OR Resolve_To_Date IS NULL)
				)
				OR
				(
					@iActiveDateInclusiveConstraint = 1
					AND (dbo.CompareDateShift(Resolve_From_Date, Resolve_From_Shift, '<=', @iStart_Date, @iStart_Shift) = 1)
					AND (dbo.CompareDateShift(Resolve_To_Date, Resolve_To_Shift, '>=', @iEnd_Date, @iEnd_Shift) = 1 
						OR Resolve_To_Date IS NULL)
				)
			)	
	END

	-- [Destination] Crusher
	IF @iType = 'Crusher' OR @iType IS NULL
	BEGIN
		INSERT INTO @Point (Type, Point, Point_Name, Is_Source, Is_Destination, Location_Id)
			SELECT 'Crusher', c.Crusher_Id, c.Crusher_Id, 0, 1, IsNull(cl.Location_Id, 0)
			FROM Crusher AS c
				LEFT JOIN CrusherLocation AS cl
					ON c.Crusher_Id = cl.Crusher_Id
	END

	SELECT *
	FROM @Point
	WHERE Location_Id = IsNull(@iLocation_Id, Location_Id)
		OR Location_Id IN ( SELECT Location_Id FROM dbo.GetLocationSubtree(@iLocation_Id) )		
END
GO
GRANT EXECUTE ON dbo.GetHaulageValidHaulagePointList TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageValidHaulagePointList">
 <Procedure>
	Returns the valid source/destinations for a given time period from the Haulage table.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationType.prc'
GO

IF OBJECT_ID('dbo.GetLocationType') IS NOT NULL 
     DROP PROCEDURE dbo.GetLocationType 
GO 
  
CREATE PROCEDURE dbo.GetLocationType
(
	@iLocation_Type_Id TINYINT
)

WITH ENCRYPTION 
AS

BEGIN
	SET NOCOUNT ON

	SELECT Location_Type_Id, Parent_Location_Type_Id, Description
	FROM dbo.LocationType
	WHERE Location_Type_Id = @iLocation_Type_Id
	
END
GO
GRANT EXECUTE ON dbo.GetLocationType TO CoreUtilityManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetLocationType">
 <Procedure>
	Returns the location type @iLocation_Type_Id from the LocationType table.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationTypeList.prc'
GO

IF object_id('dbo.GetLocationTypeList') IS NOT NULL 
     DROP PROCEDURE dbo.GetLocationTypeList 
GO 
  
CREATE PROCEDURE dbo.GetLocationTypeList 
( 
	@iParent_Location_Type_Id TINYINT = NULL,
	@iDefines_3d_Point BIT = NULL
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    -- Get the list of location types in the system
	SELECT LT.Location_Type_Id, LT.Description, LT.Parent_Location_Type_Id,
		PLT.Description AS Parent_Location_Description, LT.Defines_3d_Point
	FROM LocationType AS LT
		LEFT OUTER JOIN LocationType AS PLT
			ON LT.Parent_Location_Type_Id = PLT.Location_Type_Id
	WHERE (@iDefines_3d_Point IS NULL 
			OR LT.Defines_3d_Point = @iDefines_3d_Point)
		AND ((@iParent_Location_Type_Id = 0 
				AND LT.Parent_Location_Type_Id IS NULL)
			OR (LT.Parent_Location_Type_Id = @iParent_Location_Type_Id)
			OR (@iParent_Location_Type_Id IS NULL))

    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetLocationTypeList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetLocationTypeList">
 <Procedure>
	Returns a list of location types in the system. If a Parent Location
	Type ID is passed in with a value of 0 then only parent level location types
	are passed through.
 </Procedure>
</TAG>
*/




GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationList.prc'
GO

If Object_Id('dbo.GetLocationList') Is Not Null 
     Drop Procedure dbo.GetLocationList 
Go 
  
Create Procedure dbo.GetLocationList
( 
    @iNormal_List Bit = 1,
	@iParent_Location_Id Int = Null,
	@iLocation_Id Int = Null,
	@iLocation_Type_Id TINYINT = Null,
	@iOrderByName Bit = 0
) 
With Encryption 
As 

Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		-- Return the list of locations in the system
		If (@iNormal_List = 0)
		Begin

			Select L.Location_Id, L.Name, L.Location_Type_Id, L.Location_Type_Description, L.Parent_Location_Id, L.Description, 
				IsNull(PL.Location_Type_Id, 0) As Parent_Location_Type_Id, Count(CL.Location_Id) As Children
			From 
				(	
					Select 0 As Location_Id, 'Locations' As Name, Null As Location_Type_Id, Null As Location_Type_Description,
						Null As Parent_Location_Id, 'Locations' As Description
					Union All
					Select L.Location_Id, L.Name, L.Location_Type_Id, LT.Description As Location_Type_Description,
						 IsNull(L.Parent_Location_Id, 0) As Parent_Location_Id, L.Description
					From Location L 
						Inner Join LocationType LT 
							On L.Location_Type_Id = LT.Location_Type_Id
				) As L
				Left Outer Join Location As PL
					On L.Parent_Location_Id = PL.Location_Id
				Left Outer Join Location As CL
					On L.Location_Id = CL.Parent_Location_Id
			Where (L.Parent_Location_Id = @iParent_Location_Id 
						Or (L.Parent_Location_Id Is Null 
							And @iParent_Location_Id Is Null))
				And (L.Location_Id = @iLocation_Id 
					Or @iLocation_Id Is Null)
				And (L.Location_Type_Id = @iLocation_Type_Id
					Or @iLocation_Type_Id Is Null)
			Group by L.Location_Id, L.Name, L.Location_Type_Id, L.Parent_Location_Id, L.Description, 
				PL.Location_Type_Id, Location_Type_Description
			Order By L.Location_Type_Description, L.Name
		End
		Else
		Begin
			Select L.Location_Id, L.Name, L.Location_Type_Id, LT.Description as Location_Type_Description,
				IsNull(L.Parent_Location_Id, 0) As Parent_Location_Id, L.Description,
				IsNull(PL.Location_Type_Id, 0) As Parent_Location_Type_Id
			From Location As L
				Inner Join LocationType As LT
					On L.Location_Type_Id = LT.Location_Type_Id
				Left Outer Join Location As PL
					On L.Parent_Location_Id = PL.Location_Id
			Where (IsNull(L.Parent_Location_Id, 0) = @iParent_Location_Id 
					Or @iParent_Location_Id Is Null)
				And (L.Location_Id = @iLocation_Id 
					Or @iLocation_Id Is Null)
				And (L.Location_Type_Id = @iLocation_Type_Id 
					Or @iLocation_Type_Id Is Null)
			Order By 
				Case When @iOrderByName = 1 Then 
					L.Name
				Else 
					Convert(varchar, L.Location_Id)
				End, 
				PL.Parent_Location_Id
		End
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetLocationList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetLocationList">
 <Procedure>
	Return the list of locations in the system.
	When @NormalList is passed as false, the Location type and
	a count of its children is returned. If the parent location
	id is 0 then only return the top level locations.
 </Procedure>
</TAG>
*/	




GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeWasteTypePeriodMaterialTypeSummary.prc'
GO

IF OBJECT_ID('dbo.GetMaterialTypeWasteTypePeriodMaterialTypeSummary') IS NOT NULL
     DROP PROCEDURE dbo.GetMaterialTypeWasteTypePeriodMaterialTypeSummary  
GO 
  
CREATE PROCEDURE dbo.GetMaterialTypeWasteTypePeriodMaterialTypeSummary 
(
	@Material_Type_Id INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Sql VARCHAR(MAX)
	DECLARE @MaxDate DATETIME
	DECLARE @MinDate VARCHAR(31)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetMtlTypWasteTypPrdMtlTypSry',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- each material type + waste type is independant of each other
		-- the startdate/startshift through enddate/endshift periods are inclusive

		SET @MaxDate = '31-DEC-3000'
		SET @MinDate = '01-JAN-1900'

		CREATE TABLE dbo.#DatePeriod
		(
			Start_Date DATETIME NULL,
			End_Date DATETIME NULL
		)
	
		CREATE TABLE dbo.#DatePeriodWaste
		(
			Start_Date DATETIME NULL,
			End_Date DATETIME NULL,
			Waste_Type_Id VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			Is_Waste BIT NULL
		)

		-- STEP 1 - calculate all date-range periods

		INSERT INTO dbo.#DatePeriod
		(
			Start_Date, End_Date
		)
		SELECT
			(
				SELECT TOP 1 DateAdd(Day, +1, End_Date)
				FROM dbo.MaterialTypeWasteTypePeriod
				WHERE Material_Type_Id = mtwtp.Material_Type_Id
					AND ((End_Date < mtwtp.End_Date) OR (mtwtp.End_Date IS NULL))
				ORDER BY End_Date DESC
			) AS Start_Date, End_Date
		FROM dbo.MaterialTypeWasteTypePeriod AS mtwtp
		WHERE Material_Type_Id = @Material_Type_Id
		ORDER BY Start_Date ASC, End_Date ASC

		-- STEP 2 - merge in waste types

		INSERT INTO dbo.#DatePeriodWaste
		(
			Start_Date, End_Date, Waste_Type_Id, Is_Waste
		)
		SELECT dp.Start_Date, dp.End_Date, mtwtp.Waste_Type_Id, mtwtp.Is_Waste
		FROM dbo.#DatePeriod AS dp
			CROSS JOIN dbo.MaterialTypeWasteTypePeriod AS mtwtp
		WHERE COALESCE(mtwtp.End_Date, @MaxDate) = 
				(
					SELECT TOP 1 COALESCE(mtwtp2.End_Date, @MaxDate)
					FROM dbo.MaterialTypeWasteTypePeriod AS mtwtp2
					WHERE mtwtp2.Waste_Type_Id = mtwtp.Waste_Type_Id
						AND mtwtp2.Material_Type_Id = mtwtp.Material_Type_Id
						AND ((dp.Start_Date IS NULL) OR (mtwtp2.End_Date >= dp.Start_Date) OR (mtwtp2.End_Date IS NULL))
					ORDER BY
						-- the NULL comes after the non-null dates (rather than before, as-is by default)
						CASE
							WHEN mtwtp2.End_Date IS NULL THEN 2
							ELSE 1
						END ASC,
						mtwtp2.End_Date	ASC
				)
		ORDER BY Start_Date ASC, End_Date ASC

		-- STEP 3 - pivot & return the results

		SET @Sql =
			'(ISNULL(#DatePeriodWaste.Start_Date, ''' + @MinDate + ''') = ISNULL(#DatePeriod.Start_Date, ''' + @MinDate + '''))' +
			' AND (ISNULL(#DatePeriodWaste.End_Date, ''' + @MinDate + ''') = ISNULL(#DatePeriod.End_Date, ''' + @MinDate + '''))'

		EXEC dbo.PivotTable
			@iTargetTable = '#DatePeriod',
			@iPivotTable = '#DatePeriodWaste',
			@iJoinColumns = @Sql,
			@iPivotColumn = 'Waste_Type_Id',
			@iPivotValue = 'Is_Waste',
			@iPivotType = 'BIT',
			@iPivotOrderDirection = 'ASC'

		SELECT *
		FROM dbo.#DatePeriod
		ORDER BY Start_Date ASC, End_Date ASC

		-- Clean up

		DROP TABLE dbo.#DatePeriod
		DROP TABLE dbo.#DatePeriodWaste

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetMaterialTypeWasteTypePeriodMaterialTypeSummary TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeWasteTypePeriodMaterialTypeSummary">
 <Procedure>
	Returns a pivoted, summarised list of waste types for a given material type.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeList.prc'
GO

IF OBJECT_ID('dbo.GetMaterialTypeList') IS NOT NULL 
     DROP PROCEDURE dbo.GetMaterialTypeList
GO 
  
CREATE PROCEDURE dbo.GetMaterialTypeList
( 
    @iIs_Digblock_Group BIT = NULL,
	@iIs_Stockpile_Group BIT = NULL,
	@iLocation_Id INT = NULL,
	@iMaterial_Category_Id VARCHAR(31) = NULL,
	@iParent_Material_Type_Id INT = NULL
) 
AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
	CREATE TABLE dbo.#MaterialType
	(
		Material_Type_Group_Id INT,
		Material_Type_Group_Name VARCHAR(63) COLLATE Database_Default,
		Material_Type_Id INT
	)

	CREATE TABLE dbo.#WasteType
	(
		Material_Type_Id INT,
		Waste_Type_Id VARCHAR(63) COLLATE Database_Default,
		Is_Waste BIT
	)

	INSERT INTO dbo.#MaterialType
	(
		Material_Type_Group_Id, Material_Type_Group_Name, Material_Type_Id
	)
	SELECT mtg.Material_Type_Group_Id, mtg.Name, mt.Material_Type_Id
	FROM dbo.MaterialType AS mt
		INNER JOIN dbo.MaterialTypeGroup AS mtg
			ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		LEFT OUTER JOIN dbo.MaterialTypeLocation AS l 
			ON mt.Material_Type_Id = l.Material_Type_Id
	WHERE mtg.Is_Stockpile_Group = IsNull(@iIs_Stockpile_Group, Is_Stockpile_Group)
		AND mtg.Is_Digblock_Group = IsNull(@iIs_Digblock_Group, Is_Digblock_Group)
		AND 
		(
			@iLocation_Id IS NULL
				OR l.Location_Id in 
				(
					SELECT Location_Id 
					FROM dbo.GetLocationSubtree(@iLocation_Id)
				)
			OR l.Location_Id IS NULL
			OR @iLocation_Id < 1
		)
	GROUP BY mtg.Material_Type_Group_Id, mtg.Name, mt.Material_Type_Id
				
	INSERT INTO dbo.#WasteType	
	(
		Material_Type_Id, Waste_Type_Id, Is_Waste
	)
	SELECT mt.Material_Type_Id, 'Is_Waste_' + wt.Waste_Type_Id, mtwtp.Is_Waste
	FROM dbo.WasteType AS wt	
		CROSS JOIN dbo.MaterialType AS mt
		LEFT OUTER JOIN dbo.MaterialTypeWasteTypePeriod AS mtwtp
			ON (mt.Material_Type_Id = mtwtp.Material_Type_Id
				AND wt.Waste_Type_Id = mtwtp.Waste_Type_Id
				AND mtwtp.End_Date IS NULL)

	EXEC dbo.PivotTable
		@iTargetTable = '#MaterialType',
		@iPivotTable = '#WasteType',
		@iJoinColumns = 'dbo.#MaterialType.Material_Type_Id = dbo.#WasteType.Material_Type_Id',
		@iPivotColumn = 'Waste_Type_Id',
		@iPivotValue = 'Is_Waste',
		@iPivotType = 'BIT'

	SELECT mt.Material_Type_Id, mt2.Description, mt2.Order_No, mt2.Abbreviation, mt2.Native_Alternative,
		mt2.Parent_Material_Type_Id, mt2.Is_Waste,
		mt2.Density_Conversion_Factor, mt.Material_Type_Group_Id, mt.Material_Type_Group_Name,
		mt.Material_Type_Id, 
		mc.MaterialCategoryId As Material_Category_Id, 
		mc.ParentMaterialCategoryId As Parent_Material_Category_Id,
		Coalesce(c.Children,0) As Children, dbo.GetMaterialTypeLocationDescriptionCSV(mt.Material_Type_Id) As Location_Description_CSV
	FROM dbo.#MaterialType AS mt
		INNER JOIN dbo.MaterialType AS mt2
			ON (mt.Material_Type_Id = mt2.Material_Type_Id)
		LEFT JOIN dbo.MaterialCategory AS mc
			ON (mc.MaterialCategoryId = mt2.Material_Category_Id)
		LEFT JOIN
			(
			SELECT Parent_Material_Type_Id, Count(*) AS Children
			FROM dbo.MaterialType
			GROUP BY Parent_Material_Type_Id
			) AS c
			ON c.Parent_Material_Type_Id = mt2.Material_Type_Id
	WHERE (mt2.Parent_Material_Type_Id = @iParent_Material_Type_Id OR @iParent_Material_Type_Id IS NULL)
		AND (mt2.Material_Category_Id = @iMaterial_Category_Id OR @iMaterial_Category_Id IS NULL)
	ORDER BY mt2.Abbreviation
	
	DROP TABLE dbo.#MaterialType
	DROP TABLE dbo.#WasteType

    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetMaterialTypeList TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeList">
 <Procedure>
	Returns a list of material types.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeGroupList.prc'
GO

If Object_Id('dbo.GetMaterialTypeGroupList') Is Not Null 
     Drop Procedure dbo.GetMaterialTypeGroupList 
Go 

Create Procedure dbo.GetMaterialTypeGroupList

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Select MTG.Material_Type_Group_Id, MTG.Name, MTG.Description,
		MTG.Order_No, MTG.Is_Digblock_Group, MTG.Is_Stockpile_Group,
		dbo.GetMaterialTypeGroupMaterialTypes (MTG.Material_Type_Group_Id) As Material_Types
	From MaterialTypeGroup MTG
	Order By MTG.Order_No, MTG.Material_Type_Group_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetMaterialTypeGroupList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeGroupList">
 <Procedure>
	Returns a list of Material type groups.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeGroup.prc'
GO

If Object_Id('dbo.GetMaterialTypeGroup') Is Not Null 
     Drop Procedure dbo.GetMaterialTypeGroup 
Go 

Create Procedure dbo.GetMaterialTypeGroup
(
	@iMaterial_Type_Group_Id Int
)

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Select MTG.Material_Type_Group_Id, MTG.Name, MTG.Description,
		MTG.Order_No, MTG.Is_Digblock_Group, MTG.Is_Stockpile_Group,
		dbo.GetMaterialTypeGroupMaterialTypes (MTG.Material_Type_Group_Id) As Material_Types
	From MaterialTypeGroup MTG
	Where MTG.Material_Type_Group_Id = @iMaterial_Type_Group_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder
End
Go
GRANT EXECUTE ON dbo.GetMaterialTypeGroup TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeGroup">
 <Procedure>
	Returns material type group details for a given material type group.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialType.prc'
GO

IF OBJECT_ID('dbo.GetMaterialType') IS NOT NULL
     DROP PROCEDURE dbo.GetMaterialType  
GO 
  
CREATE PROCEDURE dbo.GetMaterialType 
(
	@iMaterialTypeId INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetMaterialType',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- return the base material + group information
		SELECT mt.Material_Type_Id, mt.Description, mt.Order_No, mt.Abbreviation, mt.Native_Alternative, mt.Is_Waste,
			mt.Density_Conversion_Factor, mt.Material_Type_Group_Id, mt.Parent_Material_Type_Id,
			mtg.Material_Type_Group_Id, mtg.Name, mt.Material_Category_Id
		FROM dbo.MaterialType AS mt
			INNER JOIN dbo.MaterialTypeGroup AS mtg
				ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		WHERE mt.Material_Type_Id = @iMaterialTypeId

		-- return the notes
		SELECT mtf.Material_Type_Field_Id, mtn.Notes
		FROM dbo.MaterialTypeField AS mtf
			LEFT OUTER JOIN dbo.MaterialTypeNotes AS mtn
				ON (mtf.Material_Type_Field_Id = mtn.Material_Type_Field_Id
					AND mtn.Material_Type_Id = @iMaterialTypeId)
		WHERE mtf.Has_Notes = 1
		ORDER BY mtf.Order_No ASC

		-- return the values
		SELECT mtf.Material_Type_Field_Id, mtv.Field_Value
		FROM dbo.MaterialTypeField AS mtf
			LEFT OUTER JOIN dbo.MaterialTypeValue AS mtv
				ON (mtf.Material_Type_Field_Id = mtv.Material_Type_Field_Id
					AND mtv.Material_Type_Id = @iMaterialTypeId)
		WHERE mtf.Has_Value = 1
		ORDER BY mtf.Order_No ASC
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetMaterialType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetMaterialType">
 <Procedure>
	Returns material type information and all notes/values.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeWasteTypePeriodList.prc'
GO

If Object_Id('dbo.GetMaterialTypeWasteTypePeriodList') Is Not Null 
     Drop Procedure dbo.GetMaterialTypeWasteTypePeriodList 
Go 

Create Procedure dbo.GetMaterialTypeWasteTypePeriodList
(
	@iMaterial_Type_Id Int = Null,
	@iWaste_Type_Id Varchar(31) = Null
)

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- Get the list of material type waste type periods
	Select Material_Type_Id, Waste_Type_Id, Is_Waste,
		(Select Max(DateAdd(Day, 1, MTWTP2.End_Date))
		From MaterialTypeWasteTypePeriod MTWTP2
		Where MTWTP.Material_Type_Id = MTWTP2.Material_Type_Id
			And MTWTP.Waste_Type_Id = MTWTP2.Waste_Type_Id
			And (MTWTP2.End_Date < MTWTP.End_Date
			Or MTWTP.End_Date Is Null)) As Start_Date,
		End_Date
	From MaterialTypeWasteTypePeriod MTWTP
	Where ((Material_Type_Id = @iMaterial_Type_Id) Or (@iMaterial_Type_Id Is Null))
		And ((Waste_Type_Id = @iWaste_Type_Id) Or (@iWaste_Type_Id Is Null))
		Order By Material_Type_Id, Waste_Type_Id,
			(Select Max(DateAdd(Day, 1, MTWTP2.End_Date))
			From MaterialTypeWasteTypePeriod MTWTP2
			Where MTWTP.Material_Type_Id = MTWTP2.Material_Type_Id
				And MTWTP.Waste_Type_Id = MTWTP2.Waste_Type_Id
				And (MTWTP2.End_Date < MTWTP.End_Date
				Or MTWTP.End_Date Is Null))

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetMaterialTypeWasteTypePeriodList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeWasteTypePeriodList">
 <Procedure>
	Returns a list of material type waste type periods.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMillList.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetMillList') IS NOT NULL
	DROP PROCEDURE dbo.GetMillList  
GO 
  
CREATE PROCEDURE dbo.GetMillList 
(
	@iLocationId INT = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	-- variable declaration here

	SET NOCOUNT ON 

	BEGIN TRY
		SELECT M.Mill_Id, M.Description
		FROM dbo.Mill AS M
			LEFT JOIN dbo.MillLocation AS L
				ON L.Mill_Id = M.Mill_Id				
			LEFT JOIN GetLocationSubtree(@iLocationId) AS LL
				ON LL.Location_Id = L.Location_Id	
		WHERE (LL.Location_Id IS NOT NULL OR @iLocationId IS NULL)			
		GROUP BY M.Mill_Id, M.Description
		ORDER BY M.Mill_Id DESC
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetMillList TO CoreUtilityManager
GO
GRANT EXECUTE ON dbo.GetMillList TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetMillList">
 <Procedure>
	Return the list of Mills in the system.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetObjectNotesList.prc'
GO

IF Object_Id('dbo.GetObjectNotesList') IS NOT NULL 
     DROP PROCEDURE dbo.GetObjectNotesList 
GO 

CREATE PROCEDURE dbo.GetObjectNotesList
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON

	--Return the list of object notes in the system 
	SELECT [Object_Id], Description, Notes
	FROM ObjectNotes
	ORDER BY [Object_Id]
END
GO

GRANT EXECUTE ON dbo.GetObjectNotesList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetObjectNotesList">
 <Procedure>
	Return the list of object notes in the system.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetObjectNotes.prc'
GO

IF Object_Id('dbo.GetObjectNotes') IS NOT NULL 
     DROP PROCEDURE dbo.GetObjectNotes 
GO 

CREATE PROCEDURE dbo.GetObjectNotes
(
	@iObject_Id VARCHAR(255)
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON

	SELECT [Object_Id], Description, Notes
	FROM ObjectNotes
	WHERE [Object_Id] = @iObject_Id
END
GO

GRANT EXECUTE ON dbo.GetObjectNotes TO CoreUtilityManager
GRANT EXECUTE ON dbo.GetObjectNotes TO CoreReporting

/*
<TAG Name="Data Dictionary" ProcedureName="GetObjectNotes">
 <Procedure>
	Return the object notes of @iObject_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetReport.prc'
GO

If Object_Id('dbo.GetReport') Is Not Null 
     Drop Procedure dbo.GetReport 
Go

Create Procedure dbo.GetReport
(
	@iReport_Id Int
)

With Encryption
As

Begin
	Set Nocount On
	
	Select Report_Id, [Name], Description, Report_Path,
		IsNull(Report_Group_Id, '') As Report_Group_Id
	From Report
	Where Report_Id = @iReport_Id
End
GO
GRANT EXECUTE ON dbo.GetReport TO CoreReportManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetReport">
 <Procedure>
	Returns the details of @iReport_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetReportGroup.prc'
GO

If Object_Id('dbo.GetReportGroup') Is Not Null 
     Drop Procedure dbo.GetReportGroup 
Go

Create Procedure dbo.GetReportGroup
(
	@iReport_Group_Id Int
)

With Encryption
As

Begin
	Set Nocount On

	Select Report_Group_Id, [Name], Description
	From ReportGroup
	Where Report_Group_Id = @iReport_Group_Id
End
Go
GRANT EXECUTE ON dbo.GetReportGroup TO CoreReportManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetReportGroup">
 <Procedure>
	Returns the details of the report group @iReport_Group_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetReportGroupList.prc'
GO

If Object_Id('dbo.GetReportGroupList') Is Not Null 
     Drop Procedure dbo.GetReportGroupList 
Go

Create Procedure dbo.GetReportGroupList
With Encryption
As
Begin
	Set Nocount On
	
	Select Report_Group_Id, [Name], Description
	From ReportGroup
	Order By Order_No, [Name]
End
GO
GRANT EXECUTE ON dbo.GetReportGroupList TO CoreReportManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetReportGroupList">
 <Procedure>
	Returns a list of all the report groups in the ReportGroup table.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetReportList.prc'
GO

If Object_Id('dbo.GetReportList') Is Not Null 
     Drop Procedure dbo.GetReportList 
Go

Create Procedure dbo.GetReportList
With Encryption
As
Begin
	Set Nocount On
	
	Select R.*,
		IsNull(RG.[Name], 'Unassigned') As Group_Name
	From Report As R
		Left Outer Join ReportGroup As RG
			On R.Report_Group_Id = RG.Report_Group_Id
	Order By RG.Order_No, IsNull(RG.[Name], 'zzz'), R.Order_No, R.[Name]
End
GO
GRANT EXECUTE ON dbo.GetReportList TO CoreReportManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetReportList">
 <Procedure>
	Returns a list of all the reports in the Report table.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetSettingList.prc'
GO

If Object_Id('dbo.GetSettingList') Is Not Null 
     Drop Procedure dbo.GetSettingList 
Go

Create Procedure dbo.GetSettingList

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Select Setting_Id, Description, Data_Type, [Value], Acceptable_Values
	From Setting
	Where Is_User_Editable = 1
	Order By Setting_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetSettingList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetSettingList">
 <Procedure>
	Returns a list of system settings.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetShiftTypeList.prc'
GO

If Object_Id('dbo.GetShiftTypeList') Is Not Null 
     Drop Procedure dbo.GetShiftTypeList 
Go

Create Procedure dbo.GetShiftTypeList

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Select Shift, Name, Order_No, Description, Start_Time, End_Time, Day_Offset
	From ShiftType
	Order By Order_No

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetShiftTypeList TO CoreDigblockManager
Go
GRANT EXECUTE ON dbo.GetShiftTypeList TO CoreUtilityManager
Go
/*
<TAG Name="Data Dictionary" ProcedureName="GetShiftTypeList">
 <Procedure>
	Returns a list if shift types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileAdjustmentList.prc'
GO

IF OBJECT_ID('dbo.GetStockpileAdjustmentList') IS NOT NULL
	DROP PROCEDURE dbo.GetStockpileAdjustmentList
GO

CREATE PROCEDURE dbo.GetStockpileAdjustmentList
(
	@iFilter_Start_Date DATETIME = NULL,
	@iFilter_End_Date DATETIME = NULL,
	@iFilter_Is_Manual BIT = NULL,
	@iFilter_Stockpile_Id INT = NULL,
	@iStockpile_Adjustment_Id INT = NULL,
	@iLocation_Id INT = NULL,
	@iRecordLimit INT = NULL,
    @iGrade_Visibility Bit = 1
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON

	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION

	DECLARE @Filter_Is_Not_Manual BIT

	CREATE TABLE dbo.#StockpileAdjustment
	(
		Stockpile_Adjustment_Id INT,
		Stockpile_Id INT,
		Stockpile_Name VARCHAR(31) COLLATE Database_Default,
		Stockpile_Description VARCHAR(255) COLLATE Database_Default,
		Build_Id INT,
		Component_Id INT,
		Adjustment_Date DATETIME,
		Adjustment_Shift CHAR(1) COLLATE Database_Default,
		Adjustment_Shift_Name VARCHAR(31) COLLATE Database_Default,
		Source_Stockpile_Id INT,
		Source_Stockpile_Name VARCHAR(31) COLLATE Database_Default,
		Source_Build_Id INT,
		Description VARCHAR(255) COLLATE Database_Default,
		Adjustment_Type_Description VARCHAR(255) COLLATE Database_Default,
		Imported_DateTime DATETIME,
		Is_Add_Or_Remove BIT,
		Is_Stockpile_Transfer BIT,
		Is_Tonnes_Adjustment BIT,
		Is_Grades_Adjustment BIT,
		Is_Manual BIT,
		Tonnes FLOAT,
		Is_Locked BIT,
		CONSTRAINT PK_STOCKPILE_ADJUSTMENT 
			PRIMARY KEY (Stockpile_Adjustment_Id)
	)

	CREATE TABLE dbo.#StockpileAdjustmentGrade
	(
		Stockpile_Adjustment_Id INT,
		Grade_Name VARCHAR(31) COLLATE Database_Default,
		Grade_Value REAL,

		CONSTRAINT PK__STOCKPILE_ADJUSTMENT_GRADE 
			PRIMARY KEY (Stockpile_Adjustment_Id, Grade_Name)
	)

	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT @iRecordLimit
	END
	
	INSERT INTO dbo.#StockpileAdjustment
	(
		Stockpile_Adjustment_Id, Stockpile_Id, Stockpile_Name, Stockpile_Description, Build_Id, Component_Id,
		Adjustment_Date, Adjustment_Shift, Adjustment_Shift_Name,
		Source_Stockpile_Id, Source_Stockpile_Name, Source_Build_Id, Description,
		Adjustment_Type_Description, Imported_DateTime,Is_Add_Or_Remove, Is_Stockpile_Transfer, 
		Is_Tonnes_Adjustment, Is_Grades_Adjustment, Is_Manual, Tonnes, Is_Locked
	)
	SELECT sa.Stockpile_Adjustment_Id, s.Stockpile_Id, s.Stockpile_Name, s.Description, sa.Build_Id, sa.Component_Id, 
		sa.Adjustment_Date, sa.Adjustment_Shift, st.Name, 
		sa.Source_Stockpile_Id, ss.Stockpile_Name, sa.Source_Build_Id, sa.Description,
		dbo.GetStockpileAdjustmentType(Is_Add_Or_Remove, Is_Grades_Adjustment, Is_Tonnes_Adjustment, Is_Stockpile_Transfer),
		Imported_Datetime, Is_Add_Or_Remove, Is_Stockpile_Transfer, Is_Tonnes_Adjustment, 
		Is_Grades_Adjustment, Is_Manual, Tonnes,
		(
			SELECT CASE WHEN Count(*) = 0 THEN 0 Else 1 END
			FROM dbo.MonthlyApproval
			WHERE Monthly_Approval_Month >= sa.Adjustment_Date
				AND Is_Approved = 1
		) AS Is_Locked
	FROM dbo.StockpileAdjustment AS sa
		INNER JOIN dbo.Stockpile AS s
			ON (sa.Stockpile_Id = s.Stockpile_Id)
		INNER JOIN dbo.ShiftType AS st
			ON (st.Shift = sa.Adjustment_Shift)
		LEFT OUTER JOIN dbo.Stockpile AS ss 
			ON (sa.Source_Stockpile_Id = ss.Stockpile_Id)
		LEFT OUTER JOIN 
		(
			SELECT sp.Stockpile_Id, IsNull(sl.Location_Id, 0) AS Location_Id
			FROM dbo.Stockpile AS sp
				LEFT OUTER JOIN dbo.StockpileLocation AS sl
					ON (sp.Stockpile_Id = sl.Stockpile_Id)		
		) AS l		
			ON s.Stockpile_Id = l.Stockpile_Id			
	WHERE sa.Adjustment_Date >= IsNull(@iFilter_Start_Date, sa.Adjustment_Date)
		AND sa.Adjustment_Date <= IsNull(@iFilter_End_Date, sa.Adjustment_Date)
		AND sa.Is_Manual = IsNull(@iFilter_Is_Manual, sa.Is_Manual)
		AND sa.Stockpile_Id = IsNull(@iFilter_Stockpile_Id, sa.Stockpile_Id)
		AND sa.Stockpile_Adjustment_Id = IsNull(@iStockpile_Adjustment_Id, Stockpile_Adjustment_Id)
		AND 
			(				
				@iLocation_Id IS NULL
					OR l.Location_Id IN 
					(	
						SELECT Location_Id
						FROM dbo.GetLocationSubtree(@iLocation_Id)
					)
			)
	ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
	
	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT 0
	END
	
	INSERT INTO dbo.#StockpileAdjustmentGrade
	(
		Stockpile_Adjustment_Id, Grade_Name, Grade_Value
	)
	SELECT -1, G.Grade_Name, NULL
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	UNION ALL
	SELECT SA.Stockpile_Adjustment_Id, G.Grade_Name, SAG.Grade_Value
	FROM dbo.StockpileAdjustmentGrade AS SAG
		INNER JOIN #StockpileAdjustment AS SA
			ON (SA.Stockpile_Adjustment_Id = SAG.Stockpile_Adjustment_Id)
		INNER JOIN dbo.Grade AS G
			ON (SAG.Grade_Id = G.Grade_Id)
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	EXEC dbo.PivotTable
		@iTargetTable = '#StockpileAdjustment',
		@iPivotTable = '#StockpileAdjustmentGrade',
		@iJoinColumns = 'dbo.#StockpileAdjustment.Stockpile_Adjustment_Id = dbo.#StockpileAdjustmentGrade.Stockpile_Adjustment_Id',
		@iPivotColumn = 'Grade_Name',
		@iPivotValue = 'Grade_Value',
		@iPivotType = 'REAL'

	SELECT A.*, st.Order_No AS Adjustment_Shift_Order_No
	FROM dbo.#StockpileAdjustment AS A
		INNER JOIN ShiftType AS ST
			ON (A.Adjustment_Shift = st.Shift)
	ORDER BY A.Adjustment_Date DESC, Adjustment_Shift_Order_No DESC	

	DROP TABLE dbo.#StockpileAdjustmentGrade
	DROP TABLE dbo.#StockpileAdjustment

	COMMIT TRANSACTION
END
GO
GRANT EXECUTE ON dbo.GetStockpileAdjustmentList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileAdjustmentList">
 <Procedure>
	Returns the stockpile adjustment list.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityList.prc'
GO

IF OBJECT_ID('dbo.GetStockpileActivityList') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityList 
GO
  
CREATE PROCEDURE dbo.GetStockpileActivityList 
( 
	@iStockpile_Id INT = NULL, --Nullable Only for Dynamic UI Purpose
	@iStart_Date DATETIME = NULL,  --Nullable Only for Dynamic UI Purpose
	@iEnd_Date DATETIME = NULL,  --Nullable Only for Dynamic UI Purpose
	@iActivityType TINYINT = NULL,
	@iGroupByActivityType BIT = 0,
	@iPivotGrades BIT = 1, 
	@iGrade_Visibility Bit = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
	SET NOCOUNT ON 

	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
	BEGIN TRANSACTION 

	DECLARE @OpeningBalance TINYINT
	DECLARE @AdditionType TINYINT
	DECLARE @RemovalType TINYINT
	DECLARE @AdjustmentType TINYINT
	DECLARE @ClosingBalance TINYINT
	DECLARE @ModelType TINYINT
	DECLARE @StateType TINYINT
	DECLARE @TonnesReturnType BIT
	DECLARE @GradesReturnType BIT
	DECLARE @OpenBalDate DATETIME
	DECLARE @OpenBalShift CHAR(1)
	DECLARE @CloseBalDate DATETIME
	DECLARE @CloseBalShift CHAR(1)

	-- Constants
	SELECT @OpeningBalance = 0,
		@AdditionType = 1,
		@RemovalType = 2,
		@AdjustmentType = 3,
		@ClosingBalance = 4,
		@ModelType = 5,
		@StateType = 6,
		@TonnesReturnType = 0,
		@GradesReturnType = 1

	CREATE TABLE dbo.#Activity
	(
		Activity_Type TINYINT,
		Transaction_Id BIGINT,
		Heading VARCHAR(255) COLLATE Database_Default,
		Sub_Heading VARCHAR(255) COLLATE Database_Default,
		Transaction_Date DATETIME,
		Transaction_Shift CHAR(1) COLLATE Database_Default,
		Tonnes FLOAT,
		Order_No INT,
		Source_Destination VARCHAR(255) COLLATE Database_Default,
		--	PRIMARY KEY (Activity_Type, Transaction_Id)
	)
	
	CREATE TABLE dbo.#ActivityGrade
	(
		Activity_Type TINYINT,
		Transaction_Id BIGINT,
		Grade_Id SMALLINT,
		Grade_Name VARCHAR(31) COLLATE Database_Default,
		Grade_Value REAL,
		Source_Destination VARCHAR(255) COLLATE Database_Default
		-- can't enforce constraint due pivot table defect
		--PRIMARY KEY (Activity_Type, Transaction_Id, Grade_Id)
	)

	-- Opening Balance
	IF IsNull(@iActivityType, @OpeningBalance) = @OpeningBalance
	BEGIN
		-- get the first date/shift for the requested date range
		SELECT TOP 1 @OpenBalDate = B.Data_Process_Stockpile_Balance_Date,
			@OpenBalShift = B.Data_Process_Stockpile_Balance_Shift
		FROM dbo.DataProcessStockpileBalance AS b
			INNER JOIN dbo.ShiftType AS st
				ON (b.Data_Process_Stockpile_Balance_Shift = st.Shift)
		WHERE b.Stockpile_Id = @iStockpile_Id
			AND b.Data_Process_Stockpile_Balance_Date BETWEEN @iStart_Date AND @iEnd_Date
		ORDER BY b.Data_Process_Stockpile_Balance_Date ASC, ST.Order_No ASC

		INSERT INTO dbo.#Activity
		(
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_Shift, Tonnes
		)
		EXEC dbo.GetStockpileActivityOpeningBalance
			@iStockpileId = @iStockpile_Id,
			@iBalanceDate = @OpenBalDate,
			@iBalanceShift = @OpenBalShift,
			@iReturnType = @TonnesReturnType,
			@iGradeVisibility = @iGrade_Visibility,
			@iActivityType = @OpeningBalance

		INSERT INTO dbo.#ActivityGrade
		( 
			Activity_Type, Transaction_Id, Grade_Id, Grade_Name, Grade_Value
		)
		EXEC dbo.GetStockpileActivityOpeningBalance
			@iStockpileId = @iStockpile_Id,
			@iBalanceDate = @OpenBalDate,
			@iBalanceShift = @OpenBalShift,
			@iReturnType = @GradesReturnType,
			@iGradeVisibility = @iGrade_Visibility,
			@iActivityType = @OpeningBalance

		--Set the other UI Element data on the records we just added
		UPDATE dbo.#Activity
		SET Heading = 'Opening Balance',
			Sub_Heading = 'Opening Balance',
			Order_No = 
				CASE 
					WHEN @iGroupByActivityType = 1 THEN 
						@OpeningBalance 
					ELSE 
						-1 
				END
		WHERE Heading IS NULL
	END

	--Closing Balance
	IF IsNull(@iActivityType, @ClosingBalance) = @ClosingBalance
	BEGIN
		SELECT TOP 1 @CloseBalDate = B.Data_Process_Stockpile_Balance_Date,
			@CloseBalShift = B.Data_Process_Stockpile_Balance_Shift
		FROM dbo.DataProcessStockpileBalance AS B
			INNER JOIN dbo.ShiftType AS ST 
				ON (B.Data_Process_Stockpile_Balance_Shift = ST.Shift)
		WHERE B.Stockpile_Id = @iStockpile_Id
			AND B.Data_Process_Stockpile_Balance_Date BETWEEN @iStart_Date AND @iEnd_Date
		ORDER BY B.Data_Process_Stockpile_Balance_Date DESC, ST.Order_No DESC

		INSERT INTO dbo.#Activity
		( 
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_Shift, Tonnes
		)
		EXEC dbo.GetStockpileActivityClosingBalance
			@iStockpileId = @iStockpile_Id,
			@iBalanceDate = @CloseBalDate,
			@iBalanceShift = @CloseBalShift,
			@iReturnType = @TonnesReturnType,
			@iGradeVisibility = @iGrade_Visibility,
			@iActivityType = @ClosingBalance

		INSERT INTO dbo.#ActivityGrade
		( 
			Activity_Type, Transaction_Id, Grade_Id, Grade_Name, Grade_Value
		)
		EXEC dbo.GetStockpileActivityClosingBalance
			@iStockpileId = @iStockpile_Id,
			@iBalanceDate = @CloseBalDate,
			@iBalanceShift = @CloseBalShift,
			@iReturnType = @GradesReturnType,
			@iGradeVisibility = @iGrade_Visibility,
			@iActivityType = @ClosingBalance

		--Set the other UI Element data on the records we just added
		UPDATE dbo.#Activity
		SET Heading = 'Closing Balance',
			Sub_Heading = 'Closing Balance',
			Order_No = 
				CASE 
					WHEN @iGroupByActivityType = 1 THEN 
						@ClosingBalance 
					ELSE 
						2 
				END
		WHERE Heading IS NULL
	END

	--Additions
	IF IsNull(@iActivityType, @AdditionType) = @AdditionType
	BEGIN
		INSERT INTO dbo.#Activity
		( 
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_Shift, Tonnes, Source_Destination
		)
		EXEC dbo.GetStockpileActivityAdditions
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @TonnesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @AdditionType

		INSERT INTO dbo.#ActivityGrade
		( 
			Activity_Type, Transaction_Id, Grade_Id, Grade_Name, Grade_Value, Source_Destination
		)
		EXEC dbo.GetStockpileActivityAdditions
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @GradesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @AdditionType

		--Set the other UI Element data on the records we just added
		UPDATE dbo.#Activity
		SET Heading = 'Additions',
			Sub_Heading = 'Tonnes Added',
			Order_No = 
				CASE 
					WHEN @iGroupByActivityType = 1 THEN 
						@AdditionType 
					ELSE 0 
				END
		WHERE Heading IS NULL
	END

	-- Removals
	IF IsNull(@iActivityType, @RemovalType) = @RemovalType
	BEGIN
		INSERT INTO dbo.#Activity
		( 
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_Shift, Tonnes, Source_Destination
		)
		EXEC dbo.GetStockpileActivityRemovals
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @TonnesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @RemovalType

		INSERT INTO dbo.#ActivityGrade
		( 
			Activity_Type, Transaction_Id, Grade_Id, Grade_Name, Grade_Value, Source_Destination
		)
		EXEC dbo.GetStockpileActivityRemovals
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @GradesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @RemovalType

		-- Set the other UI Element data on the records we just added
		UPDATE dbo.#Activity
		SET Heading = 'Removals',
			Sub_Heading = 'Tonnes Removed',
			Order_No = 
				CASE 
					WHEN @iGroupByActivityType = 1 THEN 
						@RemovalType 
					ELSE 
						0 
				END
		WHERE Heading IS NULL
	END

	-- Adjustments
	IF IsNull(@iActivityType, @AdjustmentType) = @AdjustmentType
	BEGIN
		INSERT INTO dbo.#Activity
		( 
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_Shift, Tonnes
		)
		EXEC dbo.GetStockpileActivityAdjustments
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @TonnesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @AdjustmentType

		INSERT INTO dbo.#ActivityGrade
		( 
			Activity_Type, Transaction_Id, Grade_Id, Grade_Name, Grade_Value
		)
		EXEC dbo.GetStockpileActivityAdjustments
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date,
			@iReturn_Type = @GradesReturnType,
			@iGrade_Visibility = @iGrade_Visibility,
			@iActivity_Type = @AdjustmentType

		-- Set the other UI Element data on the records we just added
		UPDATE A
		SET Heading = 'Adjustments',
			Sub_Heading = dbo.GetStockpileAdjustmentType(SA.Is_Add_Or_Remove, SA.Is_Grades_Adjustment, SA.Is_Tonnes_Adjustment, SA.Is_Stockpile_Transfer),
			Order_No = 
				CASE 
					WHEN @iGroupByActivityType = 1 THEN 
						@AdjustmentType 
					ELSE 
						0 
				END
		FROM dbo.#Activity AS A
			INNER JOIN dbo.DataProcessTransaction AS DPT	
				ON A.Transaction_Id = DPT.Data_Process_Transaction_Id
			INNER JOIN dbo.StockpileAdjustment AS SA
				ON DPT.Stockpile_Adjustment_Id = SA.Stockpile_Adjustment_Id
		WHERE a.Heading IS NULL
	END

	-- Model Types - only if we're not grouping things up
	IF (IsNull(@iActivityType, @ModelType) = @ModelType) AND (@iGroupByActivityType = 0)
	BEGIN
		CREATE TABLE dbo.#Periods
		(
			Stockpile_Id INT,
			Stockpile_Type_Id VARCHAR(31) COLLATE Database_Default,
			Start_Date DATETIME,
			End_Date DATETIME
		)

		INSERT INTO dbo.#Periods
		(
			Stockpile_Id, Stockpile_Type_Id, Start_Date, End_Date
		)
		EXEC dbo.GetStockpileStockpileTypePeriodList
			@iStockpile_Id = @iStockpile_Id

		INSERT INTO dbo.#Activity
		( 
			Activity_Type, Transaction_Date, Transaction_Shift, Heading, Sub_Heading, Order_No
		)
		SELECT @ModelType, Start_Date, dbo.GetFirstShiftType(), 
			'Model Type Change', 'Changed to ' + Stockpile_Type_Id, 0
		FROM dbo.#Periods
		WHERE Start_Date BETWEEN @iStart_Date AND @iEnd_Date

		DROP TABLE dbo.#Periods
	END

	-- State Type  - only IF we're NOT grouping things up
	IF (IsNull(@iActivityType, @StateType) = @StateType) AND (@iGroupByActivityType = 0)
	BEGIN
		CREATE TABLE dbo.#States
		(
			Stockpile_Id INT,
			Build_Id INT,
			Start_Date DATETIME,
			Start_Shift CHAR(1) COLLATE Database_Default,
			Stockpile_State_Id VARCHAR(31) COLLATE Database_Default
		)		

		INSERT INTO dbo.#States
		(
			Stockpile_Id, Build_Id, Start_Date, Start_Shift, Stockpile_State_Id
		)
		EXEC dbo.GetStockpileActivityStateChanges
			@iStockpile_Id = @iStockpile_Id,
			@iStart_Date = @iStart_Date,
			@iEnd_Date = @iEnd_Date

		INSERT INTO dbo.#Activity
		(
			Activity_Type, Transaction_Id, Transaction_Date, Transaction_shift, Heading, Sub_Heading, Order_No
		)
		SELECT @StateType, 1, Start_Date, Start_Shift, 'Build State Change', 
			'Build '+ Convert(VARCHAR, Build_Id) + ' changed to ' + Stockpile_State_Id, 0
		FROM dbo.#States

		DROP TABLE dbo.#States
	END

	IF @iPivotGrades = 1
	BEGIN
		INSERT INTO dbo.#ActivityGrade
		(
			Grade_Id, Grade_Name
		)
		SELECT G.Grade_Id, G.Grade_Name
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility OR @iGrade_Visibility IS NULL)

		EXEC dbo.PivotTable
			@iTargetTable = '#Activity',
			@iPivotTable = '#ActivityGrade',
			@iJoinColumns = '#Activity.Activity_Type = #ActivityGrade.Activity_Type AND #Activity.Transaction_Id = #ActivityGrade.Transaction_Id',
			@iPivotColumn = 'Grade_Name',
			@iPivotValue = 'Grade_Value',
			@iPivotType = 'REAL'

		SELECT A.*, ST.Order_No AS Transaction_Shift_Order_No
		FROM dbo.#Activity AS A
			INNER JOIN dbo.ShiftType AS ST
				ON (ST.Shift = A.Transaction_Shift)
		ORDER BY A.Order_No, A.Transaction_Date, ST.Order_No, 
			A.Transaction_Id,  A.Heading, A.Sub_Heading
	END
	ELSE
	BEGIN
		SELECT A.*, ST.Order_No AS Transaction_Shift_Order_No
		FROM dbo.#Activity AS A
			INNER JOIN dbo.ShiftType AS ST
				ON (ST.Shift = A.Transaction_Shift)
		ORDER BY A.Order_No, A.Transaction_Date, ST.Order_No, 
			A.Transaction_Id,  A.Heading, A.Sub_Heading

		SELECT *
		FROM dbo.#ActivityGrade
	END

	DROP TABLE dbo.#Activity
	DROP TABLE dbo.#ActivityGrade

	COMMIT TRANSACTION 
END 
GO

GRANT EXECUTE ON dbo.GetStockpileActivityList TO CoreStockpileManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityList">
 <Procedure>
	Returns the list of transactions that have taken place against a given stockpile.
	If the Group By Activity Type option is set to false then Model Type changes and
	Build state changes are also included. The list can also be limited to specific
	activity types.
 </Procedure>
</TAG>
*/

/* testing
EXEC dbo.GetStockpileActivityList
	@iStockpile_Id = 25524,
	@iStart_Date = '01-APR-2008',
	@iEnd_Date = '03-APR-2008',
	@iActivityType = NULL,
	@iGroupByActivityType = 1,
	@iPivotGrades = 0,
	@iGrade_Visibility = 1
GO
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuildList.prc'
GO

If object_id('dbo.GetStockpileBuildList') is not Null 
     Drop Procedure dbo.GetStockpileBuildList 
Go 

Create Procedure dbo.GetStockpileBuildList
(
	@iStockpile_Id Int
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select Build_Id, Case When Stockpile_State_Id <> 'CLOSED' Then 1 Else 0 End As Is_Active
	From StockpileBuild
	Where Stockpile_Id = @iStockpile_Id
	Order By Build_Id Desc

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetStockpileBuildList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileBuildList">
 <Procedure>
	Return a list of Build_Ids for a given stockpile.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuild.prc'
GO

If Object_Id('dbo.GetStockpileBuild') Is Not Null
	Drop Procedure dbo.GetStockpileBuild
Go

Create Procedure dbo.GetStockpileBuild
(
	@iStockpile_Id Int,
	@iBuild_Id Int
)
With Encryption 
As

/*-----------------------------------------------------------------------------
--  Name: GetStockpileBuild
--
--  Purpose: 
--		Return the StockpileBuild records
--
------------------------------------------------------------------------------*/

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select S.Start_Date, S.Start_Shift, S.Creation_Datetime, S.Reclaim_Start_Date, S.Reclaim_Start_Shift,
		S.End_Date, S.End_Shift, S.Last_Recalc_Date, S.Last_Recalc_Shift, S.Stockpile_State_Id, S.Completion_Description
	From StockpileBuild S
	Where S.Stockpile_Id = @iStockpile_Id
		And S.Build_Id = @iBuild_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetStockpileBuild TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileBuild">
 <Procedure>
	Return the StockpileBuild records for a given stockpile and build.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuildComponentList.prc'
GO

IF OBJECT_ID('dbo.GetStockpileBuildComponentList') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileBuildComponentList  
GO 
  
CREATE PROCEDURE dbo.GetStockpileBuildComponentList 
( 
    @iStockpile_Id Int,
	@iBuild_Id Int,
	@iGrade_Visibility Bit = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @JoinColumns VARCHAR(1024)
		
	SELECT @TransactionName = 'GetStockpileBuildComponentList',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	CREATE TABLE #Components
	(
		Stockpile_Id Int Not Null,
		Build_Id Int Not Null,
		Component_Id Int Not Null,
		Creation_DateTime DateTime Null,
		Layer Varchar(31) Collate Database_Default Null,
		Name Varchar(31) Collate Database_Default Null,
		Start_Tonnes Float Not Null
	)

	CREATE TABLE #ComponentGrades
	(
		Stockpile_Id Int Not Null,
		Build_Id Int Not Null,
		Component_Id Int Not Null,
		Grade_Name Varchar(31) Collate Database_Default Not Null,
		Value Real Null
	)

    BEGIN TRY
		Insert Into #Components
		(
			Stockpile_Id, Build_Id, Component_ID, Creation_DateTime, 
			Layer, Name, Start_Tonnes
		)		
		Select C.Stockpile_Id, C.Build_Id, C.Component_Id, C.Creation_DateTime, 
			C.Layer, C.Name, C.Start_Tonnes
		From dbo.StockpileBuildComponent AS C
		Where C.Stockpile_Id = @iStockpile_Id
			And C.Build_Id = @iBuild_Id

		Insert Into #ComponentGrades
		(
			Stockpile_Id, Build_Id, Component_ID, Grade_Name, Value
		)
		Select -1, -1, -1, G.Grade_Name, Null
		From dbo.Grade As G
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	
		Insert Into #ComponentGrades
		(
			Stockpile_Id, Build_Id, Component_ID, Grade_Name, Value
		)
		Select SBCG.Stockpile_Id, SBCG.Build_Id, SBCG.Component_ID, G.Grade_Name, SBCG.Grade_Value
		From dbo.StockpileBuildComponentGrade AS SBCG
			Inner Join dbo.Grade AS G
				On (SBCG.Grade_Id = G.Grade_Id)
			Inner Join #Components As C
				On (SBCG.Stockpile_Id = C.Stockpile_Id
					And SBCG.Build_Id = C.Build_Id		
					And SBCG.Component_ID = C.Component_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

		Select @JoinColumns = '#Components.Stockpile_Id = #ComponentGrades.Stockpile_Id ' +
			'And #Components.Build_Id = #ComponentGrades.Build_Id ' +
			'And #Components.Component_Id = #ComponentGrades.Component_Id '

		Exec dbo.PivotTable
			@iTargetTable = '#Components',
			@iPivotTable = '#ComponentGrades',
			@iJoinColumns = @JoinColumns,
			@iPivotColumn = 'Grade_Name',
			@iPivotValue = 'Value',
			@iPivotType = 'REAL'

		Select *
		From #Components

		Drop Table #Components
		Drop Table #ComponentGrades

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.GetStockpileBuildComponentList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileBuildComponentList">
 <Procedure>
	Return list of Stockpile Build Components for a given stockpile and build.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileChangesOverPeriod.prc'
GO

IF object_id('dbo.GetStockpileChangesOverPeriod') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileChangesOverPeriod 
GO 
  
CREATE PROCEDURE dbo.GetStockpileChangesOverPeriod
( 
	@iStockpile_Id INT,
    @iStart_Date DATETIME,
	@iEnd_Date DATETIME 
) 
WITH ENCRYPTION
AS 
BEGIN 

    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
    
		DECLARE @FirstBuildId INT
  
		DECLARE @STOCKPILE_CHANGES TABLE
		(
			Stockpile_Id INT,
			Heading	VARCHAR(255) COLLATE DATABASE_DEFAULT,
			Sub_Heading	VARCHAR(255) COLLATE DATABASE_DEFAULT,
			Value FLOAT,
			Order_No INT
		)	

		--Work out viable date ranges
		DECLARE @OpenBalDate DATETIME,
			@OpenBalShift CHAR(1),	
			@OpenBalShiftOrder INT,
			@CloseBalDate DATETIME,
			@CloseBalShift CHAR(1),
			@CloseBalShiftOrder INT,
			@OpenBal FLOAT,
			@StockpileBuildAdditions FLOAT,
			@StartStockpileBuildDate DATETIME,
			@StartStockpileBuildShift CHAR(1),
			@OpenBalActualDate DATETIME,
			@OpenBalActualShift CHAR(1),
			@OpenBalActualShiftOrder INT

		--Work out closing balance date
		SELECT TOP 1 @CloseBalDate = DPSB.Data_Process_Stockpile_Balance_Date,
			@CloseBalShift = DPSB.Data_Process_Stockpile_Balance_Shift
		FROM dbo.DataProcessStockpileBalance AS DPSB
			INNER JOIN dbo.ShiftType AS ST
				ON (ST.Shift = DPSB.Data_Process_Stockpile_Balance_Shift)
		WHERE DPSB.Stockpile_Id = @iStockpile_Id
			AND DPSB.Data_Process_Stockpile_Balance_Date <= @iEnd_Date
		ORDER BY DPSB.Data_Process_Stockpile_Balance_Date DESC, ST.Order_No DESC
		
		--Work out Open Balance date
		SELECT @OpenBalDate = @iStart_Date, 
			@OpenBalShift = dbo.GetFirstShiftType()

		SET @OpenBalActualDate = @OpenBalDate
		SET @OpenBalActualShift = @OpenBalShift

		EXEC dbo.GetPreviousDateShift 
			@Date = @OpenBalDate,
			@Shift = @OpenBalShift,
			@Previous_Date = @OpenBalDate OUTPUT,
			@Previous_Shift = @OpenBalShift OUTPUT

		SELECT @OpenBalShiftOrder = dbo.GetShiftTypeOrderNo(@OpenBalShift),
			@CloseBalShiftOrder = dbo.GetShiftTypeOrderNo(@CloseBalShift),
			@OpenBalActualShiftOrder = dbo.GetShiftTypeOrderNo(@OpenBalActualShift)

		--Get the last available balance date up to the shift prior to the start date filter
		--Sum all balances for all builds
		SELECT @OpenBal = Sum(B.Tonnes)
		FROM dbo.DataProcessStockpileBalance AS B
			INNER JOIN dbo.ShiftType AS ST
				ON (ST.Shift = B.Data_Process_Stockpile_Balance_Shift)
			INNER JOIN 
				(
					SELECT B2.Stockpile_Id, B2.Build_Id, 
						Max(dbo.GetDateShiftAsInt(B2.Data_Process_Stockpile_Balance_Date, B2ST.Order_No)) AS Offset
					FROM dbo.DataProcessStockpileBalance AS B2
						INNER JOIN dbo.ShiftType AS B2ST
							ON (B2ST.Shift = B2.Data_Process_Stockpile_Balance_Shift)
					WHERE B2.Stockpile_Id = @iStockpile_Id
						AND B2.Data_Process_Stockpile_Balance_Date <= @OpenBalDate
						AND dbo.GetDateShiftAsInt(B2.Data_Process_Stockpile_Balance_Date, B2ST.Order_No) <=
							dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
					GROUP BY B2.Stockpile_Id, B2.Build_Id
				) AS D
				ON (D.Stockpile_Id = B.Stockpile_Id
					AND D.Build_Id = B.Build_Id
					AND D.Offset = dbo.GetDateShiftAsInt(B.Data_Process_Stockpile_Balance_Date, ST.Order_No))

		--If there were no balances from the recalc aggregate all the start tonnes for the stockpile
		IF (@OpenBal IS NULL)
		BEGIN
			SELECT @OpenBal = Sum(Start_Tonnes)
			FROM dbo.StockpileBuildComponent AS SBC
				INNER JOIN dbo.StockpileBuild AS SB
					ON (SB.Stockpile_Id = SBC.Stockpile_Id
						AND SB.Build_Id = SBC.Build_Id)
				INNER JOIN dbo.ShiftType AS ST
				ON (ST.Shift = SB.Start_Shift)
			WHERE SBC.Stockpile_ID = @iStockpile_Id	
				AND SB.Start_Date <= @OpenBalActualDate
				AND dbo.GetDateShiftAsInt(SB.Start_Date, ST.Order_No) 
					<= dbo.GetDateShiftAsInt(@OpenBalActualDate, @OpenBalActualShiftOrder)
		END
		
		--Get Changes
		INSERT INTO @STOCKPILE_CHANGES
		(
			Stockpile_Id, Heading, Sub_Heading, Value, Order_No
		)
		--Opening Balance
		SELECT @iStockpile_Id, 'Opening Balance', 'Total', @OpenBal, 1
		WHERE @OpenBal IS NOT NULL
		UNION --Added Tonnes to the stockpile
		SELECT DPT.Destination_Stockpile_Id, 'Added', '', Sum(Tonnes), 2
		FROM dbo.DataProcessTransaction AS DPT
		WHERE DPT.Destination_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NULL
		GROUP BY DPT.Destination_Stockpile_Id
		UNION --Removed Tonnes from Stockpile
		SELECT DPT.Source_Stockpile_Id, 'Removed', '', Sum(Tonnes), 3
		FROM dbo.DataProcessTransaction AS DPT
		WHERE DPT.Source_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NULL
		GROUP BY DPT.Source_Stockpile_Id
		UNION --Adjusted Tonnes
		SELECT S.Stockpile_Id, 'Adjusted', '', 
			Sum(
					CASE 
						WHEN S.Stockpile_Id = DPT.Destination_Stockpile_Id THEN 
							DPT.Tonnes
						ELSE
							DPT.Tonnes * -1
					END
				), 4
		FROM dbo.DataProcessTransaction AS DPT
			INNER JOIN Stockpile AS S
				ON S.Stockpile_Id = DPT.Source_Stockpile_Id 
					OR S.Stockpile_Id = DPT.Destination_Stockpile_Id
		WHERE S.Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NOT NULL
		GROUP BY S.Stockpile_Id	
		UNION --Closing Balance
		SELECT DPSB.Stockpile_Id, 'Closing Balance', 'Total', DPSB.Tonnes, 5
		FROM dbo.DataProcessStockpileBalance AS DPSB	
		WHERE DPSB.Stockpile_Id = @iStockpile_Id
			AND DPSB.Data_Process_Stockpile_Balance_Date = @CloseBalDate
			AND DPSB.Data_Process_Stockpile_Balance_Shift = @CloseBalShift

		--Insert Missing Headings
		INSERT INTO @STOCKPILE_CHANGES
		(
			Stockpile_Id, Heading, Sub_Heading, Value, Order_No
		)
		SELECT @iStockpile_Id, 'Opening Balance', 'Total', 0, 1 
		WHERE NOT EXISTS (SELECT 1 FROM @STOCKPILE_CHANGES WHERE Heading = 'Opening Balance' AND Sub_Heading = 'Total')
		UNION
		SELECT @iStockpile_Id, 'Added', '', 0, 2 
		WHERE NOT EXISTS (SELECT 1 FROM @STOCKPILE_CHANGES WHERE Heading = 'Added' AND Sub_Heading = '')
		UNION
		SELECT @iStockpile_Id, 'Removed', '', 0, 3 
		WHERE NOT EXISTS (SELECT 1 FROM @STOCKPILE_CHANGES WHERE Heading = 'Removed' AND Sub_Heading = '')
		UNION
		SELECT @iStockpile_Id, 'Adjusted', '', 0, 4 
		WHERE NOT EXISTS (SELECT 1 FROM @STOCKPILE_CHANGES WHERE Heading = 'Adjusted' AND Sub_Heading = '')
		UNION
		SELECT @iStockpile_Id, 'Closing Balance', 'Total', 0, 5 
		WHERE NOT EXISTS (SELECT 1 FROM @STOCKPILE_CHANGES WHERE Heading = 'Closing Balance' AND Sub_Heading = 'Total')

		-- Get the very first build in the stockpile.
		SELECT @StartStockpileBuildDate = SB.Start_Date,
			@StartStockpileBuildShift = SB.Start_Shift,
			@FirstBuildId = SB.Build_Id
		FROM StockpileBuild AS SB
			INNER JOIN ShiftType AS ST
				ON SB.Start_Shift = ST.Shift
		WHERE Stockpile_ID = @iStockpile_Id
		ORDER BY Start_date, dbo.GetShiftTypeOrderNo(Start_Shift)
		
		-- Obtain the Additions as a result of stockpile new stockpiles builds added.
		SELECT @StockpileBuildAdditions = Sum(SBC.Start_Tonnes)
		FROM StockpileBuild AS SB
			INNER JOIN ShiftType AS ST
				ON ST.Shift = SB.Start_Shift
			INNER JOIN StockpileBuildComponent AS SBC
				ON SBC.Build_ID = SB.Build_ID
					AND SBC.Stockpile_ID = SB.Stockpile_ID
		WHERE SB.Stockpile_ID = @iStockpile_Id
			AND SB.Start_Date Between @iStart_Date AND @iEnd_Date
			AND dbo.GetDateShiftAsInt(SB.Start_Date, ST.Order_No) >= dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
			AND SB.Build_Id <> @FirstBuildId

		-- Update the result with the additions obtained (If any).
		UPDATE @STOCKPILE_CHANGES
		SET Value = Value + Coalesce(@StockpileBuildAdditions, 0)
		WHERE Heading = 'Added' AND Sub_Heading = ''

		UPDATE @STOCKPILE_CHANGES
		SET Value = Value + Coalesce(@StockpileBuildAdditions, 0)
		WHERE Heading = 'Closing Balance'
			AND Sub_Heading = 'Total'

		SELECT * 
		FROM @STOCKPILE_CHANGES
		ORDER BY Order_No
	
    COMMIT TRANSACTION 
END 
GO	
GRANT EXECUTE ON dbo.GetStockpileChangesOverPeriod TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileChangesOverPeriod">
 <Procedure>
	Returns a list of the stockpile changes over a preiod of time.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileComposition.prc'
GO

IF Object_Id('dbo.GetStockpileComposition') IS NOT NULL
	DROP PROCEDURE dbo.GetStockpileComposition
GO 

CREATE PROCEDURE dbo.GetStockpileComposition
(
	@iDate DATETIME,
	@iShift CHAR(1),
	@iStockpile_Id INT,
	@iBuild_Id INT,
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION 
AS
BEGIN
	DECLARE @Total_Tonnes FLOAT
	DECLARE @Composition_Tonnes FLOAT
	DECLARE @AvgModeled_Tonnes FLOAT
	DECLARE @Stockpile_Type_Id VARCHAR(31)
	DECLARE @Balance_Date DATETIME
	DECLARE @Balance_Shift VARCHAR(1)

	SET NOCOUNT ON

	--Work out the Stockpile Type FOR this stockpile AS at date.
	SELECT Top 1 @Stockpile_Type_Id = Stockpile_Type_Id
	FROM dbo.StockpileStockpileTypePeriod
	WHERE Stockpile_Id = @iStockpile_Id
		AND (@iDate <= End_Date 
			OR End_Date IS NULL)
	GROUP BY Stockpile_Type_Id
	ORDER BY Stockpile_Type_Id, IsNull(Max(End_Date), '1901-01-01') DESC

	CREATE TABLE #COMPOSITION
	(
		ID INT IDENTITY(1, 1),
		Original_Source VARCHAR(31) COLLATE Database_Default, 
		Tonnes FLOAT,
		Percentage_Value FLOAT,
		Percentage_Digblock	FLOAT
	)

	CREATE TABLE #COMPOSITION_GRADE
	(
		Original_Source VARCHAR(31) COLLATE Database_Default, 
		Grade_Id INT,
		Grade_Name VARCHAR(31),
		Order_No INT,
		Value FLOAT
	)

	CREATE TABLE #SUMMARY
	(
		Summary VARCHAR(255), 
		Tonnes FLOAT, 
		Percentage_Value FLOAT,
	)	

	CREATE TABLE #SUMMARY_GRADE	
	(
		Summary VARCHAR(255),
		Grade_Id INT,
		Grade_Name VARCHAR(31),
		Order_No INT,
		Value FLOAT
	)

	--Insert Base grades
	INSERT INTO #SUMMARY_GRADE
	(
		Summary, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT NULL, Grade_Id, Grade_Name, Order_No, NULL
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	INSERT INTO #COMPOSITION_GRADE
	(
		Original_Source, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT NULL, Grade_Id, Grade_Name, Order_No, NULL
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Calculate latest date and shift that has been recalced for this period and its total tonnes
	SELECT Top 1 @Balance_Date = DPSB.Data_Process_Stockpile_Balance_Date,
		@Balance_Shift = DPSB.Data_Process_Stockpile_Balance_Shift,
		@Total_Tonnes = Sum(DPSB.Tonnes)
	FROM dbo.DataProcessStockpileBalance AS DPSB
		INNER JOIN dbo.ShiftType AS ST
			ON (ST.Shift = DPSB.Data_Process_Stockpile_Balance_Shift)
	WHERE DPSB.Stockpile_Id = @iStockpile_Id
		AND DPSB.Build_Id = @iBuild_Id
		AND 
			(
				DPSB.Data_Process_Stockpile_Balance_Date < @iDate
					OR (DPSB.Data_Process_Stockpile_Balance_Date = @iDate
						AND DPSB.Data_Process_Stockpile_Balance_Shift = @iShift)
			)
	GROUP BY DPSB.Data_Process_Stockpile_Balance_Date, DPSB.Data_Process_Stockpile_Balance_Shift, ST.Order_No
	ORDER BY DPSB.Data_Process_Stockpile_Balance_Date DESC, ST.Order_No DESC

	--Get Sum of composition tonnes from LIFO/FIFO components
	SELECT @Composition_Tonnes = Sum(Tonnes_Left)
	FROM dbo.DataProcessTransactionLeft AS DPTL
	WHERE DPTL.Data_Process_Transaction_Left_Date = @Balance_Date
		AND DPTL.Data_Process_Transaction_Left_Shift = @Balance_Shift
		AND DPTL.Stockpile_Id = @iStockpile_Id
		AND DPTL.Build_Id = @iBuild_Id
		AND DPTL.Source_Digblock_Id IS NOT NULL
		
	--Calculate the tonnes that are not identified AS LIFO or FIFO Components
	--ie: Stockpile Adjustments, Tonnes carried when it was an average stockpile
	SELECT @AvgModeled_Tonnes = Round(IsNull(@Total_Tonnes, 0) - IsNull(@Composition_Tonnes, 0), 0)
	
	--Insert Summary Details
	INSERT INTO dbo.#SUMMARY
	(
		Summary, Tonnes, Percentage_Value
	)
	SELECT 'Averaged Component', ISNULL(@AvgModeled_Tonnes, 0.0),
		IsNull(@AvgModeled_Tonnes / NullIf(@Total_Tonnes, 0), 0)
	UNION ALL
	SELECT 'Composition Summary', ISNULL(@Composition_Tonnes, 0.0),
		IsNull(@Composition_Tonnes / NullIf(@Total_Tonnes, 0), 0)
	UNION ALL
	SELECT 'Stockpile Balance', ISNULL(@Total_Tonnes, 0.0), 1

	--Retreive Summary Grades
	INSERT INTO #SUMMARY_GRADE
	(
		Summary, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT 'Stockpile Balance', DPSBG.Grade_Id, G.Grade_Name, G.Order_No,  
		Sum(DPSBG.Grade_Value * DPSB.Tonnes) / NullIf(Sum(DPSB.Tonnes), 0)
	FROM dbo.DataProcessStockpileBalanceGrade AS DPSBG
		INNER JOIN dbo.DataProcessStockpileBalance AS DPSB
			ON (DPSB.Data_Process_Stockpile_Balance_Id = DPSBG.Data_Process_Stockpile_Balance_Id)
		INNER JOIN dbo.Grade AS G
			ON (DPSBG.Grade_Id = G.Grade_Id)
	WHERE DPSB.Data_Process_Stockpile_Balance_Date = @Balance_Date
		AND DPSB.Data_Process_Stockpile_Balance_Shift = @Balance_Shift
		AND DPSB.Stockpile_Id = @iStockpile_Id
		AND DPSB.Build_Id = @iBuild_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY DPSBG.Grade_Id, G.Grade_Name, G.Order_No
		
	--Do not aggregate to indicate order
	INSERT INTO #COMPOSITION
	(
		Original_Source, Tonnes, Percentage_Value, Percentage_Digblock
	)
	SELECT IsNull(DPTL.Source_Digblock_Id, 'Unknown'),
		Sum(DPTL.Tonnes_Left), IsNull(Sum(Tonnes_Left) / NullIf(@Total_Tonnes, 0), 0),
		IsNull(Sum(DPTL.Tonnes_Left) / NullIf(D.Start_Tonnes, 0), 0)
	FROM dbo.DataProcessTransactionLeft AS DPTL
		INNER JOIN dbo.Digblock AS D 
			ON (D.Digblock_Id = DPTL.Source_Digblock_Id)
	WHERE DPTL.Data_Process_Transaction_Left_Date = @Balance_Date
		AND DPTL.Data_Process_Transaction_Left_Shift = @Balance_Shift
		AND DPTL.Stockpile_Id = @iStockpile_Id
		AND DPTL.Build_Id = @iBuild_Id
	GROUP BY IsNull(DPTL.Source_Digblock_Id, 'Unknown'), D.Start_Tonnes
	ORDER BY Min(DPTL.Data_Process_Transaction_Left_Id)

	--Retrieve Composition Grades
	INSERT INTO dbo.#COMPOSITION_GRADE
	(
		Original_Source, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT IsNull(DPTL.Source_Digblock_Id, 'Unknown'), DPTLG.Grade_Id, G.Grade_Name, G.Order_No,
		Sum(DPTLG.Grade_Value * DPTL.Tonnes_Left) / NullIf(Sum(DPTL.Tonnes_Left), 0)
	FROM dbo.DataProcessTransactionLeftGrade AS DPTLG
		INNER JOIN dbo.DataProcessTransactionLeft AS DPTL
			ON (DPTL.Data_Process_Transaction_Left_Id = DPTLG.Data_Process_Transaction_Left_Id)
		INNER JOIN dbo.Grade AS G
			ON (DPTLG.Grade_Id = G.Grade_Id)
	WHERE DPTL.Data_Process_Transaction_Left_Date = @Balance_Date
		AND DPTL.Data_Process_Transaction_Left_Shift = @Balance_Shift
		AND DPTL.Stockpile_Id = @iStockpile_Id
		AND DPTL.Build_Id = @iBuild_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY IsNull(DPTL.Source_Digblock_Id, 'Unknown'), DPTLG.Grade_Id, G.Grade_Name, G.Order_No

	--Pivot Composition table
	EXEC dbo.PivotTable
		@iTargetTable = '#COMPOSITION',
		@iPivotTable = '#COMPOSITION_GRADE',
		@iJoinColumns = '#COMPOSITION.Original_Source = #COMPOSITION_GRADE.Original_Source',
		@iPivotColumn = 'Grade_Name',
		@iPivotValue = 'Value',
		@iPivotType	= 'FLOAT',
		@iPivotOrderColumn = 'Order_No'

	--INSERT Composition Summary INTO TABLE
	INSERT INTO dbo.#SUMMARY_GRADE
	(
		Summary, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT 'Composition Summary', CG.Grade_Id, CG.Grade_Name, CG.Order_No,
		Sum(CG.Value * C.Tonnes) / NullIf(Sum(C.Tonnes), 0)
	FROM dbo.#COMPOSITION AS C
		INNER JOIN dbo.#COMPOSITION_GRADE AS CG
			ON (C.Original_Source = CG.Original_Source)
	GROUP BY CG.Grade_Id, CG.Grade_Name, CG.Order_No
	
	--Calculate Average Component Grades
	INSERT INTO #SUMMARY_GRADE
	(
		Summary, Grade_Id, Grade_Name, Order_No, Value
	)
	SELECT 'Averaged Component', B.Grade_Id, B.Grade_Name, B.Order_No,
		(IsNull(B.Value, 0) * @Total_Tonnes - IsNull(C.Value, 0) * @Composition_Tonnes)
			/ NullIf(Round(@Total_Tonnes - @Composition_Tonnes, 0), 0)
	FROM #SUMMARY_GRADE AS B
		INNER JOIN #SUMMARY_GRADE AS C
			ON (B.Grade_Id = C.Grade_Id
				AND B.Summary = 'Stockpile Balance'
				AND C.Summary = 'Composition Summary')

	--Pivot Summary table
	EXEC dbo.PivotTable
		@iTargetTable = '#SUMMARY',
		@iPivotTable = '#SUMMARY_GRADE',
		@iJoinColumns = '#SUMMARY.Summary = #SUMMARY_GRADE.Summary',
		@iPivotColumn = 'Grade_Name',
		@iPivotValue = 'Value',
		@iPivotType	= 'FLOAT',
		@iPivotOrderColumn = 'Order_No'

	--Select Recordsets
	SELECT *
	FROM #SUMMARY

	SELECT * 
	FROM #COMPOSITION
	ORDER BY CASE @Stockpile_Type_Id WHEN 'LIFO' THEN ID ELSE ID * -1 END

	SELECT @Balance_Date AS BalanceDate, @Balance_Shift As BalanceShift

	--Drop Tables
	DROP TABLE #SUMMARY
	DROP TABLE #SUMMARY_GRADE
	DROP TABLE #COMPOSITION
	DROP TABLE #COMPOSITION_GRADE
END
GO
GRANT EXECUTE ON dbo.GetStockpileComposition TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileComposition">
 <Procedure>
	Returns a list of the stockpile Compositions in the DataProcessTransactionLeft table.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileFieldNotes.prc'
GO

If object_id('dbo.GetStockpileFieldNotes') is not Null 
     Drop Procedure dbo.GetStockpileFieldNotes 
Go 

CREATE Procedure dbo.GetStockpileFieldNotes
(
	@iStockpile_Id Int,
	@iStockpile_Field_Id Varchar(31),
	@oNotes VarChar(1023) Output
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Declare @Stockpile_Name VarChar(31)

	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Select @Stockpile_Name = dbo.GetStockpileName(@iStockpile_Id)


	/* If the stockpile exists */
	If (dbo.DoesStockpileExist(@Stockpile_Name) = 1)
	Begin
		/* If the stockpile field exists */
		If Exists ( Select 1 
					From StockpileField 
					Where Stockpile_Field_Id = @iStockpile_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @oNotes = Notes
			From StockpileNotes
			Where Stockpile_Id = @iStockpile_Id
				And Stockpile_Field_Id = @iStockpile_Field_Id
		End
		Else
		Begin
			Raiserror ('The given stockpile field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given stockpile does not exist', 16, 1)
	End

	Commit Transaction

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

	Return
End

GO
GRANT EXECUTE ON dbo.GetStockpileFieldNotes TO CoreStockpileManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileFieldNotes">
 <Procedure>
	If the stockpile exists and the stockpile field exists return the 
	notes for the given stockpile and field name.
	Errors are raised if:
		The given stockpile field does not exist.
		The given stockpile does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileFieldValue.prc'
GO

If object_id('dbo.GetStockpileFieldValue') is not Null 
     Drop Procedure dbo.GetStockpileFieldValue 
Go 

CREATE Procedure dbo.GetStockpileFieldValue
(
	@iStockpile_Id Int,
	@iStockpile_Field_Id Varchar(31),
	@oField_Value Float Output
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Declare @Stockpile_Name VarChar(31)
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Begin Transaction
	Set Transaction Isolation Level Repeatable Read

	Select @Stockpile_Name = dbo.GetStockpileName(@iStockpile_Id)

	/* If the stockpile exists */
	If (dbo.DoesStockpileExist(@Stockpile_Name) = 1)
	Begin
		/* If the stockpile field exists */
		If Exists ( Select 1 
					From StockpileField 
					Where Stockpile_Field_Id = @iStockpile_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @oField_Value = Min(Field_Value)
			From StockpileValue
			Where Stockpile_Id = @iStockpile_Id
				And Stockpile_Field_Id = @iStockpile_Field_Id

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given stockpile field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given stockpile does not exist', 16, 1)
	End

	Commit Transaction

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.GetStockpileFieldValue TO CoreStockpileManager




/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileFieldValue">
 <Procedure>
	If the stockpile exists and the stockpile field exists return 
	the value for the given stockpile and field name.
	Errors are raised if:
		The given stockpile field does not exist.
		The given stockpile does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileFieldNotesList.prc'
GO

If object_id('dbo.GetStockpileFieldNotesList') is not Null 
     Drop Procedure dbo.GetStockpileFieldNotesList 
Go 

CREATE Procedure dbo.GetStockpileFieldNotesList
(
	@iStockpile_Id Int
)

With Encryption 
As

Begin
	Declare @Stockpile_Name VarChar(31)
	
	Set Nocount On
	
	Select @Stockpile_Name = dbo.GetStockpileName(@iStockpile_Id)

	/* If the stockpile exists */
	If (dbo.DoesStockpileExist(@Stockpile_Name) = 1)
	Begin
			/* Return the note for the given digblock and field name */
			Select SN.*, SF.Description
			From StockpileNotes SN
				Inner Join StockpileField SF
					On SN.Stockpile_Field_Id = SF.Stockpile_Field_Id
			Where SN.Stockpile_Id = @iStockpile_Id
	End
	Else
	Begin
		Raiserror ('The given stockpile does not exist', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.GetStockpileFieldNotesList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileFieldNotesList">
 <Procedure>
	If the stockpile exists and the stockpile field exists return all the notes 
	for the given stockpile and field name.
	Errors are raised if:
		The given stockpile does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileFieldValueList.prc'
GO

If object_id('dbo.GetStockpileFieldValueList') is not Null 
     Drop Procedure dbo.GetStockpileFieldValueList 
Go 

CREATE Procedure dbo.GetStockpileFieldValueList
(
	@iStockpile_Id Int
)

With Encryption 
As

Begin
	Declare @Stockpile_Name VarChar(31)
	
	Set Nocount On
	
	Select @Stockpile_Name = dbo.GetStockpileName(@iStockpile_Id)

	/* If the stockpile exists */
	If (dbo.DoesStockpileExist(@Stockpile_Name) = 1)
	Begin
			/* Return the value for the given digblock and field name */
			Select SV.*, SF.Description
			From StockpileValue SV
				Inner Join StockpileField SF
					On SV.Stockpile_Field_Id = SF.Stockpile_Field_Id
			Where SV.Stockpile_Id = @iStockpile_Id
	End
	Else
	Begin
		Raiserror ('The given stockpile does not exist', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.GetStockpileFieldValueList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileFieldValueList">
 <Procedure>
	If the stockpile exists and the stockpile field exists return all the values 
	for the given stockpile and field name.
	Errors are raised if:
		The given stockpile does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileFieldList.prc'
GO

If Object_Id('dbo.GetStockpileFieldList') Is Not Null
	Drop Procedure dbo.GetStockpileFieldList
Go

Create Procedure dbo.GetStockpileFieldList

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Return the list of digblock virtual fields in the system */
	Select Stockpile_Field_Id, Description, Order_No, Has_Value, Has_Notes, Has_Formula
	From StockpileField
	Order By Order_No, Stockpile_Field_Id


	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetStockpileFieldList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileFieldList">
 <Procedure>
	Returns the stockpile field list.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileGroup.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetStockpileGroup'))
	Drop Procedure dbo.GetStockpileGroup
Go


CREATE Procedure dbo.GetStockpileGroup
(
	@iStockpile_Group_Id Varchar(31)
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* Get the details of the given stockpile groups */
	Select Stockpile_Group_Id, Description, Order_No
	From StockpileGroup
	Where Stockpile_Group_Id = @iStockpile_Group_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.GetStockpileGroup TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileGroup">
 <Procedure>
	Returns the details of the given stockpile group.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileGroupList.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetStockpileGroupList'))
	Drop Procedure dbo.GetStockpileGroupList
Go


CREATE Procedure dbo.GetStockpileGroupList
(
	@iDisplay_Stockpile_Descriptions Bit = 0,
	@iDisplay_Invisible Bit = 1
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* Get the details of all the stockpile groups */
	Select Stockpile_Group_Id, Description, Order_No,
	 dbo.GetStockpileGroupStockpiles (Stockpile_Group_Id, @iDisplay_Stockpile_Descriptions, @iDisplay_Invisible) As Stockpile_List,
	 Case When dbo.GetStockpileGroupStockpiles (Stockpile_Group_Id, @iDisplay_Stockpile_Descriptions, 0) <> '' Then 1 Else 0 End As Visible
	From StockpileGroup
	Order By Order_No

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.GetStockpileGroupList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileGroupList">
 <Procedure>
	Returns a list of all the stockpile groups.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileGroupStockpileList.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetStockpileGroupStockpileList'))
	Drop Procedure dbo.GetStockpileGroupStockpileList
Go


CREATE Procedure dbo.GetStockpileGroupStockpileList
(
	@iStockpile_Group_Id Varchar(31) = Null,
	@iIs_Included bit = Null,
	@iStockpile_Id Int = Null,
	@iIs_Visible bit = Null,
	@iLocation_Id Int = Null,
	@iIn_Groups bit = Null
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Declare @Location_Type_Id Int
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select @Location_Type_Id = Location_Type_Id
	From dbo.Location 
	Where @iLocation_Id = Location_Id

	Select * 
	From
	(
	Select SGS.Stockpile_Group_Id, S.Stockpile_Id, S.Stockpile_Name,
		Case When (SGS.Stockpile_Id Is Null) Then 0 Else 1 End As Is_Included,
		dbo.GetStockpileStockpileGroups (S.Stockpile_Id, Coalesce(@iStockpile_Group_Id,'')) As Other_Group_List,
		SL.Location_Id As Stockpile_Location_Id
	From dbo.Stockpile As S
		Left Outer Join dbo.StockpileGroupStockpile As SGS
			On SGS.Stockpile_Id = S.Stockpile_Id
				And SGS.Stockpile_Group_Id = IsNull(@iStockpile_Group_Id, SGS.Stockpile_Group_Id)
		Left Outer Join dbo.StockpileLocation As SL
			On SL.Stockpile_Id = S.Stockpile_Id
	-- Show all stockpiles where the following conditions apply
	-- 1. The stockpile is visible when @iIs_Visible = True or the stockpile is already assigned to a group.
	-- 2. The stockpile is hidden when @iIs_Visible = False or the stockpile is already assigned to a group.
	-- 3. All stockpiles when @iIs_Visible = Null
	Where (((S.Is_Visible = @iIs_Visible Or @iIs_Visible Is Null) Or SGS.Stockpile_Id Is Not Null)
		-- Show stockpiles when
		-- 1. If @iIs_Included = 1 then only show stockpiles belonging to group
		-- 2. If @iIs_Included = 0 then only show stockpiles belon
		And Case When (SGS.Stockpile_Id Is Null) Then 0 Else 1 End = Coalesce(@iIs_Included, Case When (SGS.Stockpile_Id Is Null) Then 0 Else 1 End))
		And (S.Stockpile_Id = @iStockpile_Id Or @iStockpile_Id is null)
		-- Show records that belong to this location
		And (@iLocation_Id = dbo.GetLocationTypeLocationId(SL.Location_Id, @Location_Type_Id) Or @iLocation_Id Is Null)
	Group By SGS.Stockpile_Group_Id, S.Stockpile_Id, S.Stockpile_Name, SGS.Stockpile_Id, SL.Location_Id
	) As VW
	Where ((Other_Group_List <> '' Or Stockpile_Group_Id Is Not Null) And @iIn_Groups = 1) 
		Or (@iIn_Groups = 0 And Coalesce(Other_Group_List,'') = '' And Stockpile_Group_Id Is Null)
		Or (@iIn_Groups Is Null)
	Order By Stockpile_Name

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.GetStockpileGroupStockpileList TO CoreUtilityManager
GO

GRANT EXECUTE ON dbo.GetStockpileGroupStockpileList TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileGroupStockpileList">
 <Procedure>
	 Returns a list of all the stockpiles in a given group.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileGradeGraph.prc'
GO

IF object_id('dbo.GetStockpileGradeGraph') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileGradeGraph 
GO 
  
CREATE PROCEDURE dbo.GetStockpileGradeGraph 
( 
    @iStockpile_Id INT,
	@iBuild_Id INT = NULL,
	@iStart_Date DATETIME,
	@iEnd_Date DATETIME,
	@iGraph_By_Shift BIT = 0,
	@iGrade_Visibility Bit = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'GetStockpileGradeGraph',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
    BEGIN TRY
		-- Normalised Grades
		CREATE TABLE #BALANCE
		(
			Balance_Date DATETIME NOT NULL,
			Balance_Shift CHAR(1) COLLATE Database_Default NOT NULL,
			Tonnes FLOAT NULL,

			PRIMARY KEY (Balance_Date, Balance_Shift)
		)

		CREATE TABLE #BALANCE_GRADE
		(
			Balance_Date DATETIME NOT NULL,
			Balance_Shift CHAR(1) COLLATE Database_Default NOT NULL,
			Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
			Grade_Value REAL NULL

			PRIMARY KEY (Balance_Date, Balance_Shift, Grade_Name)
		)

		IF @iGraph_By_Shift = 1 
		BEGIN
			INSERT INTO #BALANCE
			(
				Balance_Date, Balance_Shift, Tonnes
			)
			SELECT DPSB.Data_Process_Stockpile_Balance_Date, DPSB.Data_Process_Stockpile_Balance_Shift, 
				IsNull(Sum(DPSB.Tonnes), 0)
			FROM dbo.DataProcessStockpileBalance AS DPSB
			WHERE DPSB.Stockpile_Id = @iStockpile_Id
				AND DPSB.Build_Id = IsNull(@iBuild_Id, DPSB.Build_Id)
				AND DPSB.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
			GROUP BY DPSB.Data_Process_Stockpile_Balance_Date, DPSB.Data_Process_Stockpile_Balance_Shift

			INSERT INTO #BALANCE_GRADE
			(
				Balance_Date, Balance_Shift, 
				Grade_Name, Grade_Value
			)
			SELECT DPSB.Data_Process_Stockpile_Balance_Date, DPSB.Data_Process_Stockpile_Balance_Shift, 
				G.Grade_Name, Sum(DPSBG.Grade_Value * DPSB.Tonnes) / NullIf(Sum(DPSB.Tonnes), 0) AS Grade_Value
			FROM dbo.DataProcessStockpileBalance AS DPSB
				INNER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
					ON (DPSB.Data_Process_Stockpile_Balance_Id = DPSBG.Data_Process_Stockpile_Balance_Id)
				INNER JOIN dbo.Grade AS G
					ON (DPSBG.Grade_Id = G.Grade_Id)
			WHERE DPSB.Stockpile_Id = @iStockpile_Id
				AND DPSB.Build_Id = IsNull(@iBuild_Id, DPSB.Build_Id)
				AND DPSB.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
				AND (G.Is_Visible = @iGrade_Visibility 
					OR @iGrade_Visibility IS NULL)
			GROUP BY DPSB.Data_Process_Stockpile_Balance_Date, DPSB.Data_Process_Stockpile_Balance_Shift, G.Grade_Name
		END
		ELSE
		BEGIN
			INSERT INTO #BALANCE
			(
				Balance_Date, Balance_Shift, Tonnes
			)
			SELECT DPSB.Data_Process_Stockpile_Balance_Date, '-', 
				IsNull(Sum(DPSB.Tonnes), 0)
			FROM dbo.DataProcessStockpileBalance AS DPSB
			WHERE DPSB.Stockpile_Id = @iStockpile_Id
				AND DPSB.Build_Id = IsNull(@iBuild_Id, DPSB.Build_Id)
				AND DPSB.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
				AND DPSB.Data_Process_Stockpile_Balance_Shift = dbo.GetLastShiftType()
			GROUP BY DPSB.Data_Process_Stockpile_Balance_Date

			INSERT INTO #BALANCE_GRADE
			(
				Balance_Date, Balance_Shift, 
				Grade_Name, Grade_Value
			)
			SELECT DPSB.Data_Process_Stockpile_Balance_Date, '-', 
				G.Grade_Name, Sum(DPSBG.Grade_Value * DPSB.Tonnes) / NullIf(Sum(DPSB.Tonnes), 0) AS Grade_Value
			FROM dbo.DataProcessStockpileBalance AS DPSB
				INNER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
					ON (DPSB.Data_Process_Stockpile_Balance_Id = DPSBG.Data_Process_Stockpile_Balance_Id)
				INNER JOIN dbo.Grade AS G
					ON (DPSBG.Grade_Id = G.Grade_Id)
			WHERE DPSB.Stockpile_Id = @iStockpile_Id
				AND DPSB.Build_Id = IsNull(@iBuild_Id, DPSB.Build_Id)
				AND DPSB.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
				AND DPSB.Data_Process_Stockpile_Balance_Shift = dbo.GetLastShiftType()
				AND (G.Is_Visible = @iGrade_Visibility 
					OR @iGrade_Visibility IS NULL)
			GROUP BY DPSB.Data_Process_Stockpile_Balance_Date, G.Grade_Name
		END

		INSERT INTO #BALANCE_GRADE
		(
			Balance_Date, Balance_Shift, Grade_Name, Grade_Value
		)
		SELECT '1900-01-01', '', G.Grade_Name, NULL
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
					OR @iGrade_Visibility IS NULL)

		--Pivot the grades
		EXEC dbo.PivotTable
			@iTargetTable = '#BALANCE',
			@iPivotTable = '#BALANCE_GRADE',
			@iJoinColumns = '#BALANCE.Balance_Date = #BALANCE_GRADE.Balance_Date AND #BALANCE.Balance_Shift = #BALANCE_GRADE.Balance_Shift',
			@iPivotColumn = 'Grade_Name',
			@iPivotValue = 'Grade_Value',
			@iPivotType = 'REAL'
		
		SELECT B.*, ST.Name AS Balance_Shift_Name
		FROM #BALANCE AS B
			LEFT OUTER JOIN ShiftType AS ST
				ON (B.Balance_Shift = ST.Shift)
		ORDER BY B.Balance_Date, ST.Order_No
	
		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock		
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.GetStockpileGradeGraph TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileGradeGraph">
 <Procedure>
	Return data for the Stockpile Grade Graph.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileIdList.prc'
GO

IF OBJECT_ID('dbo.GetStockpileIdList') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileIdList 
GO 
  
CREATE PROCEDURE dbo.GetStockpileIdList 
( 
	@iMaterial_Type_Id INT = NULL,
	@iStockpile_Group_Id VARCHAR(31) = NULL,
	@iIs_Visible BIT = 1,
	@iLocationId INT = NULL
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON
  
	BEGIN TRY
		SELECT S.Stockpile_Id, S.Stockpile_Name, S.Description
		FROM dbo.Stockpile AS S
			LEFT JOIN dbo.StockpileLocation As L
				On L.Stockpile_Id = S.Stockpile_Id				
			LEFT JOIN GetLocationSubtree(@iLocationId) As LL
				On LL.Location_Id = L.Location_Id	
			LEFT OUTER JOIN dbo.StockpileGroupStockpile AS SGS
				ON S.Stockpile_Id = SGS.Stockpile_Id
		WHERE (S.Is_Visible = @iIs_Visible OR @iIs_Visible IS NULL)
			AND S.Material_Type_Id = IsNull(@iMaterial_Type_Id, S.Material_Type_Id)
			AND (SGS.Stockpile_Group_Id = @iStockpile_Group_Id
				OR @iStockpile_Group_Id IS NULL)
			AND (LL.Location_Id IS NOT NULL OR @iLocationId IS NULL)
		GROUP BY S.Stockpile_Name, S.Description, S.Stockpile_Id
		ORDER BY S.Stockpile_Name
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
  
END 
GO 
GRANT EXECUTE ON dbo.GetStockpileIdList TO CoreStockpileManager
GO
GRANT EXECUTE ON dbo.GetStockpileIdList TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileIdList">
 <Procedure>
	Return a list of stockpiles for given material type and stockpile group.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileList.prc'
GO

IF OBJECT_ID('dbo.GetStockpileList') IS NOT NULL
	DROP PROCEDURE dbo.GetStockpileList
GO

CREATE PROCEDURE dbo.GetStockpileList
(
	@iGroup_By_Stockpile_Groups BIT = 1,
	@iStockpile_Group_Id VARCHAR(31) = NULL,
	@iStockpile_Name VARCHAR(31) = NULL,
	@iIs_Visible BIT = 1,
	@iIs_Completed BIT = NULL,
	@iMaterial_Type_Id INT = NULL,
	@iSort_Type INT = NULL, --Between 1-4 Defined (see final result return set for definition)
	@iInclude_Grades BIT = 1, --If used = Performance Loss when many stockpiles and/or many grades exist in client system.
	@iFilterStartDate	DATETIME = NULL,
	@iFilterEndDate DATETIME = NULL,
	@iGrade_Visibility Bit = 1,
	@iLocationId INT = NULL,
	@iRecordLimit INT = NULL
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON
	
	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
		
	--Main Result SET
	CREATE TABLE dbo.#STOCKPILE_LIST 
	(
		Stockpile_Id INT NOT NULL, 
		Stockpile_Name VARCHAR(31) COLLATE Database_Default NULL,
		Description VARCHAR(255) COLLATE Database_Default NULL,
		Material_Type_Id INT NULL,
		Is_Completed BIT NOT NULL,
		Approved_Added_Tonnes_This_Month FLOAT NULL,
		Unapproved_Added_Tonnes_This_Month FLOAT NULL, 
		Stockpile_Added_Tonnes_This_Month FLOAT NULL,
		Removed_Tonnes_This_Month FLOAT NULL,
		Current_Tonnes FLOAT NULL, 
		Last_Adjustment_Date DATETIME,
		Last_Adjustment_Description VARCHAR(255) COLLATE Database_Default NULL,

		PRIMARY KEY (Stockpile_Id)
	)

	--For Grade Pivoting
	CREATE TABLE dbo.#STOCKPILE_LIST_GRADE 
	(
		Stockpile_Id INT NOT NULL, 
		Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Value REAL NULL,

		PRIMARY KEY (Stockpile_Id, Grade_Name)
	)
	
	--Used to enable a single lookup FROM DPT
	CREATE TABLE dbo.#DPT_SUMMARY 
	(
		Stockpile_Id INT NOT NULL,
		Code CHAR(3) COLLATE Database_Default NOT NULL,
		Tonnes FLOAT NULL,

		PRIMARY KEY (Stockpile_Id, Code)
	)

	--Used to enable a single lookup FROM Data Process Stockpile Balance
	CREATE TABLE dbo.#BALANCE_SUMMARY
	(
		Data_Process_Stockpile_Balance_Id BIGINT NOT NULL,
		Stockpile_Id INT NOT NULL,
		Tonnes FLOAT NOT NULL,

		PRIMARY KEY (Data_Process_Stockpile_Balance_Id, Stockpile_Id)
	)

	DECLARE @Month_Start_Date DATETIME
	DECLARE @Month_End_Date DATETIME

	--Define the inclusive month boundary
	SET @Month_Start_Date = dbo.GetDateMonth(GetDate())
	SET @Month_End_Date = DateAdd(DD, -1, DateAdd(MM, 1, @Month_Start_Date)) -- Start Of Month + 1 Month - 1 Day
	
	--Set Sort Type to default of 1 when NULL or out of range sort type is indicated
	IF Coalesce(@iSort_Type, -1) NOT BETWEEN 1 AND 4
	BEGIN 
		SET @iSort_Type = 1
	END
	
	--Ensure stockpile grouping is on when a group filter is in use; the alternative doesn't make sense.
	IF @iStockpile_Group_Id IS NOT NULL 
	BEGIN
		SET @iGroup_By_Stockpile_Groups = 1
	END
	
	SELECT s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id, 
		CASE WHEN COUNT(csb.Build_Id) = 0 THEN 1 ELSE 0 END AS Is_Completed
	INTO dbo.#StockpileListTemp
	FROM dbo.Stockpile AS s	
		LEFT OUTER JOIN dbo.StockpileBuild AS csb
			ON (s.Stockpile_Id = csb.Stockpile_Id
				AND csb.Stockpile_State_Id <> 'CLOSED')
		LEFT OUTER JOIN 
		(
			SELECT sp.Stockpile_Id, IsNull(spl.Location_Id, 0) AS Location_Id
			FROM dbo.Stockpile AS sp
				LEFT OUTER JOIN dbo.StockpileLocation AS spl
					ON (sp.Stockpile_Id = spl.Stockpile_Id)		
		) AS l
			ON (s.Stockpile_Id = l.Stockpile_Id)
	WHERE (s.Is_Visible = ISNULL(@iIs_Visible, s.Is_Visible))
		AND (s.Material_Type_Id = IsNull(@iMaterial_Type_Id, s.Material_Type_Id))
		AND (s.Stockpile_Name LIKE IsNull('%' + @iStockpile_Name + '%', s.Stockpile_Name))
		AND (@iStockpile_Group_Id IS NULL
			OR EXISTS 
				(
					SELECT 1
					FROM dbo.StockpileGroupStockpile AS sgs
					WHERE sgs.Stockpile_Id = s.Stockpile_Id
						AND sgs.Stockpile_Group_Id = @iStockpile_Group_Id
				)
			)
		AND ((csb.Start_Date >= IsNull(@iFilterStartDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND ((csb.Start_Date <= IsNull(@iFilterEndDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND 
			(				
				@iLocationId IS NULL
					OR l.Location_Id IN 
					(	
						SELECT Location_Id
						FROM dbo.GetLocationSubtree(@iLocationId)
					)
			)
	GROUP BY s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id
	HAVING (@iIs_Completed = 1 AND Count(csb.Build_Id) = 0)  --SB is the count of stockpile
		OR (@iIs_Completed = 0 AND Count(csb.Build_Id) > 0)  --builds for this stockpile that arent closed
		OR (@iIs_Completed IS NULL)

	IF @iRecordLimit IS NULL
	BEGIN
		INSERT INTO dbo.#STOCKPILE_LIST
		(
			Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
		)
		SELECT Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
		FROM dbo.#StockpileListTemp
	END
	ELSE
	BEGIN
		INSERT INTO dbo.#STOCKPILE_LIST
		(
			Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
		)
		SELECT TOP (@iRecordLimit)
			Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
		FROM dbo.#StockpileListTemp
	END
	
	DROP TABLE dbo.#StockpileListTemp
	
	--Summarise DPT Data for the various tonnes balances required		
	INSERT INTO dbo.#DPT_SUMMARY
	(
		Stockpile_Id, Code, Tonnes
	)	
	--Data that IS based ON the Stockpile being the Destination
	SELECT sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END	AS Code,
		Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --JOIN to Dest
			ON (sl.Stockpile_Id = dpt.Destination_Stockpile_Id)
		INNER JOIN dbo.DataTransactionTonnes AS dtt		
			ON (dtt.Data_Transaction_Tonnes_Id = dpt.Data_Transaction_Tonnes_Id)
	WHERE dpt.Data_Process_Transaction_Date Between @Month_Start_Date AND @Month_End_Date 
		AND dpt.Stockpile_Adjustment_Id IS NULL
	GROUP BY sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 
				'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END
	UNION ALL

	--Data that IS based ON the Stockpile being the Source
	SELECT sl.Stockpile_Id, 'REM' AS Code, Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --Join to Source
			ON (sl.Stockpile_Id = dpt.Source_Stockpile_Id)
	WHERE dpt.Data_Process_Transaction_Date BETWEEN @Month_Start_Date AND @Month_End_Date 
		AND dpt.Stockpile_Adjustment_Id IS NULL	
	GROUP BY sl.Stockpile_Id		

	-- Obtain the Approved for the month		
	UPDATE sl
	SET Approved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.#DPT_SUMMARY AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'APP')

	-- Obtain the Unapproved for the month
	UPDATE sl
	SET Unapproved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.#DPT_SUMMARY AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'UNA')

	-- Obtain the Stockpile Added Tonnes for the month
	UPDATE sl
	SET Stockpile_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.#DPT_SUMMARY AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'ADD')

	-- Obtain the Removed Tonnes for the month
	UPDATE sl
	SET Removed_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.#DPT_SUMMARY AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'REM')	--Get the key Records for Stockpile Balance that will be used for current tonnes and grade pivoting

	--Retrieve the balance records that are used, in order to get the current tonnes
	--and also retrieve grades IF requested to (reason for the key being stored)
	INSERT INTO dbo.#BALANCE_SUMMARY
	(
		Data_Process_Stockpile_Balance_Id, Stockpile_Id, Tonnes
	)
	SELECT d.Data_Process_Stockpile_Balance_Id, sl.Stockpile_Id, d.Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.StockpileBuild AS b 
			ON (sl.Stockpile_Id = b.Stockpile_Id)
		INNER JOIN dbo.DataProcessStockpileBalance AS d
			ON (b.Stockpile_Id = d.Stockpile_Id
				AND b.Build_Id = d.Build_Id
				AND b.Last_Recalc_Date = d.Data_Process_Stockpile_Balance_Date 
				AND b.Last_Recalc_Shift = d.Data_Process_Stockpile_Balance_Shift)

	--Get the Current Tonnes Value by Regrouping the data
	UPDATE sl
	SET Current_Tonnes = dsb.Current_Tonnes
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN
		(
			SELECT bs.Stockpile_Id,
				Sum(bs.Tonnes) AS Current_Tonnes
			FROM dbo.#BALANCE_SUMMARY AS bs
			GROUP BY bs.Stockpile_Id
		
		) dsb
		ON dsb.Stockpile_Id = sl.Stockpile_Id
		
	-- Add the last adjustment date AND description
	UPDATE sl
	SET sl.Last_Adjustment_Date = 
		(
			SELECT TOP 1 sa.Adjustment_Date
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		),
		sl.Last_Adjustment_Description = 
		(
			SELECT Top 1 sa.Description
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		)
	FROM dbo.#STOCKPILE_LIST AS sl
							
	--Only Pivot Grades if Required to
	IF @iInclude_Grades = 1
	BEGIN
		--EXTRACT GRADES FROM BALANCE DATA

		--Now Populate the stockpile grades table using the balance details collected
		INSERT INTO dbo.#STOCKPILE_LIST_GRADE
		(
			Stockpile_Id, Grade_Name,
			Grade_Value
		)
		SELECT BS.Stockpile_Id, G.Grade_Name, 
			Sum(BS.Tonnes * DPSBG.Grade_Value) / NullIf(Sum(BS.Tonnes), .00) AS Grade_Value
		FROM #BALANCE_SUMMARY AS BS
			INNER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
				ON DPSBG.Data_Process_Stockpile_Balance_Id = BS.Data_Process_Stockpile_Balance_Id
			INNER JOIN dbo.Grade AS G
				ON DPSBG.Grade_Id = G.Grade_Id
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		GROUP BY BS.Stockpile_Id, G.Grade_Name

		UNION ALL

		--Dummy Grade Values Ensure All Grade are Pivoted
		SELECT -1 AS Stockpile_Id, G.Grade_Name, Null AS Grade_Value
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

		--Pivot Grades Onto Main table
		EXEC dbo.PivotTable
			@iTargetTable='#STOCKPILE_LIST',
			@iPivotTable='#STOCKPILE_LIST_GRADE',
			@iJoinColumns='dbo.#STOCKPILE_LIST.Stockpile_Id = dbo.#STOCKPILE_LIST_GRADE.Stockpile_Id',
			@iPivotColumn='Grade_Name',
			@iPivotValue='Grade_Value',
			@iPivotType='REAL'			
	END							

	-- Return the dataset with its stockpile groups if they exist (denormalised dataset here with many groups potentially)
	SELECT Coalesce(sg.Stockpile_Group_Id, 'Stockpiles NOT Grouped') AS Stockpile_Group_Id,
		sl.*, --May Include Grades
		mt.Description AS Material_Type_Description,
		mt.Native_Alternative,		
		mt.Abbreviation,		
		mtg.Order_No,		
		mt.Is_Waste			
	FROM dbo.#STOCKPILE_LIST AS sl
		INNER JOIN dbo.MaterialType AS mt
			ON (mt.Material_Type_Id = sl.Material_Type_Id)
		INNER JOIN dbo.MaterialTypeGroup AS mtg
			ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		LEFT OUTER JOIN dbo.StockpileGroupStockpile AS sgs 
			INNER JOIN dbo.StockpileGroup AS sg
				ON (sgs.Stockpile_Group_Id = sg.Stockpile_Group_Id
					--Stockpile Ggroup Requires refiltering here, otherwise if a specific stockpile group is filtered for ealier
					--AND stockpile belongs to that group and another, the extra groups will also be returned
					AND sg.Stockpile_Group_Id = IsNull(@iStockpile_Group_Id, sg.Stockpile_Group_Id))
			--Only JOIN To stockpile GROUP IF indicated BY filter options
			ON (sgs.Stockpile_Id = CASE
									WHEN @iGroup_By_Stockpile_Groups = 0
										THEN NULL --Do not join to Stockpile group No stockpile Groups/Duplicates will be returned
									ELSE sl.Stockpile_Id --Each stockpile will be listed with each group to which it belongs
								END)
	-- Sort Type Ordering Configuration
	-- 1 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Stockpile_Name
	-- 2 = ORDER BY Coalesce(sg.Order_No, 10000), mt.Native_Alternative, sl.Stockpile_Name
	-- 3 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Description
	-- 4 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Order_No, mt.Is_Waste, mt.Abbreviation, sl.Description
	ORDER BY Coalesce(sg.Order_No, 10000), --sort position 1
		CASE @iSort_Type --sort position 2
			WHEN 1 THEN sl.Stockpile_Name
			WHEN 2 THEN mt.Native_Alternative
			WHEN 3 THEN sl.Description
			WHEN 4 THEN Cast(mtg.Order_No AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 3
			WHEN 2 THEN sl.Stockpile_Name
			WHEN 4 THEN Cast(mt.Is_Waste AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 4
			WHEN 4 THEN mt.Abbreviation
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 5
			WHEN 4 THEN sl.Description
			ELSE '0' --no further sort defined 
		END		
	
	DROP TABLE dbo.#STOCKPILE_LIST
	DROP TABLE dbo.#DPT_SUMMARY
	DROP TABLE dbo.#BALANCE_SUMMARY
	DROP TABLE dbo.#STOCKPILE_LIST_GRADE

	COMMIT TRANSACTION	
END
GO
GRANT EXECUTE ON dbo.GetStockpileList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileList">
 <Procedure>
	Returns the list of stockpile details.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileLocation.prc'
GO

If object_id('dbo.GetStockpileLocation') is not Null 
     Drop Procedure dbo.GetStockpileLocation 
Go 

CREATE Procedure dbo.GetStockpileLocation
(
	@iStockpile_Id Int
)

With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetStockpileLocation
--
--  Purpose: Retrieves a record set of all the locations in all Hierarchies 
--				belonging to a digblock.
--  Parameters: @iStockpile_Id - The digblock
--
--  Comments: 
--  
--  Modified By:		Murray Hipper
--  Modified Date: 		13 February 2007
--
------------------------------------------------------------------------------*/
Begin
	Set Nocount On
		
	Declare @Loop Int
	Declare @LocationStructure Table 
	(
		Lvl Int,
		Parent_Location_Id Int,
		Location_Id Int,
		Name Varchar(31),
		Location_Type_Id TINYINT,
		Location_Type_Description Varchar(255) collate Database_Default
	)
	Set @Loop = 0

	Insert Into @LocationStructure
	Select 0, L.Parent_Location_Id, L.Location_Id, L.Name, L.Location_Type_Id, LT.Description
	From StockpileLocation SL
		Inner Join Location L
			On SL.Location_Id = L.Location_Id
		Inner Join LocationType LT
			On L.Location_Type_Id = LT.Location_Type_Id
	Where SL.Stockpile_Id = @iStockpile_Id

	While Exists (Select * From @LocationStructure Where Lvl = @Loop)
	Begin

		Insert Into @LocationStructure
		Select Lvl + 1, L.Parent_Location_Id, L.Location_Id, L.Name, L.Location_Type_Id, LT.Description
		From @LocationStructure LS
			Inner Join Location L
				On LS.Parent_Location_Id = L.Location_Id
			Inner Join LocationType LT
				On L.Location_Type_Id = LT.Location_Type_Id
		Where Lvl = @Loop

	Set @Loop = @Loop + 1
	End

	Select *
	From @LocationStructure
	Order By Lvl Desc

End
Go
GRANT EXECUTE ON dbo.GetStockpileLocation TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileLocation">
 <Procedure>
	Returns the list of locations of the stockpile @iStockpile_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileStates.prc'
GO

If Object_Id('dbo.GetStockpileStates') Is Not Null
	Drop Procedure dbo.GetStockpileStates
Go

Create Procedure dbo.GetStockpileStates

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Get the list of stockpile details */
	Select Stockpile_State_Id, Description
	From StockpileState
	Order By Stockpile_State_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetStockpileStates TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileStates">
 <Procedure>
	Returns a list of stockpile state records.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileStockpileTypePeriodList.prc'
GO

If object_id('dbo.GetStockpileStockpileTypePeriodList') is not Null 
     Drop Procedure dbo.GetStockpileStockpileTypePeriodList 
Go 
  
Create Procedure dbo.GetStockpileStockpileTypePeriodList 
( 
    @iStockpile_Id Int = Null 
) 
As 
Begin 
    Set NoCount On 

    Select ST.Stockpile_Id, ST.Stockpile_Type_Id,
		(
			--Give me the highest possible start_date that is less than my end date
			--But if I dont have an end date just give me the max
			Select Top 1 DateAdd(d, 1, ST2.End_Date) As Start_Date
			From dbo.StockpileStockpileTypePeriod As ST2
			Where ST2.Stockpile_Id = ST.Stockpile_Id
				And (DateAdd(d, 1, ST2.End_Date) < ST.End_Date
					Or ST.End_Date Is Null)
			Order by Start_Date Desc
		) As Start_Date, ST.End_Date
	From dbo.StockpileStockpileTypePeriod As ST
	Where ST.Stockpile_Id = IsNull(@iStockpile_Id, ST.Stockpile_Id)
	Order by Stockpile_Id, Start_Date
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileStockpileTypePeriodList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileStockpileTypePeriodList">
 <Procedure>
	Returns a list of stockpile type periods.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileTypeList.prc'
GO

If Object_Id('dbo.GetStockpileTypeList') Is Not Null
	Drop Procedure dbo.GetStockpileTypeList
Go

Create Procedure dbo.GetStockpileTypeList

With Encryption 
As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Select Stockpile_Type_Id, Description
	From StockpileType
	Order By Stockpile_Type_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go

GRANT EXECUTE ON dbo.GetStockpileTypeList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileTypeList">
 <Procedure>
	Returns a list of Stockpile types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpile.prc'
GO

IF OBJECT_ID('dbo.GetStockpile') IS NOT NULL
	DROP PROCEDURE dbo.GetStockpile
GO

CREATE PROCEDURE dbo.GetStockpile
(
	@iStockpile_Id INT,
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
	
	DECLARE @Stockpile TABLE
	(
		Stockpile_Id INT,
		Stockpile_Name VARCHAR(31) COLLATE Database_Default,
		Description VARCHAR(255) COLLATE Database_Default,
		Notes VARCHAR(4095) COLLATE Database_Default,
		Creation_DateTime DATETIME,
		Is_Multi_Build BIT,
		Is_Multi_Component BIT,
		Is_Visible BIT,
		Is_In_Reports BIT,
		Max_Tonnes Float,
		Material_Type_Id INT,
		Material_Type VARCHAR(63) COLLATE Database_Default,
		Stockpile_Type_Id VARCHAR(31) COLLATE Database_Default,
		Start_Date DATETIME,
		Start_Shift Char(1) COLLATE Database_Default,
		Start_Shift_Name VARCHAR(31) COLLATE Database_Default,
		End_Date DATETIME,
		End_Shift Char(1) COLLATE Database_Default,
		End_Shift_Name VARCHAR(31) COLLATE Database_Default,
		Stockpile_State_Id VARCHAR(10) COLLATE Database_Default,
		Last_Adjustment_Date DATETIME,
		Last_Adjustment_Description VARCHAR(255),
		Tonnes Float
	)
		
	INSERT INTO @Stockpile
	(
		Stockpile_Id, Stockpile_Name, Description, Notes, 
		Creation_DATETIME, Is_Multi_Build, Is_Multi_Component,
		Is_Visible, Is_In_Reports, Max_Tonnes, Material_Type_Id, Material_Type,
		Stockpile_Type_Id
	)
	SELECT S.Stockpile_Id, S.Stockpile_Name, S.Description, S.Notes, 
		S.Creation_DateTime, S.Is_Multi_Build, S.Is_Multi_Component,
		S.Is_Visible, S.Is_In_Reports, S.Max_Tonnes, S.Material_Type_Id, MT.Description,
		STP.Stockpile_Type_Id
	FROM dbo.Stockpile AS S
		INNER JOIN dbo.MaterialType AS MT
			ON (S.Material_Type_Id = MT.Material_Type_Id)
		LEFT OUTER JOIN dbo.StockpileStockpileTypePeriod AS STP
			ON (S.Stockpile_Id = STP.Stockpile_Id
				AND (STP.End_Date IS NULL 
					OR STP.End_Date >= GETDATE()))
	WHERE S.Stockpile_Id = @iStockpile_Id
		
	--Get the earliest starting build's start date
	UPDATE S
	SET Start_Date = AGG.Start_Date,
		Start_Shift = AGG.Start_Shift,
		Start_Shift_Name = AGG.Name
	FROM @Stockpile AS S
		INNER JOIN 
			(
				SELECT TOP 1 B.Start_Date, B.Start_Shift, 
					ST.Name, B.Stockpile_Id
				FROM dbo.StockpileBuild AS B
					INNER JOIN dbo.ShiftType AS ST 
						ON B.Start_Shift = ST.Shift
				WHERE Stockpile_Id = @iStockpile_Id
				ORDER BY B.Start_Date ASC, ST.Order_No ASC
			) AS AGG
			ON (S.Stockpile_Id = AGG.Stockpile_Id)
		
	--Get the last ending build AS long AS no other builds 
	--not in a closed state
	IF NOT EXISTS 
		(
			SELECT 1 
			FROM dbo.StockpileBuild AS B
			WHERE B.Stockpile_State_Id <> 'CLOSED'
				AND B.Stockpile_Id = @iStockpile_Id
		)
	BEGIN
		UPDATE S
		SET End_Date = AGG.End_Date,
			End_Shift = AGG.End_Shift,
			End_Shift_Name = AGG.Name, 
			Stockpile_State_Id = 'CLOSED'
		FROM @Stockpile AS S
			INNER JOIN 
				(
					SELECT TOP 1 B.End_Date, B.End_Shift, 
						ST.Name, B.Stockpile_Id
					FROM dbo.StockpileBuild AS B
						INNER JOIN dbo.ShiftType AS ST 
							ON B.End_Shift = ST.Shift
					WHERE Stockpile_Id = @iStockpile_Id
					ORDER BY B.End_Date Desc, ST.Order_No DESC
				) AS AGG
				ON (S.Stockpile_Id = AGG.Stockpile_Id)
	END
	ELSE
	BEGIN
		--The status of the stockpile is always determined by the 
		--last build that is not in the closed state
		UPDATE S
		SET Stockpile_State_Id = AGG.Stockpile_State_Id
		FROM @Stockpile AS S
			INNER JOIN
				(

					SELECT TOP 1 Stockpile_Id, Stockpile_State_Id
					FROM dbo.StockpileBuild AS B
					WHERE B.Stockpile_Id = @iStockpile_Id
						AND B.Stockpile_State_Id <> 'CLOSED'
					ORDER BY B.Build_Id DESC
				) AS AGG
				ON (S.Stockpile_Id = AGG.Stockpile_Id)
	END

	--Get the aggregated tonnes balance of the stockpile
	UPDATE S
	SET Tonnes = AGG.Tonnes
	FROM @Stockpile AS S
		INNER JOIN
			(
				SELECT S.Stockpile_Id, SUM(DPSB.Tonnes) AS Tonnes
				FROM dbo.Stockpile AS S
					INNER JOIN dbo.StockpileBuild AS B
						ON S.Stockpile_Id = B.Stockpile_Id
					INNER JOIN dbo.DataProcessStockpileBalance AS DPSB
						ON B.Stockpile_Id = DPSB.Stockpile_Id
							AND B.Build_Id = DPSB.Build_Id
							AND DPSB.Data_Process_Stockpile_Balance_Date = B.Last_Recalc_Date
							AND DPSB.Data_Process_Stockpile_Balance_Shift = B.Last_Recalc_Shift
				WHERE S.Stockpile_Id = @iStockpile_Id
				GROUP BY S.Stockpile_Id
			) AS AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id)

	-- Get the Last Adjustment Data
	UPDATE S
	Set S.Last_Adjustment_Date = SA.Adjustment_Date,
		S.Last_Adjustment_Description = SA.Description
	FROM @Stockpile AS S
		INNER JOIN
			(
				SELECT Top 1 Stockpile_Id, Adjustment_Date, Description
				FROM dbo.StockpileAdjustment
				WHERE Stockpile_Id = @iStockpile_Id
				ORDER BY Adjustment_Date DESC
			) AS SA
			ON (S.Stockpile_Id = SA.Stockpile_Id)
	
	--Return Stockpiles
	SELECT *
	FROM @Stockpile

	--Return the aggregated Grades
	SELECT S.Stockpile_Id, G.Grade_Id, G.Grade_Name, 
		SUM(DPSBG.Grade_Value * DPSB.Tonnes) / NULLIF(SUM(DPSB.Tonnes), 0) AS Grade_Value
	FROM @Stockpile AS S
		CROSS JOIN dbo.Grade AS G
		INNER JOIN dbo.StockpileBuild AS B
			ON (S.Stockpile_Id = B.Stockpile_Id)
		INNER JOIN dbo.DataProcessStockpileBalance AS DPSB
			ON (B.Stockpile_Id = DPSB.Stockpile_Id
				AND B.Build_Id = DPSB.Build_Id
				AND DPSB.Data_Process_Stockpile_Balance_Date = B.Last_Recalc_Date
				AND DPSB.Data_Process_Stockpile_Balance_Shift = B.Last_Recalc_Shift)
		LEFT OUTER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
			ON (DPSB.Data_Process_Stockpile_Balance_Id = DPSBG.Data_Process_Stockpile_Balance_Id
				AND DPSBG.Grade_Id = G.Grade_Id)
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY S.Stockpile_Id, G.Grade_Id, G.Grade_Name

	--Return Opening Balances
	SELECT S.Stockpile_Id, G.Grade_Id, G.Grade_Name, 
		ISNULL(SUM(SBCG.Grade_Value * SBC.Start_Tonnes) / NULLIF(SUM(SBC.Start_Tonnes), 0), 0) AS Grade_Value, SBC.Start_Tonnes
	FROM @Stockpile AS S			
		INNER JOIN dbo.StockpileBuild AS B
			ON (S.Stockpile_Id = B.Stockpile_Id)
		INNER JOIN dbo.StockpileBuildComponent AS SBC
			ON (S.Stockpile_Id = SBC.Stockpile_Id)
		INNER JOIN dbo.StockpileBuildComponentGrade AS SBCG
			ON (B.Stockpile_Id = SBCG.Stockpile_Id
				AND B.Build_Id = SBCG.Build_Id)
		INNER JOIN dbo.Grade AS G 
			ON (SBCG.Grade_Id = G.Grade_Id)
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
	GROUP BY S.Stockpile_Id, G.Grade_Id, G.Grade_Name, SBC.Start_Tonnes
									 							 
	COMMIT TRANSACTION
END
GO
GRANT EXECUTE ON dbo.GetStockpile TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpile">
 <Procedure>
	Returns the stockpile record for a given stockpile and build.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetSystemSetting.prc'
GO

IF Object_Id('dbo.GetSystemSetting') IS NOT NULL
	DROP PROCEDURE dbo.GetSystemSetting
GO

CREATE PROCEDURE dbo.GetSystemSetting
(
	@iSetting_Id VARCHAR(63),
	@iValue VARCHAR(255) OUTPUT,
	@iSelectOutValue BIT = 0
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	SET @iValue = NULL

	SELECT @iValue = Value
	FROM Setting
	WHERE Setting_Id = @iSetting_Id

	IF @iSelectOutValue = 1
	BEGIN
		SELECT @iValue AS Setting
	END
END
GO

GRANT EXECUTE ON dbo.GetSystemSetting TO CoreUtilityManager
GRANT EXECUTE ON dbo.GetSystemSetting TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetSystemSetting">
 <Procedure>
	Returns the values for a given Setting.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTerminologyList.prc'
GO

If Object_Id('dbo.GetTerminologyList') Is Not Null
	Drop Procedure dbo.GetTerminologyList
Go

Create Procedure dbo.GetTerminologyList
(
	@iTerminology_Id Varchar(255) = Null
)
With Encryption
As
Begin
	-- Return the list of terms and their local names for the system
	Select Terminology_Id, Site_Terminology, Plural, Shorthand
	From Terminology
	Where Terminology_Id = IsNull(@iTerminology_Id, Terminology_Id)
	Order By Terminology_Id
End
Go
GRANT EXECUTE ON dbo.GetTerminologyList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetTerminologyList">
 <Procedure>
	Returns the entire list or value of the given terminology.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTruckList.prc'
GO

If object_id('dbo.GetTruckList') is not Null 
     Drop Procedure dbo.GetTruckList 
Go 
  
Create Procedure dbo.GetTruckList 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
    
	Select T.Truck_Id, T.Truck_Type_Id, TT.Name As Truck_Type, T.Description, 
		TTFP.Max_Tonnes As Max_Tonnes, 
		TTFP.Ave_Tonnes As Ave_Tonnes, 
		TTFP.Min_Tonnes As Min_Tonnes
	From Truck As T
		Inner Join TruckType As TT
			On T.Truck_Type_Id = TT.Truck_Type_Id
		Left Outer Join dbo.TruckTypeFactorPeriod As TTFP
			On TT.Truck_Type_Id = TTFP.Truck_Type_Id
			And TTFP.End_Date Is Null
	Where T.Truck_Type_Id = TT.Truck_Type_Id
	Order By Truck_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetTruckList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetTruckList">
 <Procedure>
	Returns the a list of trucks and their types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTruck.prc'
GO

If object_id('dbo.GetTruck') is not Null 
     Drop Procedure dbo.GetTruck 
Go 
  
Create Procedure dbo.GetTruck 
( 
    @iTruck_Id Varchar(31) 
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Select T.Truck_Id, T.Truck_Type_Id, TT.Name As Truck_Type, T.Description, 
		TTFP.Max_Tonnes As Max_Tonnes, TTFP.Ave_Tonnes As Ave_Tonnes, 
		TTFP.Min_Tonnes As Min_Tonnes
	From Truck As T
		Inner Join TruckType As TT
			On T.Truck_Type_Id = TT.Truck_Type_Id	
		Left Outer Join dbo.TruckTypeFactorPeriod As TTFP
			On TT.Truck_Type_Id = TTFP.Truck_Type_Id
				And TTFP.End_Date Is Null
	Where TTFP.End_Date is null
		And T.Truck_Id = @iTruck_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetTruck TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetTruck">
 <Procedure>
	Returns the a given truck and its type.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTruckTypeList.prc'
GO

If object_id('dbo.GetTruckTypeList') is not Null 
     Drop Procedure dbo.GetTruckTypeList 
Go 
  
Create Procedure dbo.GetTruckTypeList 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
    
	Select TT.Name, TT.Truck_Type_Id, TT.Description, 
		TTP.Max_Tonnes, TTP.Ave_Tonnes, TTP.Min_Tonnes, TT.Is_Default
	From TruckType As TT
		Left Outer Join TruckTypeFactorPeriod As TTP
			On TT.Truck_Type_Id = TTP.Truck_Type_Id
	Where TTP.End_Date is Null
	Order By TT.Name

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetTruckTypeList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetTruckTypeList">
 <Procedure>
	Returns a list of Truck types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTruckType.prc'
GO

If object_id('dbo.GetTruckType') is not Null 
     Drop Procedure dbo.GetTruckType 
Go 
  
Create Procedure dbo.GetTruckType 
( 
    @iTruck_Type_Id Int 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select TT.Name, TT.Truck_Type_Id, TT.Description, 
		TTP.Max_Tonnes, TTP.Ave_Tonnes, TTP.Min_Tonnes, TT.Is_Default
	From TruckType As TT
		Left Outer Join TruckTypeFactorPeriod As TTP
			On TT.Truck_Type_Id = TTP.Truck_Type_Id
	Where TTP.End_Date is Null
		and TT.Truck_Type_Id = @iTruck_Type_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetTruckType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetTruckType">
 <Procedure>
	Returns the truck type for a given truck.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetTruckTypeFactorPeriodList.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetTruckTypeFactorPeriodList'))
	Drop Procedure dbo.GetTruckTypeFactorPeriodList
Go

CREATE Procedure dbo.GetTruckTypeFactorPeriodList
(
	@iTruck_Type_Id Int = Null
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	-- Get the list of truck type factor periods
	Select TTP.Truck_Type_Id, TTP.End_Date, TTP.Max_Tonnes, TTP.Ave_Tonnes, TTP.Min_Tonnes,
		(Select Max(DateAdd(Day, 1, TTP2.End_Date))
		From TruckTypeFactorPeriod TTP2
		Where TTP.Truck_Type_Id = TTP2.Truck_Type_Id
			And (TTP2.End_Date < TTP.End_Date
				Or TTP.End_Date Is Null
				)
		) As Start_Date
	From TruckTypeFactorPeriod TTP
	Where ((TTP.Truck_Type_Id = @iTruck_Type_Id) Or (@iTruck_Type_Id Is Null))
	Order By TTP.Truck_Type_Id, 
		(Select Max(DateAdd(Day, 1, TTP2.End_Date))
		From TruckTypeFactorPeriod TTP2
		Where TTP.Truck_Type_Id = TTP2.Truck_Type_Id
			And (TTP2.End_Date < TTP.End_Date
				Or TTP.End_Date Is Null
				)
		)


	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetTruckTypeFactorPeriodList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetTruckTypeFactorPeriodList">
 <Procedure>
	Returns the truck type factor period list for a given truck.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetUnapprovedDigblockSurveyList.prc'
GO

If object_id('dbo.GetUnapprovedDigblockSurveyList') is not NULL
	Drop Procedure dbo.GetUnapprovedDigblockSurveyList
Go

Create Procedure dbo.GetUnapprovedDigblockSurveyList
(
	@iDigblock_Survey_Type_Id Int = Null
)
With Encryption As
Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Select Convert(Varchar, Digblock_Survey_Date, 106) As Digblock_Survey_Date, Digblock_Survey_Shift, 
		ST.Name As Shift_Name, DST.Digblock_Survey_Type_Id, DST.Name
	From DigblockSurvey S
		Inner Join DigblockSurveyType DST
			On (S.Digblock_Survey_Type_Id = DST.Digblock_Survey_Type_Id
				and IsNull(DST.Is_Visible, 1) = 1)
		Inner Join ShiftType ST
			On S.Digblock_Survey_Shift = ST.Shift
	Where Is_Approved = 0
	And (S.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id or @iDigblock_Survey_Type_Id is NULL)
	And Exists	(Select *
			From Haulage H
			Where Source_Digblock_Id Is Not Null
			And Child_Haulage_Id is NULL
			And Haulage_State_Id in ('A', 'N')
			And ((H.Haulage_Date < S.Digblock_Survey_Date)
			Or (H.Haulage_Date = S.Digblock_Survey_Date
			And dbo.GetShiftTypeOrderNo(H.Haulage_Shift) <= dbo.GetShiftTypeOrderNo(S.Digblock_Survey_Shift))))
	Order By Cast(Digblock_Survey_Date As Datetime), dbo.GetShiftTypeOrderNo(Digblock_Survey_Shift)

	Set @ELC_Proc_Is_Error = 0

	Commit Transaction

	-- Event_Logging_Placeholder
End
Go
GRANT EXECUTE ON dbo.GetUnapprovedDigblockSurveyList TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetUnapprovedDigblockSurveyList">
 <Procedure>
	Returns a list of unapproved Digblock Survey records.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetUserInterfaceListingFieldList.prc'
GO

If object_id('dbo.GetUserInterfaceListingFieldList') is not Null 
     Drop Procedure dbo.GetUserInterfaceListingFieldList 
Go 
  
Create Procedure dbo.GetUserInterfaceListingFieldList
( 
    @iUser_Interface_Listing_Id Int,
	@iIgnore_Empty_Check bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		If Not Exists
			(
				Select 1 
				From UserInterfaceListingField
				Where User_Interface_Listing_Id = @iUser_Interface_Listing_Id 
			)
			And @iIgnore_Empty_Check = 0 
		Begin
			RaisError('User Interface Listing does not contain any fields.', 16, 1)
		End

		-- Get the list of fields for the given User interface listing
		Select User_Interface_Listing_Field_Id,
			User_Interface_Listing_Id,
			Field_Name, Display_Name, Pixel_Width,
			Is_Visible, Sum_Field, 
			Case When Is_Visible = 1 Then IsNull(Order_No, 99) Else NULL End As Order_No
		From UserInterfaceListingField
		Where User_Interface_Listing_Id = @iUser_Interface_Listing_Id
		--Ensure visible comes first
		Order By (Is_Visible * -1), Order_No, User_Interface_Listing_Field_Id 
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End
Go
GRANT EXECUTE ON dbo.GetUserInterfaceListingFieldList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetUserInterfaceListingFieldList">
 <Procedure>
	Returns User interface fields listings.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetUserInterfaceListingList.prc'
GO

If object_id('dbo.GetUserInterfaceListingList') is not Null 
     Drop Procedure dbo.GetUserInterfaceListingList
Go 

Create Procedure dbo.GetUserInterfaceListingList

With Encryption
As 

Begin 

    Set NoCount On 
    
    -- Get the list of User interface listings
	Select User_Interface_Listing_Id, Display_Name, Internal_Name, Listing_Stored_Procedure
	From UserInterfaceListing
	Order By User_Interface_Listing_Id

End 
Go	
GRANT EXECUTE ON dbo.GetUserInterfaceListingList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetUserInterfaceListingList">
 <Procedure>
	Gets all the User Interface Listing.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetUserInterfaceListingTabList.prc'
GO

If Object_Id('dbo.GetUserInterfaceListingTabList') is not Null 
     Drop Procedure dbo.GetUserInterfaceListingTabList
Go 

Create Procedure dbo.GetUserInterfaceListingTabList
(
	@iUser_Interface_Listing_Tab_Id Varchar(63) = Null
)

With Encryption
As 

Begin 

    Set NoCount On 

    -- Get the list of tabs for the given User interface listing
	Select User_Interface_Listing_Tab_Id, Link,
		Image_Unselected, Image_Selected, Rollover_Text, 
		Option_Id, Application_Id	
	From UserInterfaceListingTab
	Where User_Interface_Listing_Tab_Id = Coalesce(@iUser_Interface_Listing_Tab_Id, User_Interface_Listing_Tab_Id)
	Order By Order_No, User_Interface_Listing_Tab_Id

End 
Go	
GRANT EXECUTE ON dbo.GetUserInterfaceListingTabList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetUserInterfaceListingTabList">
 <Procedure>
	Returns a list of tabs for the given User interface listing.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWasteTypeList.prc'
GO

If Object_Id('dbo.GetWasteTypeList') Is Not Null
	Drop Procedure dbo.GetWasteTypeList
Go

Create Procedure [dbo].[GetWasteTypeList]

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- Get the list of waste types
	Select Waste_Type_Id, Description
	From WasteType
	Order By Waste_Type_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.GetWasteTypeList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetWasteTypeList">
 <Procedure>
	Returns a list of Waste Types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWasteType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.GetWasteType'))
	Drop Procedure dbo.GetWasteType
Go
CREATE Procedure [dbo].[GetWasteType]
(
	@iWaste_Type_Id Varchar(31)
)

With Encryption 
As

Begin

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select Waste_Type_Id, Description
	From WasteType
	Where (Waste_Type_Id = @iWaste_Type_Id)

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.GetWasteType TO CoreUtilityManager

 
/*
<TAG Name="Data Dictionary" ProcedureName="GetWasteType">
 <Procedure>
	Returns the Waste Type @iWaste_Type_Id.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWeightometerList.prc'
GO

If object_id('dbo.GetWeightometerList') Is Not Null
	Drop Procedure dbo.GetWeightometerList
Go

Create Procedure dbo.GetWeightometerList
(
	@iShow_Invisible_Weightometers bit = 0
)
With Encryption As
Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select Weightometer_Id, Description
	From Weightometer
	Where (@iShow_Invisible_Weightometers = 1 or Is_Visible = 1)
	Order By Weightometer_Id

	Set @ELC_Proc_Is_Error = 0

	-- Event_Logging_Placeholder
End
Go
GRANT EXECUTE ON dbo.GetWeightometerList TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetWeightometerList">
 <Procedure>
	Returns a list of visible Weightometers from Weightometer.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWeightometerSampleList.prc'
GO

IF OBJECT_ID('dbo.GetWeightometerSampleList') IS NOT NULL 
	DROP PROCEDURE dbo.GetWeightometerSampleList
GO

CREATE PROCEDURE dbo.GetWeightometerSampleList
(
	@iWeightometer_Id VARCHAR(31) = NULL,
	@iStart_Date DATETIME = NULL,
	@iEnd_Date DATETIME = NULL,
	@iHide_Invisible_Weightometers BIT = 1,
	@iLocation_Id INT = NULL,
	@iRecordLimit INT = NULL,
    @iGrade_Visibility Bit = 1     
)
WITH ENCRYPTION AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Sample TABLE
	(
		Weightometer_Sample_Id INT NOT NULL,
		Weightometer_Id VARCHAR(31) COLLATE Database_Default NOT NULL,
		Weightometer_Sample_Date DATETIME NOT NULL,
		Weightometer_Sample_Shift CHAR(1) COLLATE Database_Default NULL,
		Source VARCHAR(64) COLLATE Database_Default NULL,
		Source_Stockpile_Id INT NULL,
		Source_Build_Id INT NULL,
		Source_Component_Id INT NULL,
		Destination VARCHAR(64) COLLATE Database_Default NULL,
		Destination_Stockpile_Id INT NULL,
		Destination_Build_Id INT NULL, 
		Destination_Component_Id INT NULL
	)
	
	SET NOCOUNT ON

	SELECT @TransactionName = 'dbo.GetWeightometerSampleList',
		@TransactionCount = @@TranCount 
	
	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SELECT ws.Weightometer_Sample_Id, ws.Weightometer_Id, ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift,
			s.Stockpile_Name AS SourceStockpileName, ws.Source_Stockpile_Id, ws.Source_Build_Id, ws.Source_Component_Id,
			d.Stockpile_Name AS DestinationStockpileName, ws.Destination_Stockpile_Id, ws.Destination_Build_Id, ws.Destination_Component_Id
		INTO dbo.#SampleTemp
		FROM dbo.WeightometerSample AS ws
			INNER JOIN dbo.Weightometer AS w
				ON (ws.Weightometer_Id = w.Weightometer_Id)
			LEFT OUTER JOIN dbo.Stockpile AS s
				ON (ws.Source_Stockpile_Id = s.Stockpile_Id)
			LEFT OUTER JOIN dbo.Stockpile AS d
				ON (ws.Destination_Stockpile_Id = d.Stockpile_Id)
			LEFT OUTER JOIN dbo.WeightometerLocation AS wl
				ON (ws.Weightometer_Id = WL.Weightometer_Id)
		WHERE ws.Weightometer_Sample_Date BETWEEN ISNULL(@iStart_Date, ws.Weightometer_Sample_Date) AND ISNULL(@iEnd_Date, ws.Weightometer_Sample_Date)
			AND ws.Weightometer_Id = ISNULL(@iWeightometer_Id, ws.Weightometer_Id)
			--IF 1 THEN show only Is_Visible = 1 else show everything aka (Is_Visible = Is_Visible)
			AND w.Is_Visible = ISNULL(NULLIF(@iHide_Invisible_Weightometers, 0), w.Is_Visible)
			AND 
			(
				@iLocation_Id IS NULL
				OR wl.Location_Id IN
					(
						SELECT Location_Id 
						FROM dbo.GetLocationSubtree(@iLocation_Id)
					)
			)

		IF @iRecordLimit IS NULL
		BEGIN
			INSERT INTO @Sample
			(
				Weightometer_Sample_Id, Weightometer_Id, Weightometer_Sample_Date, Weightometer_Sample_Shift,
				Source, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
				Destination, Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id
			)
			SELECT Weightometer_Sample_Id, Weightometer_Id, Weightometer_Sample_Date, Weightometer_Sample_Shift,
				SourceStockpileName, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
				DestinationStockpileName, Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id
			FROM dbo.#SampleTemp
			ORDER BY Weightometer_Sample_Id
		END
		ELSE
		BEGIN
			INSERT INTO @Sample
			(
				Weightometer_Sample_Id, Weightometer_Id, Weightometer_Sample_Date, Weightometer_Sample_Shift,
				Source, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
				Destination, Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id
			)
			SELECT TOP (@iRecordLimit)
				Weightometer_Sample_Id, Weightometer_Id, Weightometer_Sample_Date, Weightometer_Sample_Shift,
				SourceStockpileName, Source_Stockpile_Id, Source_Build_Id, Source_Component_Id,
				DestinationStockpileName, Destination_Stockpile_Id, Destination_Build_Id, Destination_Component_Id
			FROM dbo.#SampleTemp
			ORDER BY Weightometer_Sample_Id
		END

		DROP TABLE dbo.#SampleTemp

		-- Get Current Weightometer Flow Period Resolutions
		UPDATE s
		SET Source = 'Default (' + Coalesce(s.Source, s2.Stockpile_Name, wfp.Source_Crusher_Id, wfp.Source_Mill_Id, 'Invalid Default') + ')', 
			Source_Stockpile_Id = ISNULL(s.Source_Stockpile_Id, wfp.Source_Stockpile_Id),
			Destination =  'Default (' + Coalesce(s.Destination, d.Stockpile_Name, wfp.Destination_Crusher_Id, wfp.Destination_Mill_Id, 'Invalid Default') + ')',
			Destination_Stockpile_Id = ISNULL(s.Destination_Stockpile_Id, wfp.Destination_Stockpile_Id)
		FROM @Sample AS S
			INNER JOIN dbo.WeightometerFlowPeriod AS wfp
				ON (wfp.Weightometer_Id = s.Weightometer_Id)
			LEFT OUTER JOIN dbo.Stockpile AS s2
				ON (wfp.Source_Stockpile_Id = s2.Stockpile_Id)
			LEFT OUTER JOIN dbo.Stockpile AS d
				ON (wfp.Destination_Stockpile_Id = d.Stockpile_Id)
			INNER JOIN 
				(
					SELECT s.Weightometer_Sample_Id, Max(ISNULL(wfp.End_Date, '2999-01-01')) AS End_Date
					FROM @Sample AS s
						INNER JOIN dbo.WeightometerFlowPeriod AS wfp
							ON (wfp.Weightometer_Id = s.Weightometer_Id)
					GROUP BY s.Weightometer_Sample_Id
				) AS agg
				ON (agg.Weightometer_Sample_Id = s.Weightometer_Sample_Id
					AND (wfp.End_Date = agg.End_Date 
						OR (agg.End_Date = '2999-01-01'
							AND wfp.End_Date IS NULL))) 
		WHERE s.Source IS NULL
			OR s.Destination IS NULL

		--Get Missing Builds
		UPDATE s
		SET Source_Build_Id = dbo.GetBuildableStockpileBuild(s.Source_Stockpile_Id, 
			s.Weightometer_Sample_Date, s.Weightometer_Sample_Shift)
		FROM @Sample AS s
		WHERE Source_Build_Id IS NULL 

		UPDATE s
		SET Destination_Build_Id = dbo.GetBuildableStockpileBuild(s.Source_Stockpile_Id, 
			s.Weightometer_Sample_Date, s.Weightometer_Sample_Shift)
		FROM @Sample AS s
		WHERE Destination_Build_Id IS NULL 

		--Get Missing Components
		UPDATE s
		SET Source_Component_Id = agg.Component_Id
		FROM @Sample AS s
			INNER JOIN 
				(
					SELECT s.Weightometer_Sample_Id, Max(sbc.Component_Id) AS Component_Id
					FROM @Sample AS s
						INNER JOIN dbo.StockpileBuildComponent AS sbc
							ON (sbc.Stockpile_Id = s.Source_Stockpile_Id
								AND sbc.Build_Id = s.Source_Build_Id)
					GROUP BY s.Weightometer_Sample_Id
				) AS agg
				ON (s.Weightometer_Sample_Id = agg.Weightometer_Sample_Id)
		WHERE Source_Component_Id IS NULL  

		UPDATE s
		SET Destination_Component_Id = agg.Component_Id
		FROM @Sample AS s
			INNER JOIN 
				(
					SELECT s.Weightometer_Sample_Id, Max(sbc.Component_Id) AS Component_Id
					FROM @Sample AS s
						INNER JOIN dbo.StockpileBuildComponent AS sbc
							ON (sbc.Stockpile_Id = s.Destination_Stockpile_Id
								AND sbc.Build_Id = s.Destination_Build_Id)
					GROUP BY s.Weightometer_Sample_Id
				) AS agg
				ON (s.Weightometer_Sample_Id = agg.Weightometer_Sample_Id)
		WHERE Destination_Component_Id IS NULL  

		-- Sample Data SET
		SELECT s.Weightometer_Sample_Id, s.Weightometer_Id, s.Weightometer_Sample_Date,
			s.Weightometer_Sample_Shift, ws.Order_No, ws.Tonnes, ws.Corrected_Tonnes,
			s.Source, s.Source_Stockpile_Id, s.Source_Build_Id, s.Source_Component_Id,
			s.Destination, s.Destination_Stockpile_Id, s.Destination_Build_Id, s.Destination_Component_Id,
			st.Name AS Shift_Name, ISNULL(st.Order_No, -1) AS Shift_Order_No
		FROM dbo.WeightometerSample AS ws
			INNER JOIN @Sample AS s
				ON (ws.Weightometer_Sample_Id = s.Weightometer_Sample_Id)
			INNER JOIN dbo.Weightometer AS w
				ON (ws.Weightometer_Id = w.Weightometer_Id)
			LEFT JOIN dbo.ShiftType AS st
				ON (ws.Weightometer_Sample_Shift = st.Shift)
		ORDER BY ws.Weightometer_Sample_Date DESC, ISNULL(st.Order_No, -1) DESC,
			ws.Weightometer_Id, ws.Order_No
				
		-- Grades Data SET
		SELECT ws.Weightometer_Sample_Id, wsg.Grade_Id, g.Grade_Name, wsg.Grade_Value
		FROM dbo.WeightometerSample AS ws
			INNER JOIN @Sample AS s
				ON (ws.Weightometer_Sample_Id = s.Weightometer_Sample_Id)
			INNER JOIN dbo.WeightometerSampleGrade AS wsg
				ON (ws.Weightometer_Sample_Id = wsg.Weightometer_Sample_Id)
			INNER JOIN dbo.Grade AS g
				ON (wsg.Grade_Id = g.Grade_Id)
			INNER JOIN dbo.Weightometer AS w
				ON (ws.Weightometer_Id = w.Weightometer_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility OR @iGrade_Visibility IS NULL)		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetWeightometerSampleList TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetWeightometerSampleList">
 <Procedure>
	Returns list of records from WeightometerSample.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWeightometerSample.prc'
GO

IF object_id('dbo.GetWeightometerSample') IS NOT NULL 
	DROP PROCEDURE dbo.GetWeightometerSample
GO

CREATE PROCEDURE dbo.GetWeightometerSample
(
	@iWeightometer_Sample_Id INT,
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	--Sample Data SET
	SELECT WS.Weightometer_Sample_Id, WS.Weightometer_Id, WS.Weightometer_Sample_Date,
		WS.Weightometer_Sample_Shift, WS.Order_No, WS.Tonnes, WS.Corrected_Tonnes,
		WS.Source_Stockpile_Id, WS.Source_Build_Id, WS.Source_Component_Id,
		WS.Destination_Stockpile_Id, WS.Destination_Build_Id, WS.Destination_Component_Id,
		SOURCE.Stockpile_Name AS Source_Stockpile_Name, 
		DESTINATION.Stockpile_Name AS Destination_Stockpile_Name,
		ST.Name AS Shift_Name
	FROM dbo.WeightometerSample AS WS
		INNER JOIN dbo.Weightometer AS W
			ON WS.Weightometer_Id = W.Weightometer_Id
		LEFT JOIN dbo.ShiftType AS ST
			ON WS.Weightometer_Sample_Shift = ST.Shift
		LEFT OUTER JOIN dbo.Stockpile AS SOURCE
			ON WS.Source_Stockpile_Id = SOURCE.Stockpile_Id
		LEFT OUTER JOIN dbo.Stockpile AS DESTINATION
			ON WS.Destination_Stockpile_Id = DESTINATION.Stockpile_Id
	WHERE WS.Weightometer_Sample_Id = @iWeightometer_Sample_Id

	--Grades Data Set
	SELECT WS.Weightometer_Sample_Id, WSG.Grade_Id, G.Grade_Name, WSG.Grade_Value
	FROM dbo.WeightometerSample AS WS
		INNER JOIN dbo.WeightometerSampleGrade AS WSG
			ON (WS.Weightometer_Sample_Id = WSG.Weightometer_Sample_Id)
		INNER JOIN dbo.Grade AS G
			ON (WSG.Grade_Id = G.Grade_Id)
	WHERE WS.Weightometer_Sample_Id = @iWeightometer_Sample_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
END
GO
GRANT EXECUTE ON dbo.GetWeightometerSample TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetWeightometerSample">
 <Procedure>
	Returns records from WeightometerSample.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetWeightometerSampleListPivoted.prc'
GO

IF OBJECT_ID('dbo.GetWeightometerSampleListPivoted') IS NOT NULL
	DROP PROCEDURE dbo.GetWeightometerSampleListPivoted
GO

CREATE PROCEDURE dbo.GetWeightometerSampleListPivoted
(
	@iWeightometer_Id VARCHAR(31) = NULL,
	@iStart_Date DATETIME = NULL,
	@iEnd_Date DATETIME = NULL,
	@iHide_Invisible_Weightometers BIT = 1,
	@iLocation_Id INT = NULL,
	@iRecordLimit INT = NULL
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON
	
	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
	
	CREATE TABLE dbo.#SAMPLES
	(
		Weightometer_Sample_Date DATETIME NULL,
		Weightometer_Sample_Shift CHAR(1) COLLATE Database_Default NULL
	)

	CREATE TABLE dbo.#SAMPLES_DATA
	(
		Weightometer_Sample_Date DATETIME NULL,
		Weightometer_Sample_Shift CHAR(1) COLLATE Database_Default NULL, 
		Weightometer_Id VARCHAR(31) COLLATE Database_Default NULL,
		Tonnes FLOAT NULL
	)

	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT @iRecordLimit
	END

	INSERT INTO dbo.#SAMPLES
	(
		Weightometer_Sample_Date, Weightometer_Sample_Shift
	)
	SELECT ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift
	FROM dbo.WeightometerSample AS ws
		INNER JOIN dbo.Weightometer AS w
			ON (ws.Weightometer_Id = w.Weightometer_Id)
	WHERE ws.Weightometer_Sample_Date BETWEEN IsNull(@iStart_Date, ws.Weightometer_Sample_Date) AND IsNull(@iEnd_Date, ws.Weightometer_Sample_Date)
	GROUP BY ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift
	ORDER BY ws.Weightometer_Sample_Date, dbo.GetShiftTypeOrderNo(ws.Weightometer_Sample_Shift)

	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT 0
	END

	INSERT INTO dbo.#SAMPLES_DATA
	(
		Weightometer_Sample_Date, Weightometer_Sample_Shift,
		Weightometer_Id, Tonnes
	)
	SELECT NULL, NULL, w.Weightometer_Id, NULL
	FROM dbo.Weightometer AS w
		LEFT OUTER JOIN dbo.WeightometerLocation AS wl 
			ON (w.Weightometer_Id = wl.Weightometer_Id)
	WHERE w.Is_Visible = IsNull(NullIf(@iHide_Invisible_Weightometers, 0), w.Is_Visible)
		AND w.Weightometer_Id = IsNull(@iWeightometer_Id, w.Weightometer_Id)
		AND 
		(
			@iLocation_Id IS NULL
				OR wl.Location_Id in 
				(
					SELECT Location_Id 
					FROM dbo.GetLocationSubtree(@iLocation_Id)
				)
		)
	UNION ALL
	SELECT ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift,
		ws.Weightometer_Id, Sum(IsNull(Corrected_Tonnes, Tonnes))
	FROM dbo.WeightometerSample AS ws
		INNER JOIN dbo.#SAMPLES AS s
			ON (s.Weightometer_Sample_Date = ws.Weightometer_Sample_Date
				AND s.Weightometer_Sample_Shift = ws.Weightometer_Sample_Shift)
		INNER JOIN dbo.Weightometer AS w
			ON (ws.Weightometer_Id = w.Weightometer_Id)
		LEFT OUTER JOIN dbo.WeightometerLocation AS wl 
			ON (w.Weightometer_Id = wl.Weightometer_Id)
	WHERE ws.Weightometer_Id = IsNull(@iWeightometer_Id, ws.Weightometer_Id)
		--IF 1 THEN show only Is_Visible = 1 else show everything aka (Is_Visible = Is_Visible)
		AND w.Is_Visible = IsNull(NullIf(@iHide_Invisible_Weightometers, 0), w.Is_Visible)
		AND 
		(
			@iLocation_Id IS NULL
				OR wl.Location_Id in 
				(
					SELECT Location_Id 
					FROM dbo.GetLocationSubtree(@iLocation_Id)
				)
		)
	GROUP BY ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift, ws.Weightometer_Id

	EXEC dbo.PivotTable
		@iTargetTable = '#SAMPLES',
		@iPivotTable = '#SAMPLES_DATA',
		@iJoinColumns = 'dbo.#SAMPLES.Weightometer_Sample_Date = dbo.#SAMPLES_DATA.Weightometer_Sample_Date AND dbo.#SAMPLES.Weightometer_Sample_Shift = dbo.#SAMPLES_DATA.Weightometer_Sample_Shift',
		@iPivotColumn = 'Weightometer_Id',
		@iPivotValue = 'Tonnes',
		@iPivotType = 'FLOAT'

	SELECT ws.*, st.Name AS Shift_Name, IsNull(st.Order_No, -1) AS Shift_Order_No
	FROM dbo.#SAMPLES AS ws
		LEFT OUTER JOIN dbo.ShiftType AS st
			ON (ws.Weightometer_Sample_Shift = st.Shift)
	ORDER BY ws.Weightometer_Sample_Date, IsNull(st.Order_No, -1)

	DROP TABLE dbo.#SAMPLES
	DROP TABLE dbo.#SAMPLES_DATA

	COMMIT TRANSACTION
END
GO
GRANT EXECUTE ON dbo.GetWeightometerSampleListPivoted TO CoreUtilityManager
/*
<TAG Name="Data Dictionary" ProcedureName="GetWeightometerSampleListPivoted">
 <Procedure>
	Returns list of records from WeightometerSample with the grades.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.InitDigblockSurveyProcess.prc'
GO

IF OBJECT_ID('dbo.InitDigblockSurveyProcess') IS NOT NULL 
     DROP PROCEDURE dbo.InitDigblockSurveyProcess 
GO 
  
CREATE PROCEDURE dbo.InitDigblockSurveyProcess 
( 
    @iDigblock_Survey_Id INT 
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
	DECLARE @Digblock_Survey_Date DATETIME,
		@Digblock_Survey_Shift CHAR(1),
		@Digblock_Survey_Type_Id INT,
		@Prev_Survey_Date DATETIME,
		@Prev_Survey_Shift CHAR(1),
		@Prev_Survey_Id INT,
		@Start_Date DATETIME,
		@Start_Shift CHAR(1),
		@Is_Approved BIT,
		@Digblock_Survey_Summary_Id INT,
		@Record_No INT,
		@SurveyLocation VARCHAR(31),
		@MaxRecordNo INT,
		@CurrentMonth DATETIME

   	BEGIN TRY
		-- requires the following:
		-- 1. The DigblockSurvey record must already exist
		-- 2. The DigblockSurvey record must not be approved
		-- 3. The DigblockSurvey record must not fall within an approved month (MonthlyApproval)

		--Check to see if the given digblock survey exists
		SELECT @Digblock_Survey_Date = Digblock_Survey_Date,
			@Digblock_Survey_Shift = Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id,
			@Is_Approved = Is_Approved
		FROM dbo.DigblockSurvey
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id	

		IF @Digblock_Survey_Date IS NULL
		BEGIN
			Raiserror ('The digblock survey does NOT exist', 16, 1)
		END
		
		--Check for approval
		IF @Is_Approved = 1
		BEGIN
			Raiserror ('The given survey date has already been approved', 16, 1)
		END
		
		--Get Parent Location type for Survey
		SELECT @SurveyLocation = Location_Type_Id
		FROM DigblockSurveyType
		WHERE Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id

		-- Get the last survey date and shift before this one
		EXEC dbo.GetPreviousDigblockSurveyDate
			@Survey_Date = @Digblock_Survey_Date,
			@Survey_Shift = @Digblock_Survey_Shift,
			@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id,
			@Previous_Survey_Date = @Prev_Survey_Date OUTPUT,
			@Previous_Survey_Shift = @Prev_Survey_Shift OUTPUT

		-- Set the start date and shift based on this
		EXEC dbo.GetNextDateShift
			@Date = @Prev_Survey_Date,
			@Shift = @Prev_Survey_Shift,
			@Next_Date = @Start_Date OUTPUT,
			@Next_Shift = @Start_Shift OUTPUT

		SELECT @Prev_Survey_Id = Digblock_Survey_Id
		FROM dbo.DigblockSurvey
		WHERE Digblock_Survey_Date = @Prev_Survey_Date
			AND Digblock_Survey_Shift = @Prev_Survey_Shift
			AND Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id

		SELECT @CurrentMonth = dbo.GetDateMonth(@Start_Date)
		WHILE @CurrentMonth < @Digblock_Survey_Date
		BEGIN
			IF (dbo.IsInApprovedMonth(@CurrentMonth) = 1)
			BEGIN
				Raiserror ('The survey period falls in an already approved month', 16, 1)
			End

			SELECT @CurrentMonth = DateAdd(month, 1, @CurrentMonth)
		END

		--Delete any approved haulage in this period
		EXEC dbo.DeleteHaulageBySurveyPeriod
			@iDigblock_Survey_Id = @iDigblock_Survey_Id

		--Update the digblock survey summary id field of the actuals table
		--Where connection was missing
		UPDATE DSA
		SET	Digblock_Survey_Summary_Id = DSS.Digblock_Survey_Summary_Id
		FROM dbo.DigblockSurveyActual AS DSA
			INNER JOIN dbo.DigblockSurveySummary AS DSS
				ON (DSS.Digblock_Survey_Id = DSA.Digblock_Survey_Id
					AND DSS.Digblock_Id = DSA.Digblock_Id)
		WHERE DSS.Digblock_Survey_Id = @iDigblock_Survey_Id

		--Work Out Record No
		SELECT @MaxRecordNo = Max(Record_No)
		FROM dbo.DigblockSurveySummary AS DSS
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id

		--Add the Survey Summary records for blocks with haulage in the period
		--which don't currently have records already
		INSERT INTO dbo.DigblockSurveySummary
		(
			Digblock_Survey_Id, Digblock_Id, Digblock_Start_Tonnes, Record_No, 
			Haulage_Tonnes, Survey_Tonnes
		)
		SELECT @iDigblock_Survey_Id, H.Source_Digblock_Id, D.Start_Tonnes,
			(Row_Number() Over(Order BY H.Source_Digblock_Id)) + IsNull(@MaxRecordNo, 0), 0, 0
		FROM dbo.Haulage AS H 
			INNER JOIN dbo.ShiftType AS ST
				ON (H.Haulage_Shift = ST.Shift)
			INNER JOIN dbo.DataTransactionTonnes AS T
				ON (T.Haulage_Id = H.Haulage_Id)
			INNER JOIN dbo.Digblock AS D
				ON (T.Source_Digblock_Id = D.Digblock_Id)
			LEFT OUTER JOIN dbo.DigblockLocation DL
				ON (D.Digblock_Id = DL.Digblock_Id)
		WHERE H.Haulage_State_Id = 'N'
			AND (@SurveyLocation IS NULL
				OR dbo.GetLocationTypeLocationTypeId(DL.Location_Id, @SurveyLocation) IS NOT NULL)
			AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
				>= dbo.GetDateShiftAsInt(@Start_Date, dbo.GetShiftTypeOrderNo(@Start_Shift))
			AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
				<= dbo.GetDateShiftAsInt(@Digblock_Survey_Date, dbo.GetShiftTypeOrderNo(@Digblock_Survey_Shift))
			AND NOT EXISTS
				(
					SELECT 1
					FROM dbo.DigblockSurveySummary AS S2
					WHERE S2.Digblock_Survey_Id = @iDigblock_Survey_Id
						AND S2.Digblock_Id = H.Source_Digblock_Id
				)
		GROUP BY H.Source_Digblock_Id, D.Start_Tonnes

		--Work Out Record No
		SELECT @MaxRecordNo = Max(Record_No)
		FROM dbo.DigblockSurveySummary AS DSS
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id

		--Add the Survey Summary records for blocks With survey samples in the period
		--which don't currently have records already
		INSERT INTO dbo.DigblockSurveySummary
		(
			Digblock_Survey_Id, Digblock_Id, Digblock_Start_Tonnes, Record_No, 
			Haulage_Tonnes, Survey_Tonnes
		)
		SELECT DSS.Digblock_Survey_Id, DSS.Digblock_Id, D.Start_Tonnes,
			(Row_Number() OVER(ORDER BY DSS.Digblock_Id)) + IsNull(@MaxRecordNo, 0), 0, 0
		FROM dbo.DigblockSurveySample AS DSS
			INNER JOIN dbo.Digblock AS D
				ON (D.Digblock_Id = DSS.Digblock_Id)
		WHERE DSS.Digblock_Survey_Id = @iDigblock_Survey_Id
			AND NOT EXISTS
				(
					SELECT 1
					FROM dbo.DigblockSurveySummary AS S2
					WHERE S2.Digblock_Survey_Id = @iDigblock_Survey_Id
						AND S2.Digblock_Id = DSS.Digblock_Id
				)

		--Work Out Record No
		SELECT @MaxRecordNo = Max(Record_No)
		FROM dbo.DigblockSurveySummary AS DSS
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id

		--Add the Survey Summary records for blocks WITH survey actuals in the period
		--which don't currently have records already
		INSERT INTO dbo.DigblockSurveySummary
		(
			Digblock_Survey_Id, Digblock_Id, Digblock_Start_Tonnes, Record_No, 
			Haulage_Tonnes, Survey_Tonnes
		)
		SELECT DSA.Digblock_Survey_Id, DSA.Assigned_Digblock_Id, D.Start_Tonnes,
			(Row_Number() Over(Order BY DSA.Assigned_Digblock_Id)) + IsNull(@MaxRecordNo, 0), 0, 0
		FROM dbo.DigblockSurveyActual AS DSA
			INNER JOIN dbo.Digblock AS D
				ON (D.Digblock_Id = DSA.Assigned_Digblock_Id)
		WHERE DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
			AND NOT EXISTS
				(
					SELECT 1
					FROM DigblockSurveySummary S2
					WHERE S2.Digblock_Survey_Id = @iDigblock_Survey_Id
						AND S2.Digblock_Id = DSA.Assigned_Digblock_Id
				)
			
		--Update Cached Aggregates
		UPDATE DSS
		SET Haulage_Tonnes = IsNull(H.Tonnes, 0)
		FROM dbo.DigblockSurveySummary AS DSS
			LEFT OUTER JOIN --Where it doesnt exist make it 0 for deletion
				(
					SELECT H.Source_Digblock_Id, Sum(H.Tonnes) AS Tonnes
					FROM dbo.Haulage AS H
						INNER JOIN dbo.ShiftType AS ST
							ON (H.Haulage_Shift = ST.Shift) 
						--Joined so that it filters the digblocks (includes location filtering already)
						INNER JOIN dbo.DigblockSurveySummary AS DSS2
							ON (DSS2.Digblock_Id = H.Source_Digblock_Id)
					WHERE DSS2.Digblock_Survey_Id = @iDigblock_Survey_Id
						AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
							>= dbo.GetDateShiftAsInt(@Start_Date, dbo.GetShiftTypeOrderNo(@Start_Shift))
						AND dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No)
							<= dbo.GetDateShiftAsInt(@Digblock_Survey_Date, dbo.GetShiftTypeOrderNo(@Digblock_Survey_Shift))	
					GROUP BY H.Source_Digblock_Id
				) AS H
				ON (H.Source_Digblock_Id = DSS.Digblock_Id)
		WHERE DSS.Digblock_Survey_Id = @iDigblock_Survey_Id

		UPDATE DSS
		SET Survey_Tonnes = IsNull(A.Tonnes, 0)
		FROM dbo.DigblockSurveySummary AS DSS
			LEFT OUTER JOIN --Where it doesnt exist make it 0 for deletion
				(
					SELECT DSS2.Digblock_Id, Sum(DSS2.Depleted_Tonnes) AS Tonnes
					FROM dbo.DigblockSurveySample AS DSS2
					WHERE DSS2.Digblock_Survey_Id = @iDigblock_Survey_Id 
					GROUP BY DSS2.Digblock_Id
				) AS A
				ON (A.Digblock_Id = DSS.Digblock_Id)
		WHERE DSS.Digblock_Survey_Id = @iDigblock_Survey_Id

		--Remove any records that do not have haulage tonnes, survey tonnes or an actual assigned
		DELETE DSS
		FROM dbo.DigblockSurveySummary AS DSS
		WHERE DSS.Haulage_Tonnes = 0
			AND IsNull(DSS.Survey_Tonnes, 0) = 0
			AND NOT EXISTS
				(
					SELECT 1
					FROM dbo.DigblockSurveyActual AS DSA
					WHERE DSA.Assigned_Digblock_Id = DSS.Digblock_Id
						AND DSA.Digblock_Survey_Id = @iDigblock_Survey_Id
				)

		--Set the is_processing flag
		UPDATE dbo.DigblockSurvey
		SET	Is_Processing = 1
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id
		
		COMMIT TRANSACTION 
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	
  
    
END 
GO 
GRANT EXECUTE ON dbo.InitDigblockSurveyProcess TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="InitDigblockSurveyProcess">
 <Procedure>
	Requires the following:
	1. The DigblockSurvey record must already exist
	2. The DigblockSurvey record must not be approved
	3. The DigblockSurvey record must not fall within an approved month (MonthlyApproval)
	Get the relevent system settings.
	Check to see if the given digblock survey exists, if it does exist and if this survey date 
	is not currently approved get Parent Location type for Survey, get the last survey date 
	and shift before this one and set the start date and shift based on this.
	If the start date of the period does not fall in an approved month delete any approved 
	haulage in this period.
	Update the digblock survey summary id field of the actuals table.
	If this instance of the system is set up to only include digblocks hauled from in a 
	period and nothing else, delete any records from the digblock survey actual table 
	which relate to records in the digblock survey summary table which are going to be deleted.
	Insert into the digblock survey summary table a record for any digblocks GRANT EXECUTE ON dbo.InitDigblockSurveyProcess TO CoreDepletionManager
which do not 
	currently have a related record.
	If the given survey period is to include all digblocks from the previous survey 
	automatically insert those records if they are not already included .
	Update any records in the digblock survey summary table with the current tonnes of 
	haulage from the related digblocks.
	Update the table with the approved removed tonnes and unapproved removed tonnes from the 
	transaction table before the start of this depletion period.
	Update any of these records which do not have values set.
	Update any records in the digblock survey summary table with the related survey tonnes, 
	if they exist.
	Update any records in the digblock survey summary table with the related digblock start tonnes. 			
	For each of these records, for this survey date and shift in the survey summary table, 
	ordered by digblock id set the record no of the record.
	Set the "is processing" flag for this digblock survey period to true.
	Errors are raised if:
		The survey period falls in an already approved month.
		The given survey date has already been approved.
		The digblock survey does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ResetDigblockSurveySummaryOwnership.prc'
GO

If object_id('dbo.ResetDigblockSurveySummaryOwnership') is not null
	Drop Procedure dbo.ResetDigblockSurveySummaryOwnership
Go

CREATE Procedure dbo.ResetDigblockSurveySummaryOwnership
(
	@iDigblock_Survey_Date Datetime,
	@iDigblock_Survey_Shift Char(1),
	@iNT_Login Varchar(255),
	@iDigblock_Survey_Type_Id Int = Null
)

With Encryption 
As

Begin

	Declare @Is_Approved Bit

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* If a digblock survey type was not given */
	If (@iDigblock_Survey_Type_Id Is Null)
	Begin
		/* If there is only one available */
		If ((Select Count(*) From DigblockSurveyType) = 1)
		Begin
			/* Use that one */
			Select @iDigblock_Survey_Type_Id = Digblock_Survey_Type_Id
			From DigblockSurveyType
		End
	End

	Select @Is_Approved = Is_Approved
	From DigblockSurvey DS
	Where DS.Digblock_Survey_Date = @iDigblock_Survey_Date
	And DS.Digblock_Survey_Shift = @iDigblock_Survey_Shift
	And DS.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id

	/* If the period is not approved */
	If (@Is_Approved = 0)
	Begin
		/* Reset the ownership of these records */
		Update DSS
		Set	NT_Login = Null
		From DigblockSurveySummary DSS
			Inner Join DigblockSurvey DS
				On DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id
		Where DS.Digblock_Survey_Date = @iDigblock_Survey_Date
		And DS.Digblock_Survey_Shift = @iDigblock_Survey_Shift
		And DS.Digblock_Survey_Type_Id = @iDigblock_Survey_Type_Id
		And DSS.NT_Login = @iNT_Login

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The record falls in an already approved survey period', 16, 1)
	End

	-- Event_Logging_Placeholder


End
GO
GRANT EXECUTE ON dbo.ResetDigblockSurveySummaryOwnership TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="ResetDigblockSurveySummaryOwnership">
 <Procedure>
	If a digblock survey type was not given and there is only one available then use that one.
	If the period is not approved, reset the ownership of the records in DigblockSurveySummary.
	Errors are raised if:
		The record falls in an already approved survey period
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UnapproveDigblockSurvey.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[UnapproveDigblockSurvey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[UnapproveDigblockSurvey]
GO

CREATE Procedure [dbo].[UnapproveDigblockSurvey]
(
	@iDigblock_Survey_Id Int
)

With Encryption
As

Begin

	Declare @Digblock_Survey_Date Datetime
	Declare @Digblock_Survey_Shift Char(1)
	Declare @Digblock_Survey_Type_Id Int
	Declare @Is_Approved Bit
	Declare @Prev_Survey_Date Datetime
	Declare @Prev_Survey_Shift Char(1)
	Declare @Start_Date as Datetime
	Declare @Start_Shift as Char(1)
	Declare @Adjust_Haulage Bit
	Declare @Digblock_Id Varchar(31)
	Declare @Is_Entire_Digblock Bit

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- Check to see if the digblock survey exists
	Select @Digblock_Survey_Date = Digblock_Survey_Date,
		@Digblock_Survey_Shift = Digblock_Survey_Shift,
		@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id,
		@Is_Approved = Is_Approved,
		@Adjust_Haulage = Adjust_Haulage,
		@Is_Entire_Digblock = Is_Entire_Digblock
	From DigblockSurvey
	Where Digblock_Survey_Id = @iDigblock_Survey_Id

	-- If it does
	If (@Is_Approved Is Not Null)
	Begin
		-- If the digblock survey is currently approved
		If (@Is_Approved = 1)
		Begin
			Exec GetPreviousDigblockSurveyDate
				@Survey_Date = @Digblock_Survey_Date,
				@Survey_Shift = @Digblock_Survey_Shift,
				@Digblock_Survey_Type_Id = @Digblock_Survey_Type_Id,
				@Previous_Survey_Date = @Prev_Survey_Date Output,
				@Previous_Survey_Shift = @Prev_Survey_Shift Output

			Exec GetNextDateShift
				@Date = @Prev_Survey_Date,
				@Shift = @Prev_Survey_Shift,
				@Next_Date = @Start_Date Output,
				@Next_Shift = @Start_Shift Output

			-- If the start date for this depletion period does not fall in an already approved month
			If (dbo.IsInApprovedMonth(@Start_Date) = 0)
			Begin
				-- Set the survey date to unapproved
				Update DigblockSurvey
				Set	Is_Approved = 0
				Where Digblock_Survey_Id = @iDigblock_Survey_Id

				-- If the digblock survey defines the total survey for the entire given digblock in each case
				If (@Is_Entire_Digblock = 1)
				Begin
					-- Get a cursor of all digblocks related to this survey date
					Declare Digblock_Curs Cursor Local Fast_Forward Read_Only For
						Select Digblock_Id
						From DigblockSurveySample DSS
						Where DSS.Digblock_Survey_Id = @iDigblock_Survey_Id
						Order By Digblock_Id

					Open Digblock_Curs

					Fetch Next From Digblock_Curs Into @Digblock_Id

					-- For each digblock
					While (@@Fetch_Status = 0)
					Begin
						-- Delete any approved haulage records for this depletion period
						Exec DeleteHaulageBySurveyDigblock
							@iDigblock_Id = @Digblock_Id

						Fetch Next From Digblock_Curs Into @Digblock_Id
					End

					Close Digblock_Curs
					Deallocate Digblock_Curs
				End
				Else
				Begin
					-- Delete any approved haulage records for this depletion period
					Exec DeleteHaulageBySurveyPeriod
						@iDigblock_Survey_Id = @iDigblock_Survey_Id
				End

				-- Correct any haulage errors which may not have been able to be corrected
				-- while this period was approved
				Exec dbo.HaulageRawResolveAll

				-- Recalculate the entire period
				Exec RecalcL1RaisePeriod
					@iStart_Date = @Start_Date,
					@iEnd_Date = @Digblock_Survey_Date
			End
			Else
			Begin
				Raiserror ('At least part of the digblock survey falls in an already approved month', 16, 1)
			End
		End
		Else
		Begin
			Raiserror ('The digblock survey is not currently approved', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The digblock survey does not exist', 16, 1)
	End

	Commit Transaction

	-- Event_Logging_Placeholder
End
Go
GRANT EXECUTE ON dbo.UnapproveDigblockSurvey TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="UnapproveDigblockSurvey">
 <Procedure>
	Updates the table DigblockSurvey to unapproved if the flag is set to approved and if the 
	start date for this depletion period does not fall in an already approved month. 
	Delete any approved haulage records for this depletion period.
	Errors are raised if:
		At least part of the digblock survey falls in an already approved month.
		The digblock survey is not currently approved.
		The digblock survey does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateDataException.prc'
GO

If object_id('dbo.UpdateDataException') is not Null 
     Drop Procedure dbo.UpdateDataException 
Go 
  
Create Procedure dbo.UpdateDataException 
( 
    @iData_Exception_Id BigInt,
	@iData_Exception_Type_Id Int = Null,
	@iUpdate_Data_Exception_Type_Id bit = 0,
	@iData_Exception_Date datetime = Null,
	@iUpdate_Data_Exception_Date bit = 0,
	@iData_Exception_Shift Char(1) = Null,
	@iUpdate_Data_Exception_Shift bit = 0,
	@iData_Exception_Status_Id Varchar(5) = Null,
	@iUpdate_Data_Exception_Status_Id bit = 0,
	@iShort_Description Varchar(255) = Null,
	@iUpdate_Short_Description bit = 0,
	@iLong_Description Varchar(4096) = Null,
	@iUpdate_Long_Description bit = 0,
	@iDetails_XML xml = Null,
	@iUpdate_Details_XML bit = 0
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Begin Try
		--Validate Increment
		If Not Exists
			(
				Select 1 
				From DataException
				Where Data_Exception_Id = @iData_Exception_Id
			)
		Begin
			RaisError('The data exception does not exist', 16, 1)
		End

		Update DataException
		Set Data_Exception_Type_Id = Case When @iUpdate_Data_Exception_Type_Id = 1 Then @iData_Exception_Type_Id Else Data_Exception_Type_Id End,
			Data_Exception_Date = Case When @iUpdate_Data_Exception_Date = 1 Then @iData_Exception_Date Else Data_Exception_Date End,
			Data_Exception_Shift = Case When @iUpdate_Data_Exception_Shift = 1 Then @iData_Exception_Shift Else Data_Exception_Shift End,
			Data_Exception_Status_Id = Case When @iUpdate_Data_Exception_Status_Id = 1 Then @iData_Exception_Status_Id Else Data_Exception_Status_Id End,
			Short_Description = Case When @iUpdate_Short_Description = 1 Then @iShort_Description Else Short_Description End,
			Long_Description = Case When @iUpdate_Long_Description = 1 Then @iLong_Description Else Long_Description End,
			Details_XML = Case When @iUpdate_Details_XML = 1 Then @iDetails_XML Else Details_XML End
		Where Data_Exception_Id = @iData_Exception_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateDataException TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateDataException">
 <Procedure>
	This procedure updates the details of a data exception.

	Returns an error if the data exception does not exist.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateDigblockSurveySummaryUser.prc'
GO

If Object_Id('dbo.UpdateDigblockSurveySummaryUser') Is Not Null
	Drop Procedure dbo.UpdateDigblockSurveySummaryUser
Go

CREATE Procedure [dbo].[UpdateDigblockSurveySummaryUser]
(
	@iDigblock_Survey_Summary_Id Int,
	@iNT_Login Varchar(255)
)

With Encryption 
As

Begin

	Declare @Is_Approved Bit

	Set Nocount On

	Select @Is_Approved = Is_Approved
	From DigblockSurvey DS, DigblockSurveySummary DSS
	Where DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id
		And DSS.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id

	/* If the digblock survey summary record exists */
	If (@Is_Approved Is Not Null)
	Begin
		/* If the period is not approved */
		If (@Is_Approved = 0)
		Begin
			/* Update the digblock survey summary record with the given User login */
			Update DigblockSurveySummary
			Set	NT_Login = @iNT_Login
			Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
		End
		Else
		Begin
			Raiserror ('The record falls in an already approved survey period', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given survey summary record does not exist', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.UpdateDigblockSurveySummaryUser TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateDigblockSurveySummaryUser">
 <Procedure>
	If the digblock survey summary record exists and if the period is not approved
	update the digblock survey summary record with the given User login.
	Errors are raised if:
		The record falls in an already approved survey period
		The given survey summary record does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateDigblock.prc'
GO

IF OBJECT_ID('dbo.UpdateDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateDigblock 
GO 
  
CREATE PROCEDURE dbo.UpdateDigblock 
( 
    @iDigblock_Id VARCHAR(31),
	@iDescription VARCHAR(63) = NULL,
	@iMaterial_Type_Id INT = NULL,
	@iStart_Date DATETIME = NULL,
	@iStart_Shift CHAR(1) = NULL,
	@iEnd_Date DATETIME = NULL,
	@iEnd_Shift CHAR(1) = NULL,
	@iIs_In_Pit_Depletion BIT = 1,
	@iStart_Tonnes FLOAT = NULL,
	@iX FLOAT = NULL,
	@iY FLOAT = NULL,
	@iZ FLOAT = NULL,
	@iNotes VARCHAR(1023) = NULL,
	@iHaulage_Raw_Resolve_All BIT = 1,
	@iUpdate_Description BIT = 0,
	@iUpdate_Material_Type_Id Bit = 0,
	@iUpdate_Start_Date BIT = 0,
	@iUpdate_Start_Shift BIT = 0,
	@iUpdate_End_Date BIT = 0, 
	@iUpdate_End_Shift BIT = 0,
	@iUpdate_Is_In_Pit_Depletion BIT = 0,
	@iUpdate_Start_Tonnes BIT = 0,
	@iUpdate_X BIT = 0,
	@iUpdate_Y BIT = 0, 
	@iUpdate_Z BIT = 0,
	@iUpdate_Notes BIT = 0
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @RecalcStartDate DateTime
	Declare @AllowZeroTonnes VARCHAR(7)
		
	SELECT @TransactionName = 'UpdateDigblock',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY
		--Check digblock is in the Reconcilor
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.Digblock AS D
				WHERE D.Digblock_Id = @iDigblock_Id
			)
		BEGIN
			Raiserror ('The digblock does not exist', 16, 1)
		END

		IF @iUpdate_Material_Type_Id = 1
			AND NOT EXISTS
				(
					SELECT 1
					FROM dbo.MaterialType AS MT
					WHERE Material_Type_Id = @iMaterial_Type_Id
				)
		BEGIN
			Raiserror ('The material type does not exist', 16, 1)
		END

		IF @iUpdate_Start_Date = 1 OR @iUpdate_Start_Shift = 1
		BEGIN
			EXEC dbo.ActivateDigblock
				@iDigblock_Id = @iDigblock_Id,
				@iStart_Date = @iStart_Date,
				@iStart_Shift = @iStart_Shift,
				@iHaulage_Raw_Resolve_All = 0
		END

		
		IF @iUpdate_End_Date = 1 OR @iUpdate_End_Shift = 1
		BEGIN
			EXEC dbo.CloseDigblock
				@iDigblock_Id = @iDigblock_Id,
				@iClose_Date = @iEnd_Date,
				@iClose_Shift = @iEnd_Shift,
				@iHaulage_Raw_Resolve_All = 0
		END

		-- Default to false for backward compat
		Set @AllowZeroTonnes  = 'FALSE'

		Select @AllowZeroTonnes = Value
		From dbo.Setting
		Where Setting_Id = 'ALLOW_ZERO_TONNE_DIGBLOCKS'
		
		IF (@iUpdate_Start_Tonnes = 1 AND IsNull(@iStart_Tonnes, 0) <= 0 And @AllowZeroTonnes = 'FALSE')
		BEGIN
			Raiserror ('The start tonnes must be greater than 0.', 16, 1)	
		END

		--Update details that were specified to be updated
		UPDATE D
		SET Description = CASE WHEN @iUpdate_Description = 1 THEN @iDescription Else Description END,
			Material_Type_Id = 
				CASE WHEN @iUpdate_Material_Type_Id = 1 THEN 
					@iMaterial_Type_Id 
				Else 
					Material_Type_Id 
				END,
			Is_In_Pit_Depletion = 
				CASE WHEN @iUpdate_Is_In_Pit_Depletion = 1 THEN 
					@iIs_In_Pit_Depletion 
				Else 
					Is_In_Pit_Depletion 
				END,
			Start_Tonnes = CASE WHEN @iUpdate_Start_Tonnes = 1 THEN @iStart_Tonnes Else Start_Tonnes END,
			X = CASE WHEN @iUpdate_X = 1 THEN @iX Else X END,
			Y = CASE WHEN @iUpdate_Y = 1 THEN @iY Else Y END,
			Z = CASE WHEN @iUpdate_Z = 1 THEN @iZ Else Z END,
			Notes = CASE WHEN @iUpdate_Notes = 1 THEN @iNotes Else Notes END
		FROM dbo.Digblock as D
		WHERE D.Digblock_Id = @iDigblock_Id

		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXEC dbo.HaulageRawResolveAll
		END

		IF @iUpdate_Start_Tonnes = 1
		BEGIN
			SELECT @RecalcStartDate = D.Start_Date
			FROM dbo.DIGBLOCK AS D
			WHERE D.Digblock_Id = @iDigblock_Id
			
			If @RecalcStartDate IS NOT NULL
			BEGIN

			EXEC dbo.RecalcL1Raise
				@pDate = @RecalcStartDate,
				@pRaise_Recalc_Event = 1
				
			END
		END

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO 
GRANT EXECUTE ON dbo.UpdateDigblock TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateDigblock">
 <Procedure>
	Updates a digblock's details. This will check to ensure that the digblock exists
	and validates the material type, the start and end date. If the start tonnes has been changed
	this procedure will raise a recalc event.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateDrill.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateDrill'))
	Drop Procedure dbo.UpdateDrill
Go

CREATE Procedure dbo.UpdateDrill
(
	@iDrill_Id Varchar(31),
	@iDescription Varchar(255) = Null
)

With Encryption 
As

Begin


	Declare @Count Int

	Set Nocount On
	
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the drill exists */
	Select @Count = Count(*)
	From Drill
	Where Drill_Id = @iDrill_Id

	/* If it does */
	If (@Count > 0)
	Begin
		Update Drill
		Set Description = @iDescription
		Where Drill_Id = @iDrill_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror('This drill does not exists', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
End
GO
GRANT EXECUTE ON dbo.UpdateDrill TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateDrill">
 <Procedure>
	Updates the description of @iDrill_Id.
	Errors are raised if:
		'This drill does not exists
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateGrade.prc'
GO

IF OBJECT_ID('dbo.UpdateGrade') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateGrade  
GO 
  
CREATE PROCEDURE dbo.UpdateGrade 
( 
    @iGrade_Id SmallInt,
	@iGrade_Name Varchar(31) = NULL,
	@iUpdate_Grade_Name Bit = 0,
	@iDescription Varchar(255) = NULL,
	@iUpdate_Description Bit = 0,
	@iOrder_No Int = NULL,
	@iUpdate_Order_No Bit = 0,
	@iUnits	Varchar(15) = NULL,
	@iUpdate_Units Bit = 0,
	@iDisplay_Precision Int = NULL,
	@iUpdate_Display_Precision Bit = 0,
	@iDisplay_Format Varchar(10) = NULL,
	@iUpdate_Display_Format Bit = 0,
	@iGrade_Type_Id Varchar(31) = NULL,
	@iUpdate_Grade_Type_Id Bit = 0,
	@iIs_Visible Bit = 1,
	@iUpdate_Is_Visible Bit = 0
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'UpdateGrade',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		If Not Exists
			(
				Select 1
				From Grade
				Where Grade_Id = @iGrade_Id
			)
		Begin
			RaisError('Grade does not exists', 16, 1)	
		End

		Update Grade
		Set Grade_Name = Case When @iUpdate_Grade_Name = 1 Then @iGrade_Name Else Grade_Name End,
			Description = Case When @iUpdate_Description = 1 Then @iDescription Else Description End,
			Order_No = Case When @iUpdate_Order_No = 1 Then @iOrder_No Else Order_No End,
			Units = Case When @iUpdate_Units = 1 Then @iUnits Else Units End,
			Display_Precision = Case When @iUpdate_Display_Precision = 1 Then @iDisplay_Precision Else Display_Precision End,
			Display_Format = Case When @iUpdate_Display_Format = 1 Then @iDisplay_Format Else Display_Format End,
			Grade_Type_Id = Case When @iUpdate_Grade_Type_Id = 1 Then @iGrade_Type_Id Else Grade_Type_Id End,
			Is_Visible = Case When @iUpdate_Is_Visible = 1 Then @iIs_Visible Else Is_Visible End
		Where Grade_Id = @iGrade_Id

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.UpdateGrade TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateGrade">
 <Procedure>
	Updates a grade record in the Grade table.
	Errors are raised if:
		The grade to be updated does not exist.
		Order number supplied breaks the unique column constraInt
		Display Precision supplied breaks the check column constraInt
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateGradeOrderNo.prc'
GO

If object_id('dbo.UpdateGradeOrderNo') is not Null 
     Drop Procedure dbo.UpdateGradeOrderNo 
Go 
  
Create Procedure dbo.UpdateGradeOrderNo
( 
    @iGrade_Id Varchar(31),
	@iIncrement Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @Current_Num Int, 
			@New_Num Int,
			@Existing_Grade_Id Varchar(31)
  
	Begin Try
		--Validate Increment
		If @iIncrement <> -1 and @iIncrement <> 1
			RaisError('The adjusting increment must be -1 or 1', 16, 1)

		Select @Current_Num = Order_No, @New_Num = Order_No + @iIncrement
		From Grade
		Where Grade_Id = @iGrade_Id

		--If its the first one then do nothing if we're going up
		If @New_Num < 0 
			Set @New_Num = 0

		--If New Num is higher than the count of all the groups minus 1 (its zero based)
		--then we have tried to set it higher than it should go so put it at the max
		--allowed value.
		Select @New_Num = 
			Case 
				When Max(Order_No) > Count(*) - 1 Then 
					Max(Order_No) 
				Else 
					Count(*) - 1  
				End
		From Grade
		Having @New_Num > Count(*) - 1
			And @New_Num > Max(Order_No)

		--Only get the first group to swap order_no's with
		Select Top 1 @Existing_Grade_Id = Grade_Id
		From Grade
		Where Order_No = @New_Num
			--Do not want to swap order number with the same group.
			And Grade_Id <> @iGrade_Id 
	
		--Park it in a number that is unreachable
		Update Grade	
		Set Order_No = -999
		Where Grade_Id = @Existing_Grade_Id

		Update Grade	
		Set Order_No = @New_Num
		Where Grade_Id = @iGrade_Id
		
		Update Grade	
		Set Order_No = @Current_Num
		Where Grade_Id = @Existing_Grade_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateGradeOrderNo TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateGradeOrderNo">
 <Procedure>
	Adjusts the order number of a stockpile group up (Order_Num - 1) 
	or down (Order_No + 1), whilst maintaining the integrity of the 
	ordering by changing the one above or below it in conjunction.

	Errors are raised if:
		The increment is not -1 or 1 which represents Up or Down.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageByHaulageRaw.prc'
GO

 If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.DeleteHaulageByHaulageRaw'))
	Drop Procedure dbo.DeleteHaulageByHaulageRaw
Go

Create Procedure dbo.DeleteHaulageByHaulageRaw
(
	@iHaulage_Raw_Id Int
)

With Encryption
As

Begin
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- find the first haulage record
	Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
						From Haulage
						Where Haulage_Raw_Id = @iHaulage_Raw_Id)
	While @Haulage_Id Is Not Null
	Begin
		Exec DeleteHaulage
			@iHaulage_Id = @Haulage_Id
		
		-- locate the next haulage record
		Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
							From Haulage
							Where Haulage_Raw_Id = @iHaulage_Raw_Id)
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageByHaulageRaw">
 <Procedure>
	Deletes records from the Haulage table related to @iHaulage_Raw_Id.  Loops calling GetLastHaulageId function and DeleteHaulage
	procedure to delete the last Haulage record in the chain until all records in the chain are deleted.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageRaw.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateHaulageRaw'))
	Drop Procedure dbo.UpdateHaulageRaw
Go

Create Procedure dbo.UpdateHaulageRaw
(
	@iHaulage_Raw_Id Int,
	@iUpdate_Source Bit = 0,
	@iSource VarChar(63) = Null,
	@iUpdate_Destination Bit = 0,
	@iDestination VarChar(63) = Null,
	@iUpdate_Tonnes Bit = 0,
	@iTonnes Float = Null,
	@iUpdate_Loads Bit = 0,
	@iLoads Int = Null,
	@iUpdate_Truck Bit = 0,
	@iTruck VarChar(63) = Null,
	@iUpdate_Can_Correct_Via_User_Interface Bit = 0,
	@iCan_Correct_Via_User_Interface Bit = Null,
	@iCreate_Audit_Child Bit = 1,
	@oHaulage_Raw_Id Int = Null Output
)

With Encryption
As

Begin
	Declare @New_Haulage_Raw_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- The HaulageRaw record can only be updated if there is no conflict
	-- (that is, the original record has been end-User modified or approved)

	If (Select Child_Haulage_Raw_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @iHaulage_Raw_Id) Is Not Null
	Begin
		RaisError('UpdateHaulageRaw: Only the last raw haulage record in the chain can be modified.', 16, 1)
	End
	Else If dbo.GetHaulageRawConflictFlag(@iHaulage_Raw_Id) = 1
	Begin
		RaisError('UpdateHaulageRaw: The associated haulage record has been modified or approved.', 16, 1)
	End
	Else
	Begin
		-- if we are creating a new copy of the HaulageRaw record,
		-- copy the existing record prior to updating the values
		If @iCreate_Audit_Child = 1
		Begin
			----------------------------------------
			-- delete the existing Haulage record(s)

			-- note: this routine call should not fail
			-- the check has already been made above,
			-- through "dbo.GetHaulageRawConflictFlag"

			Exec dbo.DeleteHaulageByHaulageRaw
				@iHaulage_Raw_Id = @iHaulage_Raw_Id

			---------------------------------------------------
			-- create a copy of the existing HaulageRaw record

			-- HaulageRaw
			Insert Into dbo.HaulageRaw
			(
				Haulage_Date, Haulage_Shift, Source, Destination, Tonnes, Loads, Truck, Haulage_Raw_State_Id,
				Can_Correct_Via_User_Interface, Child_Haulage_Raw_Id, Parent_Haulage_Raw_Id, Added_DateTime
			)
			Select Haulage_Date, Haulage_Shift, Source, Destination, Tonnes, Loads, Truck, 'A',
				Can_Correct_Via_User_Interface, Null, Haulage_Raw_Id, GetDate()
			From dbo.HaulageRaw
			Where Haulage_Raw_Id = @iHaulage_Raw_Id

			Set @New_Haulage_Raw_Id = Scope_Identity()

			-- HaulageRawGrade
			Insert Into dbo.HaulageRawGrade
			(
				Haulage_Raw_Id, Grade_Id, Grade_Value
			)
			Select @New_Haulage_Raw_Id, Grade_Id, Grade_Value
			From HaulageRawGrade
			Where Haulage_Raw_Id = @iHaulage_Raw_Id

			-- HaulageRawValue
			Insert Into dbo.HaulageRawValue
			(
				Haulage_Raw_Id, Haulage_Raw_Field_Id, Field_Value
			)
			Select @New_Haulage_Raw_Id, Haulage_Raw_Field_Id, Field_Value
			From HaulageRawValue
			Where Haulage_Raw_Id = @iHaulage_Raw_Id

			-- HaulageRawNotes
			Insert into dbo.HaulageRawNotes
			(
				Haulage_Raw_Id, Haulage_Raw_Field_Id, Notes
			)
			Select @New_Haulage_Raw_Id, Haulage_Raw_Field_Id, Notes
			From HaulageRawNotes
			Where Haulage_Raw_Id = @iHaulage_Raw_Id

			-- HaulageRawLocation
			Insert into dbo.HaulageRawLocation
			(
				HaulageRawId, SourceLocationId, DestinationLocationId
			)
			Select @New_Haulage_Raw_Id, SourceLocationId, DestinationLocationId
			From HaulageRawLocation
			Where HaulageRawId = @iHaulage_Raw_Id

			------------------------------------
			-- modify the old HaulageRaw record

			Update HaulageRaw
			Set Haulage_Raw_State_Id = 'M',
				Child_Haulage_Raw_Id = @New_Haulage_Raw_Id
			Where Haulage_Raw_Id = @iHaulage_Raw_Id
			
			Delete
			From HaulageRawError
			Where Haulage_Raw_Id = @iHaulage_Raw_Id
		End
		Else
		Begin
			-- if we are not creating a new audit record,
			-- use the existing haulage record passed in

			UPDATE dbo.HaulageRaw
			SET Haulage_Raw_State_Id = 'A'
			WHERE Haulage_Raw_Id = @iHaulage_Raw_Id

			Set @New_Haulage_Raw_Id = @iHaulage_Raw_Id
		End

		-- update the appropriate HaulageRaw record
		Update HaulageRaw
		Set	Source = (Case When @iUpdate_Source = 1 Then @iSource Else Source End),
			Destination = (Case When @iUpdate_Destination = 1 Then @iDestination Else Destination End),
			Tonnes = (Case When @iUpdate_Tonnes = 1 Then @iTonnes Else Tonnes End),
			Loads = (Case When @iUpdate_Loads = 1 Then @iLoads Else Loads End),
			Truck = (Case When @iUpdate_Truck = 1 Then @iTruck Else Truck End),
			Can_Correct_Via_User_Interface = (	Case When @iUpdate_Can_Correct_Via_User_Interface = 1
													Then @iCan_Correct_Via_User_Interface
													Else Can_Correct_Via_User_Interface
												End)
		Where Haulage_Raw_Id = @New_Haulage_Raw_Id

		-- return the appropriate Haulage_Raw_Id
		Set @oHaulage_Raw_Id = @New_Haulage_Raw_Id
	End

	Commit Transaction
End
Go
 GRANT EXECUTE ON dbo.UpdateHaulageRaw TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulageRaw">
 <Procedure>
	The HaulageRaw record can only be updated if there is no conflict,	hence the original
	record has been end-User modified or approved.
	If we are creating a new copy of the HaulageRaw record, copy the existing record 
	prior to updating the values and delete the existing Haulage record(s).
	Errors are raised if:
		UpdateHaulageRaw: Only the last raw haulage record in the chain can be modified.
		UpdateHaulageRaw: The associated haulage record has been modified or approved.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageCorrectionResolutionBasic.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[UpdateHaulageCorrectionResolutionBasic]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[UpdateHaulageCorrectionResolutionBasic]
GO

CREATE Procedure [dbo].[UpdateHaulageCorrectionResolutionBasic]
(
	@iHaulage_Resolve_Basic_Id Int,
	@iDeactivate Bit = 0,
	@iDeactivate_Date Datetime = Null,
	@iDeactivate_Shift Char(1) = Null
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: UpdateHaulageCorrectionResolutionBasic
--  Purpose: Updates a Resolution Basic record.
--  Parameters: @iHaulage_Resolve_Basic_Id - The ID to update.
--				@iDeactivate - Flaged if a deactivate should be attemped.
--				@iDeactivate_Date - If deactivating, what date to set it to.
--				@iDeactivate_Shift - If deactivating, what shift to set it to.
-- 
--  Comments:
--			Update a Haulage Resolve Basic record. At this current point in time it
--			can only deactivate a record.
--  
--  Created By:		Murray Hipper
--  Created Date: 	31 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Last_Haulage_Date Datetime
	Declare @Last_Haulage_Shift Char(1)
	Declare @Error_Message Varchar(1024)
	
	Declare @Activate_Date DateTime
	Declare @Activate_Shift Char(1)
	
	Select @Activate_Date = Resolve_From_Date,
		@Activate_Shift = Resolve_From_Shift
	From dbo.HaulageResolveBasic
	Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id
	
	-- Make sure its a valid record
	If Not Exists(Select 1 From HaulageResolveBasic where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id)
	Begin
		Raiserror ('The Basic resolution for this ID does not exist.', 16, 1)
	End
	Else
	Begin

		-- Disable the Basic Resolution
		If @iDeactivate = 1 
		Begin
			If @iDeactivate_Date Is Null Or @iDeactivate_Shift Is Null
			Begin
				Raiserror ('The Deactivation Date or Shift were not set.', 16, 1)
			End
			Else
			Begin

				Select Top 1 -- Find the latest haulage record.
					@Last_Haulage_Date = Haulage_Date,
					@Last_Haulage_Shift = Haulage_Shift
				From HaulageRawResolution HRR
				Inner Join HaulageRaw HR
					On HR.Haulage_Raw_Id = HRR.Haulage_Raw_Id
				Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id
				Order By dbo.GetDateshiftAsDatetime(Haulage_Date, Haulage_Shift)

				-- Make sure the updated date is on or after the lastest haulage date if it has one.
				If dbo.GetDateshiftAsDatetime(@Last_Haulage_Date, @Last_Haulage_Shift) 
					> dbo.GetDateshiftAsDatetime(@iDeactivate_Date, @iDeactivate_Shift)
					And (@Last_Haulage_Date Is Not Null And @Last_Haulage_Shift Is Not Null)
				Begin
					Set @Error_Message = 'The latest haulage record ' + Convert(Varchar, @Last_Haulage_Date, 106) + '/' + @Last_Haulage_Shift +
						' is after the provided deactivate date.'
					Raiserror (@Error_Message, 16, 1)
				End
				Else If dbo.GetDateshiftAsDatetime(@Activate_Date, @Activate_Shift) 
					> dbo.GetDateshiftAsDatetime(@iDeactivate_Date, @iDeactivate_Shift)
				Begin
					Set @Error_Message = 'The date to date is before the date from date.'
					Raiserror (@Error_Message, 16, 1)
				End				
				Else
				Begin
					-- Update the record
					
					Update HaulageResolveBasic
					Set Resolve_To_Date = @iDeactivate_Date,
						Resolve_To_Shift = @iDeactivate_Shift
					Where Haulage_Resolve_Basic_Id = @iHaulage_Resolve_Basic_Id
				End
			End
		End
	End
End

GO
GRANT EXECUTE ON dbo.UpdateHaulageCorrectionResolutionBasic TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulageCorrectionResolutionBasic">
 <Procedure>
	Updates a Resolution Basic record.
	Parameters: @iHaulage_Resolve_Basic_Id - The ID to update.
				@iDeactivate - Flaged if a deactivate should be attemped.
				@iDeactivate_Date - If deactivating, what date to set it to.
				@iDeactivate_Shift - If deactivating, what shift to set it to.
	Comments: Update a Haulage Resolve Basic record. At this current point in time it
			can only deactivate a record.
	Errors are raised if:
		The Basic resolution for this ID does not exist.
		The Deactivation Date or Shift were not set.
		The latest haulage record @Last_Haulage_Date/@Last_Haulage_Shift 
		is after the provided deactivate date.'
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageManagementBulk.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[UpdateHaulageManagementBulk]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[UpdateHaulageManagementBulk]
GO

CREATE Procedure [dbo].[UpdateHaulageManagementBulk]
(
	@iFilter_Start_Date Datetime,
	@iFilter_End_Date Datetime,
	@iFilter_Start_Shift Char(1),
	@iFilter_End_Shift Char(1),
	@iFilter_Source Varchar(63) = Null,
	@iFilter_Destination Varchar(63) = Null,
	@iFilter_Truck Varchar(31) = Null,
	@iUpdate_Source_Digblock_Id Bit = 0,
	@iSource_Digblock_Id VarChar(31) = Null,
	@iUpdate_Source_Stockpile_Id Bit = 0,
	@iSource_Stockpile_Id Int = Null,
	@iUpdate_Source_Build_Id Bit = 0,
	@iSource_Build_Id Int = Null,
	@iUpdate_Source_Component_Id Bit = 0,
	@iSource_Component_Id Int = Null,
	@iUpdate_Source_Mill_Id Bit = 0,
	@iSource_Mill_Id VarChar(31) = Null,
	@iUpdate_Destination_Crusher_Id Bit = 0,
	@iDestination_Crusher_Id VarChar(31) = Null,
	@iUpdate_Destination_Stockpile_Id Bit = 0,
	@iDestination_Stockpile_Id Int = Null,
	@iUpdate_Destination_Build_Id Bit = 0,
	@iDestination_Build_Id Int = Null,
	@iUpdate_Destination_Component_Id Bit = 0,
	@iDestination_Component_Id Int = Null,
	@iUpdate_Destination_Mill_Id Bit = 0,
	@iDestination_Mill_Id VarChar(31) = Null,
	@iUpdate_Truck_Id Bit = 0,
	@iTruck_Id VarChar(31) = Null,
	@iDelete Bit = 0
)

With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: UpdateHaulageManagementBulk
--  Purpose: Updates the flagged Source/Destination/Trucks .
--  Parameters: @iFilter_Start_Date - Returned haulage records must be after this date inclusive.
--				@iFilter_End_Date - Returned haulage records must be before this date inclusive.
--				@iFilter_Source - Returned haulage records must have this source unless null.
--				@iFilter_Destination - Returned haulage records must have this destination unless null.
--				@iFilter_Truck - Returned haulage records must have this truck id unless it is null.
--				@iUpdate_{*} - If flagged, will update the column of the filtered haulage records to @i{*}
--								Passed into UpdateHaulage Stored Procedure.
--				@i{*} - The column's value that will be entered into the filtered haulage records if @iUpdate_{*} is flagged.
--								Passed into UpdateHaulage Stored Procedure.
-- 
--  Created By:		Murray Hipper
--  Created Date: 	3 Jan 2007
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On
	
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
	
	Declare @curHAULAGE Cursor
	Declare @Haulage_Id Int
	Declare @tmp Int

	
	Set @curHAULAGE = Cursor Local Static Read_Only For
	Select Haulage_Id
	From Haulage H
	Where (Coalesce(H.Source_Digblock_Id, Cast(H.Source_Stockpile_Id As Varchar), H.Source_Mill_Id) = @iFilter_Source Or @iFilter_Source Is Null)
		And (Coalesce(H.Destination_Crusher_Id, Cast(H.Destination_Stockpile_Id As Varchar), H.Destination_Mill_Id) = @iFilter_Destination Or @iFilter_Destination Is Null)
		And (Truck_Id = @iFilter_Truck Or @iFilter_Truck Is Null)
		And Haulage_State_Id = 'N'
		And Child_Haulage_Id Is Null
		And Haulage_Date >= @iFilter_Start_Date -- For Index Purposes
		And Haulage_Date <= @iFilter_End_Date
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>=', @iFilter_Start_Date, @iFilter_Start_Shift) = 1)
		And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '<=', @iFilter_End_Date, @iFilter_End_Shift) = 1)

	-- loop through of the filtered haulage, pass the parameters to UpdateHaulage.
	Open @curHAULAGE
	Fetch Next From @curHAULAGE Into @Haulage_Id
	While @@Fetch_Status = 0
	Begin
		
		If @iDelete = 1
		Begin -- Delete the haulage records
			Exec dbo.DeleteHaulage
				@iHaulage_Id = @Haulage_Id,
				@iAction = 'STATE'
		End
		Else -- Update the haulage records
		Begin
			Exec dbo.UpdateHaulage
				@iHaulage_Id = @Haulage_Id,
				@iUpdate_Source_Digblock_Id = @iUpdate_Source_Digblock_Id,
				@iSource_Digblock_Id = @iSource_Digblock_Id,
				@iUpdate_Source_Stockpile_Id = @iUpdate_Source_Stockpile_Id,
				@iSource_Stockpile_Id = @iSource_Stockpile_Id,
				@iUpdate_Source_Build_Id = @iUpdate_Source_Build_Id,
				@iSource_Build_Id = @iSource_Build_Id,
				@iUpdate_Source_Component_Id = @iUpdate_Source_Component_Id,
				@iSource_Component_Id = @iSource_Component_Id,
				@iUpdate_Destination_Stockpile_Id = @iUpdate_Destination_Stockpile_Id,
				@iDestination_Stockpile_Id = @iDestination_Stockpile_Id,
				@iUpdate_Destination_Build_Id = @iUpdate_Destination_Build_Id,
				@iDestination_Build_Id = @iDestination_Build_Id,
				@iUpdate_Destination_Component_Id = @iUpdate_Destination_Component_Id,
				@iDestination_Component_Id = @iDestination_Component_Id,
				@iUpdate_Destination_Crusher_Id = @iUpdate_Destination_Crusher_Id,
				@iDestination_Crusher_Id = @iDestination_Crusher_Id,
				@iUpdate_Source_Mill_Id = @iUpdate_Source_Mill_Id,
				@iSource_Mill_Id = @iSource_Mill_Id,
				@iUpdate_Destination_Mill_Id = @iUpdate_Destination_Mill_Id,
				@iDestination_Mill_Id = @iDestination_Mill_Id,
				@iUpdate_Truck_Id = @iUpdate_Truck_Id,
				@iTruck_Id = @iTruck_Id
		End
		
		Fetch Next From @curHAULAGE Into @Haulage_Id
	End
	Close @curHAULAGE
	Deallocate @curHAULAGE
	

	Commit Transaction

End
GO
GRANT EXECUTE ON dbo.UpdateHaulageManagementBulk TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulageManagementBulk">
 <Procedure>
	Updates the flagged Source/Destination/Trucks in table Haulage.
	Excutes stored procedure UpdateHaulage.
	No Errors are raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageRawBulk.prc'
GO


If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[UpdateHaulageRawBulk]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[UpdateHaulageRawBulk]
GO

Create Procedure dbo.UpdateHaulageRawBulk
(
	  @iBulk_Type Varchar(31),
      @iOld_Code VarChar(63),
      @iNew_Code VarChar(63)
)

With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: UpdateHaulageRawBulk
--  Purpose: Updates all the Haulage raw records to another value given a 
--	value of a given type.
--  Parameters: @iBulk_Type - The field that will have the update. 
--					Valid: (Source | Destination | Truck)
--				@iOld_Code - The code of type @iBulk_Type to be updated.
--				@iNew_Code - The new code that @iOld_Code will be replaced with.
-- 
--  Comments:
--  
--  Created By:		Murray Hipper
--  Created Date: 	27 October 2006
--
------------------------------------------------------------------------------*/

Begin
      Declare @curHAULAGE Cursor
      Declare @Haulage_Raw_Id Int
	  Declare @New_Haulage_Raw_Id Int

      Set NoCount On

      Set Transaction Isolation Level Repeatable Read
      Begin Transaction

	If @iBulk_Type = 'Source'
	Begin
      Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
            Select Haulage_Raw_Id
            From HaulageRaw
            Where Haulage_Raw_State_Id = 'E'
                  And Source = @iOld_Code

      -- loop through each source
      -- update, change the value as necessary

      Open @curHAULAGE
      Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      While @@Fetch_Status = 0
      Begin
            Exec dbo.UpdateHaulageRaw
                  @iHaulage_Raw_Id = @Haulage_Raw_Id,
                  @iUpdate_Source = 1,
                  @iSource = @iNew_Code,
				  @oHaulage_Raw_Id = @New_Haulage_Raw_Id Output

			Exec HaulageRawResolve 
				@iHaulage_Raw_Id = @New_Haulage_Raw_Id

            Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      End
      Close @curHAULAGE
	End
	Else If @iBulk_Type = 'Destination'
	Begin
      Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
            Select Haulage_Raw_Id
            From HaulageRaw
            Where Haulage_Raw_State_Id = 'E'
                  And Destination = @iOld_Code

      -- loop through each Destination
      -- update, change the value as necessary

      Open @curHAULAGE
      Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      While @@Fetch_Status = 0
      Begin
            Exec dbo.UpdateHaulageRaw
                  @iHaulage_Raw_Id = @Haulage_Raw_Id,
                  @iUpdate_Destination = 1,
                  @iDestination = @iNew_Code,
				  @oHaulage_Raw_Id = @New_Haulage_Raw_Id Output

			Exec HaulageRawResolve 
				@iHaulage_Raw_Id = @New_Haulage_Raw_Id

            Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      End
      Close @curHAULAGE
	End
	Else If @iBulk_Type = 'Truck'
	Begin
      Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
            Select Haulage_Raw_Id
            From HaulageRaw
            Where Haulage_Raw_State_Id = 'E'
                  And Truck = @iOld_Code

      -- loop through each Truck
      -- update, change the value as necessary

      Open @curHAULAGE
      Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      While @@Fetch_Status = 0
      Begin
            Exec dbo.UpdateHaulageRaw
                  @iHaulage_Raw_Id = @Haulage_Raw_Id,
                  @iUpdate_Truck = 1,
                  @iTruck = @iNew_Code,
				  @oHaulage_Raw_Id = @New_Haulage_Raw_Id Output

			Exec HaulageRawResolve 
				@iHaulage_Raw_Id = @New_Haulage_Raw_Id

            Fetch Next From @curHAULAGE Into @Haulage_Raw_Id
      End
      Close @curHAULAGE
	End


      Commit Transaction
End
Go
GRANT EXECUTE ON dbo.UpdateHaulageRawBulk TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulageRawBulk">
 <Procedure>
	Updates all the Haulage raw records to another value given a 
	value of a given type.
	No Errors are raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateLocationType.prc'
GO

If object_id('dbo.UpdateLocationType') Is Not Null 
     Drop Procedure dbo.UpdateLocationType 
Go 
  
Create Procedure dbo.UpdateLocationType 
( 
    @iLocation_Type_Id TINYINT,
	@iParent_Location_Type_Id TINYINT = NULL,
	@iDescription varchar(255),
	@iDefines_3d_Point Bit = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		-- If the given location type does not exist
		If Not Exists 
			(
				Select 1 
				From dbo.LocationType 
				Where Location_Type_Id = @iLocation_Type_Id
			)
		Begin
			Raiserror ('The given location type does not exist', 16, 1)
		End

		--If the parent is set to itself
		If @iParent_Location_Type_Id = @iLocation_Type_Id
		Begin
			Raiserror ('The parent location can not reference itself', 16, 1)
		End 

		-- If the given parent location type does not exist
		If Not Exists 
			(
				Select 1 
				From dbo.LocationType 
				Where Location_Type_Id = @iParent_Location_Type_Id
					Or @iParent_Location_Type_Id is NULL
			)
		Begin
			Raiserror ('The given parent location type does not exist', 16, 1)
		End

		--If they are trying to do a circular reference then raise error
		If Exists
			(
				Select 1 
				From dbo.GetLocationTypeChildLocationTypeList(@iLocation_Type_Id)
				Where Location_Type_Id = @iParent_Location_Type_Id
			)
		Begin
			Raiserror ('The parent type specified is a child of one of the children for this type.', 16, 1)
		End

		--Check that the parent does not already have a child
		If Exists
			(
				Select 1 
				From dbo.LocationType	
				Where Parent_Location_Type_Id = @iParent_Location_Type_Id
					And Location_Type_Id <> @iLocation_Type_Id
			)
		Begin
			RaisError('The parent location already has a child location type. Multiple children is currently not supported.', 16, 1)
		End

		--Update Location_Type
		Update dbo.LocationType
		Set	Parent_Location_Type_Id = @iParent_Location_Type_Id,
			Description = @iDescription,
			Defines_3d_Point = IsNull(@iDefines_3d_Point, Defines_3d_Point) 
		Where Location_Type_Id = @iLocation_Type_Id

		Commit Transaction 
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateLocationType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateLocationType">
 <Procedure>
	Update the details of Location Type @iLocation_Type_Id.
	Errors are raised if:
		The given parent location type does not exist
		The given location type does not exist
		The parent location type id is equal to its own location type id
		Parent location type already has a child
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateMaterialTypeGroup.prc'
GO

If Object_Id('dbo.UpdateMaterialTypeGroup') Is Not Null
	Drop Procedure dbo.UpdateMaterialTypeGroup
Go

Create Procedure dbo.UpdateMaterialTypeGroup
(
	@iMaterial_Type_Group_Id Int,
	@iName Varchar(63),
	@iDescription Varchar(255),
	@iOrder_No Int,
	@iIs_Digblock_Group Bit,
	@iIs_Stockpile_Group Bit
)

With Encryption 
As

Begin
	Set NoCount On

	Declare @Count Int
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the material type group exists */
	Select @Count = Count(*)
	From MaterialTypeGroup
	Where Material_Type_Group_Id = @iMaterial_Type_Group_Id

	If (@Count > 0)
	Begin
		/* Check to see if any other material types have the same name */
		Select @Count = Count(*)
		From MaterialTypeGroup
		Where Material_Type_Group_Id <> @iMaterial_Type_Group_Id
		And Name = @iName

		If (@Count = 0)
		Begin
			Update MaterialTypeGroup
			Set	Name = @iName,
				Description = @iDescription,
				Order_No = IsNull(@iOrder_No, Order_No),
				Is_Digblock_Group = @iIs_Digblock_Group,
				Is_Stockpile_Group = @iIs_Stockpile_Group
			Where Material_Type_Group_Id = @iMaterial_Type_Group_Id
	
			If @@Error = 0
				SEt @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('Another material type group with the same name already exists', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given material type group does not exist', 16, 1)
	End

	
	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.UpdateMaterialTypeGroup TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateMaterialTypeGroup">
 <Procedure>
	Updated the table MaterialTypeGroup after checking that the group exists and that name does not
	already exist.
	Errors are raised if:
		Another material type group with the same name already exists.
		The given material type group does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateMaterialType.prc'
GO

IF OBJECT_ID('dbo.UpdateMaterialType') IS NOT NULL
     DROP PROCEDURE dbo.UpdateMaterialType
GO 
  
CREATE PROCEDURE dbo.UpdateMaterialType
(
	@iMaterial_Type_Id Int,
	@iDescription Varchar(63),
	@iAbbreviation Varchar(15),
	@iIs_Waste Bit = 0,
	@iDensity_Conversion_Factor Real = 1,
	@iParent_Material_Type_Id INT = NULL,
	@iMaterial_Category_Id VARCHAR(31) = NULL,
	@iMaterial_Type_Group_Id INT = NULL
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @ParentMaterialCategoryId VARCHAR(31)
	DECLARE @Message VARCHAR(1023)
	DECLARE @MaterialTypeSetting VARCHAR(255)
	DECLARE @MaterialTypeGroupId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateMaterialType',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF @iDensity_Conversion_Factor IS NULL
		BEGIN
			RaisError ('The density conversion factor can not be empty',16,1)
		END
		
		IF @iAbbreviation IS NULL
		BEGIN
			RaisError('The abbreviation can not be empty',16,1)
		END
		
		
		SELECT @MaterialTypeSetting = Value
		FROM dbo.Setting
		WHERE Setting_Id = 'MaterialTypeGrouping'
		
		-- Check for material type.
		IF NOT EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.MaterialType
			WHERE Material_Type_Id = @iMaterial_Type_Id
		)
		BEGIN
			Raiserror ('The given material type does not exist', 16, 1)
		END
		
		IF @MaterialTypeSetting = 'HIERARCHY'
		BEGIN
		
			IF @iMaterial_Type_Group_Id IS NOT NULL
			BEGIN
				RaisError('A material type group may not be specified using the hierarchy setting',16,1)
			END

			IF (SELECT Count(*) FROM dbo.MaterialTypeGroup) <> 1
			BEGIN
				RaisError('Only one material type group may be present when using the hierarchy setting',16,1)
			END
			
			SELECT @MaterialTypeGroupId = Material_Type_Group_Id
			FROM dbo.MaterialTypeGroup
		
			IF @iMaterial_Category_Id IS NULL
			BEGIN
				RaisError('A material category must be specified',16,1)
			END
						
			-- Check to make sure the material category EXISTS.
			IF NOT EXISTS 
			(
				SELECT Top 1 1 
				FROM MaterialCategory 
				WHERE MaterialCategoryId = @iMaterial_Category_Id
			)
			BEGIN
				Raiserror ('The given material category does not exist', 16, 1)
			END
			
			-- Get the parent material category of the material category.
			SELECT @ParentMaterialCategoryId = ParentMaterialCategoryId
			FROM dbo.MaterialCategory
			WHERE MaterialCategoryId = @iMaterial_Category_Id

			-- IF the parent material category IS NULL, OR IF a parent material type id has been
			-- supplied without a parent material category being present in the hierarchy THEN
			-- throw an error.
			IF ((@ParentMaterialCategoryId IS NOT NULL) AND (@iParent_Material_Type_Id IS NULL))
			BEGIN
				SET @Message = 'The given ' + Coalesce(@iMaterial_Category_Id,'')
								+ ' requires that a parent ' 
								+ Coalesce(@ParentMaterialCategoryId,'') + ' is given'
				Raiserror (@Message, 16, 1)
			END
			
			IF ((@ParentMaterialCategoryId IS NULL) AND (@iParent_Material_Type_Id IS NOT NULL))
			BEGIN
				SET @Message = 'The given material category does not support a parent'
				Raiserror (@Message, 16, 1)
			END
					
			-- Check to see IF the parent provided EXISTS in this category 
			IF NOT EXISTS 
				(
					SELECT 1 
					FROM dbo.MaterialType
					WHERE Material_Type_Id = @iParent_Material_Type_Id 
						AND Material_Category_Id = @ParentMaterialCategoryId
				)
				AND @ParentMaterialCategoryId IS NOT NULL
			BEGIN
				SET @Message = 'The given parent ' +
							 @ParentMaterialCategoryId + ' does not exist'
				Raiserror (@Message, 16, 1)
			END
					
			-- If it is at the top level and there are no parents then sure this is the only
			-- material type in this level with the same abbreviation.
			IF @ParentMaterialCategoryId IS NULL AND 
				EXISTS
				(
				SELECT Top 1 1 
				FROM dbo.MaterialType 
				WHERE Abbreviation = @iAbbreviation
					AND Material_Category_Id = @iMaterial_Category_Id
					AND Material_Type_Id <> @iMaterial_Type_Id
				)
			BEGIN
				SET @Message = 'There is already a ' +
							 @iMaterial_Category_Id + ' with this abbreviation'
				Raiserror (@Message, 16, 1)
			END
			
			-- Ensure that the abbreviation does not appear multiple times in the same category.
			IF EXISTS 
				(
					SELECT Top 1 1 
					FROM dbo.MaterialType 
					WHERE Abbreviation = @iAbbreviation 
						AND Parent_Material_Type_Id = @iParent_Material_Type_Id
						AND Material_Type_Id <> @iMaterial_Type_Id
				)
			BEGIN
				SET @Message = 'There is already a ' + 
								@iMaterial_Category_Id + ' with this name within the ' 
								+ CAST(@iParent_Material_Type_Id AS VARCHAR)
				Raiserror (@Message, 16, 1)
			END
			
			-- Check the Parent/Child Relationship is valid
			IF @iParent_Material_Type_Id IS NOT NULL
				AND NOT EXISTS
				(
					SELECT TOP 1 1
					FROM MaterialType As PMT
						INNER JOIN MaterialCategory AS PMC
							ON PMT.Material_Category_Id = PMC.MaterialCategoryId
						INNER JOIN MaterialCategory AS MC
							ON PMT.Material_Category_Id = MC.ParentMaterialCategoryId
					WHERE Material_Type_Id = @iParent_Material_Type_Id
						AND MC.MaterialCategoryId = @iMaterial_Category_Id
				)
			BEGIN
				Raiserror('The material type for this material category is not a valid child material type for its parent.', 16, 1)
			END
			
			IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.MaterialType
				WHERE Parent_Material_Type_Id = @iMaterial_Type_Id
			) AND NOT EXISTS
				(
					SELECT TOP 1 1
					FROM dbo.MaterialType
					WHERE Material_Type_Id = @iMaterial_Type_Id
						AND Material_Category_Id = @iMaterial_Category_Id
				)
			BEGIN
				Raiserror('The material type can not be moved to a different category as it has children attached.',16,1)
			END
			
		END
			
		IF @MaterialTypeSetting = 'GROUPING'
		BEGIN
		
			IF @iMaterial_Type_Group_Id IS NULL
			BEGIN
				RaisError('A material type group must be specified',16,1)
			END
			
			SELECT @MaterialTypeGroupId = @iMaterial_Type_Group_Id
			
			IF NOT EXISTS 
				(
					SELECT TOP 1 1 
					FROM MaterialTypeGroup
					WHERE Material_Type_Group_Id = @iMaterial_Type_Group_Id
				)
			BEGIN
				Raiserror('The given material type group does not exist', 16, 1)
			END
			
			IF @iParent_Material_Type_Id IS NOT NULL
			BEGIN
				RaisError('A parent material type can not be specified without a material category',16,1)
			END
		
			--Unique artificial CONSTRAINT ON abbreviation AND GROUP.
			IF EXISTS
			(
				SELECT TOP 1 1 
				FROM dbo.MaterialType 
				WHERE Abbreviation = @iAbbreviation
					AND (Material_Type_Group_Id = @iMaterial_Type_Group_Id)
					AND (Material_Type_Id <> @iMaterial_Type_Id)
			)
			BEGIN
				Raiserror ('A material type with the same abbreviation already exists in this group', 16, 1)
			END
			
		END
				
		UPDATE dbo.MaterialType
		SET	Description = @iDescription,
			Abbreviation = @iAbbreviation,
			Is_Waste = @iIs_Waste,
			Density_Conversion_Factor = @iDensity_Conversion_Factor,
			Material_Type_Group_Id = @MaterialTypeGroupId,
			Parent_Material_Type_Id = @iParent_Material_Type_Id,
			Material_Category_Id = @iMaterial_Category_Id
		WHERE Material_Type_Id = @iMaterial_Type_Id
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.UpdateMaterialType TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="UpdateMaterialType">
 <Procedure>
	Updated the table MaterialType after checking the abbreviation, description, material type group, category and parent.
	Errors are raised if:
		Another material type with the same abbreviation already exists with the same parent or in the same material type group
		The parent is not valid
		The given material type does not exist.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateObjectNotes.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateObjectNotes'))
	Drop Procedure dbo.UpdateObjectNotes
Go

CREATE Procedure dbo.UpdateObjectNotes
(
	@iObject_Id Varchar(31),
	@iDescription Varchar(255) = Null,
	@iNotes Varchar(8000)
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the object notes value exists */
	If Exists (Select * From ObjectNotes Where Object_Id = @iObject_Id)
	Begin
		/* Update it's details */
		Update ObjectNotes
		Set	Description = @iDescription,
			Notes = @iNotes
		Where Object_Id = @iObject_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given object does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.UpdateObjectNotes TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateObjectNotes">
 <Procedure>
	Updated the table ObjectNotes if the the object notes value exists.
	Errors are raised if:
		The given object does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateSetting.prc'
GO

If Object_Id('dbo.UpdateSetting') Is Not Null
	Drop Procedure dbo.UpdateSetting
Go

Create Procedure dbo.UpdateSetting
(
	@iSetting_Id Varchar(63),
	@iValue Varchar(255)
)

With Encryption 
As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Update the setting value */
	Update Setting
	Set	[Value] = @iValue
	Where Setting_Id = @iSetting_Id

	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0
	
	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.UpdateSetting TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateSetting">
 <Procedure>
	Updated the table Setting for a given Setting_Id.
	No errors are raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileGroup.prc'
GO

If object_id('dbo.UpdateStockpileGroup') is not Null 
     Drop Procedure dbo.UpdateStockpileGroup 
Go 
  
Create Procedure dbo.UpdateStockpileGroup 
( 
    @iStockpile_Group_Id Varchar(31),	
	@iUpdate_Description bit = 0,
	@iDescription Varchar(255) = Null,
	@iUpdate_Order_No bit = 0,
	@iOrder_No Int = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		If Not Exists
			( 
				Select 1
				From StockpileGroup
				Where Stockpile_Group_Id = @iStockpile_Group_Id
			)
		Begin
			Raiserror ('The given stockpile group does not exist', 16 ,1)
		End
		
		Update StockpileGroup
		Set Description = Case When @iUpdate_Description = 1 Then @iDescription Else Description End,
			Order_No = Case When @iUpdate_Order_No = 1 Then @iOrder_No Else Order_No End
		Where Stockpile_Group_Id = @iStockpile_Group_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go	
GRANT EXECUTE ON dbo.UpdateStockpileGroup TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileGroup">
 <Procedure>
	Updated the table StockpileGroup if the stockpile group exists.
	Errors are raised if:
		The given stockpile group does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpile.prc'
GO

IF OBJECT_ID('dbo.UpdateStockpile') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateStockpile  
GO 
  
CREATE PROCEDURE dbo.UpdateStockpile 
( 
	@iStockpile_Id INT,
	@iUpdate_Stockpile_Name BIT = 0,
	@iStockpile_Name VARCHAR(31) = NULL,
	@iUpdate_Description BIT = 0,
	@iDescription VARCHAR(255) = NULL,
	@iUpdate_Is_Multi_Build BIT = 0,
	@iIs_Multi_Build BIT = NULL,
	@iUpdate_Is_Multi_Component BIT = 0,
	@iIs_Multi_Component BIT = NULL,
	@iUpdate_Material_Type_Id BIT = 0,
	@iMaterial_Type_Id INT = NULL,
	@iUpdate_Is_In_Reports BIT = NULL,
	@iIs_In_Reports BIT = NULL,
	@iUpdate_Max_Tonnes BIT = 0,	
	@iMax_Tonnes FLOAT = 0,
	@iUpdate_Is_Visible BIT = 0,
	@iIs_Visible BIT = 1,
	@iUpdate_Notes BIT = 0,
	@iNotes VARCHAR(4095) = NULL,
	@iUpdate_Start_Tonnes BIT = 0,
	@iStart_Tonnes FLOAT = 0,
	@iHaulage_Raw_Resolve_All BIT = 1
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'UpdateStockpile',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
    BEGIN TRY
		--IF the stockpile does not exist
		IF NOT EXISTS 
		(	
			SELECT 1
			FROM dbo.Stockpile
			WHERE Stockpile_Id = @iStockpile_Id
		)
		BEGIN
			RAISERROR('The given stockpile does not exist', 16, 1)
		END

		IF @iUpdate_Stockpile_Name = 1
			AND EXISTS 
				(	
					SELECT 1 
					FROM dbo.Stockpile 
					WHERE Stockpile_Id <> @iStockpile_Id 
						AND Stockpile_Name = @iStockpile_Name
				)
		BEGIN
			RAISERROR('Another stockpile has the same name', 16, 1)
		END

		-- If changing from a Multi Build Stockpile to a Single Build Stockpile
		-- raise an error IF there are already multiple builds against the stockpile
		IF @iUpdate_Is_Multi_Build = 1 AND @iIs_Multi_Build = 0
			AND 
				(
					SELECT Count(*)
					FROM dbo.StockpileBuild
					WHERE Stockpile_Id = @iStockpile_Id
				) > 1
		BEGIN
			RAISERROR('Cannot change Stockpile from Multi Build to Single Build as it already has multiple builds', 16, 1)	
		END

		UPDATE dbo.Stockpile
		SET	Description = (CASE WHEN @iUpdate_Description = 1 THEN @iDescription ELSE Description END),
			Stockpile_Name = (CASE WHEN @iUpdate_Stockpile_Name = 1 THEN @iStockpile_Name ELSE Stockpile_Name END),
			Is_Multi_Build = (CASE WHEN @iUpdate_Is_Multi_Build = 1 THEN @iIs_Multi_Build ELSE Is_Multi_Build END),
			Is_Multi_Component = (CASE WHEN @iUpdate_Is_Multi_Component = 1 THEN @iIs_Multi_Component ELSE Is_Multi_Component END),
			Material_Type_Id = (CASE WHEN @iUpdate_Material_Type_Id = 1 THEN @iMaterial_Type_Id ELSE @iMaterial_Type_Id END),
			Is_In_Reports = (CASE WHEN @iUpdate_Is_In_Reports = 1 THEN @iIs_In_Reports ELSE Is_In_Reports END),
			Max_Tonnes = (CASE WHEN @iUpdate_Max_Tonnes = 1 THEN @iMax_Tonnes ELSE Max_Tonnes END),
			Is_Visible = (CASE WHEN @iUpdate_Is_Visible = 1 THEN @iIs_Visible ELSE Is_Visible END),
			Notes = (CASE WHEN @iUpdate_Notes = 1 THEN @iNotes ELSE Notes END)
		WHERE Stockpile_Id = @iStockpile_Id

		IF @iIs_Multi_Build = 0 And @iUpdate_Start_Tonnes = 1
		BEGIN		
			EXEC dbo.UpdateStockpileBuildComponent
				@iStockpile_Id = @iStockpile_Id,
				@iBuild_Id = 1,
				@iComponent_Id = 1,
				@iUpdate_Start_Tonnes = @iUpdate_Start_Tonnes,
				@iStart_Tonnes = @iStart_Tonnes,
				@iHaulage_Raw_Resolve_All = @iHaulage_Raw_Resolve_All
		END
		ELSE IF @iIs_Multi_Build = 1 And @iUpdate_Start_Tonnes = 1
		BEGIN
			RAISERROR('Cannot update start tonnes on a multi build stockpile using this procedure.', 16, 1)	
		END			

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.UpdateStockpile TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpile">
 <Procedure>
	Updated the table Stockpile if the stockpile exists and if the 
	stockpile description is not the same as any other stockpile description.
	Errors are raised if:
		Another stockpile has the same description.
		The given stockpile does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileBuild.prc'
GO

IF OBJECT_ID('dbo.UpdateStockpileBuild') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateStockpileBuild  
GO 
  
CREATE PROCEDURE dbo.UpdateStockpileBuild 
( 
    @iStockpile_Id INT,
	@iBuild_Id INT = NULL,
	@iUpdate_Stockpile_State_Id BIT = 0,
	@iStockpile_State_Id VARCHAR(10) = NULL,
	@iUpdate_Start_Date BIT = 0,
	@iStart_Date DATETIME = NULL,
	@iUpdate_Start_Shift BIT = 0,
	@iStart_Shift CHAR(1) = NULL,
	@iUpdate_Reclaim_Start_Date BIT = 0,
	@iReclaim_Start_Date DATETIME = NULL,
	@iUpdate_Reclaim_Start_Shift BIT = 0,
	@iReclaim_Start_Shift CHAR(1) = NULL,
	@iUpdate_End_Date BIT = 0,
	@iEnd_Date DATETIME = NULL,
	@iUpdate_End_Shift BIT = 0,
	@iEnd_Shift CHAR(1) = NULL,
	@iUpdate_Completion_Description BIT = 0,
	@iCompletion_Description VARCHAR(255) = NULL,
	@iHaulage_Raw_Resolve_All BIT = 1
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
	DECLARE @CurrentStartDate DATETIME
	DECLARE @CurrentStartShift CHAR(1)
	DECLARE @CurrentReclaimStartDate DATETIME
	DECLARE @CurrentReclaimStartShift CHAR(1)
	DECLARE @CurrentEndDate DATETIME
	DECLARE @CurrentEndShift CHAR(1)
	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @ReclaimStartDate DATETIME
	DECLARE @ReclaimStartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1)
	DECLARE @RecalcDate DATETIME
	DECLARE @RecalcShift CHAR(1)
	DECLARE @StockpileStateId VARCHAR(10)
	DECLARE @CompletionDescription VARCHAR(255)

		
	SELECT @TransactionName = 'UpdateStockpileBuild',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
    BEGIN TRY
		--If a build was not given use the max build for the stockpile
		IF @iBuild_Id IS NULL
		BEGIN
			SELECT @iBuild_Id = Max(Build_Id)
			FROM dbo.StockpileBuild
			WHERE Stockpile_Id = @iStockpile_Id
		END

		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.StockpileBuild	
				WHERE Stockpile_Id = @iStockpile_Id 
					AND Build_Id = @iBuild_Id
			)
		BEGIN
			RaisError ('Stockpile build does not exist', 16, 1)
		END

		--Get some current details about the stockpile
		--and determine the details that will be validated
		SELECT @CurrentStartDate = Start_Date,
			@CurrentStartShift = Start_Shift,
			@CurrentReclaimStartDate = Reclaim_Start_Date,
			@CurrentReclaimStartShift = Reclaim_Start_Shift,
			@CurrentEndDate = End_Date,
			@CurrentEndShift = End_Shift,
			@StartDate = 
				CASE WHEN @iUpdate_Start_Date = 1 THEN 
					dbo.GetDateDay(@iStart_Date)
				ELSE 
					Start_Date 
				END,
			@StartShift = 
				CASE WHEN @iUpdate_Start_Shift = 1 THEN 
					@iStart_Shift 
				ELSE 
					Start_Shift 
				END,
			@ReclaimStartDate = 
				CASE WHEN @iUpdate_Reclaim_Start_Date = 1 THEN 
					dbo.GetDateDay(@iReclaim_Start_Date)
				ELSE 
					Reclaim_Start_Date 
				END,
			@ReclaimStartShift = 
				CASE WHEN @iUpdate_Reclaim_Start_Shift = 1 THEN 
					@iReclaim_Start_Shift 
				ELSE 
					Reclaim_Start_Shift 
				END,
			@EndDate = 
				CASE WHEN @iUpdate_End_Date = 1 THEN 
					dbo.GetDateDay(@iEnd_Date)
				ELSE 
					End_Date 
				END,
			@EndShift = 
				CASE WHEN @iUpdate_End_Shift = 1 THEN 
					@iEnd_Shift 
				ELSE 
					End_Shift 
				END,
			@StockpileStateId = 
				CASE WHEN @iUpdate_Stockpile_State_Id = 1 THEN
					@iStockpile_State_Id
				ELSE
					Stockpile_State_Id
				END,
			@CompletionDescription = 
				CASE WHEN @iUpdate_Completion_Description = 1 THEN
					@iCompletion_Description
				ELSE
					Completion_Description
				END 						
		FROM dbo.StockpileBuild
		WHERE Stockpile_Id = @iStockpile_Id
			AND Build_Id = @iBuild_Id

		EXEC dbo.ValidateStockpileStateChange 
			@iStockpile_Id = @iStockpile_Id, 
			@iBuild_Id = @iBuild_Id, 
			@iStockpile_State_Id = @StockpileStateId, 
			@iStart_Date = @StartDate, 
			@iStart_Shift = @StartShift,
			@iReclaim_Start_Date = @ReclaimStartDate, 
			@iReclaim_Start_Shift = @ReclaimStartShift,
			@iEnd_Date = @EndDate, 
			@iEnd_Shift = @EndShift,
			@iCompletion_Description = @CompletionDescription,
			@iNew_Build = 0

		UPDATE dbo.StockpileBuild
		SET	Start_Date = @StartDate, 
			Start_Shift = @StartShift,
			Reclaim_Start_Date = @ReclaimStartDate,
			Reclaim_Start_Shift = @ReclaimStartShift,
			End_Date = @EndDate,
			End_Shift = @EndShift,
			Completion_Description = @CompletionDescription,
			Stockpile_State_Id = @StockpileStateId
		WHERE Stockpile_Id = @iStockpile_Id
			AND Build_Id = @iBuild_Id


		SELECT Top 1 @RecalcDate = A.Date, @RecalcShift = A.Shift
		FROM 
			(
				SELECT @CurrentStartDate AS Date, @CurrentStartShift AS Shift
				WHERE @iUpdate_Start_Date = 1
				UNION
				SELECT @CurrentReclaimStartDate, @CurrentReclaimStartShift
				WHERE @iUpdate_Reclaim_Start_Date = 1
				UNION
				SELECT @CurrentEndDate, @CurrentEndShift
				WHERE @iUpdate_End_Date = 1
				UNION
				SELECT @StartDate AS Date, @StartShift AS Shift
				WHERE @iUpdate_Start_Date = 1
				UNION
				SELECT @ReclaimStartDate, @ReclaimStartShift
				WHERE @iUpdate_Reclaim_Start_Date = 1
				UNION
				SELECT @EndDate, @EndShift
				WHERE @iUpdate_End_Date = 1
			) AS A
			INNER JOIN dbo.ShiftType AS ST
				ON (A.Shift = ST.Shift)
		WHERE A.Date IS NOT NULL
		ORDER BY A.Date ASC, ST.Order_No ASC

		-- Raise the Recalc
		EXEC dbo.RecalcL2Raise	
			@pDate = @RecalcDate,
			@pShift = @RecalcShift

		-- Resolve Haulage Errors if required
		IF @iHaulage_Raw_Resolve_All = 1
		BEGIN
			EXEC dbo.HaulageRawResolveAll				
		END

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO 
GRANT EXECUTE ON dbo.UpdateStockpileBuild TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileBuild">
 <Procedure>
	Updated the table StockpileBuild if the stockpile and build exists.
	Errors are raised if:
		ValidateStockpileStateChange returns an error.
	Raises a recalc.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileBuildComponent.prc'
GO

If object_id('dbo.UpdateStockpileBuildComponent') is not Null 
     Drop Procedure dbo.UpdateStockpileBuildComponent 
Go 

Create Procedure dbo.UpdateStockpileBuildComponent
(
	@iStockpile_Id Int,
	@iBuild_Id Int,
	@iComponent_Id Int,
	@iUpdate_Layer Bit = 0,
	@iLayer Int = Null,
	@iUpdate_Name Bit = 0,
	@iName VarChar(31) = Null,
	@iUpdate_Start_Tonnes Bit = 0,
	@iStart_Tonnes Float = 0,
	@iHaulage_Raw_Resolve_All Bit = 1
)

With Encryption 
As

Begin

	Declare @Layer Int
	Declare @Name VarChar(31)
	Declare @Start_Tonnes Float
	Declare @Recalc_Date Datetime
	Declare @Recalc_Shift Char(1)


	--Check that the Stockpile_Id, Build_Id and Component_Id primary key exists
	If Not Exists (Select 1 
					From StockpileBuildComponent 
					Where Stockpile_Id = @iStockpile_Id
						And Build_Id = @iBuild_Id
						And Component_Id = @iComponent_Id)
	Begin
		Raiserror ('The stockpile build component does not exist', 16, 1)
	End
	Else
	Begin

		--Get Recalc Details 
		Select @Recalc_Date = Start_Date,
			@Recalc_Shift = Start_Shift
		From StockpileBuild
		Where Stockpile_Id = @iStockpile_Id
			And Build_Id = @iBuild_Id

		--Create list of updated values
		Select @Layer = (Case
							When @iUpdate_Layer = 1 Then
								@iLayer
							Else
								Layer
						End),
			@Name = (Case
							When @iUpdate_Name = 1 Then
								@iName
							Else
								Name
						End),
			@Start_Tonnes = (Case
							When @iUpdate_Start_Tonnes = 1 Then
								@iStart_Tonnes
							Else
								Start_Tonnes
						End)
		From dbo.StockpileBuildComponent
		Where Stockpile_Id = @iStockpile_Id
			And Build_Id = @iBuild_Id
			And Component_Id = @iComponent_Id
	

		--Update the record
		Update dbo.StockpileBuildComponent
		Set Layer = @Layer,
			Name = @Name,
			Start_Tonnes = @Start_Tonnes
		Where Stockpile_Id = @iStockpile_Id
			And Build_Id = @iBuild_Id
			And Component_Id = @iComponent_Id

		-- Raise the Recalc
		Exec RecalcL2Raise	
			@pDate=@Recalc_Date,
			@pShift=@Recalc_Shift

		-- Resolve Haulage Errors if required
		If @iHaulage_Raw_Resolve_All = 1
		Begin
			Exec dbo.HaulageRawResolveAll				
		End

	End
End
Go
GRANT EXECUTE ON dbo.UpdateStockpileBuildComponent TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileBuildComponent">
 <Procedure>
	Updated the table StockpileBuildComponent.
	Errors are raised if:
		Stockpile_Id, Build_Id and Component_Id primary key does not exists
	Raises a recalc.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileGroupOrderNo.prc'
GO

If object_id('dbo.UpdateStockpileGroupOrderNo') is not Null 
     Drop Procedure dbo.UpdateStockpileGroupOrderNo 
Go 
  
Create Procedure dbo.UpdateStockpileGroupOrderNo
( 
    @iStockpile_Group_Id Varchar(31),
	@iIncrement Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @Current_Num Int, 
			@New_Num Int,
			@Existing_Stockpile_Group_Id Varchar(31)
  
	Begin Try
		--Validate Increment
		If @iIncrement <> -1 and @iIncrement <> 1
			RaisError('The adjusting increment must be -1 or 1', 16, 1)

		Select @Current_Num = Order_No, @New_Num = Order_No + @iIncrement
		From StockpileGroup
		Where Stockpile_Group_Id = @iStockpile_Group_Id

		--If its the first one then do nothing if we're going up
		If @New_Num < 1 
			Set @New_Num = 1

		--If New Num is higher than the count of all the groups
		--then we have tried to set it higher than it should go so put it at the max
		--allowed value.
		Select @New_Num = Count(*)
		From StockpileGroup
		Having @New_Num > Count(*)

		--Only get the first group to swap order_no's with
		Select Top 1 @Existing_Stockpile_Group_Id = Stockpile_Group_Id
		From StockpileGroup
		Where Order_No = @New_Num
			--Do not want to swap order number with the same group.
			And Stockpile_Group_Id <> @iStockpile_Group_Id 
	
		Update StockpileGroup	
		Set Order_No = @New_Num
		Where Stockpile_Group_Id = @iStockpile_Group_Id
		
		Update StockpileGroup	
		Set Order_No = @Current_Num
		Where Stockpile_Group_Id = @Existing_Stockpile_Group_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateStockpileGroupOrderNo TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileGroupOrderNo">
 <Procedure>
	Adjusts the order number of a stockpile group up (Order_Num - 1) 
	or down (Order_No + 1), whilst maintaining the integrity of the 
	ordering by changing the one above or below it in conjunction.

	Errors are raised if:
		The increment is not -1 or 1 which represents Up or Down.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateTruckType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateTruckType'))
	Drop Procedure dbo.UpdateTruckType
Go

CREATE Procedure dbo.UpdateTruckType
(
	@iTruck_Type_Id Int,
	@iName Varchar(63),
	@iDescription Varchar(255),
	@iIs_Default Bit = NULL
)

With Encryption 
As

Begin

	Declare @Count Int

	Set Nocount On
	
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the truck type exists */
	Select @Count = Count(*)
	From TruckType
	Where Truck_Type_Id = @iTruck_Type_Id

	/* If it does */
	If (@Count > 0)
	Begin
		/* If a NULL was specified, then check to see if this Truck is the default */
		If (@iIs_Default Is Null)
		Begin
			Select @iIs_Default = Is_Default
			From TruckType
			Where Truck_Type_Id = @iTruck_Type_Id
		End

		If (@iIs_Default = 1)
		Begin
			Set @iIs_Default = 1
		End
		Else
		Begin
			Set @iIs_Default = 0
		End
		
		Update TruckType
		Set	Name = @iName,
			Description = @iDescription,
			Is_Default = @iIs_Default
		Where Truck_Type_Id = @iTruck_Type_Id

		If (@iIs_Default = 1)
		Begin
			Update TruckType
			Set	Is_Default = 0
			Where Truck_Type_Id <> @iTruck_Type_Id
		End

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given truck type does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.UpdateTruckType TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateTruckType">
 <Procedure>
	Update table TruckType details.
	Errors are raised if:
		The given truck type does not exist.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateTruck.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateTruck'))
	Drop Procedure dbo.UpdateTruck
Go

CREATE Procedure dbo.UpdateTruck
(
	@iTruck_Id Varchar(31),
	@iTruck_Type_Id Int,
	@iDescription Varchar(255) = Null
)

With Encryption 
As

Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If a truck with this name exists */
	If (dbo.DoesTruckExist (@iTruck_Id) = 1)
	Begin
		/* If the given truck type exists */
		If Exists (Select * From TruckType Where Truck_Type_Id = @iTruck_Type_Id)
		Begin
			Update Truck
			Set	Truck_Type_Id = @iTruck_Type_Id,
				Description = @iDescription
			Where Truck_Id = @iTruck_Id

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given truck type does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given truck does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.UpdateTruck TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateTruck">
 <Procedure>
	Update table Truck if a truck with this name exists and if the given truck type exists.
	Errors are raised if:
		The given truck type does not exist.
		The given truck does not exist.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateUserInterfaceListingFieldOrderNo.prc'
GO

If object_id('dbo.UpdateUserInterfaceListingFieldOrderNo') is not Null 
     Drop Procedure dbo.UpdateUserInterfaceListingFieldOrderNo 
Go 
  
Create Procedure dbo.UpdateUserInterfaceListingFieldOrderNo 
( 
	@iUser_Interface_Listing_Field_Id Int,
	@iIncrement SmallInt
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @Current_Num Int, 
			@New_Num Int,
			@User_Interface_Listing_Id Int,
			@Existing_Field_Id Varchar(31),
			@Is_Visible bit
  
    Begin Try
		--Validate Increment
		If IsNull(@iIncrement, 0) <> -1 And IsNull(@iIncrement, 0) <> 1
			RaisError('The adjusting increment must be -1 or 1', 16, 1)

		--Get the current number and the new number
		Select @Current_Num = Order_No, @New_Num = Order_No + @iIncrement,
			@User_Interface_Listing_Id = User_Interface_Listing_Id
		From UserInterfaceListingField
		Where User_Interface_Listing_Field_Id = @iUser_Interface_Listing_Field_Id

		--If its the first one then do nothing if we're going up
		If @New_Num < 0 
			Set @New_Num = 0

		--If New Num is higher than the count of all the groups minus 1 (its zero based)
		--then we have tried to set it higher than it should go so put it at the max
		--allowed value.
		Select @New_Num = Count(*) - 1
		From UserInterfaceListingField
		Where Is_Visible = 1
			And User_Interface_Listing_Id = @User_Interface_Listing_Id 
		Having IsNull(@New_Num, 99) > Count(*) - 1

		--Check the original num is not greater than the count (a null was saved through UI)
		--Treat it as a Null
		Select @Current_Num = Null
		From UserInterfaceListingField
		Where Is_Visible = 1
			And User_Interface_Listing_Id = @User_Interface_Listing_Id 
		Having @Current_Num > Count(*) - 1

		--We've tried to move a Null up
		--The New num is already the max entry so its gonna try and swap the max with null
		--We've obviously got a gap in order numbers somewhere so lets plug the gap and move this one in
		If @Current_Num Is Null
		Begin
			--If theres no zero we can fill the hole by moving everything down 1
			Update F
			Set Order_No = Order_No - 1
			From UserInterfaceListingField As F
			Where Order_No > 0
				And Not Exists 
					(
						Select 1 
						From UserInterfaceListingField 
						Where Order_No = 0
							And Is_Visible = 1
							And User_Interface_Listing_Id = @User_Interface_Listing_Id	
					)
		End
		
		--Only get the first group to swap order_no's with
		Select Top 1 @Existing_Field_Id = User_Interface_Listing_Field_Id
		From UserInterfaceListingField
		Where Order_No = @New_Num
			And Is_Visible = 1
			And User_Interface_Listing_Id = @User_Interface_Listing_Id 
			--Do not want to swap order number with the same group.
			And User_Interface_Listing_Field_Id <> @iUser_Interface_Listing_Field_Id 
	
		Update UserInterfaceListingField	
		Set Order_No = @New_Num
		Where User_Interface_Listing_Field_Id = @iUser_Interface_Listing_Field_Id
		
		Update UserInterfaceListingField	
		Set Order_No = @Current_Num
		Where User_Interface_Listing_Field_Id = @Existing_Field_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateUserInterfaceListingFieldOrderNo TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateUserInterfaceListingFieldOrderNo">
 <Procedure>
	This procedure will regulate and modify the order number for a UI Field.
 </Procedure>
</TAG>
*/	





GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateWasteType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateWasteType'))
	Drop Procedure dbo.UpdateWasteType
Go

CREATE Procedure dbo.UpdateWasteType
(
	@iWaste_Type_Id Varchar(31),
	@iDescription Varchar(255)
)

With Encryption 
As

Begin

	Declare @Count Int

	Set Nocount On
	
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* Check to see if the truck type exists */
	Select @Count = Count(*)
	From WasteType
	Where Waste_Type_Id = @iWaste_Type_Id

	/* If it does */
	If (@Count > 0)
	Begin
		
		Update WasteType
		Set	Description = @iDescription
		Where Waste_Type_Id = @iWaste_Type_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given waste type does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.UpdateWasteType TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateWasteType">
 <Procedure>
	This procedure update the WasteType details for @iWaste_Type_Id.
	Errors are raised if:
		The given waste type does not exist
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateWeightometerSample.prc'
GO

If Object_Id('dbo.UpdateWeightometerSample') Is Not Null
	Drop Procedure dbo.UpdateWeightometerSample
Go
 
Create Procedure dbo.UpdateWeightometerSample
(
	@iWeightometer_Sample_Id Int,
	@iUpdate_Weightometer_Id Bit = 0,
	@iWeightometer_Id VarChar(31) = Null,
	@iUpdate_Weightometer_Sample_Date Bit = 0,
	@iWeightometer_Sample_Date DateTime = Null,
	@iUpdate_Weightometer_Sample_Shift Bit = 0,
	@iWeightometer_Sample_Shift Char(1) = Null,
	@iUpdate_Order_No Bit = 0,
	@iOrder_No Int = Null,
	@iUpdate_Tonnes Bit = 0,
	@iTonnes Float = Null,
	@iUpdate_Corrected_Tonnes Bit = 0,
	@iCorrected_Tonnes Float = Null,
	@iUpdate_Source_Stockpile_Id Bit = 0,
	@iSource_Stockpile_Id Int = Null,
	@iUpdate_Destination_Stockpile_Id Bit = 0,
	@iDestination_Stockpile_Id Int = Null
)
With Encryption
As
Begin
	Declare @Old_Source_Stockpile_Id Int
	Declare @Old_Destination_Stockpile_Id Int
	Declare @Source_Stockpile_Id Int
	Declare @Destination_Stockpile_Id Int
	Declare @Is_Source_Stockpile_Valid Bit
	Declare @Is_Destination_Stockpile_Valid Bit
	Declare @Shift_Order_No Int
	Declare @Weightometer_Type_Id VarChar(31)
	Declare @Raised_Date Datetime

	-- replacement for AddOrUpdateWeightometerSample

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- collect the old weightometer connection details
	Select
		@Old_Source_Stockpile_Id = Source_Stockpile_Id,
		@Old_Destination_Stockpile_Id = Destination_Stockpile_Id
	From dbo.WeightometerSample
	Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

	-- specifically, do not attempt to re-evaluate weightometer flow period details
	-- these details are evaluated at add-time only

	-- determine the true target source/destination
	Set @Source_Stockpile_Id =
		Case @iUpdate_Source_Stockpile_Id
			When 0 Then @Old_Source_Stockpile_Id
			When 1 Then @iSource_Stockpile_Id
		End
	Set @Destination_Stockpile_Id =
		Case @iUpdate_Destination_Stockpile_Id
			When 0 Then @Old_Destination_Stockpile_Id
			When 1 Then @iDestination_Stockpile_Id
		End
		
	If @iWeightometer_Sample_Shift Is Null
	Begin
		Select @iWeightometer_Sample_Shift = Weightometer_Sample_Shift
		From dbo.WeightometerSample
		Where Weightometer_Sample_Id = @iWeightometer_Sample_Id
	End
	
	If @iWeightometer_Sample_Date Is Null
	Begin
		Select @iWeightometer_Sample_Date = Weightometer_Sample_Date
		From dbo.WeightometerSample
		Where Weightometer_Sample_Id = @iWeightometer_Sample_Id
	End

	-- check whether the source stockpile is valid
	Set @Is_Source_Stockpile_Valid = 1
	If (@Source_Stockpile_Id Is Not Null)
	Begin
		-- check that there is a reclaimable build for the specified stockpile
		If Not (@iWeightometer_Sample_Shift Is Null)
		Begin
			-- check for the particular shift
			If dbo.GetReclaimableStockpileBuild(@Source_Stockpile_Id, @iWeightometer_Sample_Date, @iWeightometer_Sample_Shift) Is Null
			Begin
				Set @Is_Source_Stockpile_Valid = 0
			End
		End
		Else
		Begin
			-- if the shift has not been provided, check all shifts on the day
			Set @Shift_Order_No = (Select Min(Order_No) From dbo.ShiftType)
			While @Shift_Order_No <= dbo.GetShiftTypeOrderNo(dbo.GetLastShiftType())
					And @Is_Source_Stockpile_Valid = 1
			Begin
				If dbo.GetReclaimableStockpileBuild(@Source_Stockpile_Id, @iWeightometer_Sample_Date, dbo.GetShiftTypeOrderNo(@Shift_Order_No)) Is Null
				Begin
					Set @Is_Source_Stockpile_Valid = 0
				End
				
				Set @Shift_Order_No = @Shift_Order_No + 1
			End
		End
	End

	-- check whether the destination stockpile is valid
	Set @Is_Destination_Stockpile_Valid = 1
	If (@Destination_Stockpile_Id Is Not Null)
	Begin
		-- check that there is a buildable build for the specified stockpile
		If Not (@iWeightometer_Sample_Shift Is Null)
		Begin
			-- check for the particular shift
			If dbo.GetBuildableStockpileBuild(@Destination_Stockpile_Id, @iWeightometer_Sample_Date, @iWeightometer_Sample_Shift) Is Null
			Begin
				Set @Is_Destination_Stockpile_Valid = 0
			End
		End
		Else
		Begin
			-- if the shift has not been provided, check all shifts on the day
			Set @Shift_Order_No = (Select Min(Order_No) From dbo.ShiftType)
			While @Shift_Order_No <= dbo.GetShiftTypeOrderNo(dbo.GetLastShiftType())
					And @Is_Destination_Stockpile_Valid = 1
			Begin
				If dbo.GetBuildableStockpileBuild(@Destination_Stockpile_Id, @iWeightometer_Sample_Date, dbo.GetShiftTypeOrderNo(@Shift_Order_No)) Is Null
				Begin
					Set @Is_Destination_Stockpile_Valid = 0
				End
				
				Set @Shift_Order_No = @Shift_Order_No + 1
			End
		End
	End

	-- perform regular checks
	If (@iUpdate_Tonnes = 1) And Coalesce(@iTonnes, 0.0) < 0.0
	Begin
		RaisError('dbo.UpdateWeightometerSample: Tonnes cannot be less than zero.', 16, 1)
	End
	Else If (@iUpdate_Corrected_Tonnes = 1) And Coalesce(@iCorrected_Tonnes, 0.0) < 0.0
	Begin
		RaisError('dbo.UpdateWeightometerSample: Corrected_Tonnes cannot be less than zero.', 16, 1)
	End
	Else If @Is_Source_Stockpile_Valid = 0
	Begin
		RaisError('dbo.UpdateWeightometerSample: The source stockpile specified cannot be reclaimed from.', 16, 1)
	End
	Else If @Is_Destination_Stockpile_Valid = 0
	Begin
		RaisError('dbo.UpdateWeightometerSample: The destination stockpile specified cannot be built to.', 16, 1)
	End
	Else
	Begin
		-- perform the update

		Update dbo.WeightometerSample
		Set Weightometer_Id =
				Case @iUpdate_Weightometer_Id
					When 0 Then Weightometer_Id
					When 1 Then @iWeightometer_Id
				End,
			Weightometer_Sample_Date =
				Case @iUpdate_Weightometer_Sample_Date
					When 0 Then Weightometer_Sample_Date
					When 1 Then @iWeightometer_Sample_Date
				End,
			Weightometer_Sample_Shift =
				Case @iUpdate_Weightometer_Sample_Shift
					When 0 Then Weightometer_Sample_Shift
					When 1 Then @iWeightometer_Sample_Shift
				End,
			Order_No =
				Case @iUpdate_Order_No
					When 0 Then Order_No
					When 1 Then @iOrder_No
				End,
			Tonnes =
				Case @iUpdate_Tonnes
					When 0 Then Tonnes
					When 1 Then @iTonnes
				End,
			Corrected_Tonnes =
				Case @iUpdate_Corrected_Tonnes
					When 0 Then Corrected_Tonnes
					When 1 Then @iCorrected_Tonnes
				End,
			Source_Stockpile_Id = @Source_Stockpile_Id,
			Destination_Stockpile_Id = @Destination_Stockpile_Id
		Where Weightometer_Sample_Id = @iWeightometer_Sample_Id

		-- Obtain the date to be use when raising recalc
		Select @Raised_Date = Weightometer_Sample_Date
		From dbo.WeightometerSample
		Where Weightometer_Sample_Id = @iWeightometer_Sample_Id
		
		-- determine if a recalc is required
		Select @Weightometer_Type_Id = Weightometer_Type_Id
		From dbo.Weightometer
		Where Weightometer_Id = @iWeightometer_Id

		If @Weightometer_Type_Id = 'CVF'
		Begin
			Exec dbo.CalcVirtualFlowRaise
				@pCalc_Date = @Raised_Date
		End
		Else If @Weightometer_Type_Id = 'L1'
		Begin
			Exec dbo.RecalcL1Raise
				@pDate = @Raised_Date
		End
		Else If @Weightometer_Type_Id = 'CVF+L1'
		Begin
			Exec dbo.CalcVirtualFlowRaise
				@pCalc_Date = @Raised_Date

			Exec dbo.RecalcL1Raise
				@pDate = @Raised_Date
		End
	End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.UpdateWeightometerSample TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateWeightometerSample">
 <Procedure>
	This stored procedure is the replacement for stored procedure AddOrUpdateWeightometerSample.
	Updates the table WeightometerSample if all checks pass.
	Errors are raised if:
		dbo.UpdateWeightometerSample: Tonnes cannot be less than zero.
		dbo.UpdateWeightometerSample: Corrected_Tonnes cannot be less than zero.
		dbo.UpdateWeightometerSample: The source stockpile specified cannot be reclaimed from.
		dbo.UpdateWeightometerSample: The destination stockpile specified cannot be built to.
		
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRandomNumber.prc'
GO

 If object_id('dbo.GetRandomNumber') is not Null 
     Drop Procedure dbo.GetRandomNumber 
Go 
  
Create Procedure dbo.GetRandomNumber 
( 
   	@iVariance Float,
	@oRandomNumber Float Output
) 
With Encryption 
As 

Begin 

    Set NoCount On 
    
    --Pass a range of numbers, get a random number within the inclusive range
  
	Select @oRandomNumber = @iVariance + (Rand(CHECKSUM(NEWID())) * 2 * (1-@iVariance))
	
End 
Go	

/*
<TAG Name="Data Dictionary" ProcedureName="GetRandomNumber">
 <Procedure>
	Returns a random number.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRandomNumberRange.prc'
GO

  If object_id('dbo.GetRandomNumberRange') is not Null 
     Drop Procedure dbo.GetRandomNumberRange 
Go 
  
Create Procedure dbo.GetRandomNumberRange 
( 
	@iMinValue Int = Null,
    @iMaxValue Int = Null,
	@oRandomInteger Int = Null Output
) 
With Encryption 
As
Begin 
    Set NoCount On 
    
    
    --Pass a two numbers, get a random number within the inclusive range    
    If @iMinValue > @iMaxValue
    Begin
		Raiserror('Max Value must be >= Min Value', 16, 1)
    End
		Else
	Begin  
		Select @oRandomInteger = Cast(Rand(CheckSum(NewID())) * (@iMaxValue - @iMinValue + 1) As Int) + @iMinValue
	End
End 
Go	

/*
<TAG Name="Data Dictionary" ProcedureName="GetRandomNumberRange">
 <Procedure>
	Returns a random number in the given range.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocation.prc'
GO

If object_id('dbo.GetLocation') is not Null 
     Drop Procedure dbo.GetLocation 
Go 
  
Create Procedure dbo.GetLocation
( 
    @iLocation_Id Int
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Select L.Location_Id, L.Name, L.Location_Type_Id,
		L.Parent_Location_Id, L.Description
	From Location As L
	Where L.Location_Id = @iLocation_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetLocation TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetLocation">
 <Procedure>
	Returns location data for the Location ID passed in.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageBatchLast.prc'
GO

If Object_Id('dbo.DeleteHaulageBatchLast') Is Not Null
	Drop Procedure dbo.DeleteHaulageBatchLast
Go

Create Procedure dbo.DeleteHaulageBatchLast

With Encryption
As

Begin
	-- internal use only

	-- deletes the specified haulage records
	-- the record must be the last in the chain, or an error will be thrown
	-- when deleting the last haulage record, it sets the HaulageRaw
	-- back to "A"waiting approval.

	Declare @Haulage_Date Datetime
	Declare @Digblock_Id Varchar(31)
	Declare @Haulage_Shift Char(1)

	Declare @Count Int
	Declare @curHAULAGE Cursor
	Declare @Error Bit

	Declare @curHAULAGE_DATE Cursor

	Declare @HAULAGE_NA Table
	(
		Haulage_Id Int Not Null,
		Approved_Count_Total Int Not Null,
		Approved_Count_To_Be_Deleted Int Not Null,
		Primary Key (Haulage_Id)
	)

	Declare @HAULAGE_RAW_AC Table
	(
		Haulage_Raw_Id Int Not Null,
		Haulage_Record_Count_Total Int Not Null,
		Haulage_Record_Count_To_Be_Deleted Int Not Null,
		Primary Key (Haulage_Raw_Id)
	)

	Declare @HAULAGE_DATE_LIST Table
	(
		Haulage_Date DateTime Not Null
	)

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @Error = 0

	-- check that the haulage records are the last in the chain
	Set @Count =
		(
			Select Count(*)
			From dbo.Haulage As H
				Inner Join dbo.#DELETE_HAULAGE_BATCH_LIST As DHBL
					On (H.Haulage_Id = DHBL.Haulage_Id)
			Where Child_Haulage_Id Is Not Null
		)

	If @Count > 0
	Begin
		RaisError('DeleteHaulageBatchLast: Only the last haulage record in the chain can be deleted.', 16, 1)
		Set @Error = 1
	End

	If @Error = 0
	Begin
		-- check that the haulage records are not attached to digblocks that fall in an approved survey period
		Set @curHAULAGE = Cursor Local Fast_Forward Read_Only For
			Select Distinct H.Haulage_Date, H.Haulage_Shift, H.Source_Digblock_Id
			From dbo.Haulage As H
				Inner Join dbo.#DELETE_HAULAGE_BATCH_LIST As DHBL
					On (H.Haulage_Id = DHBL.Haulage_Id)
			Where Source_Digblock_Id Is Not Null
			Order By H.Haulage_Date Asc
		
		Open @curHAULAGE
		Set @Count = 0
		Fetch Next From @curHAULAGE Into @Haulage_Date, @Haulage_Shift, @Digblock_Id
		While (@@Fetch_Status = 0) And (@Count = 0)
		Begin
			If dbo.IsInApprovedDigblockSurveyPeriod(@Haulage_Date, @Haulage_Shift, @Digblock_Id) = 1
			Begin
				Set @Count = @Count + 1
			End

			Fetch Next From @curHAULAGE Into @Haulage_Date, @Haulage_Shift, @Digblock_Id
		End
		Close @curHAULAGE

		If @Count > 0
		Begin
			RaisError('DeleteHaulageBatchLast: Digblock falls in an already approved digblock survey period.', 16, 1)
			Set @Error = 1
		End
	End

	If @Error = 0
	Begin
		-- the record is to be physically deleted

		---------------------------------
		-- modify the old Haulage records

		-- set the previous haulage records to 'Unapproved',
		-- where the haulage state to be deleted is in 'N', 'D'
		Update dbo.Haulage
		Set Haulage_State_Id = 'N',
			Child_Haulage_Id = Null
		Where Haulage_Id In
			(
				Select Parent_Haulage_Id
				From dbo.Haulage As H
					Inner Join dbo.#DELETE_HAULAGE_BATCH_LIST As DHBL
						On (H.Haulage_Id = DHBL.Haulage_Id)
				Where H.Haulage_State_Id In ('N', 'D')
			)

		-- for Approved (A) records, we need to clear the child_id if it is the last approved record
		-- otherwise, we need to link it to the next approved record

		-- create a record of haulage records that will need child relinkage, and which ones can be simply nulled
		Insert Into @HAULAGE_NA
		(
			Haulage_Id, Approved_Count_Total, Approved_Count_To_Be_Deleted
		)
		Select Distinct HN.Haulage_Id, 0, 0
		From dbo.Haulage As HA
			Inner Join dbo.#DELETE_HAULAGE_BATCH_LIST As DHBL
				On (HA.Haulage_Id = DHBL.Haulage_Id)
			Inner Join dbo.Haulage As HN
				On (HA.Parent_Haulage_Id = HN.Haulage_Id)
		Where HA.Haulage_State_Id = 'A'
			And HN.Haulage_State_Id = 'N'  -- this is implicit

		Update HNA
		Set Approved_Count_Total =
				(
					Select Count(*)
					From dbo.Haulage
					Where Parent_Haulage_Id = HNA.Haulage_Id
						And Haulage_State_Id = 'A'
				),
			Approved_Count_To_Be_Deleted =
				(
					Select Count(*)
					From dbo.Haulage
					Where Parent_Haulage_Id = HNA.Haulage_Id
						And Haulage_State_Id = 'A'
						And Haulage_Id In (Select Haulage_Id From dbo.#DELETE_HAULAGE_BATCH_LIST)
				)
		From @HAULAGE_NA As HNA

		-- for the haulage records that will clear the chain, unlink the child haulage id
		Update H
		Set Child_Haulage_Id = Null
		From dbo.Haulage As H
			Inner Join @HAULAGE_NA As HNA
				On (H.Haulage_Id = HNA.Haulage_Id)
		Where HNA.Approved_Count_Total = HNA.Approved_Count_To_Be_Deleted

		-- for all other records, link to the next available haulage id
		Update H
		Set Child_Haulage_Id =
			(
				Select Min(Haulage_Id)
				From dbo.Haulage As H2
				Where H2.Parent_Haulage_Id = H.Haulage_Id
					And H2.Haulage_State_Id = 'A'  -- implicit
					And H2.Haulage_Id Not In
						(
							Select Haulage_Id
							From dbo.#DELETE_HAULAGE_BATCH_LIST
						)
			)
		From dbo.Haulage As H
			Inner Join @HAULAGE_NA As HNA
				On (H.Haulage_Id = HNA.Haulage_Id)
		Where HNA.Approved_Count_Total > HNA.Approved_Count_To_Be_Deleted
		
		-- find all Haulage records which are the only record associated with a HaulageRaw record
		-- if this is the case, set the HaulageRaw record back to the "awaiting correction" state

		Insert Into @HAULAGE_RAW_AC
		(
			Haulage_Raw_Id, Haulage_Record_Count_Total, Haulage_Record_Count_To_Be_Deleted
		)
		Select Haulage_Raw_Id, 0, 0
		From dbo.Haulage
		Where Haulage_Id In (Select Haulage_Id From dbo.#DELETE_HAULAGE_BATCH_LIST)
			And Haulage_Raw_Id Is Not Null
		Group By Haulage_Raw_Id

		Update AC
		Set Haulage_Record_Count_Total =
			(
				Select Count(*)
				From dbo.Haulage
				Where Haulage_Raw_Id = AC.Haulage_Raw_Id
			),
			Haulage_Record_Count_To_Be_Deleted =
			(
				Select Count(*)
				From dbo.Haulage As H
					Inner Join dbo.#DELETE_HAULAGE_BATCH_LIST As DHBL
						On (H.Haulage_Id = DHBL.Haulage_Id)
				Where H.Haulage_Raw_Id = AC.Haulage_Raw_Id
			)
		From @HAULAGE_RAW_AC As AC

		Update dbo.HaulageRaw
		Set Haulage_Raw_State_Id = 'A'
		Where Haulage_Raw_Id In
			(
				Select Haulage_Raw_Id
				From @HAULAGE_RAW_AC
				Where Haulage_Record_Count_Total = Haulage_Record_Count_To_Be_Deleted
			)

		-- clear the resolution details
		Delete
		From dbo.HaulageRawResolution
		Where Haulage_Raw_Id In
			(
				Select Haulage_Raw_Id
				From @HAULAGE_RAW_AC
				Where Haulage_Record_Count_Total = Haulage_Record_Count_To_Be_Deleted
			)

		-----------------------------
		-- delete the Haulage records

		Insert Into @HAULAGE_DATE_LIST
		(
			Haulage_Date
		)
		Select Distinct Haulage_Date
		From dbo.Haulage
		Where Haulage_Id In
			(
				Select Haulage_Id
				From #DELETE_HAULAGE_BATCH_LIST
			)

		-- HaulageGrade
		Delete
		From dbo.HaulageGrade
		Where Haulage_Id In
			(
				Select Haulage_Id
				From #DELETE_HAULAGE_BATCH_LIST
			)

		-- HaulageValue
		Delete
		From dbo.HaulageValue
		Where Haulage_Id In
			(
				Select Haulage_Id
				From #DELETE_HAULAGE_BATCH_LIST
			)

		-- HaulageNotes
		Delete
		From dbo.HaulageNotes
		Where Haulage_Id In
			(
				Select Haulage_Id
				From #DELETE_HAULAGE_BATCH_LIST
			)

		-- Haulage
		Delete
		From dbo.Haulage
		Where Haulage_Id In
			(
				Select Haulage_Id
				From #DELETE_HAULAGE_BATCH_LIST
			)

	
		Set @curHAULAGE_DATE = Cursor Local Fast_Forward Read_Only For
			Select Haulage_Date
			From @HAULAGE_DATE_LIST
			Order By Haulage_Date Asc
		Open @curHAULAGE_DATE
		Fetch Next From @curHAULAGE_DATE Into @Haulage_Date
		While @@Fetch_Status = 0
		Begin
			Exec dbo.RecalcL1Raise
				@pDate = @Haulage_Date
				
			Exec dbo.CalcVirtualFlowRaise
				@pCalc_Date = @Haulage_Date

			Fetch Next From @curHAULAGE_DATE Into @Haulage_Date
		End
		Close @curHAULAGE_DATE
	End

	Commit Transaction
End
Go


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageBatchLast">
 <Procedure>
	Deletes the specified haulage records.
	The record must be the last in the chain, or an error will be thrown
	when deleting the last haulage record, it sets the HaulageRaw
	back to "A"waiting approval.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageBatch.prc'
GO

If Object_Id('dbo.DeleteHaulageBatch') Is Not Null
	Drop Procedure dbo.DeleteHaulageBatch
Go

Create Procedure dbo.DeleteHaulageBatch
(
	@iAction VarChar(5)
)

With Encryption
As

Begin
	-- @iAction:
	--
	-- 'CHAIN' - deletes the entire chain of Haulage records
	--           when deleting the last haulage record, it sets the HaulageRaw
	--           back to "A"waiting approval.
	-- 'LAST'  - deletes the last record in the chain
	--           when deleting the last haulage record, it sets the HaulageRaw
	--           back to "A"waiting approval.
	-- 'STATE' - changes the record state to "D"eleted. 

	-- requires #DELETE_HAULAGE_BATCH_LIST table
	--
	-- Create Table dbo.#DELETE_HAULAGE_BATCH_LIST
	-- (
	--		Haulage_Id Int Not Null,
	--		Constraint PK_DELETE_HAULAGE_BATCH_LIST Primary Key Clustered (Haulage_Id)
	-- )

	If Object_Id('TempDB.dbo.#DELETE_HAULAGE_BATCH_LIST') Is Null
	Begin
		RaisError('DeleteHaulageBatch: The #DELETE_HAULAGE_BATCH_LIST table must be created.', 16, 1)
	End
	Else
	Begin
		If @iAction = 'CHAIN'
		Begin
			-- delete the record, plus all others in the chain
			-- Exec dbo.Delete_Haulage_Batch_Chain
			RaisError('DeleteHaulageBatch: Not yet supporting "Delete_Haulage_Batch_Chain".', 16, 1)
		End
		Else
		If @iAction = 'STATE'
		Begin
			-- set the deleted state only
			-- Exec dbo.Delete_Haulage_Batch_State
			RaisError('DeleteHaulageBatch: Not yet supporting "Delete_Haulage_Batch_State".', 16, 1)
		End
		Else
		If @iAction = 'LAST'
		Begin
			-- deletes only the last records
			Exec dbo.DeleteHaulageBatchLast
		End
		Else
		Begin
			RaisError('DeleteHaulageBatch: Unsupported delete action.', 16, 1)
		End

		-- drop the temporary table when done
		Drop Table dbo.#DELETE_HAULAGE_BATCH_LIST
	End
End
Go
 
/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageBatch">
 <Procedure>
	Deletes haulage in a batch like process by supplying a temp table with all the Haulage ID's.
	There are three types of batch deletion (Same as the single record manipulation):
		CHAIN - deletes the entire chain of Haulage records
	            when deleting the last haulage record, it sets the HaulageRaw
	            back to "A"waiting approval.
		LAST -	Deletes the last record in the chain
				when deleting the last haulage record, it sets the HaulageRaw
				back to "A"waiting approval.
		STATE - Changes the record state to "D"eleted. 
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteReport.prc'
GO

 If Object_Id('dbo.DeleteReport') Is Not Null 
     Drop Procedure dbo.DeleteReport
Go

Create Procedure dbo.DeleteReport
(
	@iReport_Id int
)

With Encryption
As

Begin
	Set Nocount On
	
	Delete
	From Report
	Where Report_Id = @iReport_Id

End
Go
GRANT EXECUTE ON dbo.DeleteReport TO CoreReportManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteReport">
 <Procedure>
	Deletes the report
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageCorrectionSplit.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[UpdateHaulageCorrectionSplit]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[UpdateHaulageCorrectionSplit]
GO

CREATE Procedure [dbo].[UpdateHaulageCorrectionSplit]
(
	@iHaulage_Resolve_Split_Id Int,
	@iUpdate_Code Bit = 0,
	@iCode Varchar(63) = Null,
	@iUpdate_Resolve_To_Date Bit = 0,
	@iResolve_To_Date Datetime = Null,
	@iUpdate_Resolve_To_Shift Bit = 0,
	@iResolve_To_Shift Char(1) = Null,
	@iUpdate_Resolve_From_Date Bit = 0,
	@iResolve_From_Date Datetime = Null,
	@iUpdate_Resolve_From_Shift Bit = 0,
	@iResolve_From_Shift Char(1) = Null,
	@iUpdate_Description Bit = 0,
	@iDescription Varchar(255) = Null,
	@iUpdate_Haulage_Resolve_Split_Type_Id Bit = 0,
	@iHaulage_Resolve_Split_Type_Id Int = Null
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: UpdateHaulageCorrectionSplit
--  Purpose: Updates a Haulage Split.
--  Parameters: @iHaulage_Resolve_Split_Id - The Split ID to update.
--				@iUpdate_[Column] - Bit to state if the field is to be updated.
--				@i[Column] - The column value to be updated if the @iUpdate[Column] is set.
-- 
--  Comments:
--			Update a Haulage Split record. Code and Split Type can only be updated when
--			No haulage is present.
--  
--  Created By:		Murray Hipper
--  Created Date: 	31 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction
		
	Declare @Row_Num Int
	Declare @Row_Num_After_New_End_Date Int

	Select @Row_Num = Count(*) 
	From HaulageRawResolution
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	
	--Get the new end dates.
	
	Select @iResolve_To_Date = Case When @iUpdate_Resolve_To_Date = 1 Then @iResolve_To_Date Else Resolve_To_Date End
	From HaulageResolveSplit
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id

	Select @iResolve_To_Shift = Case When @iUpdate_Resolve_To_Shift = 1 Then @iResolve_To_Shift Else Resolve_To_Shift End
	From HaulageResolveSplit
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	
	Select @iResolve_From_Date = Case When @iUpdate_Resolve_From_Date = 1 Then @iResolve_From_Date Else Resolve_From_Date End
	From HaulageResolveSplit
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id

	Select @iResolve_From_Shift = Case When @iUpdate_Resolve_From_Shift = 1 Then @iResolve_From_Shift Else Resolve_From_Shift End
	From HaulageResolveSplit
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	
	If dbo.CompareDateShift(@iResolve_To_Date, @iResolve_To_Shift, '<', @iResolve_From_Date, @iResolve_From_Shift) = 1
	Begin
		Raiserror ('The Resolve To Date/Shift is before the Resolve From Date/Shift.', 16, 1)
	End		
		
	Select @Row_Num_After_New_End_Date = Count(*) 
	From HaulageRawResolution As HRR
		Inner Join HaulageRaw As HR
			On HRR.Haulage_Raw_Id = HR.Haulage_Raw_Id
	Where HRR.Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	And dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>', @iResolve_To_Date, @iResolve_To_Shift) = 1
	And Haulage_Date >= @iResolve_To_Date

	If Exists (	Select 1
				From HaulageResolveSplit
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id)
	Begin
		If @Row_Num > 0 And (@iUpdate_Code = 1 Or @iUpdate_Haulage_Resolve_Split_Type_Id = 1)
		Begin
			Raiserror ('Cannot update the Code or Split type fields when the code has haulage.', 16, 1)
		End
		Else If (@Row_Num_After_New_End_Date > 0 And (@iUpdate_Resolve_To_Shift = 1 Or @iUpdate_Resolve_To_Date = 1))
		Begin
			Raiserror ('Cannot update the Resolve to Date due to existing haulage.', 16, 1)
		End
		Else
		Begin
			
		Update HaulageResolveSplit
		Set Code = Case When @iUpdate_Code = 1 Then @iCode Else Code End,
			Resolve_From_Date = Case When @iUpdate_Resolve_From_Date = 1 Then @iResolve_From_Date Else Resolve_From_Date End,
			Resolve_From_Shift = Case When @iUpdate_Resolve_From_Shift = 1 Then @iResolve_From_Shift Else Resolve_From_Shift End,
			Resolve_To_Date = Case When @iUpdate_Resolve_To_Date = 1 Then @iResolve_To_Date Else Resolve_To_Date End,
			Resolve_To_Shift = Case When @iUpdate_Resolve_To_Shift = 1 Then @iResolve_To_Shift Else Resolve_To_Shift End,
			Description = Case When @iUpdate_Description = 1 Then @iDescription Else Description End,
			Haulage_Resolve_Split_Type_Id  = Case When @iUpdate_Haulage_Resolve_Split_Type_Id = 1 Then @iHaulage_Resolve_Split_Type_Id Else Haulage_Resolve_Split_Type_Id End
		Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
		
		End
	End
	Else
	Begin
		Raiserror ('The Haulage Split does not exist.', 16, 1)
	End


	Commit Transaction
End

GO
GRANT EXECUTE ON dbo.UpdateHaulageCorrectionSplit TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateHaulageCorrectionSplit">
 <Procedure>
	Updates a Haulage Split in table HaulageResolveSplit.
	Comments: Update a Haulage Split record. Code and Split Type can only be updated when
			no haulage is present.
	Errors are raised if:
		Cannot update the Code or Split type fields when the code has haulage.
		The Haulage Split does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageSplit.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddHaulageSplit'))
	Drop Procedure dbo.AddHaulageSplit
Go

Create Procedure dbo.AddHaulageSplit
(
	@iStart_Date DateTime,
	@iStart_Shift Char(1),
	@iEnd_Date DateTime = Null,
	@iEnd_Shift Char(1) = Null,
	@iCode Varchar(63),
	@iDescription Varchar(255),
	@iHaulage_Resolve_Split_Type_Id Int,
	@oHaulage_Resolve_Split_Id Int = Null Output
)
With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: AddHaulageSplit
--  Purpose: Adds a resolve split.
--  Parameters: 
-- 
--  Comments: Adds to HaulageResolveSplit.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 Januaray 2007
--
------------------------------------------------------------------------------*/
Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If Exists (Select 1 From HaulageResolveSplit Where Code = @iCode)
	Begin
		RaisError('The entered Code already exists', 16, 1)
	End
	Else
	Begin
		Insert Into HaulageResolveSplit (Code, Resolve_From_Date, Resolve_From_Shift, Resolve_To_Date, 
			Resolve_To_Shift, Description, Haulage_Resolve_Split_Type_Id)
		Values (@iCode, @iStart_Date, @iStart_Shift, @iEnd_Date, @iEnd_Shift, @iDescription,
			@iHaulage_Resolve_Split_Type_Id)

		Set @oHaulage_Resolve_Split_Id = Scope_Identity()
	End
	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddHaulageSplit TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageSplit">
 <Procedure>
	Adds a record to the HaulageResolveSplit table and returns the key of the added record in an output variable.
	Errors raised if:
		The entered Code already exists.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageSplitDecode.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddHaulageSplitDecode'))
	Drop Procedure dbo.AddHaulageSplitDecode
Go

Create Procedure dbo.AddHaulageSplitDecode
(
	@iHaulage_Resolve_Split_Id Int,
	@iDigblock_Id Varchar(31)
)
With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: AddHaulageSplitDecode
--  Purpose: Adds a resolve split digblock record.
--  Parameters: 
-- 
--  Comments: Adds to HaulageResolveSplitDecode.
--				Performs a check to make sure the Split_Id has no haulage recorded
--				Against it.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 Januaray 2007
--
------------------------------------------------------------------------------*/
Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If Not Exists (Select 1 From HaulageResolveSplit
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id)
	Begin
		RaisError('The entered Split ID does not exist.', 16, 1)
	End
	If Exists (Select 1 From HaulageResolveSplitDecode 
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
					And Digblock_Id = @iDigblock_Id)
	Begin
		RaisError('The entered Digblock ID is already against the record.', 16, 1)
	End
	Else If (Select Count(*) From HaulageRawResolution Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id) > 0
	Begin
		RaisError('You cannot change the digblocks on a haulage split when there are haulage records attached to the code.', 16, 1)
	End
	Else -- Enter the record.
	Begin
		Insert Into HaulageResolveSplitDecode (Haulage_Resolve_Split_Id, Digblock_Id)
		Values (@iHaulage_Resolve_Split_Id, @iDigblock_Id)
	End
	
	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddHaulageSplitDecode TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageSplitDecode">
 <Procedure>
	Adds a record to the HaulageResolveSplitDecode table.
	Errors raised if:
		The entered Split ID does not exist
		The entered Digblock ID is already against the record.
		There are haulage records attached to the code
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionSplitTypeList.prc'
GO

If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionSplitTypeList]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionSplitTypeList]
GO

CREATE Procedure [dbo].[GetHaulageCorrectionSplitTypeList]
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionSplitTypeList
--  Purpose: Returns the UI list of all the Split types
--  Parameters: -
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	23 January 2007
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On
	
	Select Haulage_Resolve_Split_Type_Id, Description
	From HaulageResolveSplitType

End
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionSplitTypeList TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionSplitTypeList">
 <Procedure>
	Returns the UI list of all HaulageResolveSplitType records.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageSplitDecode.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageSplitDecode]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageSplitDecode]
GO

Create Procedure [dbo].[GetHaulageSplitDecode]
(
	@iHaulage_Resolve_Split_Id Int
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageSplitDecode
--  Purpose: Returns a list of the Digblocks for the given split.
--  Parameters: @iHaulage_Resolve_Split_Id - Split ID to get the digblocks of.
-- 
--  Comments: 
--  
--  Created By:		Murray Hipper
--  Created Date: 	26 Feb 2007
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If Not Exists (Select 1 From HaulageResolveSplit
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id)
	Begin
		RaisError('The Split ID does not exist.', 16, 1)
	End
	Else
	Begin -- Get the digblocks for the split
		Select *
		From HaulageResolveSplitDecode
		Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
	End

	Commit Transaction
End

GO
GRANT EXECUTE ON dbo.GetHaulageSplitDecode TO CoreHaulageManager

 
/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageSplitDecode">
 <Procedure>
	Returns a list of the Digblocks for the given split.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageCorrectionSplitList.prc'
GO

If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetHaulageCorrectionSplitList]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetHaulageCorrectionSplitList]
GO

CREATE Procedure [dbo].[GetHaulageCorrectionSplitList]
(
	@iHaulage_Resolve_Split_Id Int = Null
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: GetHaulageCorrectionSplitList
--  Purpose: Returns the UI list of all the Splits
--  Parameters: -
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	28 Feb 2007
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On
	
	Select SPLIT.Haulage_Resolve_Split_Id, SPLIT.Code, SPLIT.Resolve_From_Date, 
		SPLIT.Resolve_From_shift As Resolve_From_Shift, 
		SPLIT.Resolve_To_Date, SPLIT.Resolve_To_Shift As Resolve_To_Shift, 
		SPLIT.Description, 
		STYPE.Description As Type, STYPE.Haulage_Resolve_Split_Type_Id As TypeID, 
		Coalesce(HRR.Row_Num, 0) As Row_Num, Coalesce(SDECODE.Digblock_Num, 0) As Digblock_Num
	From HaulageResolveSplit SPLIT 
		Inner Join HaulageResolveSplitType STYPE
			On SPLIT.Haulage_Resolve_Split_Type_Id = STYPE.Haulage_Resolve_Split_Type_Id
		Left Join (Select Haulage_Resolve_Split_Id, Count(*) As Row_Num
					From HaulageRawResolution
					Group By Haulage_Resolve_Split_Id) HRR
			On HRR.Haulage_Resolve_Split_Id = SPLIT.Haulage_Resolve_Split_Id
		Left Join (Select Haulage_Resolve_Split_Id, Count(*) As Digblock_Num
					From HaulageResolveSplitDecode
					Group By Haulage_Resolve_Split_Id) SDECODE
			On SPLIT.Haulage_Resolve_Split_Id = SDECODE.Haulage_Resolve_Split_Id
	Where SPLIT.Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id 
		Or @iHaulage_Resolve_Split_Id Is Null
		
End
GO
GRANT EXECUTE ON dbo.GetHaulageCorrectionSplitList TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageCorrectionSplitList">
 <Procedure>
	Returns the UI list of all HaulageResolveSplit records.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageSplitDecode.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteHaulageSplitDecode'))
	Drop Procedure dbo.DeleteHaulageSplitDecode
Go

Create Procedure dbo.DeleteHaulageSplitDecode
(
	@iHaulage_Resolve_Split_Id Int,
	@iDigblock_Id Varchar(31)
)
With Encryption
As
/*-----------------------------------------------------------------------------
--  Name: DeleteHaulageSplitDecode
--  Purpose: Deletes a resolve split digblock record.
--  Parameters: @iHaulage_Resolve_Split_Id - The Split id
--				@iDigblock_Id - The digblock to be removed from the split id.
--	
--  Comments: Deletes from HaulageResolveSplitDecode.
--				Performs a check to make sure the Split_Id has no haulage recorded
--				Against it.
--  
--  Created By:		Murray Hipper
--  Created Date: 	26 Feb 2007
--
------------------------------------------------------------------------------*/
Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If Not Exists (Select 1 From HaulageResolveSplit
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id)
	Begin
		RaisError('The entered Split ID does not exist.', 16, 1)
	End
	If Not Exists (Select 1 From HaulageResolveSplitDecode 
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
					And Digblock_Id = @iDigblock_Id)
	Begin
		RaisError('The entered Digblock ID does not exist against the record.', 16, 1)
	End
	Else If (Select Count(*) From HaulageRawResolution Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id) > 0
	Begin
		RaisError('You cannot change the digblocks on a haulage split when there are haulage records attached to the code.', 16, 1)
	End
	Else -- Enter the record.
	Begin
		Delete 
		From HaulageResolveSplitDecode
		Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
			And Digblock_Id = @iDigblock_Id
	End
	
	Commit Transaction
End
Go
  GRANT EXECUTE ON dbo.DeleteHaulageSplitDecode TO CoreHaulageManager

 
 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageSplitDecode">
 <Procedure>
	Deletes records from the HaulageResolveSplitDecode table.
	
	Errors are raised if:
		The entered Split ID does not exist
		The entered Digblock ID does not exist against the record
		there are haulage records attached to the code
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageCorrectionSplit.prc'
GO

 
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[DeleteHaulageCorrectionSplit]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[DeleteHaulageCorrectionSplit]
GO

CREATE Procedure [dbo].[DeleteHaulageCorrectionSplit]
(
	@iHaulage_Resolve_Split_Id Int
)
With Encryption 
As
/*-----------------------------------------------------------------------------
--  Name: DeleteHaulageCorrectionSplit
--  Purpose: Deletes a Resolution_Split record.
--  Parameters: @iHaulage_Resolve_Split_Id - ID to delete.
-- 
--  Comments: Deletes from HaulageResolveSplitDecode and
				HaulageResolveSplit only if it has no attached 
--				haulage records.
--  
--  Created By:		Murray Hipper
--  Created Date: 	1 March 2007
--
------------------------------------------------------------------------------*/
Begin
	Set Nocount On

	Declare @Row_Num Int

	Select @Row_Num = Count(*) 
	From HaulageRawResolution
	Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id


	If Exists (	Select 1
				From HaulageResolveSplit
				Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id)
	Begin
		If @Row_Num = 0
		Begin
		
			Delete
			From HaulageResolveSplitDecode
			Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id


			Delete
			From HaulageResolveSplit
			Where Haulage_Resolve_Split_Id = @iHaulage_Resolve_Split_Id
		End
		Else
		Begin
			Raiserror ('Cannot delete the resolution code is it is currently in use.', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The Haulage Split does not exist.', 16, 1)
	End
End
GO
GRANT EXECUTE ON dbo.DeleteHaulageCorrectionSplit TO CoreHaulageManager

 

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageCorrectionSplit">
 <Procedure>
	Deletes from HaulageResolveSplitDecode and HaulageResolveSplit only if it 
	has no attached haulage records.
	Errors are raised if:
		The Haulage Split does not exist
		The resolution code is it is currently in use
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySummaryValue.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockSurveySummaryValue') Is Not Null
	Drop Procedure dbo.AddOrUpdateDigblockSurveySummaryValue
Go

Create Procedure dbo.AddOrUpdateDigblockSurveySummaryValue

(
	@iDigblock_Survey_Summary_Id Int,
	@iDigblock_Survey_Summary_Field_Id Varchar(31),
	@iField_Value Real
)

With Encryption
As
Begin

	Set Nocount On

	/* If the digblock survey summary exists */
	If Exists (Select 1 From DigblockSurveySummary
		Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id)
	Begin
		/* If the digblock survey summary field exists */
		If Exists (Select 1 From DigblockSurveySummaryField
			Where Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
		Begin
			/* If the value is not null */
			If (@iField_Value Is Not Null)
			Begin
				/* If this field is not already populated */
				If Not Exists (Select 1 From DigblockSurveySummaryValue
					Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
						And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into DigblockSurveySummaryValue
					(
						Digblock_Survey_Summary_Id, Digblock_Survey_Summary_Field_Id, Field_Value
					)
					Values
					(
						@iDigblock_Survey_Summary_Id, @iDigblock_Survey_Summary_Field_Id, @iField_Value
					)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockSurveySummaryValue
					Set	Field_Value = @iField_Value
					Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
						And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing record */
				Delete From DigblockSurveySummaryValue
				Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
					And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
			End
		End
		Else
		Begin
			Raiserror('The given digblock survey summary field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey summary does not exist', 16, 1)
	End
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveySummaryValue">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySummaryValue table.
	Errors raised if:
		The given digblock survey summary does not exist
		The given digblock survey summary field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySummaryNotes.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockSurveySummaryNotes') Is Not Null
	Drop Procedure dbo.AddOrUpdateDigblockSurveySummaryNotes
Go


Create Procedure dbo.AddOrUpdateDigblockSurveySummaryNotes

(
	@iDigblock_Survey_Summary_Id Int,
	@iDigblock_Survey_Summary_Field_Id Varchar(31),
	@iNotes Varchar(1023)
)

With Encryption
As
Begin

	Set Nocount On

	/* If the digblock survey summary exists */
	If Exists (Select 1 From DigblockSurveySummary
		Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id)
	Begin
		/* If the digblock survey summary field exists */
		If Exists (Select 1 From DigblockSurveySummaryField
			Where Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
		Begin
			/* If the notes are not null */
			If (@iNotes Is Not Null)
			Begin
				/* If this field is not already populated */
				If Not Exists (Select * From DigblockSurveySummaryNotes
					Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
						And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into DigblockSurveySummaryNotes
					(
						Digblock_Survey_Summary_Id, Digblock_Survey_Summary_Field_Id, Notes
					)
					Values
					(
						@iDigblock_Survey_Summary_Id, @iDigblock_Survey_Summary_Field_Id, @iNotes
					)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockSurveySummaryNotes
					Set	Notes = @iNotes
					Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
						And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing record */
				Delete From DigblockSurveySummaryNotes
				Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
					And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
			End
		End
		Else
		Begin
			Raiserror('The given digblock survey summary field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey summary does not exist', 16, 1)
	End
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveySummaryNotes">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySummaryNotes table.
	Errors raised if:
		The given digblock survey summary does not exist
		The given digblock survey summary field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveySummaryFieldNotes.prc'
GO

If Object_Id('dbo.GetDigblockSurveySummaryFieldNotes') Is Not Null
	Drop Procedure dbo.GetDigblockSurveySummaryFieldNotes
Go

Create Procedure dbo.GetDigblockSurveySummaryFieldNotes

(
	@iDigblock_Survey_Summary_Id int,
	@iDigblock_Survey_Summary_Field_Id Varchar(31),
	@oNotes VarChar(1023) Output
)

With Encryption
As
Begin
	Set Nocount On

	/* If the digblock survey summary exists */
	If Exists (Select 1 From DigblockSurveySummary
		Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id)
	Begin
		/* If the digblock survey summary field exists */
		If Exists (Select 1 From DigblockSurveySummaryField
			Where Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @oNotes = Notes
			From DigblockSurveySummaryNotes
			Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
				And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
		End
		Else
		Begin
			Raiserror ('The given digblock survey summary field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock survey summary does not exist', 16, 1)
	End

	Return
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummaryFieldNotes">
 <Procedure>
	Returns Notes value for specified @iDigblock_Survey_Summary_Id and @iDigblock_Survey_Summary_Field_Id
	in the @oNotes output variable.
	Errors are raised if:
		The given @iDigblock_Survey_Summary_Id does not exist
		The given @iDigblock_Survey_Summary_Field_Id field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveySummaryFieldValue.prc'
GO

If Object_Id('dbo.GetDigblockSurveySummaryFieldValue') Is Not Null
	Drop Procedure dbo.GetDigblockSurveySummaryFieldValue
Go


Create Procedure dbo.GetDigblockSurveySummaryFieldValue

(
	@iDigblock_Survey_Summary_Id Int,
	@iDigblock_Survey_Summary_Field_Id Varchar(31),
	@oField_Value Float Output
)

With Encryption
As
Begin

	Set Nocount On

	/* If the digblock survey summary exists */
	If Exists (Select 1 From DigblockSurveySummary
		Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id)
	Begin
		/* If the digblock survey summary field exists */
		If Exists (Select 1 From DigblockSurveySummaryField
			Where Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @oField_Value = Min(Field_Value)
			From DigblockSurveySummaryValue
			Where Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
				And Digblock_Survey_Summary_Field_Id = @iDigblock_Survey_Summary_Field_Id
		End
		Else
		Begin
			Raiserror ('The given digblock survey summary field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock survey summary does not exist', 16, 1)
	End
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummaryFieldValue">
 <Procedure>
	Returns Field_Value value for specified @iDigblock_Survey_Summary_Id and @iDigblock_Survey_Summary_Field_Id
	in the @oField_Value output variable.
	Errors are raised if:
		The given @iDigblock_Survey_Summary_Id does not exist
		The given @iDigblock_Survey_Summary_Field_Id field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMinePlanPeriodLocation.prc'
GO

If object_id('dbo.AddMinePlanPeriodLocation') is not Null 
     Drop Procedure dbo.AddMinePlanPeriodLocation
Go 
  
Create Procedure dbo.AddMinePlanPeriodLocation 
( 
    @iMine_Plan_Period_Id Int,
	@iLocation_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Begin Try
		--Validate that it has not tried to add 2 of the same location type
		If Exists
			(
				Select 1
				From dbo.Location As L	
					Inner Join dbo.MinePlanPeriodLocation As ML
						On (ML.Location_Id = L.Location_Id)
					Inner Join dbo.Location As NL
						On (L.Location_Type_Id = NL.Location_Type_Id)
				Where ML.Mine_Plan_Period_Id = @iMine_Plan_Period_Id
					And NL.Location_Id = @iLocation_Id
			)	
		Begin
			RaisError('Only one location of any location type can be associated with a mine plan period.', 16, 1)
		End

		--Insert
		Insert Into dbo.MinePlanPeriodLocation
		(
			Mine_Plan_Period_Id, Location_Id
		)	
		Select @iMine_Plan_Period_Id, @iLocation_Id
		
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	  
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddMinePlanPeriodLocation">
 <Procedure>
	Adds a new record record in the MinePlanPeriodLocation table.	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMinePlanPeriodLocation.prc'
GO

If object_id('dbo.DeleteMinePlanPeriodLocation') is not Null 
     Drop Procedure dbo.DeleteMinePlanPeriodLocation 
Go 
  
Create Procedure dbo.DeleteMinePlanPeriodLocation
( 
    @iMine_Plan_Period_Id Int,
	@iLocation_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		If Not Exists
			(
				Select 1 
				From dbo.MinePlanPeriodLocation
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
					And Location_Id = @iLocation_Id
			)
		Begin
			RaisError('Mine plan period location did not exist.', 16, 1)
		End 

		Delete
		From dbo.MinePlanPeriodLocation
		Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			And Location_Id = @iLocation_Id
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteMinePlanPeriodLocation">
 <Procedure>
	Delete's the record in the MinePlanPeriodLocation table.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMinePlanPeriod.prc'
GO

If object_id('dbo.DeleteMinePlanPeriod') is not Null 
     Drop Procedure dbo.DeleteMinePlanPeriod 
Go 
  
Create Procedure dbo.DeleteMinePlanPeriod 
( 
    @iMine_Plan_Period_Id Int
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		If Not Exists
			(
				Select 1
				From dbo.MinePlanPeriod
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			)
		Begin
			RaisError('Mine plan period does not exist.', 16, 1)
		End

		--Delete Ancillary tables
		Delete A
		From dbo.MinePlanPeriodNotes As A
		Where A.Mine_Plan_Period_Id = @iMine_Plan_Period_Id

		Delete A
		From dbo.MinePlanPeriodValue As A
		Where A.Mine_Plan_Period_Id = @iMine_Plan_Period_Id

		Delete A
		From dbo.MinePlanPeriodGrade As A
		Where A.Mine_Plan_Period_Id = @iMine_Plan_Period_Id

		Delete A
		From dbo.MinePlanPeriodLocation As A
		Where A.Mine_Plan_Period_Id = @iMine_Plan_Period_Id

		Delete A
		From dbo.MinePlanPeriod As A
		Where A.Mine_Plan_Period_Id = @iMine_Plan_Period_Id

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteMinePlanPeriod">
 <Procedure>
	Removes a mine plan period.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileSurvey.prc'
GO

If object_id('dbo.DeleteStockpileSurvey') is not Null 
     Drop Procedure dbo.DeleteStockpileSurvey
Go 
  
Create Procedure dbo.DeleteStockpileSurvey 
( 
    @iStockpile_Survey_Date DateTime,
	@iStockpile_Survey_Shift Char(1),
	@iStockpile_Survey_Type_Id Int
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @Stockpile_Survey_Sample_Id Int  

    Begin Try
		--Must be unapproved
		If Exists
			(
				Select 1
				From dbo.StockpileSurvey As S
				Where S.Is_Approved = 1
					And S.Stockpile_Survey_Date = @iStockpile_Survey_Date
					And S.Stockpile_Survey_Shift = @iStockpile_Survey_Shift
					And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
			)
		Begin
			Raiserror('This stockpile survey has been approved. Please unapprove the survey before deleting it.', 16, 1)		
		End		

		--Cannot be before an approved period
		If Exists
			(
				Select 1
				From dbo.StockpileSurvey As S
					Inner Join dbo.ShiftType As ST
						On (S.Stockpile_Survey_Shift = ST.Shift)
				Where S.Is_Approved = 1
					And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
					And (S.Stockpile_Survey_Date > @iStockpile_Survey_Date
						Or (S.Stockpile_Survey_Date = @iStockpile_Survey_Date
							And ST.Order_No > dbo.GetShiftTypeOrderNo(@iStockpile_Survey_Shift)))
			)
		Begin
			Raiserror('This stockpile survey has approved surveys after it. Please unapprove all surveys occuring after this survey before deleting this survey.', 16, 1)		
		End

		--Remove Survey Samples
		Select Top 1 @Stockpile_Survey_Sample_Id = Stockpile_Survey_Sample_Id
		From dbo.StockpileSurveySample As S
		Where S.Stockpile_Survey_Date = @iStockpile_Survey_Date
			And S.Stockpile_Survey_Shift = @iStockpile_Survey_Shift
			And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
		Order By Stockpile_Survey_Sample_Id Asc

		While(@Stockpile_Survey_Sample_Id Is Not Null)
		Begin
			Exec dbo.DeleteStockpileSurveySample
				@iStockpile_Survey_Sample_Id = @Stockpile_Survey_Sample_Id

			--Reset Variable
			Set @Stockpile_Survey_Sample_Id = Null

			Select Top 1 @Stockpile_Survey_Sample_Id = Stockpile_Survey_Sample_Id
			From dbo.StockpileSurveySample As S
			Where S.Stockpile_Survey_Date = @iStockpile_Survey_Date
				And S.Stockpile_Survey_Shift = @iStockpile_Survey_Shift
				And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
			Order By Stockpile_Survey_Sample_Id Asc
		End

		--Delete the survey
		Delete
		From dbo.StockpileSurvey
		Where Stockpile_Survey_Date = @iStockpile_Survey_Date
			And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
			And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.DeleteStockpileSurvey TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileSurvey">
 <Procedure>
	Removes a stockpile survey and its related samples. Ensures the survey is not
	approved and that it does not come before a later approved period.
 </Procedure>
</TAG>
*/	
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetBlockModelTypeList.prc'
GO

If object_id('dbo.GetBlockModelTypeList') Is Not Null 
     Drop Procedure dbo.GetBlockModelTypeList 
Go 
  
Create Procedure dbo.GetBlockModelTypeList
( 
	@iBlock_Model_Type_Id Int = Null,
	@iName Varchar(63) = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select *
	From dbo.BlockModelType As BMT
	Where BMT.Block_Model_Type_Id = IsNull(@iBlock_Model_Type_Id, BMT.Block_Model_Type_Id)
		And BMT.Name = IsNull(@iName, BMT.Name)
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetBlockModelTypeList TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBlockModelTypeList">
 <Procedure>
	Returns the list of Block model types. Can be filtered by block model type id
	or the name of the block model type.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetBlockReconciliationReport.prc'
GO

IF OBJECT_ID('dbo.GetBlockReconciliationReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBlockReconciliationReport
GO

CREATE PROCEDURE dbo.GetBlockReconciliationReport   
(   
	@iLocationID INT = NULL,   
	@iBlock_Model_Id INT = 1  
)  
WITH ENCRYPTION  
AS    
-------------------------------------------------------------------------------  
--  Procedure: dbo.GetBlockReconciliationReport  
-- Created: 19-Oct-2007  
-- Dev: JBC  
--  For Core Standard reports  
--------------------------------------------------------------------------------    
BEGIN     
	DECLARE @Location VARCHAR(100)   
	DECLARE @LocationType VARCHAR(100)   
	DECLARE @BlockModelName VARCHAR(100)     

	SET NOCOUNT ON 

	-- save location name and type to be returned in main query   
	SELECT @Location = l.Name,    
		@LocationType = lt.Description   
	FROM dbo.Location AS l    
		INNER JOIN dbo.LocationType AS lt     
			ON (l.Location_Type_ID = lt.Location_Type_ID)   
	WHERE Location_Id = @iLocationID     

	-- save block model name to be returned in main query  
	SELECT @BlockModelName = bm.Name   
	FROM dbo.BlockModel AS bm    
	WHERE bm.Block_Model_ID = @iBlock_Model_ID;

	WITH LocationHierarchy AS   
	(    
		SELECT Location_Id,     
			l.Name,     
			l.Location_Type_Id,     
			lt.Description AS Location_Type,      
			l.Parent_Location_Id,
			lt.Defines_3d_Point 
		FROM dbo.Location AS l     
			INNER JOIN dbo.LocationType AS lt      
				ON (l.Location_Type_ID = lt.Location_Type_ID)    
		WHERE (Location_Id = @iLocationID OR @iLocationID IS NULL)
		UNION ALL        
		SELECT l.Location_Id,     
			l.Name,     
			l.Location_Type_Id,     
			lt.Description AS Location_Type,      
			l.Parent_Location_Id,
			lt.Defines_3d_Point
		FROM dbo.Location AS l     
			INNER JOIN dbo.LocationType AS lt      
				ON (l.Location_Type_ID = lt.Location_Type_ID)     
			INNER JOIN LocationHierarchy AS lh      
				ON (l.Parent_Location_ID = lh.Location_ID)   
		WHERE @iLocationID IS NOT NULL   
	)   
	SELECT @BlockModelName AS BlockModelName,     
		CASE WHEN @Location IS NULL 
			THEN 'ALL' 
			ELSE @Location 
		END AS Location,    
		CASE WHEN @LocationType IS NULL 
			THEN 'ALL' 
			ELSE @LocationType 
		END AS LocationType,    
		d.Digblock_Id,     
		d.Start_Tonnes As Grade_Control_Tonnes,     
		COALESCE(ht.Tonnes,0.0) As Haulage_Tonnes,    
		COALESCE(st.Tonnes,0.0) As Survey_Tonnes,     
		COALESCE(re.Tonnes,0.0) As Reconciled_Tonnes,     
		COALESCE(bm.Tonnes,0.0) As Reserve   
	FROM LocationHierarchy AS lh    
		INNER JOIN dbo.DigblockLocation AS dl     
			ON (lh.Location_ID = dl.Location_ID)    
		INNER JOIN dbo.Digblock AS d     
			ON (dl.Digblock_ID = d.Digblock_ID)    
		LEFT JOIN     
		(     
			SELECT H.Source_Digblock_Id,      
				SUM(DTT.Tonnes) As Tonnes     
			FROM dbo.Haulage H      
				INNER JOIN dbo.DataTransactionTonnes DTT       
					ON (H.Haulage_Id = DTT.Haulage_Id)     
			WHERE H.Source_Digblock_Id IS NOT NULL     
			GROUP BY H.Source_Digblock_Id    
		) AS ht     
			ON (d.Digblock_Id = ht.Source_Digblock_Id)    
		LEFT JOIN      
		(     
			SELECT DSS.Digblock_Id,      
				SUM(DSS.Depleted_Tonnes) AS Tonnes     
			FROM dbo.DigblockSurveySample DSS     
			GROUP BY DSS.Digblock_Id    
		) AS st     
			ON (d.Digblock_Id = st.Digblock_Id)    
		LEFT JOIN     
		(     
			SELECT Source_Digblock_Id,      
				SUM(Tonnes) AS Tonnes      
			FROM dbo.DataProcessTransaction     
			WHERE Source_Digblock_Id IS NOT NULL     
			GROUP BY Source_Digblock_Id    
		) AS re     
			ON (d.Digblock_Id = re.Source_Digblock_Id)    
		LEFT JOIN     
		(     
			SELECT bm.Name AS BlockModelName,      
				dmb.Digblock_Id,      
				SUM(mbp.Tonnes * dmb.Percentage_In_Digblock) AS Tonnes              
			FROM dbo.BlockModel AS bm       
				INNER JOIN ModelBlock AS mb       
					ON (bm.Block_Model_Id = mb.Block_Model_Id)      
				INNER JOIN ModelBlockPartial AS mbp       
					ON (mb.Model_Block_Id = mbp.Model_Block_Id)      
				INNER JOIN DigblockModelBlock AS dmb        
					ON (mb.Model_Block_Id = dmb.Model_Block_Id)     
			WHERE bm.Block_Model_Type_Id = @iBlock_Model_Id     
			GROUP BY bm.Name,       
				dmb.Digblock_Id    
		) AS bm     
			ON (bm.Digblock_ID = d.Digblock_ID)    
	WHERE lh.Defines_3d_Point = 1    
		AND d.End_Date IS NOT NULL    
	ORDER BY d.Digblock_ID  
END  
GO

GRANT EXECUTE ON dbo.GetBlockReconciliationReport TO CoreReporting
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataExceptionCount.prc'
GO

If object_id('dbo.GetDataExceptionCount') is not Null 
     Drop Procedure dbo.GetDataExceptionCount 
Go 
  
Create Procedure dbo.GetDataExceptionCount
( 
    @oNum_Exceptions Int Output
) 
With Encryption 
As
Begin 
    Set NoCount On 
	
	Select @oNum_Exceptions = count(*)
	From dbo.DataException As DE
	Where DE.Data_Exception_Status_Id = 'A'
End 
Go 
GRANT EXECUTE ON dbo.GetDataExceptionCount TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionCount">
 <Procedure>
	Outputs the number of active data exceptions in the system
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockHaulageOverRange.prc'
GO

If object_id('dbo.GetDigblockHaulageOverRange') Is Not Null 
     Drop Procedure dbo.GetDigblockHaulageOverRange 
Go 
  
Create Procedure dbo.GetDigblockHaulageOverRange
( 
	@iLocation_Id Int,
    @iStart_Date Datetime = Null,
	@iEnd_Date Datetime = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Select H.Source_Digblock_Id As Digblock_Id, Sum(H.Tonnes) As Tonnes
	From dbo.Haulage As H
		Inner Join 
			(
				--Eliminate double counting
				Select DL.Digblock_Id
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_Id = DL.Location_Type_Id)
					Inner Join 
						(
							Select *
							From dbo.GetLocationChildLocationList(@iLocation_Id) 
							Union 
							Select @iLocation_Id
						) As L
						On (L.Location_Id = DL.Location_Id)
				Group By DL.Digblock_Id
			) As DL
			On (DL.Digblock_Id = H.Source_Digblock_Id)
	Where H.Haulage_Date >= IsNull(@iStart_Date, H.Haulage_Date)
		And H.Haulage_Date <= IsNull(@iEnd_Date, H.Haulage_Date)
		And H.Haulage_State_Id = 'N'
		And H.Source_Digblock_Id Is Not Null
	Group By H.Source_Digblock_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockHaulageOverRange TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockHaulageOverRange">
 <Procedure>
	Returns a list of digblocks and their total survey tonnes for a given period. 
	This is filtered by a parent location that is passed in.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockMinePlanTonnesOverPeriod.prc'
GO

If object_id('dbo.GetDigblockMinePlanTonnesOverPeriod') Is Not Null 
     Drop Procedure dbo.GetDigblockMinePlanTonnesOverPeriod 
Go 
  
Create Procedure dbo.GetDigblockMinePlanTonnesOverPeriod
( 
	@iLocation_Id Int,
    @iMine_Plan_Id Int = Null,
	@iMine_Plan_Type_Id Int = Null,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @MinePlan Table
	(
		Mine_Plan_Id Int,
		Mine_Plan_Type_Id Int,
		Start_Date DateTime,
		End_Date DateTime
	)

	Declare @Digblock Table
	(
		Digblock_Id Varchar(31),	
		Location_Id Int
	)
	
	Begin Try
		If @iMine_Plan_Id Is Not Null
		Begin
			Insert Into @MinePlan
			(
				Mine_Plan_Id, Mine_Plan_Type_Id, Start_Date, End_Date
			)
			Select M.Mine_Plan_Id, M.Mine_Plan_Type_Id, D.Start_Date, D.End_Date
			From dbo.MinePlan As M
				Inner Join
					(
						Select M.Mine_Plan_Id, Min(IsNull(MP.Start_Date, PMP.Start_Date)) As Start_Date,
							Max(IsNull(MP.End_Date, PMP.End_Date)) As End_Date
						From dbo.MinePlanPeriod As MP
							Inner Join dbo.MinePlan As M
								On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
							Left Outer Join dbo.MinePlanPeriod As PMP
								On (M.Parent_Mine_Plan_Id = PMP.Mine_Plan_Id)
						Where M.Mine_Plan_Id = @iMine_Plan_Id
						Group By M.Mine_Plan_Id
					) As D
					On (M.Mine_Plan_Id = D.Mine_Plan_Id)	
			Where M.Mine_Plan_Id = @iMine_Plan_Id --Helps indexing even though this really is not required
		End
		Else
		Begin
			Insert Into @MinePlan
			(
				Mine_Plan_Id, Mine_Plan_Type_Id, Start_Date, End_Date
			)
			Exec dbo.GetMinePlansOverRange
				@iMine_Plan_Type_Id = @iMine_Plan_Type_Id,
				@iStart_Date = @iStart_Date,
				@iEnd_Date = @iEnd_Date
		End

		--Get all the digblocks that belong to the filter
		Insert Into @Digblock
		(
			Digblock_Id, Location_Id
		)
		Select DL.Digblock_Id, DL.Location_Id
		From 
			(	
				Select Location_Id 
				From dbo.GetLocationChildLocationList(@iLocation_Id)
				Union All
				Select @iLocation_Id As Location_Id
			)  As L
			Inner Join dbo.DigblockLocation As DL
				On (DL.Location_Id = L.Location_Id)
			Inner Join dbo.LocationType As LT
				On LT.Location_Type_Id = DL.Location_Type_Id
		Where LT.Defines_3d_Point = 1
	
		--Get All the period info
		Select MPL.Digblock_Id, Sum(MPP.Tonnes * MPL.Ratio) As Tonnes
		From dbo.MinePlanPeriod As MPP
			Inner Join 
				(
					--Only Return 1 MPL Record based on Digblocks (Stops double counting)
					Select MPL.Mine_Plan_Period_Id, DL.Digblock_Id,
						dbo.GetDatePeriodRatio(MPP.Start_Date, MPP.End_Date, IsNull(@iStart_Date, MPP.Start_Date), IsNull(@iEnd_Date, MPP.End_Date)) As Ratio
					From @MinePlan As MPD
						Inner Join dbo.MinePlanPeriod As MPP
							On (MPD.Mine_Plan_Id = MPP.Mine_Plan_Id
								And MPP.End_Date >= MPD.Start_Date
								And MPP.Start_Date <= MPD.End_Date)
						--Needs to be against a location otherwise we dont know how to link
						Inner Join dbo.MinePlanPeriodLocation AS MPL 
							On (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
						Inner Join @Digblock As DL
							On DL.Location_Id = MPL.Location_Id			
					Group By MPL.Mine_Plan_Period_Id, DL.Digblock_Id, MPP.Start_Date, MPP.End_Date
				) As MPL
				On (MPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
		Where MPP.Is_From_Pit = 1
		Group By MPL.Digblock_Id
		
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

GRANT EXECUTE ON dbo.GetDigblockMinePlanTonnesOverPeriod TO CoreDigblockManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockMinePlanTonnesOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total planned tonnes filtered by a given parent
	location. It can be filtered further by specifying a particular mine plan, mine plan type
	or date range.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockReconciledTonnesOverPeriod.prc'
GO

If object_id('dbo.GetDigblockReconciledTonnesOverPeriod') Is Not Null 
     Drop Procedure dbo.GetDigblockReconciledTonnesOverPeriod 
Go 
  
Create Procedure dbo.GetDigblockReconciledTonnesOverPeriod 
( 
    @iLocation_Id Int,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null 
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select DPT.Source_Digblock_Id As Digblock_Id, Sum(DPT.Tonnes) As Tonnes
	From dbo.DataProcessTransaction As DPT
		Inner Join 
			(	
				--Eliminate double counting
				Select DL.Digblock_Id
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_Id = DL.Location_Type_Id)
					Inner Join 
						(	
							Select Location_Id 
							From dbo.GetLocationChildLocationList(@iLocation_Id)
							Union All
							Select @iLocation_Id As Location_Id
						)  As L
						On (L.Location_Id = DL.Location_Id)
				Group By DL.Digblock_Id
			) As DL
			On (DL.Digblock_Id = DPT.Source_Digblock_Id)
	Where DPT.Source_Digblock_Id Is Not Null
		And DPT.Data_Process_Transaction_Date >= IsNull(@iStart_Date, DPT.Data_Process_Transaction_Date)
		And DPT.Data_Process_Transaction_Date <= IsNull(@iEnd_Date, DPT.Data_Process_Transaction_Date)
	Group By DPT.Source_Digblock_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockReconciledTonnesOverPeriod TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockReconciledTonnesOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total reconciled tonnes for a given period. 
	This is filtered by a parent location that is passed in.	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyTonnesOverPeriod.prc'
GO

If object_id('dbo.GetDigblockSurveyTonnesOverPeriod') Is Not Null 
     Drop Procedure dbo.GetDigblockSurveyTonnesOverPeriod 
Go 
  
Create Procedure dbo.GetDigblockSurveyTonnesOverPeriod 
( 
    @iLocation_Id Int,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @LastShift Char(1)
	Declare @FirstShift Char(1)
	
	Declare @SURVEY table
	(
		Digblock_Survey_Id Int,
		Digblock_Survey_Type_Id Int,
		Start_Date DateTime,
		Start_Shift Char(1) Collate Database_Default,
		End_Date DateTime,
		End_Shift Char(1) Collate Database_Default,
		End_Shift_Order_No Int,
		Ratio Float
	)  

	--Set First and Last Shift vars to avoid SQL server constantly searching for it
	Select @FirstShift = dbo.GetFirstShiftType(),
		@LastShift = dbo.GetLastShiftType()

	Insert @SURVEY
	(
		Digblock_Survey_Id, Digblock_Survey_Type_Id, End_Date, End_Shift, End_Shift_Order_No
	)
	Select D.Digblock_Survey_Id, D.Digblock_Survey_Type_Id, D.Digblock_Survey_Date, ST.Shift, ST.Order_No
	From dbo.DigblockSurvey As D
		Inner Join dbo.ShiftType As ST
			On (ST.Shift = D.Digblock_Survey_Shift)

	--Get the corresponding start dates based on the end date of the previous survey
	Update S
	Set Start_Date =
			(
				Select Top 1 DS.Digblock_Survey_Date
				From dbo.DigblockSurvey As DS
					Inner Join dbo.ShiftType As ST
						On (ST.Shift = DS.Digblock_Survey_Shift)
				Where DS.Digblock_Survey_Type_Id = S.Digblock_Survey_Type_Id 
					And ((S.End_Date > DS.Digblock_Survey_Date)
						Or (S.End_Date = DS.Digblock_Survey_Date 
							And S.End_Shift_Order_No > ST.Order_No))
				Order By DS.Digblock_Survey_Date Desc, ST.Order_No Desc
			),
		Start_Shift = 
			(
				Select Top 1 DS.Digblock_Survey_Shift
				From dbo.DigblockSurvey As DS
					Inner Join dbo.ShiftType As ST
						On (ST.Shift = DS.Digblock_Survey_Shift)
				Where DS.Digblock_Survey_Type_Id = S.Digblock_Survey_Type_Id 
					And ((S.End_Date > DS.Digblock_Survey_Date)
						Or (S.End_Date = DS.Digblock_Survey_Date 
							And S.End_Shift_Order_No > ST.Order_No))
				Order By DS.Digblock_Survey_Date Desc, ST.Order_No Desc
			)
	From @SURVEY As S

	--Since all start dates are really the shift after the end date of the previous
	--survey increment the shifts by one for all records
	Update S
	Set Start_Date =
			Case When Start_Shift = @LastShift Then
				DateAdd(d, 1, Start_Date)
			Else
				Start_Date
			End,
		Start_Shift =
			Case When Start_Shift = @LastShift Then
				@FirstShift
			Else
				dbo.GetNextShiftType(Start_Shift)
			End
	From @SURVEY As S
		
	--Get the system start date and populate it in the first survey entry
	Update S
	Set Start_Date = dbo.GetSystemStartDate(),	
		Start_Shift = @FirstShift
	From @SURVEY As S
	Where S.Start_Date Is Null

	--Calculate Ratios
	Update S
	Set Ratio = dbo.GetDatePeriodRatio(S.Start_Date, S.End_Date, IsNull(@iStart_Date, S.Start_Date), IsNull(@iEnd_Date, S.End_Date))
	From @SURVEY As S

	--Get Out the tonnes
    Select S.Digblock_Id, Sum(S.Survey_Tonnes * DS.Ratio) As Tonnes
	From dbo.DigblockSurveySummary As S
		Inner Join @SURVEY As DS
			On (S.Digblock_Survey_Id = DS.Digblock_Survey_Id)
		Inner Join 
			(
				--Eliminate double counting
				Select DL.Digblock_Id
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_Id = DL.Location_Type_Id)
					Inner Join 
						(
							Select Location_Id 
							From dbo.GetLocationChildLocationList(@iLocation_Id)
							Union All
							Select @iLocation_Id As Location_Id
						) As L
						On (L.Location_Id = DL.Location_Id)
				Group By DL.Digblock_Id
			) As DL
			On (DL.Digblock_Id = S.Digblock_Id)
	Where DS.Start_Date <= IsNull(@iEnd_Date, DS.Start_Date) 
		And DS.End_Date >= IsNull(@iStart_Date, DS.End_Date)
	Group By S.Digblock_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockSurveyTonnesOverPeriod TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyTonnesOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total survey tonnes for a given period. 
	This is filtered by a parent location that is passed in.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageVsPlantReport.prc'
GO

If Object_Id('dbo.GetHaulageVsPlantReport') Is Not Null
	Drop Procedure dbo.GetHaulageVsPlantReport
Go

Create Procedure dbo.GetHaulageVsPlantReport
(
	@iFromDate DateTime, 
	@iToDate DateTime, 
	@iSplitByShift Bit, 
	@iSummary Bit
)
With Encryption 
As

-------------------------------------------------------------------------------
--  Procedure: dbo.GetHaulageVsPlantReport
--	Created: 23-Oct-2007
--	Dev: JBC
--  For Core Standard reports
--------------------------------------------------------------------------------
Begin
	Set NoCount On

	-- Create a temporary table to hold the results
	Create Table #Results
	(
		Crusher Varchar(63) Collate Database_Default,
		Weightometer Varchar(63) Collate Database_Default,
		Haulage_Date Datetime,
		Haulage_Shift Char(1) Collate Database_Default,
		Haulage_Tonnes Float,
		Conveyor_Tonnes Float,
		Digblock_Haulage_Tonnes Float,
		Stockpile_Haulage_Tonnes Float
	)

    --Insert the details for all raw haulage tonnes delivered to crushers for each day in the range
	Insert Into #Results
	(
		Crusher, Weightometer, Haulage_Date, Haulage_Shift, 
		Haulage_Tonnes
	)
	Select C.Description, WFP.Weightometer_Id, H.Haulage_Date, H.Haulage_Shift, 
		Sum(H.Tonnes)
	From Haulage H 
		Inner Join WeightometerFlowPeriod WFP
			On H.Destination_Crusher_Id = WFP.Source_Crusher_Id
		Inner Join Crusher C	
			On H.Destination_Crusher_Id = C.Crusher_Id
	Where (WFP.End_Date =	(Select Min(W2.End_Date)
						From WeightometerFlowPeriod W2
						Where WFP.Weightometer_Id = W2.Weightometer_Id
						And W2.End_Date >= H.Haulage_Date)
			Or (WFP.End_Date Is Null
			And	(Select Min(W2.End_Date)
				From WeightometerFlowPeriod W2
				Where WFP.Weightometer_Id = W2.Weightometer_Id
				And W2.End_Date >= H.Haulage_Date) Is Null)
			)
		And H.Haulage_Date Between @iFromDate And @iToDate
	Group By C.Description, WFP.Weightometer_Id, H.Haulage_Date, H.Haulage_Shift


	-- Insert the details for all weightometer tonnes for dates not inserted by last statement
	Insert Into #Results
	(
		Crusher, Weightometer, Haulage_Date, Haulage_Shift, 
		Conveyor_Tonnes
	)
	Select C.Description, WFP.Weightometer_Id, WS.Weightometer_Sample_Date, WS.Weightometer_Sample_Shift, 
		Sum(WS.Tonnes)
	From WeightometerFlowPeriod WFP
		Inner Join WeightometerSample WS
			On WS.Weightometer_Id = WFP.Weightometer_Id
		Inner Join Crusher C
			On WFP.Source_Crusher_Id = C.Crusher_Id
	Where (WFP.End_Date =	(Select Min(W2.End_Date)
						From WeightometerFlowPeriod W2
						Where WFP.Weightometer_Id = W2.Weightometer_Id
						And W2.End_Date >= WS.Weightometer_Sample_Date)
			Or (WFP.End_Date Is Null
			And	(Select Min(W2.End_Date)
				From WeightometerFlowPeriod W2
				Where WFP.Weightometer_Id = W2.Weightometer_Id
				And W2.End_Date >= WS.Weightometer_Sample_Date) Is Null)
			)
		And WFP.Source_Crusher_Id Is Not Null
		And WS.Weightometer_Sample_Date Between @iFromDate And @iToDate
		And Exists  (Select 1
					From Haulage H2
					Where H2.Destination_Crusher_Id = WFP.Source_Crusher_Id)
		And Not Exists  (Select 1
						From #Results R2
						Where WS.Weightometer_Id = R2.Weightometer
						And WS.Weightometer_Sample_Date = R2.Haulage_Date
						And WS.Weightometer_Sample_Shift = R2.Haulage_Shift)
	Group By C.Description, WFP.Weightometer_Id, WS.Weightometer_Sample_Date, WS.Weightometer_Sample_Shift


	-- Update the details for any raw haulage tonnes delivered to crushers for each day in the 
	-- range which came directly from digblocks, where a record does not already exist
	Update R
	Set Digblock_Haulage_Tonnes =     Coalesce((Select Sum(H.Tonnes)
												From Haulage H 
													Inner Join WeightometerFlowPeriod WFP
														On H.Destination_Crusher_Id = WFP.Source_Crusher_Id
												Where  (WFP.End_Date =	(Select Min(W2.End_Date)
																		From WeightometerFlowPeriod W2
																		Where WFP.Weightometer_Id = W2.Weightometer_Id
																		And W2.End_Date >= H.Haulage_Date)
															Or (WFP.End_Date Is Null
															And	(Select Min(W2.End_Date)
																From WeightometerFlowPeriod W2
																Where WFP.Weightometer_Id = W2.Weightometer_Id
																And W2.End_Date >= H.Haulage_Date) Is Null)
														)
													And H.Haulage_Date Between @iFromDate And @iToDate
													And H.Source_Digblock_Id Is Not Null
													And WFP.Weightometer_Id = R.Weightometer
													And H.Haulage_Date = R.Haulage_Date
													And H.Haulage_Shift = R.Haulage_Shift), 0)
	From #Results R
    
	-- Update the details for any raw haulage tonnes delivered to crushers for each day in the 
	-- range which came from stockpiles, where a record does not already exist
    Update R
	Set Stockpile_Haulage_Tonnes =    Coalesce((Select Sum(H.Tonnes)
												From Haulage H 
													Inner Join WeightometerFlowPeriod WFP
														On H.Destination_Crusher_Id = WFP.Source_Crusher_Id
												Where  (WFP.End_Date =	(Select Min(W2.End_Date)
																		From WeightometerFlowPeriod W2
																		Where WFP.Weightometer_Id = W2.Weightometer_Id
																		And W2.End_Date >= H.Haulage_Date)
															Or (WFP.End_Date Is Null
															And	(Select Min(W2.End_Date)
																From WeightometerFlowPeriod W2
																Where WFP.Weightometer_Id = W2.Weightometer_Id
																And W2.End_Date >= H.Haulage_Date) Is Null)
														)
													And H.Haulage_Date Between @iFromDate And @iToDate
													And H.Source_Stockpile_Id Is Not Null
													And WFP.Weightometer_Id = R.Weightometer
													And H.Haulage_Date = R.Haulage_Date
													And H.Haulage_Shift = R.Haulage_Shift), 0)
	From #Results R

    
	-- Update the details for the weightometer readings themselves
    Update R
	Set Conveyor_Tonnes =     Coalesce((Select Sum(WS.Tonnes)
										From WeightometerSample WS, WeightometerFlowPeriod WFP
										Where WS.Weightometer_Id = WFP.Weightometer_Id
										And  (WFP.End_Date =	(Select Min(W2.End_Date)
																		From WeightometerFlowPeriod W2
																		Where WFP.Weightometer_Id = W2.Weightometer_Id
																		And W2.End_Date >= WS.Weightometer_Sample_Date)
															Or (WFP.End_Date Is Null
															And	(Select Min(W2.End_Date)
																From WeightometerFlowPeriod W2
																Where WFP.Weightometer_Id = W2.Weightometer_Id
																And W2.End_Date >= WS.Weightometer_Sample_Date) Is Null)
														)
										And WFP.Weightometer_Id = R.Weightometer
										And WS.Weightometer_Sample_Date Between @iFromDate And @iToDate
										And WS.Weightometer_Sample_Date = R.Haulage_Date
										And WS.Weightometer_Sample_Shift = R.Haulage_Shift), 0)
	From #Results R

   
	-- Update any numbers which should be zeros
	Update R
	Set Digblock_Haulage_Tonnes = 0
	From #Results R
	Where Digblock_Haulage_Tonnes Is Null

    Update R
	Set Stockpile_Haulage_Tonnes = 0
	From #Results R
	Where Stockpile_Haulage_Tonnes Is Null

	Update R
	Set Haulage_Tonnes = 0
	From #Results R
	Where Haulage_Tonnes Is Null

	Update R
	Set Conveyor_Tonnes = 0
	From #Results R
	Where Conveyor_Tonnes Is Null

	-- Return the results
	If (@iSummary = 0 And @iSplitByShift = 1) -- Display Shift and Date
	Begin
		Select *
		From #Results
		Order By Crusher, Haulage_Date, Haulage_Shift
	End
	Else If(@iSummary = 0 And @iSplitByShift = 0) -- Display Date
	Begin
		Select Crusher, Weightometer, Haulage_Date, 
			Sum(Haulage_Tonnes) As Haulage_Tonnes, 
			Sum(Digblock_Haulage_Tonnes) As Digblock_Haulage_Tonnes, 
			Sum(Stockpile_Haulage_Tonnes) As Stockpile_Haulage_Tonnes, 
			Sum(Haulage_Tonnes) As Haulage_Tonnes,
			Sum(Conveyor_Tonnes) As Conveyor_Tonnes
		From #Results
		Group By Crusher, Weightometer, Haulage_Date
		Order By Crusher, Haulage_Date
	End
	Else If(@iSummary = 1) -- Summary (No date or Shift)
	Begin
		Select Crusher, Weightometer, 
			Sum(Haulage_Tonnes) As Haulage_Tonnes, 
			Sum(Digblock_Haulage_Tonnes) As Digblock_Haulage_Tonnes, 
			Sum(Stockpile_Haulage_Tonnes) As Stockpile_Haulage_Tonnes, 
			Sum(Haulage_Tonnes) As Haulage_Tonnes, 
			Sum(Conveyor_Tonnes) As Conveyor_Tonnes
		From #Results
		Group By Crusher, Weightometer
		Order By Crusher
	End

	--Clean up
	Drop Table #RESULTS

End
GO
GRANT EXECUTE ON dbo.GetHaulagevsPlantReport TO CoreReporting



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationParentHeirarchy.prc'
GO

If object_id('dbo.GetLocationParentHeirarchy') Is Not Null 
     Drop Procedure dbo.GetLocationParentHeirarchy 
Go 
  
Create Procedure dbo.GetLocationParentHeirarchy 
( 
    @iLocation_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @Location Table
	(
		Location_Id Int,
		Location_Type_Id TINYINT,
		Name Varchar(255),
		Order_No Int Identity(1, 1)
	)

	Declare @Location_Id Int
	
	 --This query is inclusive but make sure it exists
	Select @Location_Id = @iLocation_Id
	From dbo.Location
	Where Location_Id = @iLocation_Id

	While @Location_Id Is Not Null
	Begin
		-- Insert this parent location
		Insert Into @Location
		(
			Location_Id, Location_Type_Id, Name
		)
		Select Location_Id, Location_Type_Id, Name
		From dbo.Location
		Where Location_Id = @Location_Id	

		Select @Location_Id = Parent_Location_Id
		From dbo.Location
		Where Location_Id = @Location_Id
	End

	Select L.*, LT.Description As Location_Type_Description
	From @Location As L
		Inner Join dbo.LocationType As LT
			On (L.Location_Type_Id = LT.Location_Type_Id)
	Order by Order_No * -1
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetLocationParentHeirarchy TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetLocationParentHeirarchy">
 <Procedure>
	Returns the parental heirarchy of locations for location id provided.
	This heirarchy will include the location passed in but not its children.
 </Procedure>
</TAG>
*/	



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlansOverRange.prc'
GO

If Object_Id('dbo.GetMinePlansOverRange') Is Not Null 
     Drop Procedure dbo.GetMinePlansOverRange 
Go 
  
Create Procedure dbo.GetMinePlansOverRange
( 
    @iMine_Plan_Type_Id Int = Null,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @MinePlan table
	(
		Mine_Plan_Id Int,
		Mine_Plan_Type_Id Int,
		Imported_DateTime DateTime,
		Start_Date DateTime,
		End_Date DateTime
	)

	Declare @MINE_PLAN_SPLIT Table
	(
		Mine_Plan_Id Int,
		Mine_Plan_Type_Id Int,
		Imported_DateTime DateTime,
		Start_Date DateTime,
		End_Date DateTime
	)

    Begin Try

		If (@iStart_Date Is Null And @iEnd_Date Is Not Null)
			Or (@iStart_Date Is Not Null And @iEnd_date Is Null)
		Begin
			RaisError('Start and end date must be specifed together or not at all.', 16, 1)
		End

		Insert Into @MinePlan
		(
			Mine_Plan_Id, Mine_Plan_Type_Id, Imported_DateTime, Start_Date, End_Date
		)
		Select MP.Mine_Plan_Id, MP.Mine_Plan_Type_Id, MP.Imported_DateTime, D.Start_Date, D.End_Date
		From dbo.MinePlan As MP
			Inner Join
				(
					--Get The start date and end dates of the plans - if one isnt provided look for a parent
					--plan and use its start date.
					Select M.Mine_Plan_Id, Min(IsNull(MP.Start_Date, PMP.Start_Date)) As Start_Date,
						Max(IsNull(MP.End_Date, PMP.End_Date)) As End_Date
					From dbo.MinePlanPeriod As MP
						Inner Join dbo.MinePlan As M
							On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
						Left Outer Join dbo.MinePlanPeriod As PMP
							On (M.Parent_Mine_Plan_Id = PMP.Mine_Plan_Id)
					Where M.Mine_Plan_Type_Id = IsNull(@iMine_Plan_Type_Id, M.Mine_Plan_Type_Id)
					Group By M.Mine_Plan_Id
					Having 
						(
							Max(IsNull(MP.End_Date, PMP.End_Date)) >= @iStart_Date
							And Min(IsNull(MP.Start_Date, PMP.Start_Date)) <= @iEnd_Date
						)
						Or @iStart_Date Is Null 
				) As D
				On (D.Mine_Plan_Id = MP.Mine_Plan_Id)

		--Recalculate the plan periods using Start dates of the next plan
		-- |======|
		--    |======|
		--		 |======|
		-- Becomes:
		-- |==|
		--	  |==|
		--       |======|
		Insert Into @MINE_PLAN_SPLIT
		( 
			Mine_Plan_Id, Mine_Plan_Type_Id, Imported_DateTime, Start_Date, End_Date
		)
		Select M.Mine_Plan_Id, M.Mine_Plan_Type_Id, M.Imported_DateTime, M.Start_Date,
			IsNull(
				(
					Select DateAdd(d, -1, Min(M2.Start_Date))
					From @MinePlan As M2
					Where M2.Start_Date < M.End_Date
						And M2.Mine_Plan_Id <> M.Mine_Plan_Id
						And M2.Start_Date > M.Start_Date
						And M2.Imported_DateTime > M.Imported_DateTime
				), End_Date)
		From @MinePlan As M

		--Free Up Memory
		Delete @MinePlan

		--Remove any plans that share the same start date & type but are larger than the smallest period type
		--and take the most granular
		-- |=====|
		-- |=============| <-- Delete this one
		Delete M2
		From @MINE_PLAN_SPLIT As M2
			Inner Join 
				(
					Select Mine_Plan_Type_Id, Start_Date,  
						Min(DateDiff(d, End_Date, Start_Date)) As Min_Diff
					From @MINE_PLAN_SPLIT As M2
					Group by Mine_Plan_Type_Id, Start_Date
					Having Count(*) > 1
				) As AGG
				On (AGG.Start_Date = M2.Start_Date
					And AGG.Mine_Plan_Type_Id = M2.Mine_Plan_Type_Id)
		Where DateDiff(d, M2.End_Date, M2.Start_Date) > Min_Diff
		
		--Remove any previous plans that share the same date range
		-- |===|
		-- |===|
		-- |===| <-- Take this one
		Delete M2
		From @MINE_PLAN_SPLIT As M2
			Inner Join
				(
					Select Mine_Plan_Type_Id, Start_Date, 
						Max(Imported_DateTime) AS Max_Imported_DateTime
					From @MINE_PLAN_SPLIT As M2
					Group By Mine_Plan_Type_Id, Start_Date
					Having Count(*) > 1
				) As AGG
				On (AGG.Start_Date = M2.Start_Date
					And AGG.Mine_Plan_Type_Id = M2.Mine_Plan_Type_Id)
		Where M2.Imported_DateTime < AGG.Max_Imported_DateTime

		Select Mine_Plan_Id, Mine_Plan_Type_Id, Start_Date, End_Date
		From @MINE_PLAN_SPLIT
		Order by Mine_Plan_Type_Id, Start_date

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetMinePlansOverRange">
 <Procedure>
	Returns a list of plans of which to use when referencing a given period.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlanTypeList.prc'
GO

If object_id('dbo.GetMinePlanTypeList') is not Null 
     Drop Procedure dbo.GetMinePlanTypeList 
Go 
  
Create Procedure dbo.GetMinePlanTypeList
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select Mine_Plan_Type_Id, Name, Description, Is_Location_Based
	From dbo.MinePlanType
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetMinePlanTypeList TO CoreMinePlanManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetMinePlanTypeList">
 <Procedure>
	Returns a list mine plans types available in the system.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMonthlyMaterialMovementReport.prc'
GO

If Object_Id('dbo.GetMonthlyMaterialMovementReport') Is Not Null
	Drop Procedure dbo.GetMonthlyMaterialMovementReport
Go

Create Procedure dbo.GetMonthlyMaterialMovementReport
(
	@iYear Datetime,
	@iIs_Waste Int
)
With Encryption 
As

-------------------------------------------------------------------------------
--  Procedure: dbo.GetMonthlyMaterialMovementReport
--	Created: 23-Oct-2007
--	Dev: JBC
--  For Core Standard reports
--------------------------------------------------------------------------------
Begin
	Set NoCount On

	Create Table #MOVEMENT_RESULT
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int NOT NULL, 
		Tonnes Int NULL,
		Material_Type Varchar(62) COLLATE DATABASE_DEFAULT NOT NULL,
		Is_Waste Int NULL
 		Primary Key Clustered (Month_No, Material_Type)
	)

	Create Table #DATE_LIST
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int
		Primary Key Clustered (Month_No)
	)

	Declare @Haulage_Date_From Datetime
	Declare @Haulage_Date_To Datetime

	Set @Haulage_Date_From = Convert(Datetime, '01-Jan-' + DateName(Year, @iYear))
	Set @Haulage_Date_To = DateAdd(Day, -1, DateAdd(Year, 1, @Haulage_Date_From))

	Insert Into #DATE_LIST
	(
		Report_Month, Month_No
	)
	Select (CASE WHEN Month(dbo.GetDateMonth(This_Date)) = 1 Then
				'Jan'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 2 Then
				'Feb'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 3 Then
				'Mar'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 4 Then
				'Apr'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 5 Then
				'May'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 6 Then
				'Jun'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 7 Then
				'Jul'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 8 Then
				'Aug'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 9 Then
				'Sep'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 10 Then
				'Oct'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 11 Then
				'Nov'
			WHEN Month(dbo.GetDateMonth(This_Date)) = 12 Then
				'Dec'
			Else
				'UNK'
			END ), Month(dbo.GetDateMonth(This_Date)) As This_Date
	From dbo.GetDateList(@Haulage_Date_From, @Haulage_Date_To, 'Month', 1)
	Group By Month(dbo.GetDateMonth(This_Date))
	
	Insert Into #MOVEMENT_RESULT 
	(
		Report_Month, Month_No, Material_Type, Is_Waste
	)
	Select L.Report_Month, L.Month_No, 
		R.Description, R.Is_Waste
	From #DATE_LIST L
		Cross Join
		(Select Distinct MT.Description, MT.Is_Waste
			From DataProcessTransaction DPT
				Inner Join Stockpile S
					On S.Stockpile_Id = DPT.Destination_Stockpile_Id
				Inner Join MaterialType MT
					On S.Material_Type_Id = MT.Material_Type_Id
			Where (DPT.Data_Process_Transaction_Date Between @Haulage_Date_From And @Haulage_Date_To)
		) as R

	Update #MOVEMENT_RESULT 
	Set Tonnes =  R.Tonnes
	From (
		Select Month(DPT.Data_Process_Transaction_Date) as Month_No,
			 Sum(DPT.Tonnes) As Tonnes, 
			MT.Description, 
			MT.Is_Waste
		From DataProcessTransaction DPT
			Inner Join Stockpile S
				On S.Stockpile_Id = DPT.Destination_Stockpile_Id
			Inner Join MaterialType MT
				On S.Material_Type_Id = MT.Material_Type_Id
		Where (DPT.Data_Process_Transaction_Date Between @Haulage_Date_From And @Haulage_Date_To)
		Group by Month(DPT.Data_Process_Transaction_Date), MT.Description, MT.Is_Waste
		) As R
		Inner Join #MOVEMENT_RESULT MR
			On MR.Month_No = R.Month_No And MR.Material_Type = R.Description


	If @iIs_Waste = 2
	Begin
		Select Report_Month, Month_No, Tonnes, Material_Type, Is_Waste
		From #MOVEMENT_RESULT
		Order by Material_Type, Month_No
	End
	Else If @iIs_Waste = 0
	Begin
		Select Report_Month, Month_No, Tonnes, Material_Type
		From #MOVEMENT_RESULT
		Where Is_Waste = 0
		Order by Material_Type, Month_No
	End
	Else If @iIs_Waste = 1
	Begin
		Select Report_Month, Month_No, Tonnes, Material_Type
		From #MOVEMENT_RESULT
		Where Is_Waste = 1
		Order by Material_Type, Month_No
	End

	--Clean Up
	Drop Table #MOVEMENT_RESULT
	Drop Table #DATE_LIST

End
GO
GRANT EXECUTE ON dbo.GetMonthlyMaterialMovementReport TO CoreReporting


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityAdditions.prc'
GO

IF OBJECT_ID('dbo.GetStockpileActivityAdditions') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityAdditions 
GO 
  
CREATE PROCEDURE dbo.GetStockpileActivityAdditions 
( 
	@iStockpile_Id INT,
	@iStart_Date DATETIME,
	@iEnd_Date DATETIME,
	@iReturn_Type INT,
	@iGrade_Visibility BIT,
	@iActivity_Type TINYINT
) 
WITH ENCRYPTION 
AS
BEGIN 
  SET NOCOUNT ON 

  SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
  BEGIN TRANSACTION 
 
	IF @iReturn_Type = 0 
	BEGIN
		--Return Tonnes additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPT.Data_Process_Transaction_Date,
			DPT.Data_Process_Transaction_Shift, DPT.Tonnes,
			Coalesce(SS.Stockpile_Name, DPT.Source_Digblock_Id)
		FROM dbo.DataProcessTransaction AS DPT
			LEFT OUTER JOIN dbo.Stockpile AS SS
				ON (SS.Stockpile_Id = DPT.Source_Stockpile_Id)		
		WHERE DPT.Destination_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id Is Null
	END
	ELSE IF @iReturn_Type = 1
	BEGIN
		--Return Grades additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPTG.Grade_Id, G.Grade_Name, DPTG.Grade_Value,
			COALESCE(SS.Stockpile_Name, DPT.Source_Digblock_Id)
		FROM dbo.DataProcessTransaction AS DPT
			INNER JOIN dbo.DataProcessTransactionGrade AS DPTG
				ON (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
			INNER JOIN dbo.Grade AS G
				ON (DPTG.Grade_Id = G.Grade_Id)
			LEFT OUTER JOIN dbo.Stockpile AS SS
				ON (SS.Stockpile_Id = DPT.Source_Stockpile_Id)						
		WHERE DPT.Destination_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date Between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id Is Null
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
	END
			
  COMMIT TRANSACTION 
END 
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityAdditions">
 <Procedure>
	Returns the tonnes or grade additions to the given stockpile over a specified period.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityAdjustments.prc'
GO

IF object_id('dbo.GetStockpileActivityAdjustments') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityAdjustments
GO 
  
CREATE PROCEDURE dbo.GetStockpileActivityAdjustments
( 
    @iStockpile_Id INT,
    @iStart_Date DATETIME,
	@iEnd_Date DATETIME,
	@iReturn_Type INT,
	@iGrade_Visibility BIT,
	@iActivity_Type TINYINT
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
 
	IF @iReturn_Type = 0 
	BEGIN
		--Return Tonnes additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPT.Data_Process_Transaction_Date,
			DPT.Data_Process_Transaction_Shift, 
			CASE 
				WHEN S.Stockpile_Id = DPT.Destination_Stockpile_Id THEN
					DPT.Tonnes
				ELSE
					DPT.Tonnes * -1
			END	AS Tonnes
		FROM dbo.DataProcessTransaction AS DPT	
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = DPT.Source_Stockpile_Id 
					OR S.Stockpile_Id = DPT.Destination_Stockpile_Id)
		WHERE S.Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NOT NULL
	END
	ELSE IF @iReturn_Type = 1
	BEGIN
		--Return Grades additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPTG.Grade_Id, G.Grade_Name, DPTG.Grade_Value
		FROM dbo.DataProcessTransaction AS DPT
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = DPT.Source_Stockpile_Id 
					OR S.Stockpile_Id = DPT.Destination_Stockpile_Id)
			INNER JOIN dbo.DataProcessTransactionGrade AS DPTG
				ON (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
			INNER JOIN dbo.Grade AS G
				ON (DPTG.Grade_Id = G.Grade_Id)
		WHERE S.Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date between @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NOT NULL
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
	END
		
    COMMIT TRANSACTION 
END 
GO 

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityAdjustments">
 <Procedure>
	Returns the tonnes or grade adjustments to the given stockpile over a specified period.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityOpeningBalance.prc'
GO

IF Object_Id('dbo.GetStockpileActivityOpeningBalance') IS NOT NULL
     DROP PROCEDURE dbo.GetStockpileActivityOpeningBalance
GO

CREATE PROCEDURE dbo.GetStockpileActivityOpeningBalance
(
    @iStockpileId INT,
    @iBalanceDate DATETIME,
	@iBalanceShift CHAR(1),
	@iReturnType TINYINT,
	@iGradeVisibility BIT,
	@iActivityType TINYINT
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @PrevBalanceDate DATETIME
	DECLARE @PrevBalanceShift CHAR(1)

    SET NOCOUNT ON

    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
    BEGIN TRANSACTION

	-- find the closing balance of the previous date
	EXEC dbo.GetPreviousDateShift
		@Date = @iBalanceDate,
		@Shift = @iBalanceShift,
		@Previous_Date = @PrevBalanceDate OUTPUT,
		@Previous_Shift = @PrevBalanceShift OUTPUT

	IF @iReturnType = 0
	BEGIN
		SELECT @iActivityType AS Activity_Type,
			1 AS BalanceId,  -- dummy record (working around defect)
			@iBalanceDate AS BalanceDate, @iBalanceShift AS BalanceShift,  -- (yet another defect to work around)
			ISNULL(method1.Tonnes, method2.Tonnes) AS Tonnes
		FROM dbo.Stockpile AS s
			LEFT OUTER JOIN
			(
				SELECT Stockpile_Id, SUM(Tonnes) AS Tonnes
				FROM dbo.DataProcessStockpileBalance
				WHERE Data_Process_Stockpile_Balance_Date = @PrevBalanceDate
					AND Data_Process_Stockpile_Balance_Shift = @PrevBalanceShift
				GROUP BY Stockpile_Id
			) AS method1
			ON (method1.Stockpile_Id = s.Stockpile_Id)
			LEFT OUTER JOIN
			(
				SELECT sb.Stockpile_Id, SUM(sbc.Start_Tonnes) AS Tonnes
				FROM dbo.StockpileBuildComponent AS sbc
					INNER JOIN dbo.StockpileBuild AS sb
						ON (sbc.Stockpile_Id = sb.Stockpile_Id
							AND sbc.Build_Id = sb.Build_Id)
				WHERE sb.Start_Date = @iBalanceDate
					AND sb.Start_Shift = @iBalanceShift
				GROUP BY sb.Stockpile_Id
			) AS method2
			ON (method2.Stockpile_Id = s.Stockpile_Id)
		WHERE s.Stockpile_Id = @iStockpileId
	END
	ELSE IF @iReturnType = 1
	BEGIN
		SELECT @iActivityType AS Activity_Type,
			1 AS BalanceId,  -- dummy record (working around defect)
			g.Grade_Id, g.Grade_Name, ISNULL(method1.Grade_Value, method2.Grade_Value) AS Grade_Value
		FROM dbo.Stockpile AS s
			CROSS JOIN dbo.Grade AS g
			LEFT OUTER JOIN
			(
				SELECT b.Stockpile_Id, bg.Grade_Id, bg.Grade_Value
				FROM dbo.DataProcessStockpileBalance AS b
					INNER JOIN dbo.DataProcessStockpileBalanceGrade AS bg
						ON (b.Data_Process_Stockpile_Balance_Id = bg.Data_Process_Stockpile_Balance_Id)
				WHERE b.Data_Process_Stockpile_Balance_Date = @PrevBalanceDate
					AND b.Data_Process_Stockpile_Balance_Shift = @PrevBalanceShift
			) AS method1
			ON (method1.Stockpile_Id = s.Stockpile_Id
				AND method1.Grade_Id = g.Grade_Id)
			LEFT OUTER JOIN
			(
				SELECT sb.Stockpile_Id, sbcg.Grade_Id,
				 COALESCE(SUM(sbc.Start_Tonnes * sbcg.Grade_Value) / NULLIF(SUM(sbc.Start_Tonnes), 0.0), 0) AS Grade_Value
				FROM dbo.StockpileBuildComponent AS sbc
					INNER JOIN dbo.StockpileBuild AS sb
						ON (sbc.Stockpile_Id = sb.Stockpile_Id
							AND sbc.Build_Id = sb.Build_Id)
					INNER JOIN dbo.StockpileBuildComponentGrade AS sbcg
						ON (sbc.Stockpile_Id = sbcg.Stockpile_Id
							AND sbc.Build_Id = sbcg.Build_Id
							AND sbc.Component_Id = sbcg.Component_Id)
				WHERE sb.Start_Date = @iBalanceDate
					AND sb.Start_Shift = @iBalanceShift
				GROUP BY sb.Stockpile_Id, sbcg.Grade_Id
			) AS method2
			ON (method2.Stockpile_Id = s.Stockpile_Id
				AND method2.Grade_Id = g.Grade_Id)
		WHERE s.Stockpile_Id = @iStockpileId
			AND (g.Is_Visible = @iGradeVisibility OR @iGradeVisibility IS NULL)
	END
		
    COMMIT TRANSACTION
END
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityOpeningBalance">
 <Procedure>
	Returns the opening tonnes/grade balance of the given stockpile for a given date and shift.
 </Procedure>
</TAG>
*/	

/* testing
EXEC dbo.GetStockpileActivityOpeningBalance
    @iStockpileId = 25524,
    @iBalanceDate = '02-APR-2008',
	@iBalanceShift = 'D',
	@iReturnType = 0,
	@iGradeVisibility = 1
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityClosingBalance.prc'
GO

IF object_id('dbo.GetStockpileActivityClosingBalance') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityClosingBalance 
GO 
  
CREATE PROCEDURE dbo.GetStockpileActivityClosingBalance
( 
    @iStockpileId INT,
    @iBalanceDate DATETIME,
	@iBalanceShift VARCHAR(1),
	@iReturnType TINYINT,
	@iGradeVisibility BIT,	
	@iActivityType TINYINT
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
 
	IF @iReturnType = 0 
	BEGIN
		-- return the closing balance tonnes
		SELECT @iActivityType AS Activity_Type,
			dpsb.Data_Process_Stockpile_Balance_Id, dpsb.Data_Process_Stockpile_Balance_Date,
			dpsb.Data_Process_Stockpile_Balance_Shift, dpsb.Tonnes
		FROM dbo.DataProcessStockpileBalance AS dpsb
		WHERE dpsb.Stockpile_Id = @iStockpileId
			AND dpsb.Data_Process_Stockpile_Balance_Date = @iBalanceDate
			AND dpsb.Data_Process_Stockpile_Balance_Shift = @iBalanceShift
	END
	ELSE IF @iReturnType = 1
	BEGIN
		-- return the closing balance grades
		SELECT @iActivityType AS Activity_Type,
			dpsb.Data_Process_Stockpile_Balance_Id, dpsbg.Grade_Id, g.Grade_Name, dpsbg.Grade_Value
		FROM dbo.DataProcessStockpileBalance AS dpsb
			INNER JOIN dbo.DataProcessStockpileBalanceGrade AS dpsbg
				ON (dpsb.Data_Process_Stockpile_Balance_Id = dpsbg.Data_Process_Stockpile_Balance_Id)
			INNER JOIN dbo.Grade AS g
				ON (dpsbg.Grade_Id = g.Grade_Id)
		WHERE dpsb.Stockpile_Id = @iStockpileId
			AND dpsb.Data_Process_Stockpile_Balance_Date = @iBalanceDate
			AND dpsb.Data_Process_Stockpile_Balance_Shift = @iBalanceShift
			AND (g.Is_Visible = @iGradeVisibility OR @iGradeVisibility IS NULL)
	END
		
    COMMIT TRANSACTION 
END 
GO 

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityClosingBalance">
 <Procedure>
	Returns the closing tonnes/grade balance of the given stockpile for a given date and shift.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityRemovals.prc'
GO

IF OBJECT_ID('dbo.GetStockpileActivityRemovals') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityRemovals 
GO 
  
CREATE PROCEDURE dbo.GetStockpileActivityRemovals
( 
	@iStockpile_Id INT,
	@iStart_Date DATETIME,
	@iEnd_Date DATETIME,
	@iReturn_Type INT,
	@iGrade_Visibility BIT,
	@iActivity_Type TINYINT
) 
WITH ENCRYPTION 
AS
BEGIN 
	SET NOCOUNT ON 

	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
	BEGIN TRANSACTION 

	IF @iReturn_Type = 0 
	BEGIN
		--Return Tonnes additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPT.Data_Process_Transaction_Date,
			DPT.Data_Process_Transaction_Shift, DPT.Tonnes,
			Coalesce(H.Destination_Crusher_Id, DS.Stockpile_Name, DPT.Destination_Mill_Id)
		FROM dbo.DataProcessTransaction AS DPT
			LEFT OUTER JOIN dbo.Stockpile AS DS
				ON (DS.Stockpile_Id = DPT.Destination_Stockpile_Id)
			LEFT OUTER JOIN dbo.DataTransactionTonnes AS DTT
				INNER JOIN dbo.Haulage AS H 
					ON (H.Haulage_Id = DTT.Haulage_Id)
				ON (DTT.Data_Transaction_Tonnes_Id = DPT.Data_Transaction_Tonnes_Id) 				
		WHERE DPT.Source_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date BETWEEN @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NULL
	END
	ELSE IF @iReturn_Type = 1
	BEGIN
		--Return Grades additions
		SELECT @iActivity_Type AS Activity_Type,
			DPT.Data_Process_Transaction_Id, DPTG.Grade_Id, G.Grade_Name, DPTG.Grade_Value,
			Coalesce(H.Destination_Crusher_Id, DS.Stockpile_Name, Convert(varchar, DPT.Destination_Mill_Id))
		FROM dbo.DataProcessTransaction AS DPT
			INNER JOIN dbo.DataProcessTransactionGrade AS DPTG
				ON (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
			INNER JOIN dbo.Grade AS G
				ON (DPTG.Grade_Id = G.Grade_Id)
			LEFT OUTER JOIN dbo.Stockpile AS DS
				ON (DS.Stockpile_Id = DPT.Destination_Stockpile_Id)
			LEFT OUTER JOIN dbo.DataTransactionTonnes AS DTT
				INNER JOIN dbo.Haulage AS H 
					ON (H.Haulage_Id = DTT.Haulage_Id)
				ON (DTT.Data_Transaction_Tonnes_Id = DPT.Data_Transaction_Tonnes_Id) 							
		WHERE DPT.Source_Stockpile_Id = @iStockpile_Id
			AND DPT.Data_Process_Transaction_Date BETWEEN @iStart_Date AND @iEnd_Date
			AND DPT.Stockpile_Adjustment_Id IS NULL
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
	END

	COMMIT TRANSACTION 
END 
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityRemovals">
 <Procedure>
	Returns the tonnes or grade removals to the given stockpile over a specified period.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileActivityStateChanges.prc'
GO

IF object_id('dbo.GetStockpileActivityStateChanges') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileActivityStateChanges 
GO 
  
CREATE PROCEDURE dbo.GetStockpileActivityStateChanges 
( 
    @iStockpile_Id INT,
    @iStart_Date DATETIME,
	@iEnd_Date DATETIME
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
		
	--Get the normal states to reflect as best it can
	SELECT SB.Stockpile_Id, SB.Build_Id, SB.Start_Date, SB.Start_Shift,
		CASE 
			WHEN (SB.Reclaim_Start_Date IS NOT NULL AND SB.Reclaim_Start_Date <= @iEnd_Date) THEN 
				'BUILDING'
			WHEN (SB.Reclaim_Start_Date IS NULL AND SB.End_Date IS NULL) THEN
				Stockpile_State_Id
			WHEN (SB.Reclaim_Start_Date IS NULL AND SB.End_Date IS NOT NULL) THEN
				'NORMAL'
		END AS Stockpile_State_Id
	FROM dbo.StockpileBuild AS SB
	WHERE SB.Stockpile_Id = @iStockpile_Id
		AND (SB.Start_Date Between @iStart_Date AND @iEnd_Date)
		AND (SB.End_Date IS NULL OR SB.End_Date <= @iEnd_Date)
	UNION ALL
	--Has it been set to reclaim between period
	SELECT SB.Stockpile_Id, SB.Build_Id, SB.Reclaim_Start_Date, SB.Reclaim_Start_Shift,
		'RECLAIMING'
	FROM dbo.StockpileBuild AS SB
	WHERE SB.Stockpile_Id = @iStockpile_Id
		AND SB.Reclaim_Start_Date Between @iStart_Date AND @iEnd_Date
	UNION ALL
	--Has it been set to closed between the period
	SELECT SB.Stockpile_Id, SB.Build_Id, SB.End_Date, SB.End_Shift, 'CLOSED'
	FROM dbo.StockpileBuild AS SB	
	WHERE SB.Stockpile_Id = @iStockpile_Id
		AND SB.End_Date Between @iStart_Date AND @iEnd_Date
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetStockpileActivityStateChanges TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileActivityStateChanges">
 <Procedure>
	Returns a list of stockpile build state changes for a given stockpile over a specified period
 </Procedure>
</TAG>
*/	



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBalances.prc'
GO

If object_id('dbo.GetStockpileBalances') is not Null 
     Drop Procedure dbo.GetStockpileBalances 
Go 
  
Create Procedure dbo.GetStockpileBalances 
( 
    @iStockpile_Id Int = Null,
	@iBuild_Id Int = Null,
	@iStart_Date Datetime = Null,
	@iStart_Shift Char(1) = Null,
	@iEnd_Date Datetime = Null,
	@iEnd_Shift Char(1) = Null,
	@iIs_Visible Bit = 1
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Create Table #Stockpile
	(	
		Stockpile_Id Int,
		Build_Id Int,
		Opening_Balance Float,
		Tonnes_Added Float,
		Tonnes_Removed Float,
		Balance Float
	)

	Declare @OpenBalDate DateTime,
		@OpenBalShift Char(1),	
		@StartShiftOrder Int,
		@EndShiftOrder Int,
		@OpenBalShiftOrder Int

	If @iStart_Date Is Null 
	Begin
		Select @iStart_Date = dbo.GetSystemStartDate()
	End

	If @iStart_Shift Is Null
	Begin
		Select @iStart_Shift = dbo.GetFirstShiftType()
	End

    If @iEnd_Date Is Null
	Begin
		Set @iEnd_Date = getdate()
	End
  
	If @iEnd_Shift Is Null
	Begin
		Select @iEnd_Shift = dbo.GetLastShiftType()
	End

	--Work out Open Balance date
	Select @OpenBalDate = @iStart_Date, 
		@OpenBalShift = @iStart_Shift

	Exec dbo.GetPreviousDateShift 
		@Date = @OpenBalDate,
		@Shift = @OpenBalShift,
		@Previous_Date = @OpenBalDate Output,
		@Previous_Shift = @OpenBalShift Output

	Select @StartShiftOrder = dbo.GetShiftTypeOrderNo(@iStart_Shift),
		@EndShiftOrder = dbo.GetShiftTypeOrderNo(@iEnd_Shift),
		@OpenBalShiftOrder = dbo.GetShiftTypeOrderNo(@OpenBalShift)
	
	--Get all the builds
	Insert Into #Stockpile 
	(
		Stockpile_Id, Build_Id, Opening_Balance, Balance, Tonnes_Added, Tonnes_Removed
	)
	Select SB.Stockpile_Id, SB.Build_Id, 0, 0, 0, 0
	From dbo.Stockpile As S
		Inner Join dbo.StockpileBuild As SB
			On (S.Stockpile_Id = SB.Stockpile_Id)		
		Inner Join dbo.ShiftType As SST
			On (SST.Shift = SB.Start_Shift)
		Left Outer Join dbo.ShiftType As EST
			On (EST.Shift = SB.End_Shift)
	Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
		And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
		And SB.Start_Date <= @iEnd_Date
		And dbo.GetDateShiftAsInt(SB.Start_Date, SST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
		And ((SB.End_Date >= @iStart_Date
				And dbo.GetDateShiftAsInt(SB.End_Date, EST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder))
			Or SB.End_Date Is Null)
		And S.Is_Visible = @iIs_Visible

	--Get the Balance
	Update S
	Set Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id)	
					Left Outer Join dbo.ShiftType As BST
						On (BST.Shift = SB.End_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And (SB.End_Date Is Null 
						Or (SB.End_Date >= @iEnd_Date --Optimise Indexes
							And dbo.GetDateShiftAsInt(SB.End_Date, BST.Order_No) >= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)))
					And B.Data_Process_Stockpile_Balance_Date = @iEnd_Date
					And B.Data_Process_Stockpile_Balance_Shift = @iEnd_Shift
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	Update S
	Set Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id
							And B.Data_Process_Stockpile_Balance_Date = SB.Last_Recalc_Date
							And B.Data_Process_Stockpile_Balance_Shift = SB.Last_Recalc_Shift)	
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.End_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.End_Date <= @iEnd_Date --Index Optimisation	
					And dbo.GetDateShiftAsInt(SB.End_Date, BST.Order_No) < dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)


	--Work out opening Balance
	Update S
	Set Opening_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id)	
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.Start_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.Start_Date <= @OpenBalDate
					And dbo.GetDateShiftAsInt(SB.Start_Date, BST.Order_No) <= dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
					And B.Data_Process_Stockpile_Balance_Date = @OpenBalDate
					And B.Data_Process_Stockpile_Balance_Shift = @OpenBalShift
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	--If a build started during the period - use the start tonnes
	Update S
	Set Opening_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(SBC.Start_Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.StockpileBuildComponent As SBC
						On (SB.Stockpile_Id = SBC.Stockpile_Id
							And SB.Build_Id = SBC.Build_Id)
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.Start_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.Start_Date >= @OpenBalDate
					And dbo.GetDateShiftAsInt(SB.Start_Date, BST.Order_No) > dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	--Work out Raw ons and Offs
	Update S
	Set Tonnes_Added = IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Destination_Stockpile_Id = S2.Stockpile_Id
							And T.Destination_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	--Remove The Offs
	Update S
	Set Tonnes_Removed = IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Source_Stockpile_Id = S2.Stockpile_Id
							And T.Source_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)
	

	Select S.*, SS.Stockpile_Name
	From #Stockpile As S
		Inner Join dbo.Stockpile As SS
			On S.Stockpile_Id = SS.Stockpile_Id

    Commit Transaction 

	drop table #Stockpile
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileBalances TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetStockpileBalances">
 <Procedure>
	Returns the list of stockpile balances for active stockpiles within the period given. 
	The balance returned is the last possible balance for that stockpile during that period,
	so if the stockpile closed 5 days into the period then the balance as at its closed date
	is returned. If a stockpile and/or build is specified this list is limited to that
	stockpile or build. Includes the previous balance for the shift before the date entered and
	the adds and removes to the stockpile.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBalanceReport.prc'
GO

If Object_Id('dbo.GetStockpileBalanceReport') is not Null 
     Drop Procedure dbo.GetStockpileBalanceReport 
Go 
  
Create Procedure dbo.GetStockpileBalanceReport
( 
    @iStockpile_Id Int = Null,
	@iBuild_Id Int = Null,
	@iStart_Date Datetime = Null,
	@iStart_Shift Char(1) = Null,
	@iEnd_Date Datetime = Null,
	@iEnd_Shift Char(1) = Null,
	@iIs_Visible Bit = 1,
	@iSortType VarChar(31) = ''
) 
With Encryption 
As
Begin 
    Set NoCount On 
   
	Create Table #Stockpile
	(	
		Stockpile_Id Int,
		Build_Id Int,
		Material_Type VarChar(63),
		Stockpile_Group VarChar(255),
		Opening_Balance Float,
		Tonnes_Added Float,
		Tonnes_Removed Float,
		Tonnes_Adjusted Float,
		Closing_Balance Float
	)

	Declare @OpenBalDate DateTime
	Declare	@OpenBalShift Char(1)
	Declare	@StartShiftOrder Int
	Declare	@EndShiftOrder Int
	Declare	@OpenBalShiftOrder Int

	If @iStart_Date Is Null 
	Begin
		Select @iStart_Date = dbo.GetSystemStartDate()
	End

	If @iStart_Shift Is Null
	Begin
		Select @iStart_Shift = dbo.GetFirstShiftType()
	End

    If @iEnd_Date Is Null
	Begin
		Set @iEnd_Date = getdate()
	End
  
	If @iEnd_Shift Is Null
	Begin
		Select @iEnd_Shift = dbo.GetLastShiftType()
	End

	--Work out Open Balance date
	Select @OpenBalDate = @iStart_Date, 
		@OpenBalShift = @iStart_Shift

	Exec dbo.GetPreviousDateShift 
		@Date = @OpenBalDate,
		@Shift = @OpenBalShift,
		@Previous_Date = @OpenBalDate Output,
		@Previous_Shift = @OpenBalShift Output

	Select @StartShiftOrder = dbo.GetShiftTypeOrderNo(@iStart_Shift),
		@EndShiftOrder = dbo.GetShiftTypeOrderNo(@iEnd_Shift),
		@OpenBalShiftOrder = dbo.GetShiftTypeOrderNo(@OpenBalShift)
	
	--Get all the builds
	Insert Into #Stockpile 
	(
		Stockpile_Id, Build_Id, Material_Type, Stockpile_Group, Opening_Balance, Closing_Balance, Tonnes_Added, Tonnes_Removed, Tonnes_Adjusted
	)
	Select SB.Stockpile_Id, SB.Build_Id, M.Description, SG.Description, 0, 0, 0, 0, 0
	From dbo.Stockpile As S
		Inner Join dbo.MaterialType as M
			On S.Material_Type_Id = M.Material_Type_Id
		Inner Join dbo.StockpileBuild As SB
			On (S.Stockpile_Id = SB.Stockpile_Id)		
		Inner Join dbo.ShiftType As SST
			On (SST.Shift = SB.Start_Shift)
		Left Outer Join dbo.ShiftType As EST
			On (EST.Shift = SB.End_Shift)
		Left Join StockpileGroupStockpile SGS
			On SGS.Stockpile_Id = S.Stockpile_Id
		Left Join StockpileGroup SG
			On SGS.Stockpile_Group_Id = SG.Stockpile_Group_Id  
	Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
		And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
		And SB.Start_Date <= @iEnd_Date
		And dbo.GetDateShiftAsInt(SB.Start_Date, SST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
		And ((SB.End_Date >= @iStart_Date
				And dbo.GetDateShiftAsInt(SB.End_Date, EST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder))
			Or SB.End_Date Is Null)
		And S.Is_Visible = @iIs_Visible

	--Get the Closing Balance for open stockpiles
	Update S
	Set Closing_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id)	
					Left Outer Join dbo.ShiftType As BST
						On (BST.Shift = SB.End_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And (SB.End_Date Is Null 
						Or (SB.End_Date >= @iEnd_Date --Optimise Indexes
							And dbo.GetDateShiftAsInt(SB.End_Date, BST.Order_No) >= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)))
					And B.Data_Process_Stockpile_Balance_Date = @iEnd_Date
					And B.Data_Process_Stockpile_Balance_Shift = @iEnd_Shift
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	--Get the Closing Balance for closed stockpiles
	Update S
	Set Closing_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id
							And B.Data_Process_Stockpile_Balance_Date = SB.Last_Recalc_Date
							And B.Data_Process_Stockpile_Balance_Shift = SB.Last_Recalc_Shift)	
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.End_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.End_Date <= @iEnd_Date --Index Optimisation	
					And dbo.GetDateShiftAsInt(SB.End_Date, BST.Order_No) < dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)


	--Work out opening Balance
	Update S
	Set Opening_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(B.Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.DataProcessStockpileBalance As B
						On (B.Stockpile_Id = SB.Stockpile_Id
							And B.Build_Id = SB.Build_Id)	
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.Start_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.Start_Date <= @OpenBalDate
					And dbo.GetDateShiftAsInt(SB.Start_Date, BST.Order_No) <= dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
					And B.Data_Process_Stockpile_Balance_Date = @OpenBalDate
					And B.Data_Process_Stockpile_Balance_Shift = @OpenBalShift
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	--If a build started during the period - use the start tonnes
	Update S
	Set Opening_Balance = AGG.Tonnes
	From #Stockpile As S
		Inner Join 
			(
				Select SB.Stockpile_Id, SB.Build_Id, Sum(SBC.Start_Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.StockpileBuild As SB
						On (S2.Stockpile_Id = SB.Stockpile_Id
							And S2.Build_Id = SB.Build_Id)
					Inner Join dbo.StockpileBuildComponent As SBC
						On (SB.Stockpile_Id = SBC.Stockpile_Id
							And SB.Build_Id = SBC.Build_Id)
					Inner Join dbo.ShiftType As BST
						On (BST.Shift = SB.Start_Shift)
				Where SB.Stockpile_Id = IsNull(@iStockpile_Id, SB.Stockpile_Id)
					And SB.Build_Id = IsNull(@iBuild_Id, SB.Build_Id)
					And SB.Start_Date >= @OpenBalDate
					And dbo.GetDateShiftAsInt(SB.Start_Date, BST.Order_No) > dbo.GetDateShiftAsInt(@OpenBalDate, @OpenBalShiftOrder)
				Group By SB.Stockpile_Id, SB.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id
				And S.Build_Id = AGG.Build_Id)

	--Work out Raw ons and Offs
	Update S
	Set Tonnes_Added = IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Destination_Stockpile_Id = S2.Stockpile_Id
							And T.Destination_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
					And T.Stockpile_Adjustment_Id Is Null
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	--Remove The Offs
	Update S
	Set Tonnes_Removed = IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Source_Stockpile_Id = S2.Stockpile_Id
							And T.Source_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
					And T.Stockpile_Adjustment_Id Is Null
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	-- Adjustments added
	Update S
	Set Tonnes_Adjusted = IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Destination_Stockpile_Id = S2.Stockpile_Id
							And T.Destination_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
					And T.Stockpile_Adjustment_Id Is Not Null
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	--Removed Adjustments
	Update S
	Set Tonnes_Adjusted = Tonnes_Adjusted - IsNull(AGG.Tonnes, 0)
	From #Stockpile As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From #Stockpile As S2
					Inner Join dbo.DataProcessTransaction As T
						On (T.Source_Stockpile_Id = S2.Stockpile_Id
							And T.Source_Build_Id = S2.Build_Id)
					Inner Join dbo.ShiftType AS TST
						On (TST.Shift = T.Data_Process_Transaction_Shift)
				Where T.Data_Process_Transaction_Date between @iStart_Date and @iEnd_Date
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) >= dbo.GetDateShiftAsInt(@iStart_Date, @StartShiftOrder)
					And dbo.GetDateShiftAsInt(T.Data_Process_Transaction_Date, TST.Order_No) <= dbo.GetDateShiftAsInt(@iEnd_Date, @EndShiftOrder)
					And T.Stockpile_Adjustment_Id Is Not Null
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)
	

	If @iSortType = 'Material Type'
	Begin
		Select S.*, SS.Stockpile_Name
		From #Stockpile As S
			Inner Join dbo.Stockpile As SS
				On S.Stockpile_Id = SS.Stockpile_Id
		Order by S.Material_Type
	End
	Else
	Begin
		Select S.*, SS.Stockpile_Name
		From #Stockpile As S
			Inner Join dbo.Stockpile As SS
				On S.Stockpile_Id = SS.Stockpile_Id
		Order By S.Stockpile_Group
	End

	Drop table #Stockpile

End 
Go 
GRANT EXECUTE ON dbo.GetStockpileBalanceReport TO CoreReporting


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileSurveyList.prc'
GO

If object_id('dbo.GetStockpileSurveyList') Is Not Null 
     Drop Procedure dbo.GetStockpileSurveyList 
Go 
  
Create Procedure dbo.GetStockpileSurveyList
( 
	@iStockpile_Survey_Date DateTime = Null,
	@iStockpile_Survey_Shift Char(1) = Null,
	@iStockpile_Survey_Type_Id Int = Null,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @LastShift Char(1)
	Declare @FirstShift Char(1)
	
	Declare @SURVEY table
	(
		Stockpile_Survey_Type_Id Int,
		Stockpile_Survey_Type_Name Varchar(63) Collate Database_Default, 
		Start_Date DateTime,
		Start_Shift Char(1) Collate Database_Default,
		End_Date DateTime,
		End_Shift Char(1) Collate Database_Default,
		End_Shift_Order_No Int,
		Is_Approved Bit,
		Adjust_Haulage Bit
	)  

	--Set First and Last Shift vars to avoid SQL server constantly searching for it
	Select @FirstShift = dbo.GetFirstShiftType(),
		@LastShift = dbo.GetLastShiftType()

	--Get Initial Survey Information
	Insert @SURVEY
	(
		Stockpile_Survey_Type_Id, Stockpile_Survey_Type_Name, Is_Approved, Adjust_Haulage,
		End_Date, End_Shift, End_Shift_Order_No
	)
	Select S.Stockpile_Survey_Type_Id, SST.Name, S.Is_Approved, S.Adjust_Haulage,
		S.Stockpile_Survey_Date, S.Stockpile_Survey_Shift, ST.Order_No
	From dbo.StockpileSurvey As S
		Inner Join dbo.StockpileSurveyType As SST
			On (SST.Stockpile_Survey_Type_Id = S.Stockpile_Survey_Type_Id)
		Inner Join dbo.ShiftType As ST
			On (ST.Shift = S.Stockpile_Survey_Shift)
	Where S.Stockpile_Survey_Type_Id = IsNull(@iStockpile_Survey_Type_Id, S.Stockpile_Survey_Type_Id)
		And S.Stockpile_Survey_Date = IsNull(@iStockpile_Survey_Date, S.Stockpile_Survey_Date)
		And S.Stockpile_Survey_Shift = IsNull(@iStockpile_Survey_Shift, S.Stockpile_Survey_Shift)
		And (S.Stockpile_Survey_Date >= IsNull(@iStart_Date, Stockpile_Survey_Date) 
			And S.Stockpile_Survey_Date <= IsNull(@iEnd_Date, Stockpile_Survey_Date))

	--Get the corresponding start dates based on the end date of the previous survey
	Update S
	Set Start_Date =
			(
				Select Top 1 S2.Stockpile_Survey_Date
				From dbo.StockpileSurvey As S2
					Inner Join dbo.ShiftType As ST2
						On (ST2.Shift = S2.Stockpile_Survey_Shift)
				Where S.Stockpile_Survey_Type_Id = S2.Stockpile_Survey_Type_Id 
					And ((S.End_Date > S2.Stockpile_Survey_Date)
						Or (S.End_Date = S2.Stockpile_Survey_Date 
							And S.End_Shift_Order_No > ST2.Order_No))
				Order By S2.Stockpile_Survey_Date Desc, ST2.Order_No Desc
			),
		Start_Shift = 
			(
				Select Top 1 S2.Stockpile_Survey_Shift
				From dbo.StockpileSurvey As S2
					Inner Join dbo.ShiftType As ST2
						On (ST2.Shift = S2.Stockpile_Survey_Shift)
				Where S.Stockpile_Survey_Type_Id = S2.Stockpile_Survey_Type_Id 
					And ((S.End_Date > S2.Stockpile_Survey_Date)
						Or (S.End_Date = S2.Stockpile_Survey_Date 
							And S.End_Shift_Order_No > ST2.Order_No))
				Order By S2.Stockpile_Survey_Date Desc, ST2.Order_No Desc
			)
	From @SURVEY As S

	--Since all start dates are really the shift after the end date of the previous
	--survey increment the shifts by one for all records
	Update S
	Set Start_Date =
			Case When Start_Shift = @LastShift Then
				DateAdd(d, 1, Start_Date)
			Else
				Start_Date
			End,
		Start_Shift =
			Case When Start_Shift = @LastShift Then
				@FirstShift
			Else
				dbo.GetNextShiftType(Start_Shift)
			End
	From @SURVEY As S
		
	--Get the system start date and populate it in the first survey entry
	Update S
	Set Start_Date = dbo.GetSystemStartDate(),	
		Start_Shift = @FirstShift
	From @SURVEY As S
	Where S.Start_Date Is Null

	--Return Data
	Select *
	From @SURVEY
	Order By End_Date Desc, End_Shift_Order_No Desc, Stockpile_Survey_Type_Id Desc

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileSurveyList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileSurveyList">
 <Procedure>
	Returns a list of stockpile surveys returning all period information. 
	If a Stockpile Survey date (basically the End date of the period) is passed
	with or without a shift it will limit the return set. A Stockpile Survey Type
	ID can also be passed to limit the return set.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetSurveyVsHaulageReport.prc'
GO

If Object_Id('dbo.GetSurveyVsHaulageReport') Is Not Null
	Drop Procedure dbo.GetSurveyVsHaulageReport
Go

Create Procedure dbo.GetSurveyVsHaulageReport
(
	@iYear Datetime
)
With Encryption 
As

-------------------------------------------------------------------------------
--  Procedure: dbo.GetMonthlyMaterialMovementReport
--	Created: 23-Oct-2007
--	Dev: JBC
--  For Core Standard reports
--------------------------------------------------------------------------------
Begin
	Set NoCount On

	Create Table #HAULAGE_RESULT 
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int, 
		Volume Float
		Primary Key Clustered (Month_No)
	)
	
	Create Table #SURVEY_RESULT
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int, 
		Volume Float
		Primary Key Clustered (Month_No)
	)
	
	Create Table #TRUCK_COUNT
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int, 
		Truck_Count Float
		Primary Key Clustered (Month_No)
	)

	Create Table  #DATE_LIST
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		This_Date Datetime,
		Month_No Int
		Primary Key Clustered (Month_No)
	)
	
	Create Table #RESULTS
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int,
		Heading_Id VarChar(31),
		[Value] Float
	)

	Create Table #FINAL_RESULTS
	(
		Heading_Id Varchar(31)
	)

	Declare @Haulage_Date_From Datetime
	Declare @Haulage_Date_To Datetime

	Set @Haulage_Date_From = Convert(Datetime, '01-Jan-' + DateName(Year, @iYear))
	Set @Haulage_Date_To = DateAdd(Day, -1, DateAdd(Year, 1, @Haulage_Date_From))

	Insert Into #DATE_LIST
	(
		Report_Month, This_Date, Month_No
	)
	Select Left(Convert(Varchar, Cast(This_Date As Datetime), 107), 3), 
		This_Date, 
		Month(dbo.GetDateMonth(This_Date)) As This_Date
	From dbo.GetDateList(@Haulage_Date_From, @Haulage_Date_To, 'Month', 1)
	Group By This_Date
	
	Insert Into #HAULAGE_RESULT 
	(
		Report_Month, Month_No, Volume
	)
	Select DL.Report_Month,
		DL.Month_No, 
		Sum(Tonnes)
	From #DATE_LIST DL
		Left Join (Haulage H
			Inner Join Digblock D
				On D.Digblock_Id = H.Source_Digblock_Id
			Inner Join MaterialType MT
				On MT.Material_Type_Id = D.Material_Type_Id)
			On Month(H.Haulage_Date) = Month(DL.This_Date)
	Where Year(H.Haulage_Date) = Year(@iYear)
		And MT.Is_Waste = 0
	Group by DL.Report_Month, DL.Month_No
	Order By DL.Month_No


	Insert Into #TRUCK_COUNT 
	(
		Report_Month, Month_No, Truck_Count
	)
	Select DL.Report_Month,
		DL.Month_No, 
		Sum(H.Loads)
	From #DATE_LIST DL
		Left Join (Haulage H
			Inner Join Truck T
				On T.Truck_Id = H.Truck_Id
			Inner Join Digblock D
				On D.Digblock_Id = H.Source_Digblock_Id
			Inner Join MaterialType MT
				On MT.Material_Type_Id = D.Material_Type_Id)
			On Month(H.Haulage_Date) = Month(DL.This_Date)
	Where Year(H.Haulage_Date) = Year(@iYear)
		And MT.Is_Waste = 0
	Group by DL.Report_Month, DL.Month_No


	Insert Into #SURVEY_RESULT 
	(
		Report_Month, Month_No, Volume
	)
	Select DL.Report_Month,
		DL.Month_No, 
		Sum(DSS.Depleted_Tonnes)
	From #DATE_LIST DL
		Left Join DigblockSurvey DS
			On Month(DS.Digblock_Survey_Date) = Month(DL.This_Date)
		Left Join DigblockSurveySample DSS
			On DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id
	Where Year(DS.Digblock_Survey_Date) = Year(@iYear)
	Group by DL.Report_Month, DL.Month_No

	Insert Into #RESULTS	
	Select DL.Report_Month, DL.Month_No As Month_No, 
		'Haulage Tonnes', Coalesce(H.Volume, 0) As Value
	From  #DATE_LIST DL
		Left Join #HAULAGE_RESULT H
			on H.Month_No = DL.Month_No
	Union All
	Select DL.Report_Month, DL.Month_No As Month_No, 
		'Survey Tonnes',Coalesce(S.Volume, 0)
	From  #DATE_LIST DL
		Left Join #SURVEY_RESULT S
			on S.Month_No = DL.Month_No
	Union All
	Select DL.Report_Month, DL.Month_No As Month_No, 
		'Truck Count', Coalesce(T.Truck_Count, 0)
	From  #DATE_LIST DL
		Left Join #TRUCK_COUNT T
			on T.Month_No = DL.Month_No
	Union All
	Select 'Y-T-D', 13 As Month_No, 
		'Haulage Tonnes', Sum(Coalesce(H.Volume, 0)) 
	From  #DATE_LIST DL
		Left Join #HAULAGE_RESULT H
			on H.Month_No = DL.Month_No
	Union All
	Select 'Y-T-D', 13 As Month_No, 
		'Survey Tonnes', Sum(Coalesce(S.Volume, 0))
	From  #DATE_LIST DL
		Left Join #SURVEY_RESULT S
			on S.Month_No = DL.Month_No
	Union All
	Select 'Y-T-D', 13 As Month_No, 
		'Truck Count', Sum(Coalesce(T.Truck_Count, 0))
	From  #DATE_LIST DL
		Left Join #TRUCK_COUNT T
			on T.Month_No = DL.Month_No

	--Calculate the variance
	Insert Into #RESULTS	
	Select R1.Report_Month, R1.Month_No,
		'Variance Survey/Haulage (%)',
		Case When R2.Value <> 0 Then
			Coalesce(1 - (R1.Value / R2.Value),0)
		Else
			0
		End as Value
	From  #RESULTS R1
		Left Join #RESULTS R2
			On R1.Month_No = R2.Month_No
	Where R1.Heading_Id = 'Survey Tonnes'
		And R2.Heading_Id = 'Haulage Tonnes'


	Insert into #FINAL_RESULTS
	(
		Heading_Id 
	)
	Select 'Haulage Tonnes'
	Union 
	Select 'Survey Tonnes'
	Union
	Select 'Variance Survey/Haulage (%)'
	Union
	Select 'Truck Count'

	Exec dbo.PivotTable
		@iTargetTable='#FINAL_RESULTS',
		@iPivotTable='#RESULTS',
		@iJoinColumns='#FINAL_RESULTS.Heading_Id = #RESULTS.Heading_Id',
		@iPivotColumn='Report_Month',
		@iPivotValue='Value',
		@iPivotType='Float',
		@iPivotOrderColumn = 'Month_No',
		@iPivotOrderDirection = 'Asc'

	Select * From #FINAL_RESULTS

	--Clean UP
	Drop Table #HAULAGE_RESULT
	Drop Table #SURVEY_RESULT
	Drop Table #DATE_LIST
	Drop Table #TRUCK_COUNT
	Drop Table #RESULTS
	Drop Table #FINAL_RESULTS
End
GO
GRANT EXECUTE ON dbo.GetSurveyVsHaulageReport TO CoreReporting


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetSurveyVsHaulageReportGraph.prc'
GO

If Object_Id('dbo.GetSurveyVsHaulageReportGraph') Is Not Null
	Drop Procedure dbo.GetSurveyVsHaulageReportGraph
Go


Create Procedure dbo.GetSurveyVsHaulageReportGraph
(
	@iYear Datetime
)
With Encryption 
As

-------------------------------------------------------------------------------
--  Procedure: dbo.Get_Ore_Truck_Factor_Report_Graph
--	Created: 23-Oct-2007
--	Dev: JBC
--  For Core Standard reports
--------------------------------------------------------------------------------
Begin
	Set NoCount On

	Create Table #HAULAGE_RESULT 
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int, 
		Volume Float
		Primary Key Clustered (Month_No)
	)
	
	Create Table #SURVEY_RESULT
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int, 
		Volume Float
		Primary Key Clustered (Month_No)
	)
	
	Create Table  #DATE_LIST
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		This_Date Datetime,
		Month_No Int
		Primary Key Clustered (Month_No)
	)
	
	Create Table #RESULTS
	(
		Report_Month Varchar(7) COLLATE DATABASE_DEFAULT NOT NULL,
		Month_No Int,
		Heading_Id VarChar(31),
		[Value] Float
	)

	Create Table #FINAL_RESULTS
	(
		Heading_Id Varchar(31)
	)

	Declare @Haulage_Date_From Datetime
	Declare @Haulage_Date_To Datetime

	Set @Haulage_Date_From = Convert(Datetime, '01-Jan-' + DateName(Year, @iYear))
	Set @Haulage_Date_To = DateAdd(Day, -1, DateAdd(Year, 1, @Haulage_Date_From))

	Insert Into #DATE_LIST
	(
		Report_Month, This_Date, Month_No
	)
	Select Left(Convert(Varchar, Cast(This_Date As Datetime), 107), 3), 
		This_Date, 
		Month(dbo.GetDateMonth(This_Date)) As This_Date
	From dbo.GetDateList(@Haulage_Date_From, @Haulage_Date_To, 'Month', 1)
	Group By This_Date
	
	Insert Into #HAULAGE_RESULT 
	(
		Report_Month, Month_No, Volume
	)
	Select DL.Report_Month,
		DL.Month_No, 
		Sum(Tonnes)
	From #DATE_LIST DL
		Left Join (Haulage H
			Inner Join Digblock D
				On D.Digblock_Id = H.Source_Digblock_Id
			Inner Join MaterialType MT
				On MT.Material_Type_Id = D.Material_Type_Id)
			On Month(H.Haulage_Date) = Month(DL.This_Date)
	Where Year(H.Haulage_Date) = Year(@iYear)
		And MT.Is_Waste = 0
	Group by DL.Report_Month, DL.Month_No
	Order By DL.Month_No


	Insert Into #SURVEY_RESULT 
	(
		Report_Month, Month_No, Volume
	)
	Select DL.Report_Month,
		DL.Month_No, 
		Sum(DSS.Depleted_Tonnes)
	From #DATE_LIST DL
		Left Join DigblockSurvey DS
			On Month(DS.Digblock_Survey_Date) = Month(DL.This_Date)
		Left Join DigblockSurveySample DSS
			On DSS.Digblock_Survey_Id = DS.Digblock_Survey_Id
	Where Year(DS.Digblock_Survey_Date) = Year(@iYear)
	Group by DL.Report_Month, DL.Month_No

	Insert Into #RESULTS	
	Select DL.Report_Month, DL.Month_No As Month_No, 
		'Haulage Tonnes', Coalesce(H.Volume, 0) As Value
	From  #DATE_LIST DL
		Left Join #HAULAGE_RESULT H
			on H.Month_No = DL.Month_No
	Union All
	Select DL.Report_Month, DL.Month_No As Month_No, 
		'Survey Tonnes',Coalesce(S.Volume, 0)
	From  #DATE_LIST DL
		Left Join #SURVEY_RESULT S
			on S.Month_No = DL.Month_No

	Select * from #RESULTS

	--Clean UP
	Drop Table #HAULAGE_RESULT
	Drop Table #SURVEY_RESULT
	Drop Table #DATE_LIST
	Drop Table #RESULTS

End
GO
GRANT EXECUTE ON dbo.GetSurveyVsHaulageReportGraph TO CoreReporting


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ValidateMinePlanPeriod.prc'
GO

If object_id('dbo.ValidateMinePlanPeriod') is not Null 
     Drop Procedure dbo.ValidateMinePlanPeriod 
Go 
  
Create Procedure dbo.ValidateMinePlanPeriod 
( 
    @iMine_Plan_Period_Id Int,
	@iShow_Problems Bit = 0 --Support helper bit
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @CONFLICTS table
	(
		Mine_Plan_Period_Id Int,
		Number_Locations Int,
		Matching_Plan_Period_Id Int,
		Matching_Number_Locations Int
	)

    Begin Try

		--Check details are unique if we arent using locations
		Insert Into @CONFLICTS
		(
			Mine_Plan_Period_Id, Number_Locations, 
			Matching_Plan_Period_Id, Matching_Number_Locations
		)
		Select MPP.Mine_Plan_Period_Id, Count(MPPL.Mine_Plan_Period_Id),
			MPP2.Mine_Plan_Period_Id, Count(MPPL2.Mine_Plan_Period_Id)
		From dbo.MinePlanPeriod As MPP
			Inner Join dbo.MinePlanPeriod As MPP2
				On (MPP.Mine_Plan_Id = MPP2.Mine_Plan_Id
					And MPP.Start_Date = MPP2.Start_Date
					And MPP.Material_Type_Id = MPP2.Material_Type_Id
					And MPP.Mine_Plan_Period_Type_Id = MPP2.Mine_Plan_Period_Type_Id)
			Left Outer Join dbo.MinePlanPeriodLocation As MPPL
				On (MPP.Mine_Plan_Period_Id = MPPL.Mine_Plan_Period_Id)
			Left Outer Join dbo.MinePlanPeriodLocation As MPPL2
				On (MPP2.Mine_Plan_Period_Id = MPPL2.Mine_Plan_Period_Id)
		Where MPP.Mine_Plan_Period_Id <> MPP2.Mine_Plan_Period_Id
			And MPP.Mine_Plan_Period_Id = @iMine_Plan_Period_Id
		Group By MPP.Mine_Plan_Period_Id, MPP2.Mine_Plan_Period_Id
		Having Count(MPPL.Mine_Plan_Period_Id) = 0 
			And Count(MPPL2.Mine_Plan_Period_Id) = 0

		If Exists
			(
				Select 1
				From @CONFLICTS
			)
		Begin
			RaisError('Multiple periods with the same details have been found.', 16, 1)
		End

		--Check that the new number of locations is consistant with the rest of the plan and period type
		Insert Into @CONFLICTS
		(
			Mine_Plan_Period_Id, Number_Locations, 
			Matching_Plan_Period_Id, Matching_Number_Locations
		)
		Select MPP.Mine_Plan_Period_Id, Count(MPPL.Mine_Plan_Period_Id),
			MPP2.Mine_Plan_Period_Id, Count(MPPL2.Mine_Plan_Period_Id)
		From dbo.MinePlanPeriod As MPP
			Inner Join dbo.MinePlanPeriod As MPP2
				On (MPP.Mine_Plan_Id = MPP2.Mine_Plan_Id
					And MPP.Material_Type_Id = MPP2.Material_Type_Id
					And MPP.Mine_Plan_Period_Type_Id = MPP2.Mine_Plan_Period_Type_Id)
			Left Outer Join dbo.MinePlanPeriodLocation As MPPL
				On (MPP.Mine_Plan_Period_Id = MPPL.Mine_Plan_Period_Id)
			Left Outer Join dbo.MinePlanPeriodLocation As MPPL2
				On (MPP2.Mine_Plan_Period_Id = MPPL2.Mine_Plan_Period_Id)
		Where MPP.Mine_Plan_Period_Id <> MPP2.Mine_Plan_Period_Id
			And MPP.Mine_Plan_Period_Id = @iMine_Plan_Period_Id
		Group By MPP.Mine_Plan_Period_Id, MPP2.Mine_Plan_Period_Id
		Having Count(MPPL.Mine_Plan_Period_Id) <> Count(MPPL2.Mine_Plan_Period_Id) --Our location counts dont match so somethings pear

		If Exists
			(
				Select 1
				From @CONFLICTS
			)
		Begin
			RaisError('This period has more/less locations assigned to it than it should have to be consistant with other periods.', 16, 1)
		End
		
		--Check the period's locations are unique
		Insert Into @CONFLICTS
		(
			Mine_Plan_Period_Id, Number_Locations, 
			Matching_Plan_Period_Id, Matching_Number_Locations
		)
		Select MPP.Mine_Plan_Period_Id, Count(MPPL.Mine_Plan_Period_Id),
			MPP2.Mine_Plan_Period_Id, Count(MPPL2.Mine_Plan_Period_Id)
		From dbo.MinePlanPeriod As MPP
			Inner Join dbo.MinePlanPeriod As MPP2
				On (MPP.Mine_Plan_Id = MPP2.Mine_Plan_Id
					And MPP.Start_Date = MPP2.Start_Date
					And MPP.Material_Type_Id = MPP2.Material_Type_Id
					And MPP.Mine_Plan_Period_Type_Id = MPP2.Mine_Plan_Period_Type_Id)
			Inner Join dbo.MinePlanPeriodLocation As MPPL
				On (MPP.Mine_Plan_Period_Id = MPPL.Mine_Plan_Period_Id)
			Left Outer Join dbo.MinePlanPeriodLocation As MPPL2
				On (MPP2.Mine_Plan_Period_Id = MPPL2.Mine_Plan_Period_Id
					And MPPL.Location_Id = MPPL2.Location_Id)
		Where MPP.Mine_Plan_Period_Id <> MPP2.Mine_Plan_Period_Id
			And MPP.Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			And MPP2.Mine_Plan_Period_Id Is Not Null
		Group By MPP.Mine_Plan_Period_Id, MPP2.Mine_Plan_Period_Id
		Having Count(MPPL.Mine_Plan_Period_Id) = Count(MPPL2.Mine_Plan_Period_Id)

		If Exists
			(
				Select 1
				From @CONFLICTS
			)
		Begin
			RaisError('Multiple periods with the same details and the same locations have been found.', 16, 1)
		End		

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		If @iShow_Problems = 1
		Begin
			Select *
			From @CONFLICTS
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	 
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="ValidateMinePlanPeriod">
 <Procedure>
	Validates that a Mine plan period record is unique by comparing the
	mine plan, material type, period start date, period type and the locations
	attached to the period. Will return an error if invalid. 
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileSurveyTypeList.prc'
GO

If object_id('dbo.GetStockpileSurveyTypeList') is not Null 
     Drop Procedure dbo.GetStockpileSurveyTypeList 
Go 
  
Create Procedure dbo.GetStockpileSurveyTypeList
With Encryption As 
Begin 
    Set NoCount On 
  
    Select Stockpile_Survey_Type_Id, Name, Description, Is_Auto_Adjusting
	From StockpileSurveyType
	Where Is_Manually_Entered = 1
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileSurveyTypeList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileSurveyTypeList">
 <Procedure>
	Returns a list of Stockpile survey types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMonthlyApprovalMonth.prc'
GO

If object_id('dbo.GetMonthlyApprovalMonth') is not Null 
     Drop Procedure dbo.GetMonthlyApprovalMonth 
Go 
  
Create Procedure dbo.GetMonthlyApprovalMonth 
( 
	@oLast_Approved_Month Datetime = Null output,
	@oApproval_Month Datetime = Null output,	
	@oFirst_Month Datetime = Null output
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  	
	-- Get the month where the first transaction occured
	Select @oFirst_Month = Min(Data_Transaction_Tonnes_Date)
	From DataTransactionTonnes

	Set @oFirst_Month = DateAdd(day, -1 * (DatePart(day, @oFirst_Month) - 1), @oFirst_Month)

	-- Get the last approved month in the system
	Select @oLast_Approved_Month = Max(Monthly_Approval_Month)
	From MonthlyApproval
	Where Is_Approved = 1

	-- If a previously approved month was found
	If (@oLast_Approved_Month Is Not Null)
	Begin
		-- Return the month after that
		Set @oApproval_Month = DateAdd(month, 1, @oLast_Approved_Month)
	End
	Else
	Begin
		-- Otherwise return the month where the first transaction occured
		Select @oApproval_Month = @oFirst_Month
	End
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetMonthlyApprovalMonth TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetMonthlyApprovalMonth">
 <Procedure>
	Returns the next approval month (or if this is not found the month when the first transaction occurred
	in the @oApproval_Month output parameter.
	Returns the month when the first transaction occured in the @oFirst_Month output parameter.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ApproveMonth.prc'
GO

If object_id('dbo.ApproveMonth') is not Null 
     Drop Procedure dbo.ApproveMonth
Go 
  
Create Procedure dbo.ApproveMonth 
( 
    @iMonthly_Approval_Month Datetime 
) 
With Encryption As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Is_Approved Bit

	Begin Try
		If (Exists (Select Top 1 * From RecalcL1queue))
		   Or (Exists (Select Top 1 * From RecalcL2queue))
		Begin
			RaisError('Months cannot be approved until all pending Recalculations have been applied to the system.', 16, 1)
		End
		
		-- Make sure that the month given is set to the first of the month
		Set @iMonthly_Approval_Month = dbo.GetDateMonth(@iMonthly_Approval_Month)
		
		-- Get the number of unapproved months before this month
		If Exists 
			(
				Select 1
				From MonthlyApproval With (Serializable) --Full lock on table
				Where Monthly_Approval_Month < @iMonthly_Approval_Month
					And Is_Approved = 0
				Having Count(*) > 0
			)
		Begin
			Raiserror ('There are one or more unapproved months before this month', 16, 1)
		End

		-- Check to see if a record already exists for this month and whether is approved
		Set @Is_Approved = Null
	
		Select @Is_Approved = Is_Approved
		From MonthlyApproval With (Serializable)
		Where Monthly_Approval_Month = @iMonthly_Approval_Month

		-- If a record exists and it is not already approved
		If (@Is_Approved = 0)
		Begin
			-- Update this record to set it as approved
			Update MonthlyApproval
			Set Is_Approved = 1
			Where Monthly_Approval_Month = @iMonthly_Approval_Month
		End
		Else If (@Is_Approved Is Null)
		Begin
			-- If a record does not exist then insert a new record as approved
			Insert Into MonthlyApproval
			(
				Monthly_Approval_Month, Is_Approved
			)
			Select @iMonthly_Approval_Month, 1
		End
		Else
		Begin
			Raiserror ('The month is already approved', 16, 1)
		End
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.ApproveMonth TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="ApproveMonth">
 <Procedure>
	Adds or updates a record in the MonthlyApproval table.
	Sets the record to approved.
	Errors are raised if:
		There are one or more unapproved months before this month
		The month is already approved
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UnapproveMonth.prc'
GO

If object_id('dbo.UnapproveMonth') is not Null 
     Drop Procedure dbo.UnapproveMonth 
Go 
  
Create Procedure dbo.UnapproveMonth 
( 
    @iMonthly_Approval_Month Datetime 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Is_Approved Bit,
		@Unapproved_Start_Date DateTime,
		@Unapproved_End_Date DateTime,
		@Unapproved_End_Shift Char(1)

	Begin Try
		-- Make sure that the month given is set to the first of the month
		Set @iMonthly_Approval_Month = dbo.GetDateMonth(@iMonthly_Approval_Month)

		-- Check to see whether there is a record for this month and whether it is approved
		Select @Is_Approved = Is_Approved
		From MonthlyApproval With (Serializable)
		Where Monthly_Approval_Month = @iMonthly_Approval_Month

		If (IsNull(@Is_Approved, 0) <> 1)
		Begin
			Raiserror ('The month is not currently approved', 16, 1)
		End

		-- Unapprove it
		Update MonthlyApproval
		Set Is_Approved = 0
		Where Monthly_Approval_Month = @iMonthly_Approval_Month

		-- recalc queueing - L1
		Set @Unapproved_Start_Date = @iMonthly_Approval_Month
		Set @Unapproved_End_Date = DateAdd(Day, -1, DateAdd(Month, 1, @iMonthly_Approval_Month))
	
		Exec RecalcL1ReprocessWithheld 
			@pStart_Date = @Unapproved_Start_Date,
			@pEnd_Date = @Unapproved_End_Date
	
		-- recalc queueing - L2
		Set @Unapproved_End_Date = dbo.GetDateMonth(DateAdd(Month, 1, @iMonthly_Approval_Month))
		Set @Unapproved_End_Shift = dbo.GetFirstShiftType()

		Exec dbo.GetPreviousDateShift 
			@Date = @Unapproved_End_Date,
			@Shift = @Unapproved_End_Shift,
			@Previous_Date = @Unapproved_End_Date Output,
			@Previous_Shift = @Unapproved_End_Shift Output

		Exec RecalcL2ReprocessWithheld
			@pEnd_Date = @Unapproved_End_Date,
			@pEnd_Shift = @Unapproved_End_Shift
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UnapproveMonth TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UnapproveMonth">
 <Procedure>
	Updates the table MonthlyApproval to unapproved if a record exists and is approved, 
	unapprove it and re-caculate.
	Errors are raised if:
		The month is not currently approved.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetBlockModelList.prc'
GO

IF object_id('dbo.GetBlockModelList') IS NOT NULL 
     DROP PROCEDURE dbo.GetBlockModelList 
GO 
  
CREATE PROCEDURE dbo.GetBlockModelList 
( 
    @iBlock_Model_Type_Id INT = NULL,
	@iBlock_Model_Name VARCHAR(255) = NULL,
	@iIs_Displayed Bit = 1
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    -- Return the list of block models in the system
	SELECT BM.Block_Model_Id, BM.Block_Model_Type_Id, BMT.Name AS Block_Model_Type_Name,
		BM.Name, BM.Description, BM.Generated_Date, BM.Creation_Datetime,
		BM.Is_Default, BM.Is_Displayed
	FROM dbo.BlockModel AS BM 
		INNER JOIN dbo.BlockModelType AS BMT
			ON (BM.Block_Model_Type_Id = BMT.Block_Model_Type_Id)
	WHERE BM.Block_Model_Type_Id = IsNull(@iBlock_Model_Type_Id, BM.Block_Model_Type_Id)
		AND BM.Name = IsNull(@iBlock_Model_Name, BM.Name)
		AND (BM.Is_Displayed = @iIs_Displayed 
			OR @iIs_Displayed IS NULL)
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetBlockModelList TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBlockModelList">
 <Procedure>
	Returns the list of block models in the system optionally filtered by the 
	block model type or an exact name match.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileSurvey.prc'
GO

If object_id('dbo.AddStockpileSurvey') is not Null 
     Drop Procedure dbo.AddStockpileSurvey
Go 
  
Create Procedure dbo.AddStockpileSurvey 
( 
    @iStockpile_Survey_Date DateTime,
	@iStockpile_Survey_Shift Char(1) = Null,
	@iStockpile_Survey_Type_Id Int,
	@iAdjust_Haulage Bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Begin Try
		Set @iStockpile_Survey_Date = dbo.GetDateDay(@iStockpile_Survey_Date)

		--If shift was not given default to last shift
		Select @iStockpile_Survey_Shift = IsNull(@iStockpile_Survey_Shift, dbo.GetLastShiftType())  

		--Check the survey doesnt exist
		If Exists
			(
				Select 1 
				From dbo.StockpileSurvey
				Where Stockpile_Survey_Date = @iStockpile_Survey_Date
					And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
					And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
			)
		Begin
			Raiserror ('A stockpile survey already exists for this date and shift', 16, 1)	
		End

		If Exists
			(
				Select 1
				From dbo.StockpileSurvey As S
					Inner Join dbo.ShiftType As ST	
						On (S.Stockpile_Survey_Shift = ST.Shift)
				Where S.Is_Approved = 1
					And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
					And ((S.Stockpile_Survey_Date > @iStockpile_Survey_Date)
						Or (S.Stockpile_Survey_Date = @iStockpile_Survey_Date
							And ST.Order_No > dbo.GetShiftTypeOrderNo(@iStockpile_Survey_Shift)))
			)
		Begin
			Raiserror ('An approved stockpile survey exists after this date and shift', 16, 1)
		End

		Insert Into StockpileSurvey
		(
			Stockpile_Survey_Date, Stockpile_Survey_Shift, Stockpile_Survey_Type_Id,
			Is_Approved, Adjust_Haulage
		)
		Select @iStockpile_Survey_Date, @iStockpile_Survey_Shift, @iStockpile_Survey_Type_Id, 
			0, @iAdjust_Haulage
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch 
End 
Go 
GRANT EXECUTE ON dbo.AddStockpileSurvey TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileSurvey">
 <Procedure>
	Adds a new record in the StockpileSurvey table.
	Errors are raised if:
		A stockpile survey already exists for this date and shift
		An approved stockpile survey exists after this date and shift
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlanList.prc'
GO

If object_id('dbo.GetMinePlanList') is not Null 
     Drop Procedure dbo.GetMinePlanList
Go 
  
Create Procedure dbo.GetMinePlanList 
( 
	@iMine_Plan_Type_Id Int = Null,
    @iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null,
	@iDate_Filter_Type Int = 0,
	@iShow_Parents_Only Bit = 1
) 
With Encryption As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @MinePlan table
	(
		Mine_Plan_Id Int,
		Mine_Plan_Type_Id Int,
		Name Varchar(255) Collate Database_Default,
		Description Varchar(1023) Collate Database_Default,
		Imported_Datetime Datetime,
		Is_Default Bit,
		Minimum_Period_Length Varchar(31) Collate Database_Default,
		Parent_Mine_Plan_Id Int,
		Start_Date DateTime,
		End_Date DateTime
	)

	Insert Into @MinePlan
	(
		Mine_Plan_Id, Mine_Plan_Type_Id, Name, Description, 
		Imported_Datetime, Is_Default, Minimum_Period_Length, Parent_Mine_Plan_Id
	)
	Select MP.Mine_Plan_Id, MP.Mine_Plan_Type_Id, MP.Name, MP.Description, 
		MP.Imported_DateTime, MP.Is_Default, MPT.Minimum_Period_Length, MP.Parent_Mine_Plan_Id
	From dbo.MinePlan As MP
		Inner Join dbo.MinePlanType As MPT
			On (MP.Mine_Plan_Type_Id = MPT.Mine_Plan_Type_Id)
	Where MP.Mine_Plan_Type_Id = IsNull(@iMine_Plan_Type_Id, MP.Mine_Plan_Type_Id)
		And (MP.Parent_Mine_Plan_Id Is Null 
			Or @iShow_Parents_Only = 0)
		And ((@iDate_Filter_Type = 1 --If We're filtering on import datetime
				And MP.Imported_DateTime >= IsNull(@iStart_Date, MP.Imported_DateTime)
				And MP.Imported_DateTime <= IsNull(@iEnd_Date, MP.Imported_DateTime))
			Or (@iDate_Filter_Type <> 1))

	--Work out the start and end date from the mine plan period entries
	Update M
	Set Start_Date = IsNull(AGG.Start_Date, PAGG.Start_Date),
		End_Date =  IsNull(AGG.End_Date, PAGG.End_Date)
	From @MinePlan As M
		Inner Join 
			(
				Select MP.Mine_Plan_Id, Min(MP.Start_Date) As Start_Date,
					Max(MP.End_Date) As End_Date
				From dbo.MinePlanPeriod As MP
					Inner Join @MinePlan As M --Join to use previous filters
						On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
				Group By MP.Mine_Plan_Id
			) As AGG
			On (AGG.Mine_Plan_Id = M.Mine_Plan_Id)
		--If the start date wasnt supplied and it has a parent - use the parents
		Left Outer Join 
			(
				Select MP.Mine_Plan_Id, Min(PMP.Start_Date) As Start_Date,
					Max(PMP.End_Date) As End_Date
				From dbo.MinePlan As MP
					Inner Join @MinePlan As M --Join to use previous filters
						On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
					Inner Join dbo.MinePlanPeriod As PMP
						On (MP.Parent_Mine_Plan_Id = PMP.Mine_Plan_Id)
				Group By MP.Mine_Plan_Id
			) As PAGG
			On (AGG.Mine_Plan_Id = M.Mine_Plan_Id)
	
	Select *
	From @MinePlan As MP
	Where ((@iDate_Filter_Type = 0 --If We're filtering on import Start_Date
				And MP.Start_Date >= IsNull(@iStart_Date, MP.Start_Date)
				And MP.Start_Date <= IsNull(@iEnd_Date, MP.Start_Date))
			Or (@iDate_Filter_Type <> 0))

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetMinePlanList TO CoreMinePlanManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetMinePlanList">
 <Procedure>
	Returns the list of mine plans. If a start and end date filter is passed
	it can be one of two types specified in the date filter type (0 - filter
	on the start date of the plan. 1 - filter on the import date of the plan).
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlan.prc'
GO

If object_id('dbo.GetMinePlan') is not Null 
     Drop Procedure dbo.GetMinePlan 
Go 
  
Create Procedure dbo.GetMinePlan
( 
    @iMine_Plan_Id Int 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Declare @MinePlan table
	(
		Mine_Plan_Id Int,
		Mine_Plan_Type_Id Int,
		Name Varchar(255) Collate Database_Default,
		Description Varchar(1023) Collate Database_Default,
		Imported_Datetime Datetime,
		Is_Default Bit,
		Period_Length Varchar(31) Collate Database_Default,
		Parent_Mine_Plan_Id Int,
		Start_Date DateTime,
		End_Date DateTime
	)

	Insert Into @MinePlan
	(
		Mine_Plan_Id, Mine_Plan_Type_Id, Name, Description, 
		Imported_Datetime, Is_Default, Period_Length, Parent_Mine_Plan_Id
	)
	Select MP.Mine_Plan_Id, MP.Mine_Plan_Type_Id, MP.Name, MP.Description, 
		MP.Imported_DateTime, MP.Is_Default, MPT.Minimum_Period_Length, MP.Parent_Mine_Plan_Id
	From dbo.MinePlan As MP
		Inner Join dbo.MinePlanType As MPT	
			On (MP.Mine_Plan_Type_Id = MPT.Mine_Plan_Type_Id)
	Where MP.Mine_Plan_Id = @iMine_Plan_Id

	--Work out the start and end date from the mine plan period entries
	Update M
	Set Start_Date = IsNull(AGG.Start_Date, PAGG.Start_Date),
		End_Date =  IsNull(AGG.End_Date, PAGG.End_Date)
	From @MinePlan As M
		Inner Join 
			(
				Select MP.Mine_Plan_Id, Min(MP.Start_Date) As Start_Date,
					Max(MP.End_Date) As End_Date
				From dbo.MinePlanPeriod As MP
					Inner Join @MinePlan As M --Join to use previous filters
						On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
				Group By MP.Mine_Plan_Id
			) As AGG
			On (AGG.Mine_Plan_Id = M.Mine_Plan_Id)
		--If the start date wasnt supplied and it has a parent - use the parents
		Left Outer Join 
			(
				Select MP.Mine_Plan_Id, Min(PMP.Start_Date) As Start_Date,
					Max(PMP.End_Date) As End_Date
				From dbo.MinePlan As MP
					Inner Join @MinePlan As M --Join to use previous filters
						On (MP.Mine_Plan_Id = M.Mine_Plan_Id)
					Inner Join dbo.MinePlanPeriod As PMP
						On (MP.Parent_Mine_Plan_Id = PMP.Mine_Plan_Id)
				Group By MP.Mine_Plan_Id
			) As PAGG
			On (AGG.Mine_Plan_Id = M.Mine_Plan_Id)
	
	Select *
	From @MinePlan As MP
  
    Commit Transaction 
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="GetMinePlan">
 <Procedure>
	Return a given mine plan details.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMinePlanPeriod.prc'
GO

If object_id('dbo.AddOrUpdateMinePlanPeriod') is not Null 
     Drop Procedure dbo.AddOrUpdateMinePlanPeriod
Go 
  
Create Procedure dbo.AddOrUpdateMinePlanPeriod
( 
    @iMine_Plan_Id Int,
	@iMine_Plan_Period_Type_Id Int,
	@iStart_Date Datetime,
	@iEnd_Date Datetime,
	@iMaterial_Type_Id Int,
	@iImported_Datetime Datetime = Null,
	@iTonnes Float,
	@iIs_From_Pit Bit = 1 ,
	@iForce_New_Record Bit = 0,
	@ioMine_Plan_Period_Id Int = Null Output
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		If @iImported_Datetime Is Null
		Begin
			Set @iImported_Datetime = getdate()
		End

		If Not Exists
			(
				Select 1 
				From dbo.MinePlan
				Where Mine_Plan_Id = @iMine_Plan_Id
			)
		Begin
			RaisError('The given mine plan does not exist', 16, 1)
		End

		--If we are trying to pass a specific id and it doesnt exist
		If @ioMine_Plan_Period_Id Is Not Null 
			And Not Exists
				(
					Select 1
					From dbo.MinePlanPeriod 
					Where Mine_Plan_Period_Id = @ioMine_Plan_Period_Id
				)
		Begin
			RaisError('The given mine plan period record does not exist', 16, 1)
		End

		--Check for a period record with matching criteria if the id was not passed
		If @iForce_New_Record = 0 And @ioMine_Plan_Period_Id Is Null 
		Begin
			Select Top 1 @ioMine_Plan_Period_Id = P.Mine_Plan_Period_Id
			From dbo.MinePlanPeriod As P
			Where P.Mine_Plan_Id = @iMine_Plan_Id
				And P.Start_Date = @iStart_Date
				And P.Mine_Plan_Period_Type_Id = @iMine_Plan_Period_Type_Id
				And P.Material_Type_Id = @iMaterial_Type_Id
		End
	
		--Insert/Update
		If @ioMine_Plan_Period_Id Is Null 
		Begin
			Insert Into dbo.MinePlanPeriod
			(
				Mine_Plan_Id, Start_Date, End_Date, Material_Type_Id, Mine_Plan_Period_Type_Id, 
				Is_From_Pit, Imported_Datetime, Tonnes
			)
			Select @iMine_Plan_Id, @iStart_Date, @iEnd_Date, @iMaterial_Type_Id, @iMine_Plan_Period_Type_Id,
				@iIs_From_Pit, @iImported_Datetime, @iTonnes

			Select @ioMine_Plan_Period_Id = @@identity
		End
		Else
		Begin
			Update dbo.MinePlanPeriod	
			Set Mine_Plan_Id = @iMine_Plan_Id,
				Start_Date = @iStart_Date,
				End_Date = @iEnd_Date,
				Material_Type_Id = @iMaterial_Type_Id,
				Mine_Plan_Period_Type_Id = @iMine_Plan_Period_Type_Id,
				Is_From_Pit = @iIs_From_Pit,
				Imported_Datetime = @iImported_Datetime,
				Tonnes = @iTonnes
			Where Mine_Plan_Period_Id = @ioMine_Plan_Period_Id
		End		
	

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMinePlanPeriod">
 <Procedure>
	Adds a new record or updates an existing record in the MinePlanPeriod table
	If a plan period id is not been given, and the option is to not force a new record then 
	it will look for a matching entry.

	Errors raised if:
		The given mine plan does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UnapproveStockpileSurvey.prc'
GO

If object_id('dbo.UnapproveStockpileSurvey') is not Null 
     Drop Procedure dbo.UnapproveStockpileSurvey 
Go 
  
Create Procedure dbo.UnapproveStockpileSurvey 
( 
    @iStockpile_Survey_Date Datetime,
	@iStockpile_Survey_Shift Char(1),
	@iStockpile_Survey_Type_Id Int,
	@iResolve_Haulage Bit = 1
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @StartDate DateTime,
		@StartShift Char(1)

	Declare @SURVEY table
	(
		Stockpile_Survey_Type_Id Int,
		Stockpile_Survey_Type_Name Varchar(63) Collate Database_Default, 
		Start_Date DateTime,
		Start_Shift Char(1) Collate Database_Default,
		End_Date DateTime,
		End_Shift Char(1) Collate Database_Default,
		End_Shift_Order_No Int,
		Is_Approved Bit,
		Adjust_Haulage Bit
	)  	

	Begin Try
		--Get Survey Info 
		Insert Into @SURVEY
		Exec dbo.GetStockpileSurveyList
			@iStockpile_Survey_Date = @iStockpile_Survey_Date,
			@iStockpile_Survey_Shift = @iStockpile_Survey_Shift,
			@iStockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id

		Select @StartDate = Start_Date, @StartShift = Start_Shift
		From @SURVEY

		--Check survey does exist
		If Not Exists
			(
				Select 1 
				From @SURVEY
			)
		Begin
			Raiserror('The stockpile survey does not exist', 16, 1)
		End 

		--Check for Monthly Approvals
		If Exists
			(
				Select 1
				From dbo.MonthlyApproval As A
					Inner Join @SURVEY As S
						On (A.Monthly_Approval_Month Between S.Start_Date And S.End_Date)
				Where A.Is_Approved = 1
			)
		Begin
			Raiserror('At least part of the stockpile survey falls in an already approved month', 16, 1)
		End

		--Check the survey is approved
		If Not Exists
			(
				Select 1 
				From @SURVEY
				Where Is_Approved = 1
			)
		Begin
			Raiserror('The stockpile survey is not currently approved', 16, 1)  
		End

		--Check survey is last in the chain of approved months
		If Exists
			(
				Select 1
				From dbo.StockpileSurvey As SS
					Cross Join @SURVEY As S
				Where SS.Is_Approved = 1
					And SS.Adjust_Haulage = 1
					And SS.Stockpile_Survey_Date >= S.End_Date --Optimised to use index
					And dbo.CompareDateShift(SS.Stockpile_Survey_Date, SS.Stockpile_Survey_Shift, '>', S.End_Date, S.End_Shift) = 1
			)
		Begin
			Raiserror('The stockpile survey can not be unapproved as there are approved surveys after it that modify haulage.', 16, 1)
		End

		-- Set the survey date to unapproved
		Update StockpileSurvey
		Set	Is_Approved = 0
		Where Stockpile_Survey_Date = @iStockpile_Survey_Date
			And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
			And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id

		--Now that the period is unapproved check to see if any haulage errors can be corrected
		If @iResolve_Haulage = 1
		Begin
			Exec dbo.HaulageRawResolveAll
		End

		-- Recalculate for the given period
		Exec RecalcL2Raise
			@pDate = @StartDate,
			@pShift = @StartShift

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 
GRANT EXECUTE ON dbo.UnapproveStockpileSurvey TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="UnapproveStockpileSurvey">
 <Procedure>
	Updates the table StockpileSurvey to unapproved if the flag is set to approved, if there is 
	no previous stockpile survey and if the start date for this depletion period does not fall 
	in an already approved month.
	Errors are raised if:
		Could not unapprove stockpile survey.
		At least part of the stockpile survey falls in an already approved month.
		The stockpile survey is not currently approved.
		The stockpile survey does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMinePlan.prc'
GO

If object_id('dbo.DeleteMinePlan') is not Null 
     Drop Procedure dbo.DeleteMinePlan
Go 
  
Create Procedure dbo.DeleteMinePlan
( 
    @iMine_Plan_Id Int
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @ChildPlanId Int
	Select @ChildPlanId = Null

	Begin Try
		If Not Exists
			(
				Select 1
				From dbo.MinePlan
				Where Mine_Plan_Id = @iMine_Plan_Id
			)
		Begin
			RaisError('Mine plan id does not exists.', 16, 1)
		End

		--Delete Children first
		Select Top 1 @ChildPlanId = Mine_Plan_Id
		From dbo.MinePlan
		Where Parent_Mine_Plan_Id = @iMine_Plan_Id

		While @ChildPlanId Is Not Null
		Begin
			Exec dbo.DeleteMinePlan
				@iMine_Plan_Id = @iMine_Plan_Id

			Select @ChildPlanId = Null

			Select Top 1 @ChildPlanId = Mine_Plan_Id
			From dbo.MinePlan
			Where Parent_Mine_Plan_Id = @iMine_Plan_Id
		End

		--Delete Ancillary tables
		Delete A
		From dbo.MinePlanPeriodNotes As A
			Inner Join dbo.MinePlanPeriod As P
				On (A.Mine_Plan_Period_Id = P.Mine_Plan_Period_Id)
		Where P.Mine_Plan_Id = @iMine_Plan_Id

		Delete A
		From dbo.MinePlanPeriodValue As A
			Inner Join dbo.MinePlanPeriod As P
				On (A.Mine_Plan_Period_Id = P.Mine_Plan_Period_Id)
		Where P.Mine_Plan_Id = @iMine_Plan_Id

		Delete A
		From dbo.MinePlanPeriodGrade As A
			Inner Join dbo.MinePlanPeriod As P
				On (A.Mine_Plan_Period_Id = P.Mine_Plan_Period_Id)
		Where P.Mine_Plan_Id = @iMine_Plan_Id

		Delete A
		From dbo.MinePlanPeriodLocation As A
			Inner Join dbo.MinePlanPeriod As P
				On (A.Mine_Plan_Period_Id = P.Mine_Plan_Period_Id)
		Where P.Mine_Plan_Id = @iMine_Plan_Id

		Delete
		From dbo.MinePlanPeriod
		Where Mine_Plan_Id = @iMine_Plan_Id

		Delete
		From dbo.MinePlan
		Where Mine_Plan_Id = @iMine_Plan_Id

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteMinePlan">
 <Procedure>
	Deletes records with the specified @Mine_Plan_Id and associated child records from the following tables:
		MinePlanPeriodNotes
		MinePlanPeriodValue 
		MinePlanPeriodGrade
		MinePlanPeriodLocation
		MinePlanPeriod
		MinePlan
	Recursively calls DeleteMinePlan to delete child records.
	Errors raised if:
		The given mine plan does not exist	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddStockpileAdjustment.prc'
GO

If object_id('dbo.AddStockpileAdjustment') is not Null 
     Drop Procedure dbo.AddStockpileAdjustment 
Go 
  
Create Procedure dbo.AddStockpileAdjustment 
( 
    @iStockpile_Id Int,
	@iBuild_Id Int,
	@iComponent_Id Int = Null,
	@iAdjustment_Date Datetime,
	@iAdjustment_Shift Char(1),
	@iDescription Varchar(255),
	@iIs_Add_Or_Remove Bit,
	@iIs_Tonnes_Adjustment Bit,
	@iIs_Grades_Adjustment Bit,
	@iIs_Manual Bit = 1,
	@iTonnes Float = Null,
	@iStockpile_Survey_Sample_Id Int = Null,
	@iIs_Stockpile_Transfer Bit = 0,
	@iSource_Stockpile_Id Int = Null,
	@iSource_Build_Id Int = Null,
	@iUse_Given_Moisture_Scaling Bit = 0,
	@oStockpile_Adjustment_Id Int = NULL Output
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @tmpDate Datetime

	Begin Try
		Set @iAdjustment_Date = dbo.GetDateDay (@iAdjustment_Date)

		-- If the stockpile does not exists
		If Not Exists
			(
				Select 1
				From dbo.Stockpile
				Where Stockpile_Id = @iStockpile_Id
			)
		Begin
			RaisError('The stockpile does not exist', 16, 1)
		End

		--If stockpile Build does not exist
		If Not Exists
			(
				Select 1 
				From dbo.StockpileBuild
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
			)
		Begin
			RaisError('The stockpile build does not exist', 16, 1)
		End
		
		--If the stockpile component is specified and is not null
		If @iComponent_Id Is Not Null 
			And Not Exists
				(
					Select 1 
					From dbo.StockpileBuildComponent
					Where Stockpile_Id = @iStockpile_Id
						And Build_Id = @iBuild_Id
						And Component_Id = @iComponent_Id
				)
		Begin
			RaisError('The stockpile component does not exist', 16, 1)
		End

		--If the stockpile build is not active
		If (dbo.IsStockpileBuildActive (@iStockpile_Id, @iBuild_Id, @iAdjustment_Date, @iAdjustment_Shift) <> 1)
		Begin
			Raiserror ('The stockpile build is not active on this date and shift', 16, 1)
		End

		--If this is a stockpile to stockpile transfer
		If @iIs_Stockpile_Transfer = 1
		Begin
			--Validate Source Stockpile & Source Build Exist
			If Not Exists
			(
				Select 1
				From dbo.Stockpile
				Where Stockpile_Id = @iSource_Stockpile_Id
			)
			Begin
				RaisError('The source stockpile does not exist', 16, 1)
			End

			If Not Exists
			(
				Select 1 
				From dbo.StockpileBuild
				Where Stockpile_Id = @iSource_Stockpile_Id
					And Build_Id = @iSource_Build_Id
			)
			Begin
				RaisError('The source stockpile build does not exist', 16, 1)
			End

			--Ensure Source Build is active
			If (dbo.IsStockpileBuildActive (@iSource_Stockpile_Id, @iSource_Build_Id, @iAdjustment_Date, @iAdjustment_Shift) <> 1)
			Begin
				RaisError('The source stockpile build is not active on this date and shift', 16, 1)
			End
		End

		--Check to see if there is already a stockpile adjustment in the system for 
		--this stockpile build on this date and shift
		If Exists 
			(
				Select 1
				From dbo.StockpileAdjustment
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
					And Adjustment_Date = @iAdjustment_Date
					And Adjustment_Shift = @iAdjustment_Shift
			)
		Begin
			RaisError('There is an existing adjustment for this stockpile build on this date and shift', 16, 1)	
		End

		-- Check to see if this adjustment falls in an already approved month, 
		-- allowing for corrections on the last shift of approved months
		If @iAdjustment_Shift = dbo.GetLastShiftType()
		Begin
			Set @tmpDate = DateAdd(Day, 1, @iAdjustment_Date)
		End
		Else
		Begin
			Set @tmpDate = @iAdjustment_Date
		End

		If dbo.IsInApprovedMonth(@tmpDate) <> 0
		Begin
			RaisError('The adjustment falls in an already approved month', 16, 1)
		End

		-- Insert the manual adjustment record
		Insert Into dbo.StockpileAdjustment
		(
			Stockpile_Id, Build_Id, Component_Id, Adjustment_Date, Adjustment_Shift,
			Source_Stockpile_Id, Source_Build_Id, Imported_Datetime, Is_Add_Or_Remove, 
			Is_Stockpile_Transfer, Is_Tonnes_Adjustment,Is_Grades_Adjustment, Is_Manual, 
			Tonnes, Description, Stockpile_Survey_Sample_Id, Use_Given_Moisture_Scaling
		)
		Select @iStockpile_Id, @iBuild_Id, @iComponent_Id, @iAdjustment_Date, @iAdjustment_Shift,
			@iSource_Stockpile_Id, @iSource_Build_Id, GetDate(), @iIs_Add_Or_Remove, 
			@iIs_Stockpile_Transfer, @iIs_Tonnes_Adjustment, @iIs_Grades_Adjustment, @iIs_Manual, 
			@iTonnes, @iDescription, @iStockpile_Survey_Sample_Id, @iUse_Given_Moisture_Scaling

		Set @oStockpile_Adjustment_Id = Scope_Identity()

		/* Raise this as an event */
		Exec dbo.RecalcL2Raise 
			@pDate = @iAdjustment_Date, 
			@pShift = @iAdjustment_Shift
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.AddStockpileAdjustment TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddStockpileAdjustment">
 <Procedure>
	Adds a new record in the StockpileAdjustment table.
	Raises a Level 2 Recalc for the Adjustment date and shift.
	Errors are raised if:
		The stockpile, build or component does not exist
		The stockpile build is not active on this date and shift
		There is an existing adjustment for this stockpile build on this date and shift
		The adjustment falls in an already approved month
		The source stockpile for the transfer is not active on the given data and shift				
		The source stockpile or source build does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMinePlanPeriodValue.prc'
GO

If object_id('dbo.AddOrUpdateMinePlanPeriodValue') is not Null 
     Drop Procedure dbo.AddOrUpdateMinePlanPeriodValue
Go 
  
Create Procedure dbo.AddOrUpdateMinePlanPeriodValue 
( 
    @iMine_Plan_Period_Id Int,
	@iMine_Plan_Field_Id Varchar(31),
	@iField_Value Real
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		If Not Exists
			(
				Select 1 
				From dbo.MinePlanPeriod
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			)
		Begin
			RaisError('The given mine plan period does not exist', 16, 1)
		End	

		If Not Exists
			(
				Select 1
				From dbo.MinePlanPeriodValue
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
					And Mine_Plan_Field_Id = @iMine_Plan_Field_Id
			)
		Begin
			Insert Into dbo.MinePlanPeriodValue
			(
				Mine_Plan_Period_Id, Mine_Plan_Field_Id, Field_Value
			)
			Select @iMine_Plan_Period_Id, @iMine_Plan_Field_Id, @iField_Value
		End
		Else
		Begin
			Update dbo.MinePlanPeriodValue
			Set Field_Value = @iField_Value
			Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
				And Mine_Plan_Field_Id = @iMine_Plan_Field_Id
		End

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMinePlanPeriodValue">
 <Procedure>
	Adds a new record or updates an existing record in the MinePlanPeriodValue table if a @Field_Value value is specified.
	If the @Field_Value value is not specified and the record exists in the MinePlanPeriodValue table the record is deleted.
	Errors raised if:
		The given mine plan period does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMinePlanPeriodNotes.prc'
GO

If object_id('dbo.AddOrUpdateMinePlanPeriodNotes') is not Null 
     Drop Procedure dbo.AddOrUpdateMinePlanPeriodNotes
Go 
  
Create Procedure dbo.AddOrUpdateMinePlanPeriodNotes 
( 
    @iMine_Plan_Period_Id Int,
	@iMine_Plan_Field_Id Varchar(31),
	@iNotes Varchar(1024)
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Begin Try
		If Not Exists
			(
				Select 1 
				From dbo.MinePlanPeriod
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			)
		Begin
			RaisError('The given mine plan does not exist', 16, 1)
		End	

		If Not Exists
			(
				Select 1
				From dbo.MinePlanPeriodNotes
				Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
					And Mine_Plan_Field_Id = @iMine_Plan_Field_Id
			)
		Begin
			Insert Into dbo.MinePlanPeriodNotes
			(
				Mine_Plan_Period_Id, Mine_Plan_Field_Id, Notes
			)
			Select @iMine_Plan_Period_Id, @iMine_Plan_Field_Id, @iNotes
		End
		Else
		Begin
			Update dbo.MinePlanPeriodNotes
			Set Notes = @iNotes
			Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
				And Mine_Plan_Field_Id = @iMine_Plan_Field_Id
		End

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMinePlanPeriodNotes">
 <Procedure>
	Adds a new record or updates an existing record in the MinePlanPeriodNotes table if a @Notes value is specified.
	If the @Notes value is not specified and the record exists in the MinePlanPeriodNotes table the record is deleted.
	Errors raised if:
		The given mine plan period does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileSurveySampleList.prc'
GO

If object_id('dbo.GetStockpileSurveySampleList') is not Null 
     Drop Procedure dbo.GetStockpileSurveySampleList 
Go 
  
Create Procedure dbo.GetStockpileSurveySampleList
( 
    @iStockpile_Survey_Date Datetime,
	@iStockpile_Survey_Shift Char(1),
	@iStockpile_Survey_Type_Id Int,
	@iStockpile_Survey_Sample_Id Int = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @OpenBalDate DateTime,
		@OpenBalShift Char(1)

	Declare @SURVEY table
	(
		Stockpile_Survey_Type_Id Int,
		Stockpile_Survey_Type_Name Varchar(63) Collate Database_Default, 		
		Start_Date DateTime,
		Start_Shift Char(1) Collate Database_Default,
		End_Date DateTime,
		End_Shift Char(1) Collate Database_Default,
		End_Shift_Order_No Int,
		Is_Approved Bit,
		Adjust_Haulage Bit
	)  

	Declare @SAMPLE Table
	(
		Stockpile_Survey_Sample_Id Int,
		Stockpile_Id Int,
		Build_Id Int,
		Opening_Balance Float,
		Tonnes_Added Float,
		Tonnes_Removed Float
	)

	--Get Survey Info 
	Insert Into @SURVEY
	Exec dbo.GetStockpileSurveyList
		@iStockpile_Survey_Date = @iStockpile_Survey_Date,
		@iStockpile_Survey_Shift = @iStockpile_Survey_Shift,
		@iStockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id

	Select @OpenBalDate = Start_Date, @OpenBalShift = Start_Shift
	From @SURVEY
		
	Exec dbo.GetPreviousDateShift 
		@Date = @OpenBalDate,
		@Shift = @OpenBalShift,
		@Previous_Date = @OpenBalDate Output,
		@Previous_Shift = @OpenBalShift Output

	--Get Sample Opening Balances First 
	Insert Into @SAMPLE
	(
		Stockpile_Survey_Sample_Id, Stockpile_Id, Build_Id, Opening_Balance, Tonnes_Added, Tonnes_Removed
	)
	Select SS.Stockpile_Survey_Sample_Id, SS.Stockpile_Id, SS.Build_Id, IsNull(Sum(B.Tonnes), 0), 0, 0
	From dbo.StockpileSurveySample As SS
		Left Outer Join dbo.DataProcessStockpileBalance As B
			On (B.Data_Process_Stockpile_Balance_Date = @OpenBalDate
				And B.Data_Process_Stockpile_Balance_Shift = @OpenBalShift
				And B.Stockpile_Id = SS.Stockpile_Id
				And B.Build_Id = SS.Build_Id)
	Where SS.Stockpile_Survey_Date = @iStockpile_Survey_Date
		And SS.Stockpile_Survey_Shift = @iStockpile_Survey_Shift
		And SS.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
		And SS.Stockpile_Survey_Sample_Id = IsNull(SS.Stockpile_Survey_Sample_Id, @iStockpile_Survey_Sample_Id)
	Group By SS.Stockpile_Survey_Sample_Id, SS.Stockpile_Id, SS.Build_Id

	--Add The Adds
	Update S
	Set Tonnes_Added = IsNull(AGG.Tonnes, 0)
	From @SAMPLE As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From @SAMPLE As S2
					Inner Join dbo.DataTransactionTonnes As T
						On (T.Destination_Stockpile_Id = S2.Stockpile_Id
							And T.Destination_Build_Id = S2.Build_Id)
					Cross Join @SURVEY As S3
				Where T.Data_Transaction_Tonnes_Date between S3.Start_Date and S3.End_Date
					And dbo.CompareDateShift(T.Data_Transaction_Tonnes_Date, T.Data_Transaction_Tonnes_Shift, '<=', S3.Start_Date, S3.Start_Shift) = 1
					And dbo.CompareDateShift(T.Data_Transaction_Tonnes_Date, T.Data_Transaction_Tonnes_Shift, '>=', S3.End_Date, S3.End_Shift) = 1
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	--Remove The Offs
	Update S
	Set Tonnes_Removed = IsNull(AGG.Tonnes, 0)
	From @SAMPLE As S
		Inner Join 
			(
				Select S2.Stockpile_Id, S2.Build_Id, Sum(Tonnes) As Tonnes
				From @SAMPLE As S2
					Inner Join dbo.DataTransactionTonnes As T
						On (T.Source_Stockpile_Id = S2.Stockpile_Id
							And T.Source_Build_Id = S2.Build_Id)
					Cross Join @SURVEY As S3
				Where T.Data_Transaction_Tonnes_Date between S3.Start_Date and S3.End_Date
					And dbo.CompareDateShift(T.Data_Transaction_Tonnes_Date, T.Data_Transaction_Tonnes_Shift, '<=', S3.Start_Date, S3.Start_Shift) = 1
					And dbo.CompareDateShift(T.Data_Transaction_Tonnes_Date, T.Data_Transaction_Tonnes_Shift, '>=', S3.End_Date, S3.End_Shift) = 1
				Group by S2.Stockpile_Id, S2.Build_Id
			) As AGG
			On (S.Stockpile_Id = AGG.Stockpile_Id 
				And S.Build_Id = AGG.Build_Id)

	--Return Sample Information
	Select SS.Stockpile_Survey_Sample_Id, SS.Stockpile_Survey_Date, SS.Stockpile_Survey_Shift,
		SS.Stockpile_Survey_Type_Id, SS.Stockpile_Id, S.Stockpile_Name, SS.Build_Id,
		SS.Is_Auto_Adjusting, SS.Imported_DateTime, SS.Is_Tonnes_Survey, SS.Is_Grades_Survey,
		SS.Use_Given_Moisture_Scaling, SS.Tonnes, S2.Opening_Balance,
		(S2.Opening_Balance + S2.Tonnes_Added - S2.Tonnes_Removed) As Balance, 
		S2.Tonnes_Added, S2.Tonnes_Removed,
		SS.Tonnes - (S2.Opening_Balance + S2.Tonnes_Added - S2.Tonnes_Removed) As [Difference]
	From dbo.StockpileSurveySample As SS
		Inner Join dbo.Stockpile As S
			On (S.Stockpile_Id = SS.Stockpile_Id)
		Inner Join @SAMPLE As S2
			On (S2.Stockpile_Survey_Sample_Id = SS.Stockpile_Survey_Sample_Id)
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileSurveySampleList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileSurveySampleList">
 <Procedure>
	Returns the survey sample information for a given survey period and type
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileAdjustment.prc'
GO

If object_id('dbo.DeleteStockpileAdjustment') is not Null 
     Drop Procedure dbo.DeleteStockpileAdjustment 
Go 
  
Create Procedure dbo.DeleteStockpileAdjustment 
( 
    @iStockpile_Adjustment_Id Int 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Is_Approved Bit,
		@Adjustment_Date Datetime,
		@Adjustment_Shift Char(1)

    Begin Try
		If Not Exists
			(
				Select 1
				From dbo.StockpileAdjustment
				Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
			)
		Begin
			Raiserror ('The stockpile adjustment does not exist', 16, 1)
		End	

		-- Get the details of the stockpile adjustment
		Select @Adjustment_Date = Adjustment_Date,
			@Adjustment_Shift = Adjustment_Shift
		From dbo.StockpileAdjustment
		Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id

		-- If the stockpile adjustment does falls in an already approved month
		If dbo.IsInApprovedMonth (@Adjustment_Date) <> 0
		Begin
			Raiserror ('The stockpile adjustment falls in an already approved month', 16, 1)
		End

		-- Delete from the Grade table
		Delete 
		From dbo.StockpileAdjustmentGrade
		Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id

		-- Delete the adjustment record
		Delete 
		From dbo.StockpileAdjustment
		Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id

		-- Raise recalc
		Exec RecalcL2Raise 
			@pDate = @Adjustment_Date, 
			@pShift = @Adjustment_Shift
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.DeleteStockpileAdjustment TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileAdjustment">
 <Procedure>
	Deletes records with the specified @Stockpile_Adjustment_Id from the following tables:
		StockpileAdjustmentGrade
		StockpileAdjustment
	A Level 2 Recalc event is raised for the date and shift of the adjustment record that is deleted.
	Errors are raised if:
		The stockpile adjustment does not exist
		The stockpile adjustment falls in an already approved month
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileSurveySample.prc'
GO

If object_id('dbo.DeleteStockpileSurveySample') is not Null 
     Drop Procedure dbo.DeleteStockpileSurveySample 
Go 
  
Create Procedure dbo.DeleteStockpileSurveySample 
( 
    @iStockpile_Survey_Sample_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Stockpile_Adjustment_Id Int

    Begin Try
		If Not Exists
			(
				Select 1 
				From dbo.StockpileSurveySample As S
				Where S.Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id
			)
		Begin
			Raiserror('The stockpile survey sample does not exist.', 16, 1)
		End

		If Exists
			(
				Select 1
				From dbo.StockpileSurveySample As SS
					Inner Join dbo.StockpileSurvey As S
						On (SS.Stockpile_Survey_Date = S.Stockpile_Survey_Date
							And SS.Stockpile_Survey_Shift = S.Stockpile_Survey_Shift
							And SS.Stockpile_Survey_Type_Id = S.Stockpile_Survey_Type_Id)
				Where SS.Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id
					And S.Is_Approved = 1
			)
		Begin
			Raiserror('This stockpile survey has been approved. Please unapprove the survey before modifying.', 16, 1)		
		End
	
		--Remove adjustment associated with sample if it exists
		Select @Stockpile_Adjustment_Id = Stockpile_Adjustment_Id
		From dbo.StockpileAdjustment
		Where Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id

		If (@Stockpile_Adjustment_Id Is Not Null)
		Begin
			Exec dbo.DeleteStockpileAdjustment 
				@iStockpile_Adjustment_Id = @Stockpile_Adjustment_Id
		End
		
		--Remove Grades
		Delete 
		From dbo.StockpileSurveySampleGrade
		Where Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id

		--Remove the sample
		Delete
		From dbo.StockpileSurveySample 
		Where Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
			Rollback Transaction

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileSurveySample">
 <Procedure>
	Deletes records from the following tables:
		StockpileSurveySampleGrade
		StockpileSurveySample
	Any adjustments related to the @Stockpile_Survey_Sample_Id value are deleted by calling the DeleteStockpileAdjustment procedure.
	Errors are raised if:
		The stockpile survey sample does not exist
		The survey is approved
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileSurveySample.prc'
GO

If object_id('dbo.AddOrUpdateStockpileSurveySample') is not Null 
     Drop Procedure dbo.AddOrUpdateStockpileSurveySample
Go 
  
Create Procedure dbo.AddOrUpdateStockpileSurveySample 
( 
    @iStockpile_Id Int,
	@iBuild_Id Int = Null,
	@iStockpile_Survey_Date Datetime,
	@iStockpile_Survey_Shift Char(1),
	@iStockpile_Survey_Type_Id Int,
	@iImported_Datetime Datetime,
	@iIs_Auto_Adjusting Bit = Null,
	@iIs_Tonnes_Survey Bit,
	@iIs_Grades_Survey Bit,
	@iTonnes Float = Null,
	@iAdjust_Haulage Bit = 0,
	@iUse_Given_Moisture_Scaling Bit = 1,
	@oStockpile_Survey_Sample_Id Int = Null Output
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Stockpile_Adjustment_Id Int
	Declare @Stockpile_Name Varchar(31)

    Begin Try
		
		--Ensure Survey Type Exists
		If dbo.DoesStockpileSurveyTypeExist(@iStockpile_Survey_Type_Id) <> 1
		Begin
			Raiserror ('The stockpile survey type does not exist', 16, 1)
		End

		--Check Stockpile Exists
		If Not Exists
			(
				Select 1 
				From Stockpile 
				Where Stockpile_Id = @iStockpile_Id
			)
		Begin
			Raiserror ('The stockpile does not exist', 16, 1)
		End
		
		--If there is not a record for this date/shift and type in StockpileSurvey 
		If dbo.IsStockpileBuildActive (@iStockpile_Id, @iBuild_Id, @iStockpile_Survey_Date, @iStockpile_Survey_Shift) <> 1
		Begin
			Raiserror ('The stockpile build is not active on the given date/shift', 16, 1)
		End
				
		If Exists
			(
				Select 1
				From dbo.StockpileSurvey As S
				Where S.Is_Approved = 1
					And S.Stockpile_Survey_Date = @iStockpile_Survey_Date
					And S.Stockpile_Survey_Shift = @iStockpile_Survey_Shift
					And S.Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
			)
		Begin
			Raiserror('This stockpile survey has been approved. Please unapprove the survey before modifying.', 16, 1)		
		End

		--Work out the default Auto Adjust based on survey type
		If (@iIs_Auto_Adjusting Is Null)
		Begin
			Select @iIs_Auto_Adjusting = Is_Auto_Adjusting
			From dbo.StockpileSurveyType
			Where Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
		End

		If dbo.DoesStockpileSurveySampleExist(@iStockpile_Id, @iBuild_Id, @iStockpile_Survey_Date, @iStockpile_Survey_Shift) = 0
		Begin
			--Do not enter empty Tonnes samples
			If @iIs_Tonnes_Survey = 1 And @iTonnes Is Not Null
			Begin
				Insert Into StockpileSurveySample
				(
					Stockpile_Survey_Date, Stockpile_Survey_Shift, Stockpile_Id, Build_Id,
					Stockpile_Survey_Type_Id, Is_Auto_Adjusting, Imported_Datetime, Is_Tonnes_Survey, Is_Grades_Survey,
					Tonnes, Use_Given_Moisture_Scaling
				)
				Select @iStockpile_Survey_Date, @iStockpile_Survey_Shift, @iStockpile_Id, @iBuild_Id,
					@iStockpile_Survey_Type_Id, @iIs_Auto_Adjusting, IsNull(@iImported_Datetime, GetDate()), @iIs_Tonnes_Survey, @iIs_Grades_Survey,
					@iTonnes, @iUse_Given_Moisture_Scaling

				Set @oStockpile_Survey_Sample_Id = Scope_Identity()
			End
			Else
			Begin
				Set @oStockpile_Survey_Sample_Id = -1
			End
		End
		Else
		Begin
			Select @oStockpile_Survey_Sample_Id = Stockpile_Survey_Sample_Id
			From StockpileSurveySample
			Where Stockpile_Survey_Date = @iStockpile_Survey_Date
				And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
				And Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id

			If @iIs_Tonnes_Survey = 1 And @iTonnes Is Null
			Begin
				--Remove the sample
				Exec dbo.DeleteStockpileSurveySample
					@iStockpile_Survey_Sample_Id = @oStockpile_Survey_Sample_Id

				Set @oStockpile_Survey_Sample_Id = -1
			End
			Else
			Begin
				Update StockpileSurveySample
				Set	Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id,
					Is_Auto_Adjusting = @iIs_Auto_Adjusting,
					Imported_Datetime = IsNull(@iImported_Datetime, GetDate()),
					Is_Tonnes_Survey = @iIs_Tonnes_Survey,
					Is_Grades_Survey = @iIs_Grades_Survey,
					Tonnes = @iTonnes,
					Use_Given_Moisture_Scaling = @iUse_Given_Moisture_Scaling
				Where Stockpile_Survey_Sample_Id = @oStockpile_Survey_Sample_Id
			End
		End

		--Auto Adjusted Samples are ignored by the recalc so they will automatically create
		--a stockpile adjustment for this stockpile.
		--Make sure the sample was not deleted also.
		If (@iIs_Auto_Adjusting = 1) And (@oStockpile_Survey_Sample_Id <> -1)
		Begin
			--Remove any existing adjustment for this Survey Id
			Select @Stockpile_Adjustment_Id = Stockpile_Adjustment_Id
			From dbo.StockpileAdjustment
			Where Stockpile_Survey_Sample_Id = @oStockpile_Survey_Sample_Id

			If (@Stockpile_Adjustment_Id Is Not Null)
			Begin
				Exec DeleteStockpileAdjustment 
					@iStockpile_Adjustment_Id = @Stockpile_Adjustment_Id
			End

			Set @Stockpile_Adjustment_Id = Null

			-- Delete any existing adjustments for this stockpile build, date and shift
			Select @Stockpile_Adjustment_Id = Stockpile_Adjustment_Id
			From dbo.StockpileAdjustment
			Where Stockpile_Id = @iStockpile_Id
				And Build_Id = @iBuild_Id
				And Adjustment_Date = @iStockpile_Survey_Date
				And Adjustment_Shift = @iStockpile_Survey_Shift

			If (@Stockpile_Adjustment_Id Is Not Null)
			Begin
				Exec DeleteStockpileAdjustment 
					@iStockpile_Adjustment_Id = @Stockpile_Adjustment_Id
			End

			--Add a stockpile adjustment to set the new tonnes of the stockpile
			Exec AddStockpileAdjustment	
				@iStockpile_Id = @iStockpile_Id, 
				@iBuild_Id = @iBuild_Id, 
				@iAdjustment_Date = @iStockpile_Survey_Date,
				@iAdjustment_Shift = @iStockpile_Survey_Shift, 
				@iStockpile_Survey_Sample_Id = @oStockpile_Survey_Sample_Id,
				@iDescription = 'Stockpile Survey Auto Adjustment',
				@iIs_Add_Or_Remove = 0, 
				@iIs_Tonnes_Adjustment = @iIs_Tonnes_Survey,
				@iIs_Grades_Adjustment = @iIs_Grades_Survey,
				@iIs_Manual = 0, 
				@iTonnes = @iTonnes
		End

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.AddOrUpdateStockpileSurveySample TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileSurveySample">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileSurveySample table.
	If this is a new record a record is added to the StockpileSurvey table for this @Stockpile_Survey_Date,
	@Stockpile_Survey_Shift and @Stockpile_Survey_Type_Id if it does not already exist
	If the  If this survey is auto adjusting (the @Is_Auto_Adjusting is set to 1) a stockpile adjustment is added
	to set the new tonnes for the stockpile (any previous stockpile adjustments for this stockpile build and date 
	are first removed. 
	
	Will Remove sample if a tonnes survey is passed in but the tonnes value is Null.

	Errors raised if:
		The stockpile survey type does not exist
		The stockpile does not exist
		The stockpile build is not active on the given date/shift
		The Survey is approved.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.ApproveStockpileSurvey.prc'
GO

If object_id('dbo.ApproveStockpileSurvey') is not Null 
     Drop Procedure dbo.ApproveStockpileSurvey 
Go 
  
Create Procedure dbo.ApproveStockpileSurvey 
( 
    @iStockpile_Survey_Date Datetime,
	@iStockpile_Survey_Shift Char(1),
	@iStockpile_Survey_Type_Id Int 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @StartDate DateTime,
		@StartShift Char(1)

	Declare @SURVEY table
	(
		Stockpile_Survey_Type_Id Int,
		Stockpile_Survey_Type_Name Varchar(63) Collate Database_Default, 
		Start_Date DateTime,
		Start_Shift Char(1) Collate Database_Default,
		End_Date DateTime,
		End_Shift Char(1) Collate Database_Default,
		End_Shift_Order_No Int,
		Is_Approved Bit,
		Adjust_Haulage Bit
	)  

	Begin Try
		--Get Survey Info 
		Insert Into @SURVEY
		Exec dbo.GetStockpileSurveyList
			@iStockpile_Survey_Date = @iStockpile_Survey_Date,
			@iStockpile_Survey_Shift = @iStockpile_Survey_Shift,
			@iStockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id		

		Select @StartDate = Start_Date, @StartShift = Start_Shift
		From @SURVEY

		--Ensure there are no adjustments during this period
		If Exists
			(
				Select 1
				From dbo.StockpileAdjustment
				Where Adjustment_Date Between @StartDate and @iStockpile_Survey_Date --Optimised for index
					And dbo.CompareDateShift(Adjustment_Date, Adjustment_Shift, '>=', @StartDate, @StartShift) = 1
					And dbo.CompareDateShift(Adjustment_Date, Adjustment_Shift, '<=', @iStockpile_Survey_Date, @iStockpile_Survey_Shift) = 1
			)
		Begin
			Raiserror ('Stockpile survey period can not be approved due to stockpile adjustments in period', 16, 1)	
		End

		--Check for Monthly Approvals
		If Exists
			(
				Select 1
				From dbo.MonthlyApproval As A
					Inner Join @SURVEY As S
						On (A.Monthly_Approval_Month Between S.Start_Date And S.End_Date)
				Where A.Is_Approved = 1
			)
		Begin
			Raiserror('At least part of the stockpile survey falls in an already approved month', 16, 1)
		End

		--Ensure there is no unapproved stockpile survey periods before this stockpile survey period
		If Exists
			(
				Select 1
				From dbo.StockpileSurvey
				Where Stockpile_Survey_Date < @iStockpile_Survey_Date --Optimised for index
					And dbo.CompareDateShift(Stockpile_Survey_Date, Stockpile_Survey_Shift, '<', @iStockpile_Survey_Date, @iStockpile_Survey_Shift) = 1
					And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id
					And Is_Approved = 0
					And Adjust_Haulage = 1
			)
		Begin
			Raiserror ('Unapproved stockpile surveys before this stockpile survey that modify haulage must be approved before trying to approve this survey', 16, 1)
		End
	  
		--Ensure theres actual samples in there
		If Not Exists
			(
				Select 1
				From dbo.StockpileSurveySample
				Where Stockpile_Survey_Date = @iStockpile_Survey_Date
					And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
					And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id		
			)
		Begin
			Raiserror ('There are no survey records for this survey period. Please add some sample entries.', 16, 1)
		End

		-- Update the stockpile survey record
		Update dbo.StockpileSurvey
		Set	Is_Approved = 1
		Where Stockpile_Survey_Date = @iStockpile_Survey_Date
			And Stockpile_Survey_Shift = @iStockpile_Survey_Shift
			And Stockpile_Survey_Type_Id = @iStockpile_Survey_Type_Id

		-- Recalculate for the given period
		Exec RecalcL2Raise
			@pDate = @StartDate,
			@pShift = @StartShift

		Commit Transaction 
	End Try
	Begin Catch
		If @@Trancount > 0
			Rollback Transaction
	
		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 
GRANT EXECUTE ON dbo.ApproveStockpileSurvey TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="ApproveStockpileSurvey">
 <Procedure>
	Updates a record in the StockpileSurvey table to set the Is_Approved to 1.
	Errors are raised if:
		There are associated stockpile adjustments in this period
		There are unapproved stockpile surveys before this stockpile survey 
		There are no survey samples
		Survey is in an approved period
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileAdjustmentGrade.prc'
GO

If object_id('dbo.AddOrUpdateStockpileAdjustmentGrade') is not Null 
     Drop Procedure dbo.AddOrUpdateStockpileAdjustmentGrade 
Go 
  
Create Procedure dbo.AddOrUpdateStockpileAdjustmentGrade 
( 
    @iStockpile_Adjustment_Id Int,
	@iGrade_Id SmallInt,
	@iGrade_Value real = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @Adjustment_Date DateTime,
		@Adjustment_Shift Varchar(1)

	Begin Try
		--Check Grade and Adjustment exist
		If Not Exists	
			(
				Select 1
				From dbo.Grade
				Where Grade_Id = @iGrade_Id
			)
		Begin
			RaisError('The grade id specified does not exist.', 16, 1)
		End

		If Not Exists
			(
				Select 1 
				From dbo.StockpileAdjustment
				Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
			)
		Begin
			RaisError('The stockpile adjustment id specified does not exist.', 16, 1)
		End

		--If the new value is null then we want to remove the entry
		If @iGrade_Value is Null 
		Begin
			Delete
			From dbo.StockpileAdjustmentGrade
			Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
					And Grade_Id = @iGrade_Id 
		End
		--If entry does not exist yet then insert it
		Else If Not Exists
			( 
				Select 1
				From dbo.StockpileAdjustmentGrade
				Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
					And Grade_Id = @iGrade_Id 
			)
		Begin
				Insert Into dbo.StockpileAdjustmentGrade
				(
					Stockpile_Adjustment_Id, Grade_Id, Grade_Value
				)
				Select @iStockpile_Adjustment_Id, @iGrade_Id, @iGrade_Value
		End
		--If it does exist then we want to update the entry
		Else
		Begin
			Update dbo.StockpileAdjustmentGrade
			Set Grade_Value = @iGrade_Value
			Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
				And Grade_Id = @iGrade_Id 
		End

		Select @Adjustment_Date = Adjustment_Date,
			@Adjustment_Shift = Adjustment_Shift 
		From dbo.StockpileAdjustment

		--Raise Level 2 Recalc
		Exec RecalcL2Raise 
			@pDate = @Adjustment_Date, 
			@pShift = @Adjustment_Shift

		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch	
End 
Go 
GRANT EXECUTE ON dbo.AddOrUpdateStockpileAdjustmentGrade TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileAdjustmentGrade">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileAdjustmentGrade table.
	Raises a 2nd Level recalc for the date that the adjustment occurred.
	Errors not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlanDetails.prc'
GO

If Object_Id('dbo.GetMinePlanDetails') Is Not Null
	Drop Procedure dbo.GetMinePlanDetails
Go

Create Procedure dbo.GetMinePlanDetails
(
	@iMine_Plan_Id Int,
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null,
	@iInclude_Grades Bit = 1,
	@iInclude_Locations Bit = 1
)

With Encryption
As

Begin
	-- returns four result sets
	-- 1. The general mine plan details
	-- 2. the mine plan period records
	-- 3. the grades
	-- 4. the locations

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	--Return the Plan Details
	Exec GetMinePlan 
		@iMine_Plan_Id = @iMine_Plan_Id

	Select MPPT.Mine_Plan_Period_Type_Name, MPPTG.Mine_Plan_Period_Type_Group_Name, 
		MPP.Mine_Plan_Period_Id, MPP.Start_Date, MPP.End_Date, 
		MT.Material_Type_Id, MT.Abbreviation, MT.Description,
		MPP.Tonnes
	From dbo.MinePlanPeriod As MPP
		Left Outer Join dbo.MaterialType As MT
			On (MPP.Material_Type_Id = MT.Material_Type_Id)
		Inner Join dbo.MinePlanPeriodType As MPPT
			On (MPP.Mine_Plan_Period_Type_Id = MPPT.Mine_Plan_Period_Type_Id)
		Inner Join dbo.MinePlanPeriodTypeGroup As MPPTG
			On (MPPT.Mine_Plan_Period_Type_Group_Id = MPPTG.Mine_Plan_Period_Type_Group_Id)
	Where MPP.Mine_Plan_Id = @iMine_Plan_Id
		And MPP.End_Date >= IsNull(@iStart_Date, MPP.End_Date) 
		And MPP.Start_Date <= IsNull(@iEnd_Date, MPP.Start_Date)
	Order By MPP.Start_Date, Mine_Plan_Period_Id

	If @iInclude_Grades = 1
	Begin
		Select MPPG.Mine_Plan_Period_Id, MPPG.Grade_Id, MPPG.Grade_Value
		From dbo.MinePlanPeriodGrade As MPPG
			Inner Join dbo.MinePlanPeriod As MPP
				On (MPPG.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
		Where MPP.Mine_Plan_Id = @iMine_Plan_Id
			And MPP.End_Date >= IsNull(@iStart_Date, MPP.End_Date) 
			And MPP.Start_Date <= IsNull(@iEnd_Date, MPP.Start_Date)
		Order By MPPG.Grade_Id
	End

	If @iInclude_Locations = 1
	Begin
		Select MPPL.Mine_Plan_Period_Id, L.Location_Type_Id, L.Name As Location_Name
		From dbo.MinePlanPeriodLocation As MPPL
			Inner Join dbo.Location As L
				On (MPPL.Location_Id = L.Location_Id)
			Inner Join dbo.MinePlanPeriod As MPP
				On (MPPL.Mine_Plan_Period_Id = MPP.Mine_Plan_Period_Id)
		Where MPP.Mine_Plan_Id = @iMine_Plan_Id
			And MPP.End_Date >= IsNull(@iStart_Date, MPP.End_Date) 
			And MPP.Start_Date <= IsNull(@iEnd_Date, MPP.Start_Date)
		Order By L.Location_Type_Id
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="GetMinePlanDetails">
 <Procedure>
	Returns four result sets
	1. The general mine plan details
	2. the mine plan period records
	3. the grades
	4. the locations
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateLocation.prc'
GO

IF OBJECT_ID('dbo.UpdateLocation') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateLocation 
GO 
  
CREATE PROCEDURE dbo.UpdateLocation 
( 
    @iLocation_Id INT,
	@iName VARCHAR(31),
	@iLocation_Type_Id TINYINT,
	@iParent_Location_Id INT = NULL,
	@iDescription VARCHAR(255)
) 
WITH ENCRYPTION
AS 
BEGIN 

    SET NOCOUNT ON
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
	
	BEGIN TRY
		-- IF the given location type does NOT EXISTS
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.LocationType 
				WHERE Location_Type_Id = @iLocation_Type_Id
			)
		BEGIN
			Raiserror('The given location type does NOT exist', 16, 1)
		END

		-- IF the location does NOT exist
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.Location 
				WHERE Location_Id = @iLocation_Id
			)
		BEGIN
			Raiserror('The given location ID does NOT exist', 16, 1)
		END

		-- The name can NOT be NULL
		IF @iName IS NULL
		BEGIN
			Raiserror('The given name can NOT be NULL', 16, 1)
		END

		-- Check unique combination of Location_Type_Id AND Name.
		IF EXISTS 
			(
				SELECT 1 
				FROM dbo.Location AS L 
				WHERE L.Location_Type_Id = @iLocation_Type_Id
					AND L.[Name] = @iName
					AND Coalesce(L.Parent_Location_Id,-1) = Coalesce(@iParent_Location_Id,-1)
					AND L.Location_Id <> @iLocation_Id
			)
		BEGIN
			Raiserror('The unique combination of Location Type ID and Name already exists', 16, 1)
		END
		
		--Check the Parent/Child Relationship IS valid
		IF @iParent_Location_Id IS NOT NULL
			AND NOT EXISTS
			(
				SELECT 1
				FROM dbo.Location AS PL
					INNER JOIN LocationType AS PLT
						ON PL.Location_Type_Id = PLT.Location_Type_Id
					INNER JOIN LocationType AS LT
						ON PL.Location_Type_Id = LT.Parent_Location_Type_Id
				WHERE PL.Location_Id = @iParent_Location_Id
					AND LT.Location_Type_Id = @iLocation_Type_Id
			)
		BEGIN
			Raiserror('The location type for this location is not a valid child location for its parent.', 16, 1)
		END
		Else IF EXISTS
			(
				SELECT 1 
				FROM dbo.LocationType
				WHERE Location_Type_Id = @iLocation_Type_Id
					AND Parent_Location_Type_Id IS NOT NULL
			) AND @iParent_Location_Id IS NULL
		BEGIN
			Raiserror('The location type must have a parent location.', 16, 1)	
		END


		UPDATE dbo.Location
		SET [Name] = @iName,
			Location_Type_Id = @iLocation_Type_Id,
			Parent_Location_Id = @iParent_Location_Id,
			Description = @iDescription
		WHERE Location_Id = @iLocation_Id
	
		COMMIT TRANSACTION
	END TRY
	BEGIN Catch
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END Catch 
END 
GO 
GRANT EXECUTE ON dbo.UpdateLocation TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateLocation">
 <Procedure>
	Update the details of Location @iLocation_Id.
	Errors are raised if:
		The given location type does not exist
		The given location ID does not exist
		The given name can not be null
		The unique combination of Location Type ID and Name already exists
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDataException.prc'
GO

If object_id('dbo.AddDataException') is not Null 
     Drop Procedure dbo.AddDataException 
Go 
  
Create Procedure dbo.AddDataException 
( 
	@iData_Exception_Type_Id Int,
	@iData_Exception_Date Datetime,
	@iData_Exception_Shift Varchar(1),
	@iData_Exception_Status_Id Varchar(5),
	@iShort_Description Varchar(128),
	@iLong_Description Varchar(1046),
	@iDetails_XML Xml,
    @oData_Exception_Id BigInt = NULL Output
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Insert Into DataException
	(
		Data_Exception_Type_Id, Data_Exception_Date, Data_Exception_Shift,
		Data_Exception_Status_Id, Short_Description, Long_Description,
		Details_XML
	)
	Select @iData_Exception_Type_Id, @iData_Exception_Date, @iData_Exception_Shift,
		@iData_Exception_Status_Id, @iShort_Description, @iLong_Description,
		@iDetails_XML
		
	Set @oData_Exception_Id = @@identity	
  
    Commit Transaction 
End 
Go	
GRANT EXECUTE ON dbo.AddDataException TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddDataException">
 <Procedure>
	Adds a record to the DataException table
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileStockpileTypePeriod.prc'
GO

If Object_Id('dbo.DeleteStockpileStockpileTypePeriod') Is Not Null
	Drop Procedure dbo.DeleteStockpileStockpileTypePeriod
Go

Create Procedure dbo.DeleteStockpileStockpileTypePeriod
(
	@iStockpile_Id Int
)

With Encryption 
As

Begin

	Set Nocount On

	-- If the given record does not exist
	If Not Exists (	Select 1
					From dbo.StockpileStockpileTypePeriod SSTP
					Where SSTP.Stockpile_Id = @iStockpile_Id 
						And End_Date Is Null)
	Begin
		Raiserror ('The given Stockpile Stockpile Type period record does not exist', 16, 1)
	End
	Else
	Begin

		Begin Transaction

		-- Delete that record
		Delete From dbo.StockpileStockpileTypePeriod
		Where Stockpile_Id = @iStockpile_Id 
			And End_Date Is Null

		-- Update the end date of the last period record to null
		Update SSTP
		Set	End_Date = Null
		From dbo.StockpileStockpileTypePeriod SSTP
		Where SSTP.Stockpile_Id = @iStockpile_Id 
			And End_Date = (Select Max(SSTP2.End_Date)
							From dbo.StockpileStockpileTypePeriod SSTP2
							Where SSTP.Stockpile_Id = SSTP2.Stockpile_Id)

		Commit Transaction
	End

End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileStockpileTypePeriod">
 <Procedure>
	Deletes a record from the StockpileStockpileTypePeriod table and updates the End_Date of the 
	previous entry to Null for this @iStockpile_Id
	
	Errors are raised if:
		The given Stockpile Stockpile Type period record does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuildBalance.prc'
GO

If object_id('dbo.GetStockpileBuildBalance') is not Null 
     Drop Procedure dbo.GetStockpileBuildBalance 
Go 
  
Create Procedure dbo.GetStockpileBuildBalance 
( 
    @iStockpile_Id Int,
	@iBuild_Id Int,
	@iBalance_Date Datetime = Null,
	@iBalance_Shift Char(1) = Null
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @BalanceDate Datetime,
		@BalanceShift Char(1)

	Select @BalanceDate = @iBalance_Date,
		@BalanceShift = @iBalance_Shift

	--Both filters were not provided
	If @BalanceDate Is Null And @BalanceShift Is Null
	Begin
		Select @BalanceDate = SB.Last_Recalc_Date,
			@BalanceShift = SB.Last_Recalc_Shift
		From dbo.StockpileBuild As SB
		Where SB.Stockpile_Id = @iStockpile_Id
			And SB.Build_Id = @iBuild_Id
	End
	
	--If just balance date was not provided
	If @BalanceDate Is Null
	Begin
		Select @BalanceDate = SB.Last_Recalc_Date
		From dbo.StockpileBuild As SB
		Where SB.Stockpile_Id = @iStockpile_Id
			And SB.Build_Id = @iBuild_Id
	End

	--If just the shift was not provided
	If @BalanceShift Is Null
	Begin
		Select @BalanceShift = dbo.GetLastShiftType()
	End

	--Return Tonnes Balance
	Select Sum(B.Tonnes) As Tonnes
	From dbo.DataProcessStockpileBalance As B
	Where B.Data_Process_Stockpile_Balance_Date = @BalanceDate
		And B.Data_Process_Stockpile_Balance_Shift = @BalanceShift
		And B.Stockpile_Id = @iStockpile_Id
		And B.Build_Id = @iBuild_Id
	Group By B.Stockpile_Id, B.Build_Id

	--Return Grades Balance
	Select BG.Grade_Id, Sum(B.Tonnes * BG.Grade_Value) / NullIf(Sum(B.Tonnes), 0) As Grade_Value
	From dbo.DataProcessStockpileBalance As B
		Inner Join dbo.DataProcessStockpileBalanceGrade As BG
			On B.Data_Process_Stockpile_Balance_Id = BG.Data_Process_Stockpile_Balance_Id
	Where B.Data_Process_Stockpile_Balance_Date = @BalanceDate
		And B.Data_Process_Stockpile_Balance_Shift = @BalanceShift
		And B.Stockpile_Id = @iStockpile_Id
		And B.Build_Id = @iBuild_Id
	Group By B.Stockpile_Id, B.Build_Id, BG.Grade_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetStockpileBuildBalance TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileBuildBalance">
 <Procedure>
	Returns the stockpile balance tonnes and grades for a given date and shift. 
	If the balance date is not provided then the latest balance date possible is used.
	If the balance shift is not provided then the last shift is used.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileRunningBalance.prc'
GO

IF object_id('dbo.GetStockpileRunningBalance') IS NOT NULL 
     DROP PROCEDURE dbo.GetStockpileRunningBalance 
GO 
  
CREATE PROCEDURE dbo.GetStockpileRunningBalance 
( 
	@iStockpile_Id INT,
	@iStart_Date DATETIME,
	@iEnd_Date DATETIME,
	@iGrade_Visibility Bit = 1,
	@iGrade_Type Varchar(31) = Null
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 

	DECLARE @JoinColumns VARCHAR(255)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1)
  
	CREATE TABLE #TRANSACTION
	(
		Transaction_Type VARCHAR(31) COLLATE Database_Default NOT NULL,
		Transaction_Date DATETIME NOT NULL,
		Tonnes FLOAT NULL,

		PRIMARY KEY (Transaction_Type, Transaction_Date)
	)

	CREATE TABLE #TRANSACTION_GRADE
	(
		Transaction_Type VARCHAR(31) COLLATE Database_Default NOT NULL,
		Transaction_Date DATETIME NOT NULL,
		Grade_Id INT NOT NULL,  
		Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Value REAL NULL

		PRIMARY KEY (Transaction_Type, Transaction_Date, Grade_Id)
	)

	--Insert Base set of grades
	INSERT INTO #TRANSACTION_GRADE
	(
		Transaction_Type, Transaction_Date, Grade_Id, Grade_Name, Grade_Value
	)
	SELECT '', getdate(), Grade_Id, Grade_Name, NULL
	FROM dbo.Grade AS G
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND (G.Grade_Type_Id = @iGrade_Type
			OR @iGrade_Type IS NULL)

	--Retrieve Transaction Tonnages
	INSERT INTO #TRANSACTION
	(
		Transaction_Type, Transaction_Date, Tonnes
	)
	--Get Addition Transactions
	SELECT 'Additions', T.Data_Process_Transaction_Date, Sum(T.Tonnes)
	FROM dbo.DataProcessTransaction AS T
	WHERE T.Destination_Stockpile_Id = @iStockpile_Id
		AND T.Data_Process_Transaction_Date Between @iStart_Date AND @iEnd_Date
		AND T.Stockpile_Adjustment_Id IS NULL
	GROUP BY T.Data_Process_Transaction_Date
	--Get Removal Transactions
	UNION ALL
	SELECT 'Removals', T.Data_Process_Transaction_Date, Sum(T.Tonnes)
	FROM dbo.DataProcessTransaction AS T
	WHERE T.Source_Stockpile_Id = @iStockpile_Id
		AND T.Data_Process_Transaction_Date Between @iStart_Date AND @iEnd_Date
		AND T.Stockpile_Adjustment_Id IS NULL
	GROUP BY T.Data_Process_Transaction_Date
	--Get Balance Transactions
	UNION ALL
	SELECT 'Balances', B.Data_Process_Stockpile_Balance_Date, Sum(B.Tonnes)
	FROM dbo.DataProcessStockpileBalance AS B
	WHERE B.Stockpile_Id = @iStockpile_Id
		AND B.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
		AND B.Data_Process_Stockpile_Balance_Shift = dbo.GetLastShiftType()
	GROUP BY B.Data_Process_Stockpile_Balance_Date	

	--Retrieve Transaction Grades
	INSERT INTO #TRANSACTION_GRADE
	(
		Transaction_Type, Transaction_Date, Grade_Id, Grade_Name, Grade_Value
	)
	--Get Addition TRANSACTION Grades
	SELECT 'Additions', T.Data_Process_Transaction_Date, G.Grade_Id, G.Grade_Name,
		Sum(T.Tonnes * TG.Grade_Value) / NullIf(Sum(T.Tonnes), 0)
	FROM dbo.DataProcessTransaction AS T
		INNER JOIN dbo.DataProcessTransactionGrade AS TG
			ON (T.Data_Process_Transaction_Id = TG.Data_Process_Transaction_Id)
		INNER JOIN dbo.Grade AS G
			ON (TG.Grade_Id = G.Grade_Id)
	WHERE T.Destination_Stockpile_Id = @iStockpile_Id
		AND T.Data_Process_Transaction_Date Between @iStart_Date AND @iEnd_Date
		AND T.Stockpile_Adjustment_Id IS NULL
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND (G.Grade_Type_Id = @iGrade_Type
			OR @iGrade_Type IS NULL)
	GROUP BY T.Data_Process_Transaction_Date, G.Grade_Id, G.Grade_Name
	--Get Removal Transaction Grades
	UNION ALL
	SELECT 'Removals', T.Data_Process_Transaction_Date, G.Grade_Id, G.Grade_Name,
		Sum(T.Tonnes * TG.Grade_Value) / NullIf(Sum(T.Tonnes), 0)
	FROM dbo.DataProcessTransaction AS T
		INNER JOIN dbo.DataProcessTransactionGrade AS TG
			ON (T.Data_Process_Transaction_Id = TG.Data_Process_Transaction_Id)
		INNER JOIN dbo.Grade AS G
			ON (TG.Grade_Id = G.Grade_Id)
	WHERE T.Source_Stockpile_Id = @iStockpile_Id
		AND T.Data_Process_Transaction_Date Between @iStart_Date AND @iEnd_Date
		AND T.Stockpile_Adjustment_Id IS NULL
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND (G.Grade_Type_Id = @iGrade_Type
			OR @iGrade_Type IS NULL)
	GROUP BY T.Data_Process_Transaction_Date, G.Grade_Id, G.Grade_Name
	--Get Balance Transactions
	UNION ALL
	SELECT 'Balances', B.Data_Process_Stockpile_Balance_Date, G.Grade_Id, G.Grade_Name,
		Sum(B.Tonnes * BG.Grade_Value) / NullIf(B.Tonnes, 0)
	FROM dbo.DataProcessStockpileBalance AS B
		INNER JOIN dbo.DataProcessStockpileBalanceGrade AS BG
			ON (B.Data_Process_Stockpile_Balance_Id = BG.Data_Process_Stockpile_Balance_Id)
		INNER JOIN dbo.Grade AS G
			ON (BG.Grade_Id = G.Grade_Id)
	WHERE B.Stockpile_Id = @iStockpile_Id
		AND B.Data_Process_Stockpile_Balance_Date Between @iStart_Date AND @iEnd_Date
		AND B.Data_Process_Stockpile_Balance_Shift = dbo.GetLastShiftType()
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND (G.Grade_Type_Id = @iGrade_Type
			OR @iGrade_Type IS NULL)
	GROUP BY B.Data_Process_Stockpile_Balance_Date, G.Grade_Id, G.Grade_Name, B.Tonnes
	
	--If close on a shift that is not the last still need the balance
	Select @EndDate = End_Date, @EndShift = End_Shift
	From dbo.StockpileBuild As S
	Where S.Stockpile_Id = @iStockpile_Id

	IF @EndDate <= @iEnd_Date And @EndDate >= @iStart_Date And @EndShift <> dbo.GetLastShiftType()
	BEGIN
		INSERT INTO #TRANSACTION
		(
			Transaction_Type, Transaction_Date, Tonnes
		)
		SELECT 'Balances', B.Data_Process_Stockpile_Balance_Date, Sum(B.Tonnes)
		FROM dbo.DataProcessStockpileBalance AS B
		WHERE B.Stockpile_Id = @iStockpile_Id
			AND B.Data_Process_Stockpile_Balance_Date = @EndDate
			AND B.Data_Process_Stockpile_Balance_Shift = @EndShift
		GROUP BY B.Data_Process_Stockpile_Balance_Date

		--Grades
		INSERT INTO #TRANSACTION_GRADE
		(
			Transaction_Type, Transaction_Date, Grade_Id, Grade_Name, Grade_Value
		)
		SELECT 'Balances', B.Data_Process_Stockpile_Balance_Date, G.Grade_Id, G.Grade_Name,
			Sum(B.Tonnes * BG.Grade_Value) / NullIf(B.Tonnes, 0)
		FROM dbo.DataProcessStockpileBalance AS B
			INNER JOIN dbo.DataProcessStockpileBalanceGrade AS BG
				ON (B.Data_Process_Stockpile_Balance_Id = BG.Data_Process_Stockpile_Balance_Id)
			INNER JOIN dbo.Grade AS G
				ON (BG.Grade_Id = G.Grade_Id)
		WHERE B.Stockpile_Id = @iStockpile_Id
			AND B.Data_Process_Stockpile_Balance_Date = @EndDate
			AND B.Data_Process_Stockpile_Balance_Shift = @EndShift
			AND (G.Is_Visible = @iGrade_Visibility 
				OR @iGrade_Visibility IS NULL)
			AND (G.Grade_Type_Id = @iGrade_Type
				OR @iGrade_Type IS NULL)
		GROUP BY B.Data_Process_Stockpile_Balance_Date, G.Grade_Id, G.Grade_Name, B.Tonnes
	END
	
	--Pivot Grades onto Transaction table
	SET @JoinColumns = '#TRANSACTION.Transaction_Type = #TRANSACTION_GRADE.Transaction_Type ' +
		'AND #TRANSACTION.Transaction_Date = #TRANSACTION_GRADE.Transaction_Date '

	EXEC dbo.PivotTable
		@iTargetTable = '#TRANSACTION',
		@iPivotTable = '#TRANSACTION_GRADE',
		@iJoinColumns = @JoinColumns,
		@iPivotColumn = 'Grade_Name',
		@iPivotValue = 'Grade_Value',
		@iPivotType = 'REAL'

	SELECT *
	FROM #TRANSACTION

	DROP TABLE #TRANSACTION
	DROP TABLE #TRANSACTION_GRADE
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetStockpileRunningBalance TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileRunningBalance">
 <Procedure>
	Returns the daily balances and aggregated daily transactions for a given stockpile and period.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockIdList.prc'
GO

If object_id('dbo.GetDigblockIdList') Is Not Null 
     Drop Procedure dbo.GetDigblockIdList 
Go 
  
Create Procedure dbo.GetDigblockIdList 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select Digblock_Id
	From dbo.Digblock
	Order by Digblock_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockIdList TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockIdList">
 <Procedure>
	Returns a list of digblock ids.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockModelBlockTonnesOverPeriod.prc'
GO

If object_id('dbo.GetDigblockModelBlockTonnesOverPeriod') Is Not Null 
     Drop Procedure dbo.GetDigblockModelBlockTonnesOverPeriod 
Go 
  
Create Procedure dbo.GetDigblockModelBlockTonnesOverPeriod
( 
    @iLocation_Id Int,
	@iBlock_Model_Id Int
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select DL.Digblock_Id, Sum(MBP.Tonnes * IsNull(DMB.Percentage_In_Digblock, 1)) As Tonnes
	From dbo.ModelBlock As MB
		Inner Join dbo.ModelBlockPartial As MBP
			On (MB.Model_Block_Id = MBP.Model_Block_Id)
		Inner Join dbo.DigblockModelBlock as DMB
			On (MB.Model_Block_Id = DMB.Model_Block_Id)
		Inner Join 
			(
				--Eliminate double counting
				Select DL.Digblock_Id
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_Id = DL.Location_Type_Id)
					Inner Join 
						(
							Select *
							From dbo.GetLocationChildLocationList(@iLocation_Id) 
							Union 
							Select @iLocation_Id
						) As L
						On (L.Location_Id = DL.Location_Id)
				Group By DL.Digblock_Id
			) As DL
			On (DMB.Digblock_Id = DL.Digblock_Id)
	Where MB.Block_Model_Id = @iBlock_Model_Id
	Group By DL.Digblock_Id
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockModelBlockTonnesOverPeriod TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockModelBlockTonnesOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total tonnes according to the chosen block model. 
	This is filtered by a parent location that is passed in.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlanStartDateList.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Get_Mine_Plan_Start_Date_List]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[Get_Mine_Plan_Start_Date_List]
GO

CREATE Procedure [dbo].[Get_Mine_Plan_Start_Date_List]

(@Mine_Plan_ID Int)

With Encryption As
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Select Convert(Varchar, MPP.Start_Date, 106) As Start_Date
	From MINE_PLAN MP, MINE_PLAN_PERIOD MPP
	Where MP.Mine_Plan_ID = MPP.Mine_Plan_ID
	And (MP.Mine_Plan_ID = @Mine_Plan_ID
	Or MP.Parent_Mine_Plan_ID = @Mine_Plan_ID)
	Group By MPP.Start_Date
	Order By Cast(MPP.Start_Date As Datetime)

	Set @ELC_Proc_Is_Error = 0
GO


/*
<TAG Name="Data Dictionary" ProcedureName="Get_Mine_Plan_Start_Date_List">
 <Procedure>
	Returns the Mine Plan period start dates.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicHistoryDescription.prc'
GO

If object_id('dbo.GetRecalcLogicHistoryDescription') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicHistoryDescription
Go 
  
Create Procedure dbo.GetRecalcLogicHistoryDescription
( 
    @iRecalc_Logic_History_Id BigInt 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 

	Declare @COMPARISON table
	(
		Item Varchar(31) Collate Database_Default Not Null,
		Old_Value Float Null,
		New_Value Float Null,
		Order_No Int Not Null
	)
  
	--Return the Action and Long description
	Select RLT.Name As Action, RLH.Long_Description
	From dbo.RecalcLogicHistory As RLH
		Inner Join dbo.RecalcLogicType As RLT
			On (RLH.Recalc_Logic_Type_Id = RLT.Recalc_Logic_Type_Id)
	Where RLH.Recalc_Logic_History_Id = @iRecalc_Logic_History_Id

	--Get the before and after comparison table
	Insert Into @COMPARISON
	(
		Item, Old_Value, New_Value, Order_No
	)
	Select 'Tonnes', Old_Tonnes, New_Tonnes, -1
	From dbo.RecalcLogicHistory As RLH
	Where RLH.Recalc_Logic_History_Id = @iRecalc_Logic_History_Id
	Union All
	Select G.Grade_Name, RLHG.Old_Grade_Value, RLHG.New_Grade_Value, G.Order_No
	From dbo.RecalcLogicHistoryGrade As RLHG
		Inner Join dbo.Grade As G 
			On (RLHG.Grade_Id = G.Grade_Id)
	Where RLHG.Recalc_Logic_History_Id = @iRecalc_Logic_History_Id

	Insert Into @COMPARISON
	(
		Item, Old_Value, New_Value, Order_No
	)
	Select G.Grade_Name, Null, Null, G.Order_No
	From dbo.Grade As G
		Left Outer Join @COMPARISON As C
			On (G.Grade_Name = C.Item)
	Group By G.Grade_Name, G.Order_No
	Having count(C.Item) = 0

	Select * 
	From @COMPARISON
	Order By Order_No  

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicHistoryDescription TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicHistoryDescription">
 <Procedure>
	Returns the description of the recalc logic history entry as well as all the before and after 
	details of the record.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicHistoryTransactionLevel0.prc'
GO

If object_id('dbo.GetRecalcLogicHistoryTransactionLevel0') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicHistoryTransactionLevel0 
Go 
  
Create Procedure dbo.GetRecalcLogicHistoryTransactionLevel0 
( 
	@iFrom_Date Datetime ,		
	@iFrom_Shift Char(1),			
	@iTo_Date Datetime,				
	@iTo_Shift Char(1),				
	@iSource Varchar(31) = Null,			
	@iDestination Varchar(31) = Null,		
	@iTransaction_Type Varchar(31) = Null,
	@iInclude_Grades Bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		-- Create a temporary table to hold the main listing information
		Create Table dbo.#TRANSACTION_LIST
		(
			Transaction_List_Id Int Identity(1, 1) Not Null,
			Date Datetime Null,
			Shift Char(1) Collate Database_Default Null,
			Original_Source Varchar(31) Collate Database_Default Null,
			Original_Destination Varchar(31) Collate Database_Default Null,
			Transaction_Type Varchar(31) Collate Database_Default Null,
			Record_Id BigInt Null,
			Recalc_History_Id BigInt Null,
			Recalc_Logic_History_Id BigInt Null,
			Min_Data_Transaction_Tonnes_Id BigInt Null,
			Equipment Varchar(31) Collate Database_Default Null,
			Action Varchar(128) Collate Database_Default Not Null,
			Orig_Tonnes Float Null,
			New_Tonnes Float Null,
			Tonnes_Perc_Diff Real Null,
			Tonnes_Abs_Diff Float Null
			
			--Primary Key (Transaction_List_Id)
		)

		Create NonClustered Index IX_TRANSACTION_LIST_01
			On dbo.#TRANSACTION_LIST (Record_Id)

		-- Create the related grade temporary tables
		Create Table dbo.#TRANSACTION_LIST_GRADE
		(
			Transaction_List_Id Int Not Null,
			Grade_Id Int Not Null,
			Grade_Name Varchar(31) Collate Database_Default Not Null,
			Grade_Value Real Null
	
			Primary Key(Transaction_List_Id, Grade_Name)
		)  

		Declare @From_Shift_Order Int,
			@To_Shift_Order Int

		Select @From_Shift_Order = dbo.GetShiftTypeOrderNo(@iFrom_Shift),
			@To_Shift_Order = dbo.GetShiftTypeOrderNo(@iTo_Shift)

		-- If the option is to include haulage data
		If (IsNull(@iTransaction_Type, 'Haulage') = 'Haulage')
		Begin
			-- Insert the details for haulage records into the temporary table
			Insert Into dbo.#TRANSACTION_LIST
			(
				Date, Shift, Original_Source, Original_Destination,
				Transaction_Type, Record_Id, Min_Data_Transaction_Tonnes_Id,
				Equipment, Action, Orig_Tonnes, New_Tonnes
			)
			Select H.Haulage_Date, H.Haulage_Shift,
				Coalesce(H.Source_Digblock_Id, SS.Stockpile_Name, H.Source_Mill_Id),
				Coalesce(DS.Stockpile_Name, H.Destination_Crusher_Id, H.Destination_Mill_Id),
				'Haulage', H.Haulage_Id, RHLDTT.Min_Data_Transaction_Tonnes_Id,
				H.Truck_Id, 'Summary', H.Tonnes, 0
			From dbo.Haulage As H
				Inner Join dbo.ShiftType As ST
					On (H.Haulage_Shift = ST.Shift)
				Inner Join 
					(
						--Get the minimum DTT Id and ensure that this haulage record has 
						--a logic history record attached to it.
						Select H.Haulage_Id, Min(DTT.Data_Transaction_Tonnes_Id) As Min_Data_Transaction_Tonnes_Id
						From dbo.Haulage As H
							Left Outer Join dbo.DataTransactionTonnes As DTT
								On (DTT.Haulage_Id = H.Haulage_Id)
						Where H.Haulage_Date Between @iFrom_Date And @iTo_Date --Cut down on grouping
							And Exists 
								( 
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH
									Where RLH.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id
									Union
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH 
									Where RLH.Haulage_Id = H.Haulage_Id
								)
						Group by H.Haulage_Id
					) As RHLDTT
					On (H.Haulage_Id = RHLDTT.Haulage_Id)
				Left Outer Join dbo.Stockpile As SS
					On (H.Source_Stockpile_Id = SS.Stockpile_Id)
				Left Outer Join dbo.Stockpile As DS
					On (H.Destination_Stockpile_Id = DS.Stockpile_Id)
			Where H.Haulage_Date Between @iFrom_Date And @iTo_Date --Index Optimisation
				And dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) >= dbo.GetDateShiftAsInt(@iFrom_Date, @From_Shift_Order)
				And dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) <= dbo.GetDateShiftAsInt(@iTo_Date, @To_Shift_Order)
				And (@iSource Is Null
					Or Coalesce(H.Source_Digblock_Id, Convert(Varchar, SS.Stockpile_Id), H.Source_Mill_Id) = @iSource)
				And (@iDestination Is Null
					Or Coalesce(Convert(Varchar, DS.Stockpile_Id), H.Destination_Crusher_Id, H.Destination_Mill_Id) = @iDestination)

			-- Set the new value for tonnes, based on the final version from the transaction table
			-- If the record has no DTT record (ie haulage to crusher with no weightometer sample and the Use CV tonnes setting is true)
			-- Then this is valid as being 0.
			Update TL
			Set	New_Tonnes = IsNull(
				(
					Select Sum(DPT2.Tonnes)
					From dbo.DataProcessTransaction As DPT2
						Inner Join DataTransactionTonnes DTT2
							On DPT2.Data_Transaction_Tonnes_Id = DTT2.Data_Transaction_Tonnes_Id
					Where TL.Record_Id = DTT2.Haulage_Id
				), 0)
			From #TRANSACTION_LIST As TL
			Where TL.Transaction_Type = 'Haulage'


			If @iInclude_Grades = 1 
			Begin
				--Get Original Haulage Grade
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'Orig_' + G.Grade_Name, HG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.HaulageGrade As HG
						On (TL.Record_Id = HG.Haulage_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = HG.Grade_Id)
				Where TL.Transaction_Type = 'Haulage'

				--Get the new mass averaged DPT Grade
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'New_' + G.Grade_Name, 
					Sum(DPTG.Grade_Value * DPT.Tonnes) / NullIf(Sum(DPT.Tonnes), 0)
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnes As DTT
						On (TL.Record_Id = DTT.Haulage_Id)
					Inner Join dbo.DataProcessTransaction As DPT
						On (DPT.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id)
					Inner Join dbo.DataProcessTransactionGrade As DPTG
						On (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Transaction_Type = 'Haulage'
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End

		-- If the option is to include weightometer data
		If (IsNull(@iTransaction_Type, 'Weightometer') = 'Weightometer')
		Begin
			-- Insert the details for weightometer sample records into the temporary table
			Insert Into #TRANSACTION_LIST
			(
				Date, Shift, Original_Source, Original_Destination,
				Transaction_Type, Record_Id, Min_Data_Transaction_Tonnes_Id,
				Equipment, Action, Orig_Tonnes, New_Tonnes
			)
			Select WS.Weightometer_Sample_Date, WS.Weightometer_Sample_Shift,
				Coalesce(SS.Stockpile_Name, WFP.Source_Crusher_Id, WFP.Source_Mill_Id),
				Coalesce(DS.Stockpile_Name, WFP.Destination_Crusher_Id, WFP.Destination_Mill_Id),
				'Weightometer', WS.Weightometer_Sample_Id, RHLDTT.Min_Data_Transaction_Tonnes_Id,
				WS.Weightometer_Id, 'Summary', Coalesce(WS.Corrected_Tonnes, WS.Tonnes), 0
			From dbo.WeightometerSample As WS
				Inner Join dbo.ShiftType As ST
					On (WS.Weightometer_Sample_Shift = ST.Shift)
				Inner Join 
					(
						--Get the minimum DTT Id and ensure that this haulage record has 
						--a logic history record attached to it.
						Select WS.Weightometer_Sample_Id, Min(DTTF.Data_Transaction_Tonnes_Id) As Min_Data_Transaction_Tonnes_Id
						From dbo.WeightometerSample As WS
							Left Outer Join dbo.DataTransactionTonnesFlow As DTTF
								On (WS.Weightometer_Sample_Id = DTTF.Weightometer_Sample_Id)
						Where WS.Weightometer_Sample_Date Between @iFrom_Date And @iTo_Date --Cut down on grouping
							And Exists 
								( 
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH
									Where RLH.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id
									Union
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH 
									Where RLH.Weightometer_Sample_Id = WS.Weightometer_Sample_Id
								)
						Group by WS.Weightometer_Sample_Id
					) As RHLDTT
					On (WS.Weightometer_Sample_Id = RHLDTT.Weightometer_Sample_Id)
				Left Outer Join dbo.WeightometerFlowPeriod As WFP
					On (WS.Weightometer_Id = WFP.Weightometer_Id
						And IsNull(WFP.End_Date, '1900-01-01') = IsNull(	
							( --This sub query adds a second, theres gotta be a better way to optimise
								Select Max(WFP2.End_Date)
								From dbo.WeightometerFlowPeriod As WFP2
								Where WFP2.Weightometer_Id = WS.Weightometer_Id
									And WFP2.End_Date >= WS.Weightometer_Sample_Date
							), '1900-01-01')
						)
				Left Outer Join dbo.Stockpile As SS
					On (Coalesce(WS.Source_Stockpile_Id, WFP.Source_Stockpile_Id) = SS.Stockpile_Id)
				Left Outer Join dbo.Stockpile As DS
					On (Coalesce(WS.Destination_Stockpile_Id, WFP.Destination_Stockpile_Id) = DS.Stockpile_Id)
			Where WS.Weightometer_Sample_Date Between @iFrom_Date And @iTo_Date --Index Optimisation
				And dbo.GetDateShiftAsInt(WS.Weightometer_Sample_Date, ST.Order_No) >= dbo.GetDateShiftAsInt(@iFrom_Date, @From_Shift_Order)
				And dbo.GetDateShiftAsInt(Ws.Weightometer_Sample_Date, ST.Order_No) <= dbo.GetDateShiftAsInt(@iTo_Date, @To_Shift_Order)
				And (@iSource Is Null
					Or Coalesce(Convert(Varchar, SS.Stockpile_Id), WFP.Source_Crusher_Id, WFP.Source_Mill_Id) = @iSource)
				And (@iDestination Is Null
					Or Coalesce(Convert(Varchar, DS.Stockpile_Id), WFP.Destination_Crusher_Id, WFP.Destination_Mill_Id) = @iDestination)

			-- Set the new value for tonnes, based on the final version from the transaction table
			Update TL
			Set	New_Tonnes = AGG.Tonnes
			From dbo.#TRANSACTION_LIST As TL
				Inner Join
					(
						Select TL.Transaction_List_Id, Sum(DPT.Tonnes) As Tonnes
						From dbo.DataProcessTransaction As DPT
							Inner Join dbo.DataTransactionTonnesFlow As DTTF
								On (DPT.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id)
							Inner Join dbo.#TRANSACTION_LIST As TL
								On (TL.Record_Id = DTTF.Weightometer_Sample_Id)	
						Group By TL.Transaction_List_Id
					) As AGG
					On (TL.Transaction_List_Id = AGG.Transaction_List_Id)
			Where TL.Transaction_Type = 'Weightometer'

			-- Insert the related grade records into the grade tables
			If @iInclude_Grades = 1 
			Begin
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'Orig_' + G.Grade_Name, WSG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.WeightometerSampleGrade As WSG
						On (TL.Record_Id = WSG.Weightometer_Sample_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = WSG.Grade_Id)
				Where TL.Transaction_Type = 'Weightometer'

				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id,
					Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'New_' + G.Grade_Name, 
					Sum(DPTG.Grade_Value * DPT.Tonnes) / NullIf(Sum(DPT.Tonnes), 0)
				From #TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnesFlow DTTF
						On TL.Record_Id = DTTF.Weightometer_Sample_Id
					Inner Join dbo.DataProcessTransaction As DPT
						On DPT.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id
					Inner Join dbo.DataProcessTransactionGrade DPTG
						On DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Transaction_Type = 'Weightometer'
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End
			
		-------------------------------------------------------------------------
		-- Update the difference details	
		-------------------------------------------------------------------------
		Update TL
		Set	Tonnes_Perc_Diff = Round((New_Tonnes - Orig_Tonnes) / Orig_Tonnes, 8)
		From dbo.#TRANSACTION_LIST As TL
		Where Orig_Tonnes > 0
			And New_Tonnes > 0

		Update TL
		Set	Tonnes_Abs_Diff = Round(New_Tonnes - Orig_Tonnes, 2)
		From dbo.#TRANSACTION_LIST As TL

		If @iInclude_Grades = 1
		Begin
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Perc_Diff',
				Case When (TLOG.Grade_Value > 0 And TLNG.Grade_Value > 0) Then
					Round((TLNG.Grade_Value - TLOG.Grade_Value) / TLOG.Grade_Value, 8)
				Else
					Null
				End
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0

			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Abs_Diff',
				TLNG.Grade_Value - TLOG.Grade_Value
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0
			
			--Add Missing Grades to the mix to ensure maximum pivot and then pivot
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, Grade_Name
			)
			Select -1, G.Grade_Id, 'Orig_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, 'New_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Abs_Diff' 
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Perc_Diff'
			From dbo.Grade As G

			-- Pivot the grade fields as required
			Exec dbo.PivotTable
				@iTargetTable = '#TRANSACTION_LIST',
				@iPivotTable = '#TRANSACTION_LIST_GRADE',
				@iJoinColumns = '#TRANSACTION_LIST.Transaction_List_Id = #TRANSACTION_LIST_GRADE.Transaction_List_Id',
				@iPivotColumn = 'Grade_Name',
				@iPivotValue = 'Grade_Value',
				@iPivotType = 'Real'
		End

		Select TL.*
		From  dbo.#TRANSACTION_LIST As TL
			Left Outer Join dbo.ShiftType As ST
				On (ST.Shift = TL.Shift)
		Order By Date, ST.Order_No, Min_Data_Transaction_Tonnes_Id, 
			Transaction_Type, Record_Id

		Drop Table dbo.#TRANSACTION_LIST
		Drop Table dbo.#TRANSACTION_LIST_GRADE  
	
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicHistoryTransactionLevel0 TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicHistoryTransactionLevel0">
 <Procedure>
	Returns the base level recalc logic records and the necessary before and after comparison details.
	Transaction type is exclusively, 'Weightometer' or 'Haulage'.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicHistoryTransactionLevel1.prc'
GO

If object_id('dbo.GetRecalcLogicHistoryTransactionLevel1') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicHistoryTransactionLevel1 
Go 
  
Create Procedure dbo.GetRecalcLogicHistoryTransactionLevel1
( 
	@iRecord_Id BigInt,
	@iTransaction_Type Varchar(31),
	@iInclude_Grades Bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
		-- Create a temporary table to hold the main listing information
		Create Table dbo.#TRANSACTION_LIST
		(
			Transaction_List_Id Int Identity(1, 1) Not Null,
			Date Datetime Null,
			Shift Char(1) Collate Database_Default Null,
			Original_Source Varchar(31) Collate Database_Default Null,
			Original_Destination Varchar(31) Collate Database_Default Null,
			Transaction_Type Varchar(31) Collate Database_Default Null,
			Record_Id BigInt Null,
			Recalc_History_Id BigInt Null,
			Recalc_Logic_History_Id BigInt Null,
			Min_Data_Transaction_Tonnes_Id BigInt Null,
			Equipment Varchar(31) Collate Database_Default Null,
			Action Varchar(128) Collate Database_Default Not Null,
			Orig_Tonnes Float Null,
			New_Tonnes Float Null,
			Tonnes_Perc_Diff Real Null,
			Tonnes_Abs_Diff Float Null
			
			--Primary Key (Transaction_List_Id)
		)

		Create NonClustered Index IX_TRANSACTION_LIST_01
			On dbo.#TRANSACTION_LIST (Record_Id)

		-- Create the related grade temporary tables
		Create Table dbo.#TRANSACTION_LIST_GRADE
		(
			Transaction_List_Id Int Not Null,
			Grade_Id Int Not Null,
			Grade_Name Varchar(31) Collate Database_Default Not Null,
			Grade_Value Real Null

			Primary Key(Transaction_List_Id, Grade_Name)
		)  
	
		-- If the raw record is a haulage record
		If (@iTransaction_Type = 'Haulage')
		Begin
			-- Insert the records directly related to the given haulage record
			Insert Into dbo.#TRANSACTION_LIST
			(
				Recalc_Logic_History_Id, Recalc_History_Id, Action,
				Orig_Tonnes, New_Tonnes
			)
			Select RLH.Recalc_Logic_History_Id, RLH.Recalc_History_Id, RLT.Name,
				RLH.Old_Tonnes, RLH.New_Tonnes
			From dbo.RecalcLogicHistory As RLH
				Inner Join dbo.RecalcLogicType As RLT
					On (RLH.Recalc_Logic_Type_Id = RLT.Recalc_Logic_Type_Id)
			Where RLH.Haulage_Id = @iRecord_Id
				And RLH.Data_Transaction_Tonnes_Id Is Null
				And RLH.Data_Process_Transaction_Id Is Null

			If @iInclude_Grades = 1
			Begin
				-- Insert the related grade records into the grade tables
				Insert Into dbo.#TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, 
					Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id,	
					'Orig_' + G.Grade_Name, RLHG.Old_Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.RecalcLogicHistoryGrade As RLHG
						On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = RLHG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Not Null
				Union All
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'New_' + G.Grade_Name, RLHG.New_Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.RecalcLogicHistoryGrade As RLHG
						On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = RLHG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Not Null
			End

			-- Also insert the child summary records created by the level 1 recalculation
			Insert Into dbo.#TRANSACTION_LIST
			(
				Record_Id, Action,
				Orig_Tonnes, New_Tonnes
			)
			Select DTT.Data_Transaction_Tonnes_Id, 'Summary Level 1',
				Null, DTT.Tonnes
			From DataTransactionTonnes As DTT
			Where DTT.Haulage_Id = @iRecord_Id

			If @iInclude_Grades = 1
			Begin
				-- Insert the related final grades
				Insert Into dbo.#TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id,
					Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'Orig_' + G.Grade_Name, HG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnes DTT
						On (TL.Record_Id = DTT.Data_Transaction_Tonnes_Id)
					Inner Join dbo.HaulageGrade As HG
						On (DTT.Haulage_Id = HG.Haulage_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = HG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Null
				Union All
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'New_' + G.Grade_Name, Sum(DPTG.Grade_Value * DPT.Tonnes) / Sum(DPT.Tonnes)
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataProcessTransaction As DPT
						On (DPT.Data_Transaction_Tonnes_Id = TL.Record_Id)
					Inner Join dbo.DataProcessTransactionGrade As DPTG
						On (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Null
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End
		Else
		Begin
			-- Insert the records directly related to the given weightometer sample record
			Insert Into dbo.#TRANSACTION_LIST
			(
				Recalc_Logic_History_Id, Recalc_History_Id, Action,
				Orig_Tonnes, New_Tonnes
			)
			Select RLH.Recalc_Logic_History_Id, RLH.Recalc_History_Id, RLT.Name,
				RLH.Old_Tonnes, RLH.New_Tonnes
			From dbo.RecalcLogicHistory As RLH
				Inner Join dbo.RecalcLogicType As RLT
					On (RLH.Recalc_Logic_Type_Id = RLT.Recalc_Logic_Type_Id)
			Where RLH.Weightometer_Sample_Id = @iRecord_Id
				And RLH.Data_Transaction_Tonnes_Id Is Null
				And RLH.Data_Process_Transaction_Id Is Null

			If @iInclude_Grades = 1
			Begin
				-- Insert the related grade records into the grade tables
				Insert Into dbo.#TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id,
					Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'Orig_' + G.Grade_Name, RLHG.Old_Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.RecalcLogicHistoryGrade As RLHG
						On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
					Inner Join dbo.Grade As G 
						On (G.Grade_Id = RLHG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Not Null
				Union All
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'New_' + G.Grade_Name, RLHG.New_Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.RecalcLogicHistoryGrade As RLHG
						On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
					Inner Join dbo.Grade As G 
						On (G.Grade_Id = RLHG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Not Null
			End

			-- Also insert the child summary records created by the level 1 recalculation
			Insert Into dbo.#TRANSACTION_LIST
			(
				Record_Id, Action,
				Orig_Tonnes, New_Tonnes
			)
			Select DTTF.Data_Transaction_Tonnes_Id, 'Summary Level 1',
				Null, DTT.Tonnes
			From dbo.DataTransactionTonnesFlow As DTTF
				Inner Join dbo.DataTransactionTonnes As DTT
					On (DTTF.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id)
			Where DTTF.Weightometer_Sample_Id = @iRecord_Id

			If @iInclude_Grades = 1
			Begin
				-- Insert the related grade records into the grade tables
				Insert Into dbo.#TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id,
					Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'Orig_' + G.Grade_Name, WSG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnesFlow As DTTF
						On (TL.Record_Id = DTTF.Data_Transaction_Tonnes_Id
							And DTTF.Weightometer_Sample_Id = @iRecord_Id)
					Inner Join dbo.WeightometerSampleGrade As WSG
						On (DTTF.Weightometer_Sample_Id = WSG.Weightometer_Sample_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = WSG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Null

				-- Insert the related final grades
				Insert Into dbo.#TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id,
					Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'New_' + G.Grade_Name, Sum(DPTG.Grade_Value * DPT.Tonnes) / Sum(DPT.Tonnes)
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataProcessTransaction As DPT
						On (DPT.Data_Transaction_Tonnes_Id = TL.Record_Id)
					Inner Join DataProcessTransactionGrade As DPTG
						On (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Recalc_Logic_History_Id Is Null
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End	

		-------------------------------------------------------------------------
		-- Update the difference details	
		-------------------------------------------------------------------------
		Update TL
		Set	Tonnes_Perc_Diff = Round((New_Tonnes - Orig_Tonnes) / Orig_Tonnes, 8)
		From dbo.#TRANSACTION_LIST As TL
		Where Orig_Tonnes > 0
			And New_Tonnes > 0

		Update TL
		Set	Tonnes_Abs_Diff = Round(New_Tonnes - Orig_Tonnes, 2)
		From dbo.#TRANSACTION_LIST As TL

		If @iInclude_Grades = 1
		Begin
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Perc_Diff',
				Case When (TLOG.Grade_Value > 0 And TLNG.Grade_Value > 0) Then
					Round((TLNG.Grade_Value - TLOG.Grade_Value) / TLOG.Grade_Value, 8)
				Else
					Null
				End
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0

			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Abs_Diff',
				TLNG.Grade_Value - TLOG.Grade_Value
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0
			
			--Add Missing Grades to the mix to ensure maximum pivot and then pivot
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, Grade_Name
			)
			Select -1, G.Grade_Id, 'Orig_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, 'New_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Abs_Diff' 
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Perc_Diff'
			From dbo.Grade As G

			-- Pivot the grade fields as required
			Exec dbo.PivotTable
				@iTargetTable = '#TRANSACTION_LIST',
				@iPivotTable = '#TRANSACTION_LIST_GRADE',
				@iJoinColumns = '#TRANSACTION_LIST.Transaction_List_Id = #TRANSACTION_LIST_GRADE.Transaction_List_Id',
				@iPivotColumn = 'Grade_Name',
				@iPivotValue = 'Grade_Value',
				@iPivotType = 'Real'
		End

		Select TL.*
		From dbo.#TRANSACTION_LIST As TL
			Left Outer Join dbo.ShiftType As ST
				On (ST.Shift = TL.Shift)
		Order By Date, ST.Order_No, Min_Data_Transaction_Tonnes_Id, 
			Transaction_Type, Record_Id

		Drop Table dbo.#TRANSACTION_LIST
		Drop Table dbo.#TRANSACTION_LIST_GRADE  

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicHistoryTransactionLevel1 TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicHistoryTransactionLevel1">
 <Procedure>
	Returns the level 1 Recalc logic history for a specified record and transaction type.
	Transaction type is exclusively, 'Weightometer' or 'Haulage'.	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicHistoryTransactionLevel2.prc'
GO

If object_id('dbo.GetRecalcLogicHistoryTransactionLevel2') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicHistoryTransactionLevel2 
Go 
  
Create Procedure dbo.GetRecalcLogicHistoryTransactionLevel2
( 
    @iRecord_Id BigInt,
	@iInclude_Grades Bit = 0
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		-- Create a temporary table to hold the main listing information
		Create Table dbo.#TRANSACTION_LIST
		(
			Transaction_List_Id Int Identity(1, 1) Not Null,
			Date Datetime Null,
			Shift Char(1) Collate Database_Default Null,
			Original_Source Varchar(31) Collate Database_Default Null,
			Original_Destination Varchar(31) Collate Database_Default Null,
			Transaction_Type Varchar(31) Collate Database_Default Null,
			Record_Id BigInt Null,
			Recalc_History_Id BigInt Null,
			Recalc_Logic_History_Id BigInt Null,
			Min_Data_Transaction_Tonnes_Id BigInt Null,
			Equipment Varchar(31) Collate Database_Default Null,
			Action Varchar(128) Collate Database_Default Not Null,
			Orig_Tonnes Float Null,
			New_Tonnes Float Null,
			Tonnes_Perc_Diff Real Null,
			Tonnes_Abs_Diff Float Null
			
			--Primary Key (Transaction_List_Id)
		)

		Create NonClustered Index IX_TRANSACTION_LIST_01
			On dbo.#TRANSACTION_LIST (Record_Id)

		-- Create the related grade temporary tables
		Create Table dbo.#TRANSACTION_LIST_GRADE
		(
			Transaction_List_Id Int Not Null,
			Grade_Id Int Not Null,
			Grade_Name Varchar(31) Collate Database_Default Not Null,
			Grade_Value Real Null

			Primary Key(Transaction_List_Id, Grade_Name)
		)   

		-- Insert the records directly related to the given data transaction tonnes record
		Insert Into dbo.#TRANSACTION_LIST
		(
			Recalc_Logic_History_Id, Recalc_History_Id, Action,
			Orig_Tonnes, New_Tonnes
		)
		Select RLH.Recalc_Logic_History_Id, RLH.Recalc_History_Id, RLT.Name,
			RLH.Old_Tonnes, RLH.New_Tonnes
		From dbo.RecalcLogicHistory As RLH
			Inner Join dbo.RecalcLogicType As RLT
				On (RLH.Recalc_Logic_Type_Id = RLT.Recalc_Logic_Type_Id)
		Where RLH.Data_Transaction_Tonnes_Id = @iRecord_Id
			And RLH.Data_Process_Transaction_Id Is Null

		If @iInclude_Grades = 0
		Begin
			-- Insert the related grade records into the grade tables
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, 
				Grade_Name, Grade_Value
			)
			Select TL.Transaction_List_Id, G.Grade_Id, 
				'Orig_' + G.Grade_Name, RLHG.Old_Grade_Value
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.RecalcLogicHistoryGrade As RLHG
					On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
				Inner Join dbo.Grade As G
					On (G.Grade_Id = RLHG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Not Null	
			Union All
			Select TL.Transaction_List_Id, G.Grade_Id, 
				'New_' + G.Grade_Name, RLHG.New_Grade_Value
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.RecalcLogicHistoryGrade As RLHG
					On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
				Inner Join Grade As G
					On (G.Grade_Id = RLHG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Not Null
		End
		
		-- Also insert the child summary records created by the level 2 recalculation
		Insert Into dbo.#TRANSACTION_LIST
		(
			Record_Id, Action,
			Orig_Tonnes, New_Tonnes
		)
		Select DPT.Data_Process_Transaction_Id, 'Summary Level 2',
			Null, DPT.Tonnes
		From dbo.DataProcessTransaction As DPT
		Where DPT.Data_Transaction_Tonnes_Id = @iRecord_Id
		

		If @iInclude_Grades = 0 
		Begin
			-- Insert the related grade records into the grade tables
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, 
				Grade_Name, Grade_Value
			)
			Select TL.Transaction_List_Id, G.Grade_Id, 
				'Orig_' + G.Grade_Name, DTTG.Grade_Value
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.DataProcessTransaction As DPT
					On (TL.Record_Id = DPT.Data_Process_Transaction_Id)
				Inner Join dbo.DataTransactionTonnesGrade As DTTG
					On (DPT.Data_Transaction_Tonnes_Id = DTTG.Data_Transaction_Tonnes_Id)
				Inner Join dbo.Grade As G
					On (G.Grade_Id = DTTG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Null
			Union All
			Select TL.Transaction_List_Id, G.Grade_Id, 
				'New_' + G.Grade_Name, Sum(DPTG.Grade_Value * DPT.Tonnes) / NullIf(Sum(DPT.Tonnes), 0)
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.DataProcessTransaction As DPT
					On (DPT.Data_Process_Transaction_Id = TL.Record_Id)
				Inner Join dbo.DataProcessTransactionGrade As DPTG
					On (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
				Inner Join dbo.Grade As G
					On (G.Grade_Id = DPTG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Null
			Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
		End
  
		-------------------------------------------------------------------------
		-- Update the difference details	
		-------------------------------------------------------------------------
		Update TL
		Set	Tonnes_Perc_Diff = Round((New_Tonnes - Orig_Tonnes) / Orig_Tonnes, 8)
		From dbo.#TRANSACTION_LIST As TL
		Where Orig_Tonnes > 0
			And New_Tonnes > 0

		Update TL
		Set	Tonnes_Abs_Diff = Round(New_Tonnes - Orig_Tonnes, 2)
		From dbo.#TRANSACTION_LIST As TL

		If @iInclude_Grades = 1
		Begin
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Perc_Diff',
				Case When (TLOG.Grade_Value > 0 And TLNG.Grade_Value > 0) Then
					Round((TLNG.Grade_Value - TLOG.Grade_Value) / TLOG.Grade_Value, 8)
				Else
					Null
				End
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0

			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Abs_Diff',
				TLNG.Grade_Value - TLOG.Grade_Value
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0
			
			--Add Missing Grades to the mix to ensure maximum pivot and then pivot
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, Grade_Name
			)
			Select -1, G.Grade_Id, 'Orig_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, 'New_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Abs_Diff' 
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Perc_Diff'
			From dbo.Grade As G

			-- Pivot the grade fields as required
			Exec dbo.PivotTable
				@iTargetTable = '#TRANSACTION_LIST',
				@iPivotTable = '#TRANSACTION_LIST_GRADE',
				@iJoinColumns = '#TRANSACTION_LIST.Transaction_List_Id = #TRANSACTION_LIST_GRADE.Transaction_List_Id',
				@iPivotColumn = 'Grade_Name',
				@iPivotValue = 'Grade_Value',
				@iPivotType = 'Real'
		End

		Select TL.*
		From dbo.#TRANSACTION_LIST As TL
			Left Outer Join dbo.ShiftType As ST
				On (ST.Shift = TL.Shift)
		Order By Date, ST.Order_No, Min_Data_Transaction_Tonnes_Id, 
			Transaction_Type, Record_Id

		Drop Table dbo.#TRANSACTION_LIST
		Drop Table dbo.#TRANSACTION_LIST_GRADE  

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicHistoryTransactionLevel2 TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicHistoryTransactionLevel2">
 <Procedure>
	Returns the level 2 Recalc logic history for a specified record.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicHistoryTransactionLevel3.prc'
GO

If object_id('dbo.GetRecalcLogicHistoryTransactionLevel3') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicHistoryTransactionLevel3 
Go 
  
Create Procedure dbo.GetRecalcLogicHistoryTransactionLevel3 
( 
    @iRecord_Id BigInt,
	@iInclude_Grades Bit = 0 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		-- Create a temporary table to hold the main listing information
		Create Table dbo.#TRANSACTION_LIST
		(
			Transaction_List_Id Int Identity(1, 1) Not Null,
			Date Datetime Null,
			Shift Char(1) Collate Database_Default Null,
			Original_Source Varchar(31) Collate Database_Default Null,
			Original_Destination Varchar(31) Collate Database_Default Null,
			Transaction_Type Varchar(31) Collate Database_Default Null,
			Record_Id BigInt Null,
			Recalc_History_Id BigInt Null,
			Recalc_Logic_History_Id BigInt Null,
			Min_Data_Transaction_Tonnes_Id BigInt Null,
			Equipment Varchar(31) Collate Database_Default Null,
			Action Varchar(128) Collate Database_Default Not Null,
			Orig_Tonnes Float Null,
			New_Tonnes Float Null,
			Tonnes_Perc_Diff Real Null,
			Tonnes_Abs_Diff Float Null
			
			--Primary Key (Transaction_List_Id)
		)

		Create NonClustered Index IX_TRANSACTION_LIST_01
			On dbo.#TRANSACTION_LIST (Record_Id)

		-- Create the related grade temporary tables
		Create Table dbo.#TRANSACTION_LIST_GRADE
		(
			Transaction_List_Id Int Not Null,
			Grade_Id Int Not Null,
			Grade_Name Varchar(31) Collate Database_Default Not Null,
			Grade_Value Real Null

			Primary Key(Transaction_List_Id, Grade_Name)
		)   
		
		-- Insert the records directly related to the given data process transaction record
		Insert Into #TRANSACTION_LIST
		(
			Recalc_Logic_History_Id, Recalc_History_Id, Action,
			Orig_Tonnes, New_Tonnes
		)
		Select RLH.Recalc_Logic_History_Id, RLH.Recalc_History_Id, RLT.Name,
			RLH.Old_Tonnes, RLH.New_Tonnes
		From dbo.RecalcLogicHistory As RLH
			Inner Join dbo.RecalcLogicType As RLT
				On (RLH.Recalc_Logic_Type_Id = RLT.Recalc_Logic_Type_Id)
		Where RLH.Data_Process_Transaction_Id = @iRecord_Id

		If @iInclude_Grades = 1
		Begin
			-- Insert the related grade records into the grade tables
			Insert Into #TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, 
				Grade_Name, Grade_Value
			)
			Select TL.Transaction_List_Id, G.Grade_Id, 
				'Orig_' + G.Grade_Name, RLHG.Old_Grade_Value
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.RecalcLogicHistoryGrade As RLHG
					On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
				Inner Join dbo.Grade As G
					On (G.Grade_Id = RLHG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Not Null
			Union All
			Select TL.Transaction_List_Id, G.Grade_Id,
				'New_' + G.Grade_Name, RLHG.New_Grade_Value
			From dbo.#TRANSACTION_LIST As TL
				Inner Join dbo.RecalcLogicHistoryGrade As RLHG
					On (TL.Recalc_Logic_History_Id = RLHG.Recalc_Logic_History_Id)
				Inner Join dbo.Grade As G
					On (G.Grade_Id = RLHG.Grade_Id)
			Where TL.Recalc_Logic_History_Id Is Not Null
		End

		-------------------------------------------------------------------------
		-- Update the difference details	
		-------------------------------------------------------------------------
		Update TL
		Set	Tonnes_Perc_Diff = Round((New_Tonnes - Orig_Tonnes) / Orig_Tonnes, 8)
		From dbo.#TRANSACTION_LIST As TL
		Where Orig_Tonnes > 0
			And New_Tonnes > 0

		Update TL
		Set	Tonnes_Abs_Diff = Round(New_Tonnes - Orig_Tonnes, 2)
		From dbo.#TRANSACTION_LIST As TL

		If @iInclude_Grades = 1
		Begin
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Perc_Diff',
				Case When (TLOG.Grade_Value > 0 And TLNG.Grade_Value > 0) Then
					Round((TLNG.Grade_Value - TLOG.Grade_Value) / TLOG.Grade_Value, 8)
				Else
					Null
				End
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0

			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Abs_Diff',
				TLNG.Grade_Value - TLOG.Grade_Value
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0
			
			--Add Missing Grades to the mix to ensure maximum pivot and then pivot
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, Grade_Name
			)
			Select -1, G.Grade_Id, 'Orig_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, 'New_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Abs_Diff' 
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Perc_Diff'
			From dbo.Grade As G

			-- Pivot the grade fields as required
			Exec dbo.PivotTable
				@iTargetTable = '#TRANSACTION_LIST',
				@iPivotTable = '#TRANSACTION_LIST_GRADE',
				@iJoinColumns = '#TRANSACTION_LIST.Transaction_List_Id = #TRANSACTION_LIST_GRADE.Transaction_List_Id',
				@iPivotColumn = 'Grade_Name',
				@iPivotValue = 'Grade_Value',
				@iPivotType = 'Real'
		End

		Select TL.*
		From dbo.#TRANSACTION_LIST As TL
			Left Outer Join dbo.ShiftType As ST
				On (ST.Shift = TL.Shift)
		Order By Date, ST.Order_No, Min_Data_Transaction_Tonnes_Id, 
			Transaction_Type, Record_Id

		Drop Table dbo.#TRANSACTION_LIST
		Drop Table dbo.#TRANSACTION_LIST_GRADE  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicHistoryTransactionLevel3 TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicHistoryTransactionLevel3">
 <Procedure>
	Returns the level 3 Recalc logic history for a specified record.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcLogicTypeList.prc'
GO

If object_id('dbo.GetRecalcLogicTypeList') Is Not Null 
     Drop Procedure dbo.GetRecalcLogicTypeList 
Go 
  
Create Procedure dbo.GetRecalcLogicTypeList
(	
	@iRecalc_Logic_Type_Id Int = Null
)
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select Recalc_Logic_Type_Id, Name, Description
	From dbo.RecalcLogicType
	Where Recalc_Logic_Type_Id = IsNull(@iRecalc_Logic_Type_Id, Recalc_Logic_Type_Id)
  
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetRecalcLogicTypeList TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcLogicTypeList">
 <Procedure>
	Returns a list of Recalc Logic types.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurvey.prc'
GO

If object_id('dbo.GetDigblockSurvey') Is Not Null 
     Drop Procedure dbo.GetDigblockSurvey
Go 
  
Create Procedure dbo.GetDigblockSurvey 
( 
    @iDigblock_Survey_Id Int 
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
	Declare @PreviousDate datetime,
		@PreviousShift char(1)

	--Get The End date of the previous survey
	Select Top 1 @PreviousDate = PDS.Digblock_Survey_Date,
		@PreviousShift = PDS.Digblock_Survey_Shift
	From dbo.DigblockSurvey As DS
		Inner Join dbo.ShiftType As ST
			On (DS.Digblock_Survey_Shift = ST.Shift)
		Inner Join dbo.DigblockSurvey As PDS
			On (PDS.Digblock_Survey_Date <= DS.Digblock_Survey_Date)
		Inner Join dbo.ShiftType As PST
			On (PDS.Digblock_Survey_Shift = PST.Shift)
	Where DS.Digblock_Survey_Id = @iDigblock_Survey_Id	
		And dbo.GetDateShiftAsInt(PDS.Digblock_Survey_Date, PST.Order_No) < dbo.GetDateShiftAsInt(DS.Digblock_Survey_Date, ST.Order_No)
	Order By PDS.Digblock_Survey_Date Desc, PST.Order_No Desc

	--If there was a previous survey then get the next day after its end date otherwise use system start
	If @PreviousDate Is Null
	Begin
		Select @PreviousDate = dbo.GetSystemStartDate(), 
			@PreviousShift = dbo.GetFirstShiftType()
	End
	Else
	Begin
		Exec GetNextDateShift
			@Date = @PreviousDate,
			@Shift = @PreviousShift,
			@Next_Date = @PreviousDate output,
			@Next_Shift = @PreviousShift output
	End

    Select DS.Digblock_Survey_Id, DS.Digblock_Survey_Date, DS.Digblock_Survey_Shift,
		ST.Name As Digblock_Survey_Shift_Name, DS.Digblock_Survey_Type_Id, DS.Is_Approved,
		@PreviousDate As Start_Date, @PreviousShift As Start_Shift,
		PST.Name As Start_Shift_Name
	From dbo.DigblockSurvey As DS
		Inner Join dbo.ShiftType As ST
			On (DS.Digblock_Survey_Shift = ST.Shift)
		Inner Join dbo.ShiftType As PST
			On (PST.Shift = @PreviousShift) 
	Where DS.Digblock_Survey_Id = @iDigblock_Survey_Id	
	
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetDigblockSurvey TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetDigblockSurvey">
 <Procedure>
	Returns the details for specified Digblock Survey
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddBlastBlock.prc'
GO

If Object_Id('dbo.AddBlastBlock') Is Not Null
	Drop Procedure dbo.AddBlastBlock
Go

CREATE Procedure dbo.AddBlastBlock
(
	@iCode Varchar(31),
	@iDrilling_Start_Date Datetime = Null,
	@iDrilling_End_Date Datetime = Null,
	@iBlasted_Date Datetime = Null,
	@iCompleted_Date Datetime = Null,
	@iX Float = Null,
	@iY Float = Null,
	@iZ Float = Null,
	@iNotes Varchar(1023) = Null,
	@oBlast_Block_Id Int = Null Output
)
With Encryption 
As

Begin

	-- adds a blast block

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If there is no other blast block with the same code */
	If Not Exists (Select 1 From BlastBlock Where Code = @iCode)
	Begin
		/* Insert the new record */
		Insert Into BlastBlock
		(
			Code, 
			Drilling_Start_Date, Drilling_End_Date, Blasted_Date,
			Completed_Date, X, Y, Z, Notes
		)
		Values 
		(
			@iCode, 
			@iDrilling_Start_Date, @iDrilling_End_Date, @iBlasted_Date,
			@iCompleted_Date, @iX, @iY, @iZ, @iNotes
		)

		/* Return the ID of the new blast block record */
		Set @oBlast_Block_Id = @@Identity

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('A blast block with the same code already exists', 16, 1)
	End

	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddBlastBlock">
 <Procedure>
	Adds a record to the BlastBlock table and returns the key to the record in the @oBlast_Block_Id output variable.
	Errors are raised 
		if the record already exists
 </Procedure>
</TAG>
*/





GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateBlastBlockLocation.prc'
GO

If object_id('dbo.AddOrUpdateBlastBlockLocation') is not Null 
     Drop Procedure dbo.AddOrUpdateBlastBlockLocation 
Go 

Create Procedure dbo.AddOrUpdateBlastBlockLocation
(
	@iBlast_Block_Id Int,
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin

	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.AddOrUpdateBlastBlockLocation
	-- Author: Jennifer Claughton
	-- Comments: Adds or updates records to the BlastBlockLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Only update if the Location_Id is a not child of the current Location_Id for the Blast_Block
	-- Parameters:
	-- 1. blast_block_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) null, null, null - throw error
	--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) REFACTORING SECTION
	-- 
	-- refactors the location hierarchy 
	--
	-- Use:
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @Location_Id = passed in or calculated Location_Id from the above checks
	--
	-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
	--     (store in: @LOCATION_TYPE_HIERARCHY)
	-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
	-- (c) within the blast_block location table, find all records which are children of this location_id - and remove everything else
	--     -> Delete from BlastBlockLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
	-- (d) if there are children in the blast_block location table (or this locid already exists) of this location_id - do nothing at all
	--     a. check for # records from BlastBlockLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
	--     b. if there are records, don't do anything !
	--        else insert the new location_id/location_type_id
	------------------------------------------------------------------------------------------------*/

	Declare @Message VarChar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	Declare @LOCATION_TYPE_HIERARCHY Table 
	(
		Location_Type_Id TINYINT Not Null,
		Primary Key (Location_Type_Id)
	)

	Declare @CHILD_LOCATION_HIERARCHY Table 
	(
		Location_Id Int Not Null,
		Primary Key (Location_Id)
	)

	------------------------------
	-- LOOKUP & VALIDATION SECTION 
	-- 
	-- (1) Get the valid Location_Id and Location_Type_Id from the inserted parameters.
	------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record.'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record.'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record.'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record.'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) null, null, null - throw error
						--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
						--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
						Set @Message = 'The minimum set parameters has not been met.'
						RaisError (@Message, 16, 1)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End

	
	----------------------
	-- REFACTORING SECTION
	-- 
	-- Refactors the location hierarchy based on the Location_Id and Location_Type_Id
	-- -------------------
	
	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin

		-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
		--     (store in: @LOCATION_TYPE_HIERARCHY)
		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From dbo.GetLocationTypePArentLocationTypeList(@Location_Type_Id)

		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeChildLocationTypeList(@Location_Type_Id)

		-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
		Insert Into @CHILD_LOCATION_HIERARCHY
		(
			Location_Id
		)
		Select Location_Id 
		From dbo.GetLocationChildLocationList(@Location_Id)

		-- (c) within the blast_block location table, find all records which are children of this location_id 
		--     - and remove everything else
		--    Delete from BlastBlockLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
		Delete
		From dbo.BlastBlockLocation 
		Where Location_Id Not In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
			And	Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPE_HIERARCHY) 
			And Blast_Block_Id = @iBlast_Block_Id 
			And	Location_Id <> @Location_Id

		-- (d) if there are children in the blast_block location table (or this Location_Id already exists) for this location_id 
		--		- do nothing at all
		--     a. check for the number of records from BlastBlockLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
		--     b. if there are records, don't do anything !
		--        else insert the new location_id/location_type_id
		If Not Exists
			(
				Select 1 
				From dbo.BlastBlockLocation 
				Where
					(
						Location_Id In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
						Or Location_Id = @Location_Id
					)
					And Blast_Block_Id = @iBlast_Block_Id
			)
		Begin
			-- Insert the relevant record
			Insert Into dbo.BlastBlockLocation
			(
				Blast_Block_Id, Location_Type_Id, Location_Id
			)
			Values
			(
				@iBlast_Block_Id, @Location_Type_Id, @Location_Id
			)
		End
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateBlastBlockLocation">
 <Procedure>
	Adds a new record or updates and existing record in the BlastBlockLocation table.
	Errors raised if:
		The minimum set parameters has not been met.
		The Location Name @iLocation_Name does not match the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMinePlanPeriodGrade.prc'
GO

If object_id('dbo.AddOrUpdateMinePlanPeriodGrade') is not Null 
     Drop Procedure dbo.AddOrUpdateMinePlanPeriodGrade 
Go 
  
Create Procedure dbo.AddOrUpdateMinePlanPeriodGrade 
( 
	@iMine_Plan_Period_Id Int,
    @iGrade_Id Varchar(31),
	@iGrade_Value Real 
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    If Not Exists
		(
			Select 1
			From dbo.MinePlanPeriodGrade
			Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
				And Grade_Id = @iGrade_Id
		)
	Begin
		Insert Into dbo.MinePlanPeriodGrade
		(
			Mine_Plan_Period_Id, Grade_Id, Grade_Value
		)
		Select @iMine_Plan_Period_Id, @iGrade_Id, @iGrade_Value
	End
	Else
	Begin
		Update dbo.MinePlanPeriodGrade
		Set Grade_Value = @iGrade_Value
		Where Mine_Plan_Period_Id = @iMine_Plan_Period_Id
			And Grade_Id = @iGrade_Id
	End
  
    Commit Transaction 
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMinePlanPeriodGrade">
 <Procedure>
	Adds a new record or updates an existing record in the MinePlanPeriodGrade table
	Errors not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddBlockModelType.prc'
GO

IF OBJECT_ID('dbo.AddBlockModelType') IS NOT NULL
     DROP PROCEDURE dbo.AddBlockModelType  
GO 
  
CREATE PROCEDURE dbo.AddBlockModelType
(
	@Name VARCHAR(63),
	@Description VARCHAR(1023) = NULL,
	@oBlock_Model_Type_Id INT = NULL OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBlockModelType',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		/* If a block model type with this name does not exist */
		IF NOT EXISTS (SELECT * FROM BlockModelType WHERE NAME = @Name)
		BEGIN
			/* Insert the block model type */
			INSERT INTO BlockModelType
				(Name, Description)
			VALUES 
				(@Name, @Description)

			/* Return it's ID */
			SELECT @oBlock_Model_Type_Id = @@Identity
		END
		ELSE
		BEGIN
			RAISERROR ('A block model type with this name already exists', 16, 1)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO 
GRANT EXECUTE ON dbo.AddBlockModelType TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddBlockModelType">
 <Procedure>
	Adds a record into the BlockModelType table and returns the key to the new record in the resultset. 
	Errors are raised 
		if Block_Model_Type_Id already exists in the BlockModelType table.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddBlockModel.prc'
GO

IF OBJECT_ID('dbo.AddBlockModel') IS NOT NULL 
     DROP PROCEDURE dbo.AddBlockModel 
GO 
  
CREATE PROCEDURE dbo.AddBlockModel 
( 
	@iBlock_Model_Type_Id INT,
	@iName VARCHAR(255),
	@iDescription VARCHAR(1023) = NULL,
	@iGenerated_Date DATETIME = NULL,
	@iCreation_Datetime DATETIME = NULL,
	@iIs_Default BIT = 0,
	@iIs_Displayed BIT = 0,
    @oBlock_Model_Id INT OUTPUT 
) 
WITH ENCRYPTION
AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'AddBlockModel',
		@TransactionCount = @@Trancount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY
		-- If the block model type doesnt exist
		IF (dbo.DoesBlockModelTypeExist (@iBlock_Model_Type_Id) = 0)
		BEGIN
			Raiserror ('The given block model type does not exist', 16, 1)
		END
		
		-- If this model is being set as the default
		IF @iIs_Default = 1
		BEGIN
			-- Set all other models of this type to not be default 
			UPDATE dbo.BlockModel
			SET	Is_Default = 0
			WHERE Block_Model_Type_Id = @iBlock_Model_Type_Id
		END
		ELSE IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.BlockModel
				WHERE Is_Default = 1
			)
		BEGIN
			-- Otherwise, if there are no other block models of this type in the system 
			-- Set this one as the default anyway 
			SET @iIs_Default = 1
		END

		-- Insert the block model
		INSERT INTO dbo.BlockModel
		(
			Block_Model_Type_Id, Name, Description, Generated_Date, 
			Creation_Datetime, Is_Default, Is_Displayed
		)
		SELECT @iBlock_Model_Type_Id, @iName, @iDescription, @iGenerated_Date, 
			IsNull(@iCreation_Datetime, GetDate()), @iIs_Default, @iIs_Displayed

		--Return it's ID
		SELECT @oBlock_Model_Id = @@Identity

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH		
END 
GO 
GRANT EXECUTE ON dbo.AddBlockModel TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddBlockModel">
 <Procedure>
	Adds a record to the BlockModel table and returns the key to the new record in the resultset. 
	If this is the only record for this Block_Model_Type or if the Is_Default flag parameter is set to true 
	this record becomes the default record for this Block_Model_Type.
	Errors are raised 
		if the @iBlock_Model_Type_Id record does not exist in the BlockModelType table.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddModelBlockPartial.prc'
GO

IF OBJECT_ID('dbo.AddModelBlockPartial') IS NOT NULL 
     DROP PROCEDURE dbo.AddModelBlockPartial 
GO 
  
CREATE PROCEDURE dbo.AddModelBlockPartial 
( 
    @iModel_Block_Id INT,
	@iDigblock_Survey_Date DATETIME = NULL,
	@iDigblock_Survey_Shift CHAR(1) = NULL,
	@iMaterial_Type_Id INT,
	@iTonnes FLOAT,
	@ioSequence_No INT = NULL OUTPUT 
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'AddModelBlockPartial',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
    BEGIN TRY
		-- If the block does not exist in this model
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM dbo.ModelBlock AS MB
				WHERE MB.Model_Block_Id = @iModel_Block_Id
			)
		BEGIN
			Raiserror ('The block does not exist', 16, 1)
		END

		--If material type does not exist
		IF NOT EXISTS
			(
				SELECT 1 
				FROM dbo.MaterialType AS MT
				WHERE Material_Type_Id = @iMaterial_Type_Id
			)
		BEGIN
			Raiserror ('The material type does not exist', 16, 1)
		END

		--If we were not provided a sequence no get the next one
		--otherwise check to ensure it does not already exist
		IF @ioSequence_No IS NULL
		BEGIN
			SELECT @ioSequence_No = Max(Sequence_No) + 1
			FROM dbo.ModelBlockPartial AS MPB
			WHERE Model_Block_Id = @iModel_Block_Id
			
			SELECT @ioSequence_No = IsNull(@ioSequence_No, 1)
		END
		Else IF EXISTS
			(
				SELECT 1
				FROM dbo.ModelBlockPartial AS MBP
				WHERE MBP.Model_Block_Id = @iModel_Block_Id
					AND MBP.Sequence_No = @ioSequence_No
			)
		BEGIN
			Raiserror ('The model block and sequence number provided already exists', 16, 1)
		END

		INSERT INTO dbo.ModelBlockPartial
		(
			Model_Block_Id, Sequence_No, Digblock_Survey_Date, 
			Digblock_Survey_Shift, Material_Type_Id, Tonnes
		)
		SELECT @iModel_Block_Id, @ioSequence_No, @iDigblock_Survey_Date, 
			@iDigblock_Survey_Shift, @iMaterial_Type_Id, @iTonnes

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.AddModelBlockPartial TO CoreBlockModelManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddModelBlockPartial">
 <Procedure>
	Adds a record to the ModelBlockPartial table.  
	Sets the sequence number to be the maximum sequence value + 1 and returns this value in the sequnece no output variable.
	Errors raised if:
		The material type does not exist
		The block does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateModelBlockPartialGrade.prc'
GO

If Object_Id('dbo.AddOrUpdateModelBlockPartialGrade') Is Not Null
	Drop Procedure dbo.AddOrUpdateModelBlockPartialGrade
GO

Create Procedure dbo.AddOrUpdateModelBlockPartialGrade
(
	@iModel_Block_Id Int,
	@iSequence_No Int,
	@iGrade_Id SmallInt,
	@iGrade_Value Real
)

With Encryption
As 

Begin
	Set NoCount On
	
	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If @iGrade_Value Is Null
	Begin
		-- Delete the grade
		Delete
		From dbo.ModelBlockPartialGrade
		Where Grade_Id = @iGrade_Id
			And Model_Block_Id = @iModel_Block_Id
			And Sequence_No = @iSequence_No
	End
	Else If Exists (Select 1
					From dbo.ModelBlockPartialGrade
					Where Grade_Id = @iGrade_Id
						And Model_Block_Id = @iModel_Block_Id
						And Sequence_No = @iSequence_No)
	Begin
		-- Update the grade
		Update dbo.ModelBlockPartialGrade
		Set Grade_Value = @iGrade_Value
		Where Grade_Id = @iGrade_Id
			And Model_Block_Id = @iModel_Block_Id
			And Sequence_No = @iSequence_No
	End
	Else
	Begin
		-- Insert the grade
		Insert Into dbo.ModelBlockPartialGrade
			(Model_Block_Id, Sequence_No, Grade_Id, Grade_Value)
		Values
			(@iModel_Block_Id, @iSequence_No, @iGrade_Id, @iGrade_Value)
	End	
	
	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateModelBlockPartialGrade TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateModelBlockPartialGrade">
 <Procedure>
	Adds a new record or updates an existing record in the ModelBlockPartialGrade table if a @iGrade_Value value is specified.
	If the @iGrade_Value value is not specified and the record exists in the ModelBlockPartialGrade table the record is deleted.
	Errors not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddHaulageRaw.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddHaulageRaw'))
	Drop Procedure dbo.AddHaulageRaw
Go

Create Procedure dbo.AddHaulageRaw
(
	@iHaulage_Date DateTime,
	@iHaulage_Shift Char(1),
	@iSource VarChar(63),
	@iDestination VarChar(63),
	@iTonnes Float,
	@iLoads Int,
	@iTruck VarChar(63),
	@iCan_Correct_Via_User_Interface Bit = 1,
	@oHaulage_Raw_Id Int = Null Output
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Insert Into dbo.HaulageRaw
	(
		Haulage_Date, Haulage_Shift, Source, Destination, Tonnes, Loads, Truck, Haulage_Raw_State_Id,
		Can_Correct_Via_User_Interface, Child_Haulage_Raw_Id, Parent_Haulage_Raw_Id, Added_DateTime
	)
	Values
	(
		@iHaulage_Date, @iHaulage_Shift, @iSource, @iDestination, @iTonnes, @iLoads, @iTruck, 'A',
		@iCan_Correct_Via_User_Interface, Null, Null, GetDate()
	)

	Set @oHaulage_Raw_Id = Scope_Identity()

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddHaulageRaw TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddHaulageRaw">
 <Procedure>
	Adds a record to the HaulageRaw table and returns the key of the added record in an output variable.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteWeightometerSampleValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DeleteWeightometerSampleValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[DeleteWeightometerSampleValue]
GO

Create Procedure [dbo].DeleteWeightometerSampleValue

(@Weightometer_Sample_Id Int,
 @Weightometer_Sample_Field_Id Varchar(31))

With Encryption As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Delete
	From WeightometerSampleValue
	Where Weightometer_Sample_Id = @Weightometer_Sample_Id
	And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id

	If @@Error = 0
		SEt @ELC_Proc_Is_Error = 0
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteWeightometerSampleValue">
 <Procedure>
	Deletes a record from the WeightometerSampleValue table.
	Errors not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileSurveySampleGrade.prc'
GO

If exists (Select * from dbo.sysobjects Where id = object_id(N'[dbo].[AddOrUpdateStockpileSurveySampleGrade]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateStockpileSurveySampleGrade]
GO

create procedure dbo.AddOrUpdateStockpileSurveySampleGrade
(
  @iStockpile_Survey_Sample_Id int,
  @iGrade_Id varchar(31),
  @iGrade_Value real
)

With Encryption As 

  
  Declare @ErrorCode Int
  Declare @RowsUpdated Int
  Declare @ErrorDescription Varchar(200) 

  Set @RowsUpdated = 0
  Set @ErrorCode = -1

    --Handle Potential Updates of Grade 'Columns'
    If @iGrade_Value Is Not Null
    Begin
		--Updating to a non-null grade value, update original record if it exists
		Update Stockpile_Survey_Sample_Grade
		Set Grade_Value = @iGrade_Value
		Where Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id
			And Grade_Id = @iGrade_Id 
	    
		Select @ErrorCode = @@ERROR, @RowsUpdated = @@ROWCOUNT
		If(@ErrorCode <> 0)
		Begin
			  Set @ErrorDescription = 'Failed to Update Stockpile_Survey_Sample_Grade during an update from a non-null to another non-null value.'
			  Goto ErrorHandler
		End
		
		 -- If the record did not exist and it is not null then add it
		If(@RowsUpdated = 0) 
		Begin
		  Insert into Stockpile_Survey_Sample_Grade
		  (
			Stockpile_Survey_Sample_Id,
			Grade_Id,
			Grade_Value
		  )
		  Values
		  (
			@iStockpile_Survey_Sample_Id,
			@iGrade_Id,
			@iGrade_Value
		  )
		End
    
		Select @ErrorCode = @@ERROR
		If(@ErrorCode <> 0)
		Begin
			  Set @ErrorDescription = 'Failed to insert into Stockpile_Survey_Sample_Grade'
			  Goto ErrorHandler
		End
		
		
    End
		Else
	Begin    
		-- Updating to a null grade value, the original record needs to be removed if it exists
		Delete Stockpile_Survey_Sample_Grade
		Where Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id
			And Grade_Id = @iGrade_Id 
		
		Select @ErrorCode = @@ERROR
		If(@ErrorCode <> 0)
		Begin
			  Set @ErrorDescription = 'Failed to Delete Stockpile_Survey_Sample_Grade.'
			  Goto ErrorHandler
		End
	End
 
   

  return(@ErrorCode)
  
ErrorHandler:      

  Raiserror(@ErrorDescription, 16, 1)
  return(@ErrorCode)

GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateStockpileSurveySampleGrade">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileSurveySampleGrade table if @iGrade_Value is specified.
	If the @iGrade_Value value is not specified and the record exists in the StockpileSurveySampleGrade table the record is deleted.
	Errors raised if:
		If the Insert statement fails
		If the Update statement fails
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateMinePlan.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[UpdateMinePlan]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[UpdateMinePlan]
GO

CREATE Procedure [dbo].[UpdateMinePlan]

(@Mine_Plan_Id Int,
@Name Varchar(63),
@Description Varchar(255),
@Is_Default Bit = 0)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the given mine plan exists */
	If Exists (Select * From MinePlan Where Mine_Plan_Id = @Mine_Plan_Id)
	Begin
		/* If this mine plan is being set to default */
		If (@Is_Default = 1)
		Begin
			/* Set all other mine plans of this type to not be default */
			Update MP
			Set	Is_Default = 0
			From 	MinePlan MP
			Where Mine_Plan_Type_Id =	(Select MP2.Mine_Plan_Type_Id
							From MinePlan MP2
							Where MP2.Mine_Plan_Id = @Mine_Plan_Id)
		End

		/* Update the mine plan */
		Update MP
		Set	Name = @Name,
			Description = @Description,
			Is_Default = @Is_Default
		From MinePlan MP
		Where Mine_Plan_Id = @Mine_Plan_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given mine plan does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder
GO


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateMinePlan">
 <Procedure>
	Updated the table MinePlan setting the description and is_default flag.
	Errors are raised if:
		The given mine plan does not exist.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMinePlan.prc'
GO

If object_id('dbo.AddMinePlan') Is Not Null 
     Drop Procedure dbo.AddMinePlan 
Go 
  
Create Procedure dbo.AddMinePlan 
( 
    @Name Varchar(255),
	@Description Varchar(1023),
	@Imported_Datetime Datetime = Null,
	@Is_Default Bit = 1,
	@Mine_Plan_Type_Id Int,
	@Parent_Mine_Plan_Id Int = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    If (@Imported_Datetime Is Null)
	Begin
		Set @Imported_Datetime = GetDate()
	End

	If (@Is_Default = 1)
	Begin
		Update MinePlan
		Set Is_Default = 0
		Where Mine_Plan_Type_Id = @Mine_Plan_Type_Id
	End

	/* Insert the new mine plan into the database */
	Insert Into MinePlan
	(
		Name, Description, Imported_Datetime,
		Is_Default, Mine_Plan_Type_Id, Parent_Mine_Plan_Id
	)
	Select @Name, @Description, @Imported_Datetime,
		@Is_Default, @Mine_Plan_Type_Id, @Parent_Mine_Plan_Id
  
    Commit Transaction 
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddMinePlan">
 <Procedure>
	Adds a record to the MinePlan table and returns the key of the added record in the resultset.
	If the @Is_Default flag is set all other MinePlan records with the same Mine_Plan_Type are set to not be the default
	Errors not raised
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockList.prc'
GO

IF OBJECT_ID('dbo.GetModelBlockList') IS NOT NULL 
     DROP PROCEDURE dbo.GetModelBlockList
GO 
  
CREATE PROCEDURE dbo.GetModelBlockList 
( 
    @iBlock_Model_Id INT = NULL,
	@iBlast_Block_Id INT = NULL,
	@iCode VARCHAR(255) = NULL
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	IF @iBlast_Block_Id IS NULL
	BEGIN
		SELECT MB.Block_Model_Id, MB.Model_Block_Id, MB.Code,
			MB.X, MB.Y, MB.Z, MB.X_Inc, MB.Y_Inc, MB.Z_Inc, BM.Block_Model_Type_Id
		FROM dbo.ModelBlock AS MB
			INNER JOIN dbo.BlockModel As BM
				On (MB.Block_Model_Id = BM.Block_Model_Id)
		WHERE MB.Block_Model_Id = IsNull(@iBlock_Model_Id, MB.Block_Model_Id)
			AND MB.Code = IsNull(@iCode, MB.Code)			
		ORDER BY MB.Code
	END
	ELSE
	BEGIN
		SELECT MB.Block_Model_Id, MB.Model_Block_Id, MB.Code,
			MB.X, MB.Y, MB.Z, MB.X_Inc, MB.Y_Inc, MB.Z_Inc, BM.Block_Model_Type_Id
		FROM dbo.ModelBlock AS MB
			INNER JOIN dbo.BlastBlockModelBlock AS BBMB
				ON (BBMB.Model_Block_Id = MB.Model_Block_Id)
			INNER JOIN dbo.BlockModel As BM
				On (MB.Block_Model_Id = BM.Block_Model_Id)
		WHERE MB.Block_Model_Id = IsNull(@iBlock_Model_Id, MB.Block_Model_Id)
			AND MB.Code = IsNull(@iCode, MB.Code)
			AND BBMB.Blast_Block_Id = @iBlast_Block_Id			
		ORDER BY MB.Code
	END
END 
GO 
GRANT EXECUTE ON dbo.GetModelBlockList TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetModelBlockList">
 <Procedure>
	Returns the list of model block records, filtered as required.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetNoHaulageErrors.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetNoHaulageErrors') IS NOT NULL
     DROP PROCEDURE dbo.GetNoHaulageErrors 
GO 
  
CREATE PROCEDURE dbo.GetNoHaulageErrors 
( 
	@iLocationId INT = NULL,
    @No_Errors INT OUTPUT
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @LocationSubtree TABLE
    (
		Location_Id INT
    )
	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetNoHaulageErrors',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		IF @iLocationId IS NULL
		BEGIN
			SELECT @No_Errors = Count(*)
			FROM HaulageRawError
		END
		ELSE
		BEGIN
		
			INSERT INTO @LocationSubtree
			(
				Location_Id
			)
			SELECT Location_Id
			FROM GetLocationSubtree(@iLocationId)
		
			SELECT @No_Errors = Count(*)
			FROM dbo.HaulageRawError AS HRE
				INNER JOIN HaulageRawLocation AS HRL
					ON HRE.Haulage_Raw_Id = HRL.HaulageRawId
			WHERE HRL.SourceLocationId IN (SELECT Location_Id FROM @LocationSubtree)
				OR HRL.DestinationLocationId IN (SELECT Location_Id FROM @LocationSubtree)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNoHaulageErrors TO CoreHaulageManager
GO

GRANT EXECUTE ON dbo.GetNoHaulageErrors TO CoreNotificationManager
/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetNoHaulageErrors">
 <Procedure>
	Returns the number of Haulage Raw Errors
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteLocation.prc'
GO

IF OBJECT_ID('dbo.DeleteLocation') IS NOT NULL
     DROP PROCEDURE dbo.DeleteLocation
GO 
  
CREATE PROCEDURE dbo.DeleteLocation
( 
    @iLocation_Id INT = NULL,
	@iName VARCHAR(31) = NULL,
	@iLocation_Type_Id TINYINT = NULL,
	@iParent_Location_Name Varchar(31) = NULL
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @IsError BIT
	DECLARE @ErrorMessage VARCHAR(255)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		EXEC dbo.TryDeleteLocation
			@iLocationId = @iLocation_Id,
			@iName = @iName,
			@iLocationTypeId = @iLocation_Type_Id,
			@iParentLocationName = @iParent_Location_Name,
			@oIsError = @IsError OUTPUT,
			@oErrorMessage = @ErrorMessage OUTPUT

		IF @IsError = 1
		BEGIN
			RAISERROR(@ErrorMessage, 16, 1)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteLocation TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteLocation">
 <Procedure>
	Deletes a record from the Location table.
	Can be called by on of the following methods:
	  1. Providing the location id
	  2. Providing the location name and parent location name, if the location is in a hierarchical group which has a parent group
	  3. Providing the location name and location type group, if the location is in an independant group
	Errors are raised if:
		The given location does not exist
		There are other location records which depend on this @iLocation_Type_Id
		This location is being used by one or more digblocks
		This location is being used by one or more Blast Blocks
		This location is being used by one or more Crushers
		This location is being used by one or more Model Blocks
		This location is being used by one or more Mills
		This location is being used by one or more Stockpiles
		This location is being used by one or more Weightomters
		This location is being used by one or more Mine Plan Periods
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.TryDeleteLocation.prc'
GO

IF OBJECT_ID('dbo.TryDeleteLocation') IS NOT NULL
     DROP PROCEDURE dbo.TryDeleteLocation
GO 
  
CREATE PROCEDURE dbo.TryDeleteLocation
( 
    @iLocationId INT,
	@iName VARCHAR(31),
	@iLocationTypeId TINYINT,
	@iParentLocationName VARCHAR(31),
	@oIsError BIT OUTPUT,
	@oErrorMessage VARCHAR(255) OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @IsError BIT
	DECLARE @ErrorMessage VARCHAR(255)
	DECLARE @LocationId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'TryDeleteLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- if the location id is not given
		IF (@iLocationId IS NULL)
		BEGIN
			-- obtain it from the other details given
			IF (@iLocationTypeId IS NOT NULL)
			BEGIN
				SET @LocationId =	
					(
						SELECT Location_Id
						FROM dbo.Location
						WHERE Name = @iName
							AND Location_Type_Id = @iLocationTypeId
					)
			END
			ELSE
			BEGIN
				SET @LocationId =	
					(
						SELECT L.Location_Id
						FROM dbo.Location AS L
							INNER JOIN dbo.Location AS PL
								ON (L.Parent_Location_Id = PL.Location_Id)
						WHERE L.Name = @iName
							AND PL.Name = @iParentLocationName
					)
			END
		END	
		ELSE
		BEGIN
			SET @LocationId = @iLocationId
		END

		SET @IsError = 0
		SET @ErrorMessage = NULL

		-- error checking
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.Location
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'The given location does not exist.'
		END
	
		-- If this location is not a parent of any other locations
		IF EXISTS
			(
				SELECT 1
				FROM dbo.Location
				WHERE Parent_Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1

			-- Get the details of the location type, and it's parent location type if given
			SELECT @ErrorMessage = 'There are other location records which depend on this ' + lt.Description + '.'
			FROM dbo.Location AS l
				INNER JOIN dbo.LocationType AS lt
					ON (l.Location_Type_Id = lt.Location_Type_Id)
			WHERE Location_Id = @LocationId
		END

		-- If there are no digblock_location records associated
		IF EXISTS
			(
				SELECT 1
				FROM dbo.DigblockLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more digblocks.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.BlastBlockLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1			
			SET @ErrorMessage = 'This location is being used by one or more Blast Blocks.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.CrusherLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more Crushers.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.ModelBlockLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1			
			SET @ErrorMessage = 'This location is being used by one or more Model Blocks.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.MillLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more Mills.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.StockpileLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more Stockpiles.'
		END
	
		IF EXISTS
			(
				SELECT 1
				FROM dbo.WeightometerLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more Weightomters.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.MinePlanPeriodLocation
				WHERE Location_Id = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is being used by one or more Mine Plan Periods.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.HaulageRawLocation
				WHERE SourceLocationId = @LocationId
					OR DestinationLocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a haulage raw location constraint.'
		END

		IF EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceHaulage
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a haulage notification.'
		END
	
		-- delete the location record
		IF @IsError = 0
		BEGIN
			DELETE
			FROM dbo.Location
			WHERE Location_Id = @LocationId
		END

		-- return the check results
		SET @oIsError = @IsError
		SET @oErrorMessage = @ErrorMessage

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.TryDeleteLocation TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.TryDeleteLocation">
 <Procedure>
	Attempts to deletes a record from the Location table.
	Can be called by on of the following methods:
	  1. Providing the location id
	  2. Providing the location name and parent location name, if the location is in a hierarchical group which has a parent group
	  3. Providing the location name and location type group, if the location is in an independant group
	Errors are raised if:
		The given location does not exist
		There are other location records which depend on this @iLocation_Type_Id
		This location is being used by one or more digblocks
		This location is being used by one or more Blast Blocks
		This location is being used by one or more Crushers
		This location is being used by one or more Model Blocks
		This location is being used by one or more Mills
		This location is being used by one or more Stockpiles
		This location is being used by one or more Weightomters
		This location is being used by one or more Mine Plan Periods
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateWeightometerSampleValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateWeightometerSampleValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateWeightometerSampleValue]
GO

Create Procedure [dbo].[AddOrUpdateWeightometerSampleValue]

(@Weightometer_Sample_Id Int,
@Weightometer_Sample_Field_Id Varchar(31),
@Field_Value Real)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the mine plan period exists */
	If Exists (Select * From WeightometerSample Where Weightometer_Sample_Id = @Weightometer_Sample_Id)
	Begin
		/* If the value given is not null */
		If (@Field_Value Is Not Null)
		Begin
			/* If this field is not already populated */
			If Not Exists (Select * From WeightometerSampleValue Where Weightometer_Sample_Id = @Weightometer_Sample_Id
			And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id)
			Begin
				/* Insert a new value for the field */
				Insert Into WeightometerSampleValue
				 (Weightometer_Sample_Id, Weightometer_Sample_Field_Id, Field_Value)
				Values (@Weightometer_Sample_Id, @Weightometer_Sample_Field_Id, @Field_Value)
			End
			Else
			Begin
				/* Otherwise, update the field */
				Update WeightometerSampleValue
				Set	Field_Value = @Field_Value
				Where Weightometer_Sample_Id = @Weightometer_Sample_Id
				And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id
			End
		End
		Else
		Begin
			/* Otherwise, delete the record if it exists */
			Delete From WeightometerSampleValue
			Where Weightometer_Sample_Id = @Weightometer_Sample_Id
			And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id
		End

		If @@Error = 0
		Begin
			Set @ELC_Proc_Is_Error = 0
		End
	End
	Else
	Begin
		Raiserror('The given weightometer sample does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------


GO

GRANT EXECUTE ON dbo.AddOrUpdateWeightometerSampleValue TO CoreUtilityManager
GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateWeightometerSampleValue">
 <Procedure>
	Adds a new record or updates an existing record in the WeightometerSampleValue table if @Field_Value is specified.
	If @Field_Value is not specified and the records exists in WeightometerSampleValue table the record is deleted.
	Errors are raised if:
		The given weightometer sample does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageRawGrade.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddOrUpdateHaulageRawGrade'))
	Drop Procedure dbo.AddOrUpdateHaulageRawGrade
Go

Create Procedure dbo.AddOrUpdateHaulageRawGrade
(
	@iHaulage_Raw_Id Int,
	@iGrade_Id VarChar(31),
	@iGrade_Value Real
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If (Select Haulage_Raw_State_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @iHaulage_Raw_Id) <> 'A'
	Begin
		RaisError('AddOrUpdateHaulageRawGrade: Raw haulage must be in the awaiting correction state.', 16, 1)
	End
	Else
	Begin
		If Exists (	Select 1
					From HaulageRawGrade
					Where Haulage_Raw_Id = @iHaulage_Raw_Id
						And Grade_Id = @iGrade_Id)
		Begin
			If @iGrade_Value Is Null
			Begin
				Delete
				From HaulageRawGrade
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Grade_Id = @iGrade_Id
			End
			Else
			Begin
				Update HaulageRawGrade
				Set Grade_Value = @iGrade_Value
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Grade_Id = @iGrade_Id
			End
		End
		Else
		Begin
			If @iGrade_Value Is Not Null
			Begin
				Insert Into HaulageRawGrade
				(
					Haulage_Raw_Id, Grade_Id, Grade_Value
				)
				Values
				(
					@iHaulage_Raw_Id, @iGrade_Id, @iGrade_Value
				)
			End
		End
	End

	Commit Transaction
End
Go
  GRANT EXECUTE ON dbo.AddOrUpdateHaulageRawGrade TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageRawGrade">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageRawGrade table if the @iGrade_Value value is specified.
	If no @iGrade_Value value is specified and the record exists in the HaulageRawGrade table the record is deleted.
	Raises a recalc record for the associated Haulage record.
	Errors raised if:
		Raw haulage record is not in the awaiting correction state
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageRawNotes.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddOrUpdateHaulageRawNotes'))
	Drop Procedure dbo.AddOrUpdateHaulageRawNotes
Go

Create Procedure dbo.AddOrUpdateHaulageRawNotes
(
	@iHaulage_Raw_Id Int,
	@iHaulage_Raw_Field_Id VarChar(31),
	@iNotes VarChar(1023)
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- only allow add/update of HaulageRaw records
	-- that are not at the end of a chain

	If (Select Haulage_Raw_State_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @iHaulage_Raw_Id) <> 'A'
	Begin
		RaisError('AddOrUpdateHaulageRawNotes: Raw haulage must be in the awaiting correction state.', 16, 1)
	End
	Else
	Begin
		If Exists (	Select 1
					From HaulageRawNotes
					Where Haulage_Raw_Id = @iHaulage_Raw_Id
						And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id)
		Begin
			If @iNotes Is Null
			Begin
				Delete
				From HaulageRawNotes
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id
			End
			Else
			Begin
				Update HaulageRawNotes
				Set Notes = @iNotes
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id
			End
		End
		Else
		Begin
			If @iNotes Is Not Null
			Begin
				Insert Into HaulageRawNotes
				(
					Haulage_Raw_Id, Haulage_Raw_Field_Id, Notes
				)
				Values
				(
					@iHaulage_Raw_Id, @iHaulage_Raw_Field_Id, @iNotes
				)
			End
		End
	End

	Commit Transaction
End
Go
  GRANT EXECUTE ON dbo.AddOrUpdateHaulageRawNotes TO CoreHaulageManager

 
/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageRawNotes">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageRawNotes table if the @iNotes value is specified.
	If no @iNotes value is specified and the record exists in the HaulageRawNotes table the record is deleted.
	Raises a recalc record for the associated Haulage record.
	Errors raised if:
		Raw haulage is not in the awaiting correction state
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageRawValue.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AddOrUpdateHaulageRawValue'))
	Drop Procedure dbo.AddOrUpdateHaulageRawValue
Go

Create Procedure dbo.AddOrUpdateHaulageRawValue
(
	@iHaulage_Raw_Id Int,
	@iHaulage_Raw_Field_Id VarChar(31),
	@iField_Value Real
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	If (Select Haulage_Raw_State_Id
		From HaulageRaw
		Where Haulage_Raw_Id = @iHaulage_Raw_Id) <> 'A'
	Begin
		RaisError('AddOrUpdateHaulageRawValue: Raw haulage must be in the awaiting correction state.', 16, 1)
	End
	Else
	Begin
		If Exists (	Select 1
					From HaulageRawValue
					Where Haulage_Raw_Id = @iHaulage_Raw_Id
						And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id)
		Begin
			If @iField_Value Is Null
			Begin
				Delete
				From HaulageRawValue
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id
			End
			Else
			Begin
				Update HaulageRawValue
				Set Field_Value = @iField_Value
				Where Haulage_Raw_Id = @iHaulage_Raw_Id
					And Haulage_Raw_Field_Id = @iHaulage_Raw_Field_Id
			End
		End
		Else
		Begin
			If @iField_Value Is Not Null
			Begin
				Insert Into HaulageRawValue
				(
					Haulage_Raw_Id, Haulage_Raw_Field_Id, Field_Value
				)
				Values
				(
					@iHaulage_Raw_Id, @iHaulage_Raw_Field_Id, @iField_Value
				)
			End
		End
	End

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.AddOrUpdateHaulageRawValue TO CoreHaulageManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateHaulageRawValue">
 <Procedure>
	Adds a new record or updates an existing record in the HaulageRawValue table if the @iField_Value value is specified.
	If no @iField_Value value is specified and the record exists in the HaulageRawValue table the record is deleted.
	Errors raised if:
		Raw haulage is not in the awaiting correction state
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateWeightometerSampleNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateWeightometerSampleNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateWeightometerSampleNotes]
GO

Create Procedure [dbo].[AddOrUpdateWeightometerSampleNotes]

(@Weightometer_Sample_Id Int,
@Weightometer_Sample_Field_Id Varchar(31),
@Notes Varchar(1023))

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the mine plan period exists */
	If Exists (Select * From WeightometerSample Where Weightometer_Sample_Id = @Weightometer_Sample_Id)
	Begin
		/* If the value given is not null */
		If (@Notes Is Not Null)
		Begin
			/* If this field is not already populated */
			If Not Exists (Select * From WeightometerSampleNotes Where Weightometer_Sample_Id = @Weightometer_Sample_Id
			And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id)
			Begin
				/* Insert a new value for the field */
				Insert Into WeightometerSampleNotes
				 (Weightometer_Sample_Id, Weightometer_Sample_Field_Id, Notes)
				Values (@Weightometer_Sample_Id, @Weightometer_Sample_Field_Id, @Notes)
			End
			Else
			Begin
				/* Otherwise, update the field */
				Update WeightometerSampleNotes
				Set	Notes = @Notes
				Where Weightometer_Sample_Id = @Weightometer_Sample_Id
				And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id
			End
		End
		Else
		Begin
			/* Otherwise, delete the record if it exists */
			Delete From WeightometerSampleNotes
			Where Weightometer_Sample_Id = @Weightometer_Sample_Id
			And Weightometer_Sample_Field_Id = @Weightometer_Sample_Field_Id
		End

		If @@Error = 0
		Begin
			Set @ELC_Proc_Is_Error = 0
		End
	End
	Else
	Begin
		Raiserror('The given weightometer sample does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
GO

GRANT EXECUTE ON dbo.AddOrUpdateWeightometerSampleNotes TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateWeightometerSampleNotes">
 <Procedure>
	Adds a new record or updates an existing record in the WeightometerSampleNotes table 
	Errors raised if:
		The given weightometer sample does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySampleGrade.prc'
GO

If Object_Id('dbo.AddOrUpdateDigblockSurveySampleGrade') Is Not Null 
     Drop Procedure dbo.AddOrUpdateDigblockSurveySampleGrade 
Go 

Create Procedure dbo.AddOrUpdateDigblockSurveySampleGrade
(
  @iDigblock_Survey_Sample_Id int,
  @iGrade_Id SmallInt,
  @iGrade_Value real
)
With Encryption 
As 

Begin
	Set Nocount On

	Begin Transaction

    --Check for a valid grade value	
	If @iGrade_Value < 0
	Begin
		RaisError('Grade value specified is less than 0',16,1)
	End
	Else
	Begin
		If @iGrade_Value Is Null
		Begin
				Delete From DigblockSurveySampleGrade
				Where Digblock_Survey_Sample_Id = @iDigblock_Survey_Sample_Id
					And Grade_Id = @iGrade_Id
		End
		Else If Exists 
			(
			Select Top 1 1 
			From dbo.DigblockSurveySampleGrade 
			Where Grade_Id = @iGrade_Id
				And Digblock_Survey_Sample_Id = @iDigblock_Survey_Sample_Id
			) 
		Begin
			Update DigblockSurveySampleGrade
			Set Grade_Value = @iGrade_Value
			Where Digblock_Survey_Sample_Id = @iDigblock_Survey_Sample_Id
				And Grade_Id = @iGrade_Id
		End
		Else
		Begin
			Insert Into DigblockSurveySampleGrade
			(
				Digblock_Survey_Sample_Id,
				Grade_Id,
				Grade_Value
			)
			Values
			(
				@iDigblock_Survey_Sample_Id,
				@iGrade_Id,
				@iGrade_Value
			)
		End
	End

	Commit Transaction

End
Go
GRANT EXECUTE ON dbo.AddOrUpdateDigblockSurveySampleGrade TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateDigblockSurveySampleGrade">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySampleGrade table.
	Errors raised if:
		Update or insert of the record fails
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.SolveLinearEquationSystem.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SolveLinearEquationSystem]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[SolveLinearEquationSystem]
GO

CREATE Procedure [dbo].[SolveLinearEquationSystem]

(@Is_Singular Bit Output)

With Encryption As

Declare @No_Rows Int
Declare @No_Columns Int
Declare @Size Int
Declare @Max_Value Float
Declare @Temp_Sum Float
Declare @I Int
Declare @J Int
Declare @K Int
Declare @II Int
Declare @LL Int
Declare @Max_Value_Pos Int
Declare @Temp_Value Float
Declare @Tiny_Value Float

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set @Tiny_Value = 0.000000000000001

	-- Get the number of distinct rows in the "A" matrix
	Select @No_Rows = Count(Distinct I)
	From SolverLinearEquationA

	-- Get the number of distinct columns in the "A" matrix
	Select @No_Columns = Count(Distinct J)
	From SolverLinearEquationA

	-- Also get the number of records in the "B" vector
	Select @Size = Count(*)
	From SolverLinearEquationB

	-- If all these numbers are the same
	If ((@Size = @No_Rows) And (@Size = @No_Columns))
	Begin
		-- Initialise the working value fields
		Update SolverLinearEquationA
		Set	Working_Value = Initial_Value

		Update SolverLinearEquationB
		Set	Working_Value = Initial_Value

		Declare @VV Table
		 (I Int, Value Float)

		Declare @INDX Table
		 (I Int, Value Float)

		Set @I = 1
		While (@I <= @Size)
		Begin
			Insert Into @VV
			 (I)
			Values (@I)
	
			Insert Into @INDX
			 (I)
			Values (@I)
	
			Set @I = @I + 1
		End
	
		Set @Is_Singular = 0

		Set @I = 1
		While ((@I <= @Size) And (@Is_Singular = 0))
		Begin
			Set @Max_Value = 0

			Set @J = 1
			While (@J <= @Size)
			Begin
				Select @Temp_Value = Working_Value
				From SolverLinearEquationA
				Where I = @I
				And J = @J
	
				If (ABS(@Temp_Value) > @Max_Value)
				Begin
					Set @Max_Value = ABS(@Temp_Value)
				End

				Set @J = @J + 1
			End

			-- If all the values in one row are 0, the matrix is singular
			If (@Max_Value < @Tiny_Value)
			Begin
				Set @Is_Singular = 1
			End

			Set @J = @I + 1
			While ((@J <= @Size) And (@Is_Singular = 0))
			Begin
				Set @K = 1

				While (((Select Working_Value From SolverLinearEquationA Where I = @I And J = @K) = 0)
				Or ((Select Working_Value From SolverLinearEquationA Where I = @J And J = @K) = 0))
				And (@Is_Singular = 0)
				And (@K <= @Size)
				Begin
					If ((Select Working_Value From SolverLinearEquationA Where I = @I And J = @K) = 0)
					And ((Select Working_Value From SolverLinearEquationA Where I = @J And J = @K) = 0)
					Begin
						Set @Is_Singular = 1
					End
					Else
					Begin
						Set @K = @K + 1
					End
				End

				If ((@Is_Singular = 0) And (@K < @Size))
				Begin
					Set @Temp_Sum = 0

					Select @Temp_Value = T1.Working_Value / T2.Working_Value
					From SolverLinearEquationA T1, SolverLinearEquationA T2
					Where T1.I = @I
					And T1.J = @K
					And T2.I = @J
					And T2.J = @K

					While (@K <= @Size)
					Begin
						If (ABS((Select Working_Value From SolverLinearEquationA Where I = @I And J = @K)
						- ((Select Working_Value From SolverLinearEquationA Where I = @J And J = @K) * @Temp_Value)) > @Tiny_Value)
						Begin
							Set @Temp_Sum = @Temp_Sum + 1
						End

						Set @K = @K + 1
					End

					If (@Temp_Sum = 0)
					Begin
						Set @Is_Singular = 1
					End
				End				

				Set @J = @J + 1
			End

			If (@Is_Singular = 0)
			Begin
				Update @VV
				Set	Value = 1.0 / @Max_Value
				Where I = @I
			End

			Set @I = @I + 1
		End

		If (@Is_Singular = 0)
		Begin
			Set @J = 1
			While (@J <= @Size)
			Begin
				Set @I = 1
				While (@I < @J)
				Begin
					Select @Temp_Sum = Working_Value
					From SolverLinearEquationA
					Where I = @I
					And J = @J
		
					Set @K = 1
					While (@K < @I)
					Begin
						Set @Temp_Sum = @Temp_Sum -
								((Select Working_Value From SolverLinearEquationA Where I = @I And J = @K)
								* (Select Working_Value From SolverLinearEquationA Where I = @K And J = @J))
		
						Set @K = @K + 1
					End
		
					Update SolverLinearEquationA
					Set	Working_Value = @Temp_Sum
					Where I = @I
					And J = @J
		
					Set @I = @I + 1
				End

				Set @Max_Value = 0.0;

				Set @I = @J
				While (@I <= @Size)
				Begin
					Select @Temp_Sum = Working_Value
					From SolverLinearEquationA
					Where I = @I
					And J = @J
		
					Set @K = 1
					While (@K < @J)
					Begin
						Set @Temp_Sum = @Temp_Sum -
								((Select Working_Value From SolverLinearEquationA Where I = @I And J = @K)
								* (Select Working_Value From SolverLinearEquationA Where I = @K And J = @J))
		
						Set @K = @K + 1
					End

					Update SolverLinearEquationA
					Set	Working_Value = @Temp_Sum
					Where I = @I
					And J = @J

					Select @Temp_Value = Value * ABS(@Temp_Sum)
					From @VV
					Where I = @I

					If (@Temp_Value >= @Max_Value)
					Begin
						Set @Max_Value_Pos = @I
						Set @Max_Value = @Temp_Value
					End

					Set @I = @I + 1
				End

				If (@J <> @Max_Value_Pos)
				Begin
					Set @K = 1
					While (@K <= @Size)
					Begin
						Select @Temp_Value = Working_Value
						From SolverLinearEquationA
						Where I = @Max_Value_Pos
						And J = @K

						Update T
						Set	Working_Value = T2.Working_Value
						From SolverLinearEquationA T, SolverLinearEquationA T2
						Where T.I = @Max_Value_Pos
						And T.J = @K
						And T2.I = @J
						And T2.J = @K

						Update SolverLinearEquationA
						Set	Working_Value = @Temp_Value
						Where I = @J
						And J = @K

						Set @K = @K + 1
					End

					Update V
					Set	Value = V2.Value
					From @VV V, @VV V2
					Where V.I = @Max_Value_Pos
					And V2.I = @J
				End

				Update @INDX
				Set	Value = @Max_Value_Pos
				Where I = @J

				If (ABS((Select Working_Value From SolverLinearEquationA Where I = @J And J = @J)) < @Tiny_Value)
				Begin
					Update SolverLinearEquationA
					Set	Working_Value = @Tiny_Value
					Where I = @J
					And J = @J
				End

				If (@J <> @Size)
				Begin
					Set @Temp_Value = 1.0 / (Select Working_Value From SolverLinearEquationA Where I = @J And J = @J)

					Set @I = @J + 1
					While (@I <= @Size)
					Begin
						Update SolverLinearEquationA
						Set	Working_Value = Working_Value * @Temp_Value
						Where I = @I
						And J = @J
		
						Set @I = @I + 1
					End
				End
		
				Set @J = @J + 1
			End


			-- Code to actually solve the system from new matrix given
			Set @II = 0

			Set @I = 1
			While (@I <= @Size)
			Begin
				Select @LL = Value
				From @INDX
				Where I = @I

				Select @Temp_Sum = Working_Value
				From SolverLinearEquationB
				Where I = @LL

				Update T
				Set	Working_Value = T2.Working_Value
				From SolverLinearEquationB T, SolverLinearEquationB T2
				Where T.I = @LL
				And T2.I = @I

				If (@II <> 0)
				Begin
					Set @J = @II
					While (@J < @I)
					Begin
						Set @Temp_Sum = @Temp_Sum -
								((Select Working_Value From SolverLinearEquationA Where I = @I And J = @J)
								* (Select Working_Value From SolverLinearEquationB Where I = @J))
	
						Set @J = @J + 1
					End
				End
				Else
				Begin
					If (@Temp_Sum <> 0)
					Begin
						Set @II = @I
					End
				End
	
				Update T
				Set	Working_Value = @Temp_Sum
				From SolverLinearEquationB T
				Where T.I = @I
	
				Set @I = @I + 1
			End
	
			Set @I = @Size
			While (@I >= 1)
			Begin
				Select @Temp_Sum = Working_Value
				From SolverLinearEquationB
				Where I = @I
	
				If (@I < @Size)
				Begin
					Set @J = @I + 1
					While (@J <= @Size)
					Begin
						Set @Temp_Sum = @Temp_Sum -
								((Select Working_Value From SolverLinearEquationA Where I = @I And J = @J)
								* (Select Working_Value From SolverLinearEquationB Where I = @J))
	
						Set @J = @J + 1
					End
				End

				Update T
				Set	Working_Value = @Temp_Sum / (Select Working_Value From SolverLinearEquationA Where I = @I And J = @I)
				From SolverLinearEquationB T
				Where T.I = @I

				Set @I = @I - 1
			End
		End

		Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The details in the source tables are not valid', 16, 1)
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="SolveLinearEquationSystem">
 <Procedure>
	Solves a Linear Equation.
	Errors raised if:
		The details in the source tables are not valid
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockPartialListPivoted.prc'
GO

IF OBJECT_ID('dbo.GetModelBlockPartialListPivoted') IS NOT NULL 
     DROP PROCEDURE dbo.GetModelBlockPartialListPivoted 
GO 
  
CREATE PROCEDURE dbo.GetModelBlockPartialListPivoted
( 
	@iBlock_Model_Id Int = Null,
	@iModel_Block_Id Int = Null,
	@iMaterial_Type_Id Int = Null,
	@iDigblock_Survey_Date Datetime = Null,
	@iDigblock_Survey_Shift Char(1) = Null,
	@iDigblock_Survey_Type_Id Int = Null,
	@iBlast_Block_Id Int = Null,
	@iGrade_Visibility Bit = 1 
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'GetModelBlockPartialListPivoted',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	CREATE TABLE dbo.#Blocks
	(
		Block_Model_Id Int Not Null,
		Model_Block_Id Int Not Null,
		Code Varchar(31) Collate Database_Default Not Null,
		Sequence_No Int Not Null,
		Material_Type_Id Int Not Null,
		Digblock_Survey_Date DateTime Null,
		Digblock_Survey_Shift Char(1) Collate Database_Default Null,		
		Tonnes Float Not Null
	)

	Create Table dbo.#PivotData
	(
		Model_Block_Id Int Not Null,
		Sequence_No Int Not Null,
		Pivot_Id Varchar(31) Collate Database_Default Not Null,
		Value Float Null
	)
	
	Create Table dbo.#PivotStringData
	(
		Model_Block_Id Int Not Null, 
		Sequence_No Int Not Null,
		Pivot_Id Varchar(31) Collate Database_Default Not Null,
		Value Varchar(1023) Collate Database_Default Null
	)

    BEGIN TRY
		--Load Block Data
		Insert Into dbo.#Blocks
		(
			Block_Model_Id, Model_Block_Id, Code, Sequence_No,
			Material_Type_Id, Digblock_Survey_Date, Digblock_Survey_Shift, Tonnes
		)
		Select MB.Block_Model_Id, MBP.Model_Block_Id, MB.Code, MBP.Sequence_No,
			MBP.Material_Type_Id, MBP.Digblock_Survey_Date, MBP.Digblock_Survey_Shift, MBP.Tonnes
		From dbo.ModelBlockPartial AS MBP
			Inner Join dbo.ModelBlock AS MB
				On (MBP.Model_Block_Id = MB.Model_Block_Id)
		Where MB.Block_Model_Id = IsNull(@iBlock_Model_Id, MB.Block_Model_Id)
			And MBP.Model_Block_Id = IsNull(@iModel_Block_Id, MBP.Model_Block_Id)
			And MBP.Material_Type_Id = IsNull(@iMaterial_Type_Id, MBP.Material_Type_Id)
			And (MBP.Digblock_Survey_Date = @iDigblock_Survey_Date
				Or @iDigblock_Survey_Date Is Null)
			And (MBP.Digblock_Survey_Shift = @iDigblock_Survey_Shift 
				Or @iDigblock_Survey_Shift Is Null)

		--Filter Blast Blocks
		If @iBlast_Block_Id Is Not Null
		Begin
			Delete B
			From dbo.#Blocks AS B
			Where Not Exists
				(
					Select 1
					From dbo.BlastBlockModelBlock As BBMB
					Where BBMB.Model_Block_Id = B.Model_Block_Id
						And BBMB.Blast_Block_Id = @iBlast_Block_Id
				)
		End

		--Load Pivot Defaults
		Insert Into dbo.#PivotData
		(
			Model_Block_Id, Sequence_No, Pivot_Id, Value
		)
		Select -1, -1, G.Grade_Name, Null
		From dbo.Grade As G
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		Union
		Select -1, -1, MBPF.Model_Block_Partial_Field_Id, Null
		From dbo.ModelBlockPartialField AS MBPF
		Where Has_Value = 1

		Insert Into dbo.#PivotStringData
		(
			Model_Block_Id, Sequence_No, Pivot_Id, Value
		)
		Select -1, -1, MBPF.Model_Block_Partial_Field_Id, Null
		From dbo.ModelBlockPartialField AS MBPF
		Where Has_Notes = 1

		--Load Pivot Data
		Insert Into dbo.#PivotData
		(
			Model_Block_Id, Sequence_No, Pivot_Id, Value
		)
		Select B.Model_Block_Id, B.Sequence_No, G.Grade_Name, MBPG.Grade_Value
		From dbo.ModelBlockPartialGrade AS MBPG
			Inner Join dbo.#Blocks As B
				On (MBPG.Model_Block_Id = B.Model_Block_Id
					And MBPG.Sequence_No = B.Sequence_No)
			Inner Join dbo.Grade As G
				On (MBPG.Grade_Id = G.Grade_Id)
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		Union
		Select B.Model_Block_Id, B.Sequence_No, 
			MBPV.Model_Block_Partial_Field_Id, MBPV.Field_Value
		From dbo.ModelBlockPartialValue AS MBPV
			Inner Join dbo.#Blocks As B
				On (MBPV.Model_Block_Id = B.Model_Block_Id
					And MBPV.Sequence_No = B.Sequence_No)

		Insert Into dbo.#PivotStringData
		(
			Model_Block_Id, Sequence_No, Pivot_Id, Value
		)
		Select B.Model_Block_Id, B.Sequence_No, 
			MBPN.Model_Block_Partial_Field_Id, MBPN.Notes
		From dbo.ModelBlockPartialNotes AS MBPN
			Inner Join dbo.#Blocks As B
				On (MBPN.Model_Block_Id = B.Model_Block_Id
					And MBPN.Sequence_No = B.Sequence_No)

		--Pivot Data
		Exec dbo.PivotTable	
			@iTargetTable = '#Blocks',
			@iPivotTable = '#PivotData',
			@iJoinColumns = '#Blocks.Model_Block_Id = #PivotData.Model_Block_Id And #Blocks.Sequence_No = #PivotData.Sequence_No',
			@iPivotColumn = 'Pivot_Id',
			@iPivotValue = 'Value',
			@iPivotType = 'Float'

		Exec dbo.PivotTable	
			@iTargetTable = '#Blocks',
			@iPivotTable = '#PivotStringData',
			@iJoinColumns = '#Blocks.Model_Block_Id = #PivotStringData.Model_Block_Id And #Blocks.Sequence_No = #PivotStringData.Sequence_No',
			@iPivotColumn = 'Pivot_Id',
			@iPivotValue = 'Value',
			@iPivotType = 'Float'

		Select *
		From dbo.#Blocks

		DROP TABLE dbo.#Blocks
		DROP TABLE dbo.#PivotData
		DROP TABLE dbo.#PivotStringData

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH	
END 
GO 

GRANT EXECUTE ON dbo.GetModelBlockPartialListPivoted TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetModelBlockPartialListPivoted">
 <Procedure>
	Returns list of Model_Block and Model_Block_Partial Records.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockPartialList.prc'
GO

IF OBJECT_ID('dbo.GetModelBlockPartialList') IS NOT NULL
	DROP PROCEDURE dbo.GetModelBlockPartialList
GO 
  
CREATE PROCEDURE dbo.GetModelBlockPartialList
(
	@iModelBlockId INT,
	@iSequenceNo INT
)
WITH ENCRYPTION
AS
BEGIN
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT Model_Block_Id AS ModelBlockId, Sequence_No AS SequenceNo, Digblock_Survey_Date AS DigblockSurveyDate,
			Digblock_Survey_Shift AS DigblockSurveyShift, Material_Type_Id AS MaterialTypeId, Tonnes
		FROM dbo.ModelBlockPartial
		WHERE Model_Block_Id = @iModelBlockId
			AND Sequence_No = ISNULL(@iSequenceNo, Sequence_No)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetModelBlockPartialList TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetModelBlockPartialList">
 <Procedure>
	Returns a specific (or list of) Partial records for a specified Model Block record.
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockPartialFieldList.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetModelBlockPartialFieldList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetModelBlockPartialFieldList]
GO

CREATE Procedure [dbo].[GetModelBlockPartialFieldList]

With Encryption As

Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* Return the list of model block virtual fields in the system */
	Select Model_Block_Partial_Field_Id, Description, Order_No, Has_Value, Has_Notes, Has_Formula
	From ModelBlockPartialField
	Order By Order_No, Model_Block_Partial_Field_Id

	Return
End
GO

GRANT EXECUTE ON dbo.GetModelBlockPartialFieldList TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetModelBlockPartialFieldList">
 <Procedure>
	Return the list of model block virtual fields in the system.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdatePeriodNotesGroup.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdatePeriodNotesGroup]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdatePeriodNotesGroup]
GO

CREATE Procedure [dbo].[AddOrUpdatePeriodNotesGroup]

(@pPeriod_Notes_Group_Id Int = Null Output,
 @pParent_Period_Notes_Group_Id Int = Null,
 @pGroup_Name VarChar(255))

With Encryption As

Begin
	Declare @Record_Count Int

	Set NoCount On
	Set XAct_Abort On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction Add_Or_Update_Period_Group_Notes

	-- we're intending to insert a new record
	If @pPeriod_Notes_Group_Id Is Null
	Begin
		Insert Into PeriodNotesGroup
		 (Parent_Period_Notes_Group_Id, Group_Name)
		Select @pParent_Period_Notes_Group_Id, @pGroup_Name

		Set @pPeriod_Notes_Group_Id = Scope_Identity()
	End
	Else
	Begin
		-- check to see if the record exists - if not, raise an error
		Set @Record_Count = (Select Count(*)
		                     From PeriodNotesGroup
		                     Where Period_Notes_Group_Id = @pPeriod_Notes_Group_Id)

		If @Record_Count = 0
		Begin
			Commit Transaction AddOrUpdatePeriodNotesGroup
			RaisError('AddOrUpdatePeriodNotesGroup: Period_Note_Group_Id of %u does not exist.', 16, 1, @pPeriod_Notes_Group_Id)
			Return
		End

		-- perform the update
		Update PeriodNotesGroup
		Set Parent_Period_Notes_Group_Id = @pParent_Period_Notes_Group_Id,
		 Group_Name = @pGroup_Name
		Where Period_Notes_Group_Id = @pPeriod_Notes_Group_Id
	End

	Commit Transaction AddOrUpdatePeriodNotesGroup
	Set Transaction Isolation Level Read Committed

	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdatePeriodNotesGroup">
 <Procedure>
	Adds a new record or updates an existing record in the PeriodNotesGroup table.
	Errors raised if:
		The @pPeriod_Notes_Group_Id is specified but does not exist in the PeriodNotesGroup table
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetPeriodNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPeriodNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetPeriodNotes]
GO

CREATE Procedure [dbo].[GetPeriodNotes]

(@pPeriod_Notes_Id Int = Null,
 @pPeriod_Notes_Group_Id Int = Null,
 @pPeriod_Start_Date DateTime = Null,
 @pPeriod_End_Date DateTime = Null,
 @pAdded_By VarChar(50) = Null)

With Encryption As

Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction GetPeriodNotes

	-- 1. @pPeriod_Notes_Id
	If @pPeriod_Notes_Id Is Not Null
	Begin
		Select PN.Period_Notes_Id, PN.Period_Notes_Group_Id,
		 Convert(VarChar, PN.Period_Start_Date, 106) As Period_Start_Date,
		 Convert(VarChar, PN.Period_End_Date, 106) As Period_End_Date,
		 PN.Notes, PN.Added_By, PNG.Parent_Period_Notes_Group_Id
		From PeriodNotes PN
		 Inner Join PeriodNotesGroup PNG On (PN.Period_Notes_Group_Id = PNG.Period_Notes_Group_Id)
		Where Period_Notes_Id = @pPeriod_Notes_Id
	End
	Else
	Begin
		-- 2. @pPeriod_Notes_Group_Id, @pPeriod_Start_Date,
		--    @pPeriod_Start_Date, @pPeriod_End_Date, @pAdded_By

		Select PN.Period_Notes_Id, PN.Period_Notes_Group_Id,
		 Convert(VarChar, PN.Period_Start_Date, 106) As Period_Start_Date,
		 Convert(VarChar, PN.Period_End_Date, 106) As Period_End_Date,
		 PN.Notes,
		 PN.Added_By, PNG.Parent_Period_Notes_Group_Id
		From PeriodNotes PN
		 Inner Join PeriodNotesGroup PNG On (PN.Period_Notes_Group_Id = PNG.Period_Notes_Group_Id)
		Where (PN.Period_Notes_Group_Id = @pPeriod_Notes_Group_Id
		       Or @pPeriod_Notes_Group_Id Is Null)
		 And (PN.Period_Start_Date >= @pPeriod_Start_Date
		      Or @pPeriod_Start_Date Is Null)
		 And (PN.Period_End_Date <= @pPeriod_End_Date
		      Or @pPeriod_End_Date Is Null)
		 And (PN.Added_By = @pAdded_By
		      Or @pAdded_By Is Null)
		Order By PN.Period_Start_Date, PN.Period_Notes_Id
	End

	Commit Transaction GetPeriodNotes
	Set Transaction Isolation Level Read Committed

	Return
End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetPeriodNotes">
 <Procedure>
	Returns the period notes for a selected period.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeletePeriodNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DeletePeriodNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[DeletePeriodNotes]
GO

CREATE Procedure [dbo].[DeletePeriodNotes]

(@pPeriod_Notes_Id Int)

With Encryption As

Begin
	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Delete
	From PeriodNotes
	Where Period_Notes_Id = @pPeriod_Notes_Id

	If @@Error = 0
		SEt @ELC_Proc_Is_Error = 0
	
End
GO



/*
<TAG Name="Data Dictionary" ProcedureName="DeletePeriodNotes">
 <Procedure>
	Deletes a record from the PeriodNotes table.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdatePeriodNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdatePeriodNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdatePeriodNotes]
GO

CREATE Procedure [dbo].[AddOrUpdatePeriodNotes]

(@pPeriod_Notes_Id Int = Null Output,
 @pPeriod_Notes_Group_Id Int,
 @pNotes VarChar(255),
 @pPeriod_Start_Date DateTime = Null,
 @pPeriod_End_Date DateTime = Null,
 @pAdded_By VarChar(50) = Null)

With Encryption As

Begin
	Declare @Record_Count Int

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set NoCount On
	Set XAct_Abort On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction AddOrUpdatePeriodNotes

	-- we're intending to insert a new record
	If @pPeriod_Notes_Id Is Null
	Begin
		Insert Into PeriodNotes
		 (Period_Notes_Group_Id, Period_Start_Date, Period_End_Date, Notes, Added_By)
		Select @pPeriod_Notes_Group_Id,
		 Coalesce(@pPeriod_Start_Date, dbo.GetDateDay(GetDate())),
		 @pPeriod_End_Date,
		 @pNotes,
		 Coalesce(@pAdded_By, SUser_SName())

		Set @pPeriod_Notes_Id = Scope_Identity()
	End
	Else
	Begin
		-- check to see if the record exists - if not, raise an error
		Set @Record_Count = (Select Count(*)
		                     From PeriodNotes
		                     Where Period_Notes_Id = @pPeriod_Notes_Id)

		If @Record_Count = 0
		Begin
			Commit Transaction AddOrUpdatePeriodNotes
			RaisError('AddOrUpdatePeriodNotes: Period_Note_Id of %u does not exist.', 16, 1, @pPeriod_Notes_Id)
			Return
		End

		-- perform the update
		Update PeriodNotes
		Set Period_Notes_Group_Id = @pPeriod_Notes_Group_Id,
		 Period_Start_Date = Coalesce(@pPeriod_Start_Date, dbo.GetDateDay(GetDate())),
		 Period_End_Date = @pPeriod_End_Date,
		 Notes = @pNotes,
		 Added_By = Coalesce(@pAdded_By, SUser_SName())
		Where Period_Notes_Id = @pPeriod_Notes_Id
	End

	Commit Transaction AddOrUpdatePeriodNotes
	Set Transaction Isolation Level Read Committed
	
	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




End

GO



/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdatePeriodNotes">
 <Procedure>
	Adds a new record or updates an existing record in the PeriodNotes table.
	Errors raised if:
		The @pPeriod_Notes_Id is specified but does not exist in the PeriodNotes table
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateBlastBlock.prc'
GO

if object_id('dbo.UpdateBlastBlock') is not null
	Drop Procedure dbo.UpdateBlastBlock
Go

CREATE Procedure dbo.UpdateBlastBlock
(
	@Blast_Block_Id Int = Null,
	@Code Varchar(31) = '',
	@Drilling_Start_Date Datetime = '1-1-1901',
	@Drilling_End_Date Datetime = '1-1-1901',
	@Blasted_Date Datetime = '1-1-1901',
	@Completed_Date Datetime = '1-1-1901',
	@X Float = -1,
	@Y Float = -1,
	@Z Float = -1,
	@Notes Varchar(1023) = ''
)
With Encryption As
Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If this blast block exists in the system */
	If Exists (Select * From BlastBlock Where Blast_Block_Id = @Blast_Block_Id Or Code = @Code)
	Begin
		/* Update the existing record */
		Update BlastBlock
		Set	Code = Case When (@Code = '') Then Code Else @Code End,
			Drilling_Start_Date = Case When (@Drilling_Start_Date = '1-1-1901') Then Drilling_Start_Date Else @Drilling_Start_Date End,
			Drilling_End_Date = Case When (@Drilling_End_Date = '1-1-1901') Then Drilling_End_Date Else @Drilling_End_Date End,
			Blasted_Date = Case When (@Blasted_Date = '1-1-1901') Then Blasted_Date Else @Blasted_Date End,
			Completed_Date = Case When (@Completed_Date = '1-1-1901') Then Completed_Date Else @Completed_Date End,
			X = Case When (@X = -1) Then X Else @X End,
			Y = Case When (@Y = -1) Then Y Else @Y End,
			Z = Case When (@Z = -1) Then Z Else @Z End,
			Notes = Case When (@Notes = '') Then Notes Else @Notes End
		Where Blast_Block_Id = @Blast_Block_Id
		Or Code = @Code

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The given blast block does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateBlastBlock">
 <Procedure>
	Updates the table BlastBlock fields Code, Mine, Pit, Area, Phase, Bench_No,
	Blast_No, Drilling_Start_Date, Drilling_End_Date, Completed_Date, X, Y, X, Notes
	for a given Blast_Block_Id or Code.
	Errors are raised if:
		The given blast block does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMaterialTypeNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateMaterialTypeNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateMaterialTypeNotes]
GO

CREATE Procedure [dbo].[AddOrUpdateMaterialTypeNotes]

(@Material_Type_Id Int,
@Material_Type_Field_Id Varchar(31) = Null,
@Notes Varchar(1023),
@Order_No Int = Null)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the material type exists */
	If Exists (Select * From MaterialType Where Material_Type_Id = @Material_Type_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Material_Type_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Material_Type_Field_Id = Material_Type_Field_Id
			From MaterialTypeField
			Where Order_No = @Order_No
		End

		/* If the hole field exists */
		If Exists (Select * From MaterialTypeField Where Material_Type_Field_Id = @Material_Type_Field_Id)
		Begin
			/* If the value is not null */
			If (@Notes Is Not Null)
			Begin
				/* If this forecast field is not already populated */
				If Not Exists (Select * From MaterialTypeNotes Where Material_Type_Id = @Material_Type_Id And Material_Type_Field_Id = @Material_Type_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into MaterialTypeNotes
					 (Material_Type_Id, Material_Type_Field_Id, Notes)
					Values (@Material_Type_Id, @Material_Type_Field_Id, @Notes)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update MaterialTypeNotes
					Set	Notes = @Notes
					Where Material_Type_Id = @Material_Type_Id
					And Material_Type_Field_Id = @Material_Type_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From MaterialTypeNotes
				Where Material_Type_Id = @Material_Type_Id
				And Material_Type_Field_Id = @Material_Type_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given material type field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given material type does not exist', 16, 1)
	End

	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMaterialTypeNotes">
 <Procedure>
	Adds a new record or updates an existing record in the MaterialTypeNotes table if the @Notes value is specified.
	If no @Notes value is specified and the record exists in the MaterialTypeNotes table the record is deleted.
	If @Order_No is specified and @Material_Type_Field_Id is not, the @Material_Type_Field_Id value is determined from the MaterialTypeField table
	Errors raised if:
		The given material type does not exist
		The given material type field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddModelBlock.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddModelBlock]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddModelBlock]
GO

CREATE Procedure [dbo].[AddModelBlock]

(@Block_Model_Id Int,
@Code Varchar(31) = Null,
@X Float = Null,
@Y Float = Null,
@Z Float = Null,
@X_Inc Real = Null,
@Y_Inc Real = Null,
@Z_Inc Real = Null,
@oModel_Block_Id Int = NULL Output)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the block does not already exist in this model */
	If (dbo.DoesModelBlockExist (@Block_Model_Id, Null, @Code, @X, @Y, @Z) = 0)
	Begin
		/* Insert the block into the model */
		Insert Into ModelBlock
		 (Block_Model_Id, Code, X, Y, Z, X_Inc, Y_Inc, Z_Inc)
		Values (@Block_Model_Id, @Code, @X, @Y, @Z, @X_Inc, @Y_Inc, @Z_Inc)

		/* Return it's ID */
		Set @oModel_Block_Id = @@Identity
		Select @oModel_Block_Id As Model_Block_Id

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0

	End
	Else
	Begin
		Raiserror ('This block already exists in this model', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------


GO
GRANT EXECUTE ON dbo.AddModelBlock TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="AddMinePlan">
 <Procedure>
	Adds a record to the ModelBlock table and returns the key of the added record in @oModel_Block_Id output parameter.
	Errors raised if:
		The block already exists in this model
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateModelBlockPartial.prc'
GO

If Object_Id('dbo.UpdateModelBlockPartial') Is Not Null
	Drop Procedure dbo.UpdateModelBlockPartial
Go

CREATE Procedure dbo.UpdateModelBlockPartial
(
	@Model_Block_Id Int,
	@Sequence_No Int,
	@Tonnes Float,
	@iUpdate_Material_Type_Id Bit = 0,
	@iMaterial_Type_Id Int = Null
)
With Encryption As
Begin

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the block partial exists */
	If (dbo.DoesModelBlockPartialExist (@Model_Block_Id, @Sequence_No) = 1)
	Begin
		/* Update the block partial */
		Update ModelBlockPartial
		Set	Tonnes = @Tonnes,
			Material_Type_Id = Case When @iUpdate_Material_Type_Id = 1 Then @iMaterial_Type_Id Else Material_Type_Id End
		Where Model_Block_Id = @Model_Block_Id
		And Sequence_No = @Sequence_No
		
		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
	Begin
		Raiserror ('The block partial does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder

End
GO
GRANT EXECUTE ON dbo.UpdateModelBlockPartial TO CoreBlockModelManager


/*
<TAG Name="Data Dictionary" ProcedureName="UpdateModelBlockPartial">
 <Procedure>
	Updated the table ModelBlockPartial if the the block partial exists.
	Errors are raised if:
		The block partial does not exist.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuildStateList.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetStockpileBuildStateList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetStockpileBuildStateList]
GO

CREATE Procedure [dbo].[GetStockpileBuildStateList]

(@Stockpile_Id Int)

With Encryption As
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* Return the details of each build of this stockpile related to it's date details */
	Select Build_Id, Stockpile_State_Id, Start_Date,
	 dbo.GetShiftTypeName(Start_Shift) As Start_Shift,
	 Reclaim_Start_Date,
	 dbo.GetShiftTypeName(Reclaim_Start_Shift) As Reclaim_Start_Shift,
	 End_Date,
	 dbo.GetShiftTypeName(End_Shift) As End_Shift,
	 Completion_Description
	From StockpileBuild
	Where Stockpile_Id = @Stockpile_Id
	Order By Build_Id
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileBuildStateList">
 <Procedure>
	Return the details of each build of the given stockpile related to it's date details.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblock.prc'
GO

If object_id('dbo.AddOrUpdateDigblock') is not Null 
     Drop Procedure dbo.AddOrUpdateDigblock 
Go 
  
Create Procedure dbo.AddOrUpdateDigblock 
( 
    @Digblock_Id Varchar(31),
	@Description Varchar(63) = Null,
	@Bench_No Varchar(15) = Null,
	@Blast_No Varchar(15) = Null,
	@Material_Type_Id Int,
	@Area Varchar(10) = Null,
	@Phase Varchar(10) = Null,
	@Creation_Datetime DateTime = Null,
	@Start_Date DateTime = Null,
	@Start_Shift Char(1) = Null,
	@Is_In_Pit_Depletion Bit = 1,
	@Is_Visible Bit = 1,
	@Start_Tonnes Float,
	@OC_Density Real = 0,
	@OC_Au Real = 0,
	@OC_CuCN Real = 0,
	@OC_S Real = 0,
	@OC_Cu Real = 0,
	@OC_CaCO3 Real = 0,
	@OC_Au_Recovery_Grade Real = 0,
	@OC_Cu_Recovery_Grade Real = 0,
	@OC_Fe Real = 0,
	@OC_SiO2 Real = 0,
	@OC_Al2O3 Real = 0,
	@OC_K2O Real = 0,
	@OC_P Real = 0,
	@X Float = Null,
	@Y Float = Null,
	@Z Float = Null,
	@Mine Varchar(10) = Null,
	@Pit Varchar(10) = Null,
	@OC_Yield Real = 0,
	@OC_Ash Real = 0,
	@OC_H2O_Inherent Real = 0,
	@OC_H2O_Surface Real = 0,
	@OC_Fluidity Real = 1,
	@OC_Alkali Real = 0,
	@OC_Volatile_Matter Real = 0,
	@OC_Reflectance Real = 0,
	@Notes Varchar(1023) = Null,
	@Auto_Activate_Haulage Bit = 0,
	@iHaulage_Raw_Resolve_All Bit = 1,
	@Auto_Validate_Depletion_Tonnes Bit = 0 
) 
With Encryption
As 
Begin 
	/*-----------------------------------------------------------------------------
	--  Name: [AddOrUpdateDigblock]
	--
	--  Purpose: 
	--		Inserts a new digblock or updates and existing digblock
	--
	--  Parameters: 
	--		Each field required in the digblock table
	--		@iHaulage_Raw_Resolve_All flag to indicate if HaulageRawResolveAll procedure
	--			should be called
	--
	--  Comments: 
	--		Logic copied from the existing AddDigblock procedure but modified to 
	--		update an existing digblock rather than failing if the digblock exists
	--
	--		Needs to be modified to handle Normalised Grades
	--
	--  Created By:		Nigel Linton
	--  Created Date: 		31 May 2006
	--
	------------------------------------------------------------------------------*/


    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Declare @Count Int
	Declare @Exists Bit
	Declare @Is_Approved Bit
	Declare @lErrorCode Int

	Set @Start_Date = dbo.GetDateDay (@Start_Date)

	/* Clean up the date/shift pairs */
	If ((@Start_Date Is Null) And (@Start_Shift Is Not Null))
	Begin
		Select @Start_Date = Null
	End

	If (@Start_Date Is Null)
	Begin
		Select @Start_Shift = Null
	End
	Else
	Begin
		If (@Start_Shift Is Null)
		Begin
			Select @Start_Shift = dbo.GetFirstShiftType ()
		End
	End

	/* If the material type does not exist */
	If (dbo.DoesMaterialTypeExist (@Material_Type_Id) <> 1)
	Begin
		Set @lErrorCode = 1
		Raiserror ('The Material Type does not exist', 16, 1)
	End

	/* If for both shifts, each is either null or valid */
	If (	@lErrorCode = 0 And 			
			(@Start_Shift Is Not Null And (dbo.DoesShiftTypeExist (@Start_Shift) <> 1)))
	Begin
		Set @lErrorCode = 1
		Raiserror ('The shift(s) given are not valid', 16, 1)
	End

	/* If the digblock start date falls in an approved month */
	If (	@lErrorCode = 0 And 			
			dbo.IsInApprovedMonth (@Start_Date) <> 0 And 
			@Start_Date Is Not Null)
	Begin
		Raiserror ('The start date of the digblock falls in an approved month', 16, 1)
	End


	/* If a digblock with this name already exists update the existing record otherwise
		update the record */
	If (@lErrorCode = 0)
	Begin
		If (dbo.DoesDigblockExist (@Digblock_Id) = 0)
		Begin
			/* Insert a new digblock record */
			Insert Into Digblock
			(
				Digblock_Id, Description, Notes, Material_Type_Id,
				Creation_Datetime, Start_Date, Start_Shift, X, Y, Z,
				Auto_Activate_Haulage, Auto_Validate_Depletion_Tonnes,
				Is_In_Pit_Depletion, Is_Visible, Start_Tonnes
			)
			Values
			 (@Digblock_Id, @Description, @Notes, @Material_Type_Id,
			 Coalesce(@Creation_Datetime, GetDate()), @Start_Date, @Start_Shift, @X, @Y, @Z,
			 @Auto_Activate_Haulage, @Auto_Validate_Depletion_Tonnes,
			 @Is_In_Pit_Depletion, @Is_Visible, @Start_Tonnes)

			Set @lErrorCode = @@ERROR
		End
		Else
		Begin

			/* Insert a new digblock record */
			Update Digblock
			Set
				Description = @Description, 
				Notes = @Notes, 
				Material_Type_Id = @Material_Type_Id,
				Start_Date = @Start_Date, 
				Start_Shift = @Start_Shift, 
				X = @X, 
				Y = @Y, 
				Z = @Z,
				Auto_Activate_Haulage = @Auto_Activate_Haulage, 
				Auto_Validate_Depletion_Tonnes = @Auto_Validate_Depletion_Tonnes,
				Is_In_Pit_Depletion = @Is_In_Pit_Depletion, 
				Is_Visible = @Is_Visible, 
				Start_Tonnes = @Start_Tonnes 
			Where Digblock_Id = @Digblock_Id

			Set @lErrorCode = @@ERROR

		End
	End

	-- If no error occurred set Proc to success, raise event, correct Haulage Errors
	If (@lErrorCode = 0)
	Begin
		/* Correct any related haulage errors */
		If @iHaulage_Raw_Resolve_All = 1
		Begin
			Execute dbo.HaulageRawResolveAll
		End
	End
  
    Commit Transaction 
End 
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblock">
 <Procedure>
	Inserts a new digblock or updates and existing digblock
	Raises a Recalc event and optionally attempts to resolve Haulage errors.
	Errors raised
		The Material Type does not exist
		The specified or calculated shift(s) are not valid
		The start date of the digblock falls in an approved month
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateBlastBlockValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateBlastBlockValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateBlastBlockValue]
GO


CREATE Procedure [dbo].[AddOrUpdateBlastBlockValue]

(@Blast_Block_Id Int,
@Blast_Block_Field_Id Varchar(31) = Null,
@Field_Value Real,
@Order_No Int = Null)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the blast block exists */
	If Exists (Select * From BlastBlock Where Blast_Block_Id = @Blast_Block_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Blast_Block_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Blast_Block_Field_Id = Blast_Block_Field_Id
			From BlastBlockField
			Where Order_No = @Order_No
		End

		/* If the blast block field exists */
		If Exists (Select * From BlastBlockField Where Blast_Block_Field_Id = @Blast_Block_Field_Id)
		Begin
			/* If the value is not null */
			If (@Field_Value Is Not Null)
			Begin
				/* If this blast block field is not already populated */
				If Not Exists (Select * From BlastBlockValue Where Blast_Block_Id = @Blast_Block_Id And Blast_Block_Field_Id = @Blast_Block_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into BlastBlockValue
					 (Blast_Block_Id, Blast_Block_Field_Id, Field_Value)
					Values (@Blast_Block_Id, @Blast_Block_Field_Id, @Field_Value)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update BlastBlockValue
					Set	Field_Value = @Field_Value
					Where Blast_Block_Id = @Blast_Block_Id
					And Blast_Block_Field_Id = @Blast_Block_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From BlastBlockValue
				Where Blast_Block_Id = @Blast_Block_Id
				And Blast_Block_Field_Id = @Blast_Block_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given blast block field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given blast block does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateBlastBlockValue">
 <Procedure>
	Adds a new record or updates and existing record in the BlastBlockValue table if the @Field_Value value is specified.
	If @Field_Value is null and there is an existing entry in the BlastBlockValue table then this record is deleted.
	Errors raised if:
		The given blast block field does not exist
		The given blast block does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateBlastBlockNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateBlastBlockNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateBlastBlockNotes]
GO


CREATE Procedure [dbo].[AddOrUpdateBlastBlockNotes]

(@Blast_Block_Id Int,
@Blast_Block_Field_Id Varchar(31) = Null,
@Notes Varchar(1023),
@Order_No Int = Null)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the blast block exists */
	If Exists (Select * From BlastBlock Where Blast_Block_Id = @Blast_Block_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Blast_Block_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Blast_Block_Field_Id = Blast_Block_Field_Id
			From BlastBlockField
			Where Order_No = @Order_No
		End

		/* If the blast block field exists */
		If Exists (Select * From BlastBlockField Where Blast_Block_Field_Id = @Blast_Block_Field_Id)
		Begin
			/* If the value is not null */
			If (@Notes Is Not Null)
			Begin
				/* If this blast block field is not already populated */
				If Not Exists (Select * From BlastBlockNotes Where Blast_Block_Id = @Blast_Block_Id And Blast_Block_Field_Id = @Blast_Block_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into BlastBlockNotes
					 (Blast_Block_Id, Blast_Block_Field_Id, Notes)
					Values (@Blast_Block_Id, @Blast_Block_Field_Id, @Notes)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update BlastBlockNotes
					Set	Notes = @Notes
					Where Blast_Block_Id = @Blast_Block_Id
					And Blast_Block_Field_Id = @Blast_Block_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From BlastBlockNotes
				Where Blast_Block_Id = @Blast_Block_Id
				And Blast_Block_Field_Id = @Blast_Block_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given blast block field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given blast block does not exist', 16, 1)
	End

	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




GO
/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateBlastBlockNotes">
 <Procedure>
	Adds a new record or updates and existing record in the BlastBlockNotes table if the @Notes value is specified.
	If @Notes is null and there is an existing entry in the BlastBlockNotes table then this record is deleted.
	Errors raised if:
		The given blast block field does not exist
		The given blast block does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulage.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetHaulage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetHaulage]
GO

CREATE Procedure [dbo].[GetHaulage]
(
	@Haulage_Id Int
)

With Encryption
As

Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Create Table #Haulage
	(
		Haulage_Id Int,
		Haulage_Date VarChar(255) Collate Database_Default Null,
		Haulage_Shift VarChar(31) Collate Database_Default Null,
		Haulage_Tonnes Float Null,
		No_Loads Int Null,
		Truck_Id VarChar(31) Collate Database_Default Null,
		Source VarChar(31) Collate Database_Default Null,
		Destination VarChar(31) Collate Database_Default Null,
		Haulage_State_Id Char(1) Collate Database_Default Null,
		Is_Approved Bit Not Null,
		Primary Key (Haulage_Id)
	)
	
	Create Table #HaulageNotes
	(
		Haulage_Id Int Not Null,
		Haulage_Field_Id VarChar(31) Not Null,
		Notes VarChar(1023) Null,
		Primary Key (Haulage_Id, Haulage_Field_Id)
	)

	Create Table #HaulageValue
	(
		Haulage_Id Int Not Null,
		Haulage_Field_Id VarChar(31) Not Null,
		Field_Value Real,
		Primary Key (Haulage_Id, Haulage_Field_Id)
	)

	Insert Into #Haulage
	(
		Haulage_Id, Haulage_Date, Haulage_Shift, Haulage_Tonnes, No_Loads,
		Truck_Id, Source, Destination, Haulage_State_Id, Is_Approved
	)
	Select Haulage_Id, Convert(Varchar, Haulage_Date, 106) As Haulage_Date,
		dbo.GetShiftTypeName(Haulage_Shift) As Haulage_Shift,
		Tonnes As Haulage_Tonnes, Loads As No_Loads, Truck_Id,
		Coalesce(Source_Digblock_Id, Source_Stockpile_Id) AS Source,
		Coalesce(Destination_Stockpile_Id, Destination_Crusher_Id) AS Destination,
		Haulage_State_Id,
		(Case When Haulage_State_Id = 'A' Then 1 Else 0 End) As Is_Approved
	From Haulage
	Where Haulage_Id = @Haulage_Id

	Insert Into #HaulageNotes
	(
		Haulage_Id, Haulage_Field_Id, Notes
	)
	Select Haulage_Id, Haulage_Field_Id, Notes
	From HaulageNotes
	Where Haulage_Id = @Haulage_Id
	
	Insert Into #HaulageValue
	(
		Haulage_Id, Haulage_Field_Id, Field_Value
	)
	Select Haulage_Id, Haulage_Field_Id, Field_Value
	From HaulageValue
	Where Haulage_Id = @Haulage_Id

	-- pivot the virtual fields
	Exec PivotTable
		@iTargetTable = '#Haulage',
		@iPivotTable = '#HaulageNotes',
		@iJoinColumns = '#Haulage.Haulage_Id = #HaulageNotes.Haulage_Id',
		@iPivotColumn = 'Haulage_Field_Id',
		@iPivotValue = 'Notes',
		@iPivotType = 'VarChar(1023)'

	Exec PivotTable
		@iTargetTable = '#Haulage',
		@iPivotTable = '#HaulageValue',
		@iJoinColumns = '#Haulage.Haulage_Id = #HaulageValue.Haulage_Id',
		@iPivotColumn = 'Haulage_Field_Id',
		@iPivotValue = 'Field_Value',
		@iPivotType = 'Real'

	Select *
	From #Haulage

	Drop Table #HaulageNotes
	Drop Table #HaulageValue
	Drop Table #Haulage

	Set @ELC_Proc_Is_Error = 0

	Commit Transaction

	-- Event_Logging_Placeholder
End


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulage">
 <Procedure>
	Returns Haulage record for the specified @Haulage_Id
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockFieldValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockFieldValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetDigblockFieldValue]
GO

CREATE Procedure [dbo].[GetDigblockFieldValue]

(@Digblock_Id Varchar(31),
@Digblock_Field_Id Varchar(31),
@Field_Value Float Output)

With Encryption As
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* If the digblock exists */
	If (dbo.DoesDigblockExist(@Digblock_Id) = 1)
	Begin
		/* If the digblock field exists */
		If Exists (Select * From DigblockField Where Digblock_Field_Id = @Digblock_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @Field_Value = Min(Field_Value)
			From DigblockValue
			Where Digblock_Id = @Digblock_Id
			And Digblock_Field_Id = @Digblock_Field_Id

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given digblock field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock does not exist', 16, 1)
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockFieldValue">
 <Procedure>
	Returns Field_Value value for specified @Digblock_Id and @Digblock_Field_Id.
	Errors are raised if:
		The given digblock does not exist
		The given digblock field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockFieldNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockFieldNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetDigblockFieldNotes]
GO

CREATE Procedure [dbo].[GetDigblockFieldNotes]

(@Digblock_Id Varchar(31),
@Digblock_Field_Id Varchar(31),
@Notes Varchar(1023) Output)

With Encryption As
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* If the digblock exists */
	If (dbo.DoesDigblockExist(@Digblock_Id) = 1)
	Begin
		/* If the digblock field exists */
		If Exists (Select * From DigblockField Where Digblock_Field_Id = @Digblock_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @Notes = Min(Notes)
			From DigblockNotes
			Where Digblock_Id = @Digblock_Id
			And Digblock_Field_Id = @Digblock_Field_Id

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given digblock field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock does not exist', 16, 1)
	End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockFieldNotes">
 <Procedure>
	Returns Notes value for specified @Digblock_Id and @Digblock_Field_Id.
	Errors are raised if:
		The given digblock does not exist
		The given digblock field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteModelBlockPartial.prc'
GO

If object_id('dbo.DeleteModelBlockPartial') is not NULL
	Drop Procedure dbo.DeleteModelBlockPartial
Go

CREATE Procedure [dbo].[DeleteModelBlockPartial]
(
	@Model_Block_Id Int,
	@Sequence_No Int
)
With Encryption As
Begin

	Set NoCount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Begin Transaction DeleteModelBlockPartial

	-- first check that the model block partial exists
	If (dbo.DoesModelBlockPartialExist(@Model_Block_Id, @Sequence_No) = 1)
	Begin
		-- delete the record and all child records
		Delete
		From ModelBlockPartialNotes
		Where Model_Block_Id = @Model_Block_Id
		 And Sequence_No = @Sequence_No

		Delete
		From ModelBlockPartialValue
		Where Model_Block_Id = @Model_Block_Id
		 And Sequence_No = @Sequence_No

		Delete
		From ModelBlockPartialMaterialType
		Where Model_Block_Id = @Model_Block_Id
		 And Sequence_No = @Sequence_No

		-----------------------------------------------------------------------
		-- Delete from the Grade table
		-----------------------------------------------------------------------
		Delete 
		From ModelBlockPartialGrade
		Where Model_Block_Id = @Model_Block_Id
		 And Sequence_No = @Sequence_No

		Delete
		From ModelBlockPartial
		Where Model_Block_Id = @Model_Block_Id
		 And Sequence_No = @Sequence_No

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0
	End
	Else
		Raiserror ('The model block partial does not exist', 16, 1)

	Commit Transaction DeleteModelBlockPartial
	
	-- Event_Logging_Placeholder

End
Go
GRANT EXECUTE ON dbo.DeleteModelBlockPartial TO CoreBlockModelManager



/*
<TAG Name="Data Dictionary" ProcedureName="DeleteModelBlockPartial">
 <Procedure>
	Deletes records with the specified @iModel_Block_Id and @Sequence_No from the following tables:
		ModelBlockPartialNotes
		ModelBlockPartialValue
		ModelBlockPartialMaterialType
		ModelBlockPartialGrade
		ModelBlockPartial
	Errors are raised if:
		The model block partial does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteBlastBlock.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DeleteBlastBlock]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[DeleteBlastBlock]
GO

CREATE Procedure [dbo].[DeleteBlastBlock]

(@Blast_Block_Id Int)

With Encryption As

Declare @Exists Bit
Declare @Count Int
Declare @Error Int
Declare @Start_Date Datetime
Declare @Shift Char(1)

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the blast block exists */
	If ((Select Count(*) From BlastBlock Where Blast_Block_Id = @Blast_Block_Id) > 0)
	Begin
		/* Begin the transaction to delete the stockpile and all it's related records */
		Set @Error = 0
		Begin Transaction DeleteBlastBlock


		If (@Error = 0)
		Begin
			Delete From BlastBlockNotes
			Where Blast_Block_Id = @Blast_Block_Id

			Set @Error = @@Error
		End

		If (@Error = 0)
		Begin
			Delete From BlastBlockValue
			Where Blast_Block_Id = @Blast_Block_Id

			Set @Error = @@Error
		End

		If (@Error = 0)
		Begin
			Delete From BlastBlockModelBlock
			Where Blast_Block_Id = @Blast_Block_Id

			Set @Error = @@Error
		End

		If (@Error = 0)
		Begin
			Update Digblock
			Set	Blast_Block_Id = Null
			Where Blast_Block_Id = @Blast_Block_Id

			Set @Error = @@Error
		End


		-- Delete the blast block itself
		If (@Error = 0)
		Begin
			Delete From BlastBlock
			Where Blast_Block_Id = @Blast_Block_Id

			Set @Error = @@Error
		End
		

		/* If nothing went wrong */
		If (@Error = 0)
		Begin
			/* Commit the transaction */
			Commit Transaction DeleteBlastBlock		

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			/* Otherwise, cancel it */
			Rollback Transaction DeleteBlastBlock

			Raiserror ('Error occured while deleting blast block and related details', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The blast block does not exist', 16, 1)
	End

		
	-- Event_Logging_Placeholder

GO

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteBlastBlock">
 <Procedure>
	Deletes records from the following tables relating to @Blast_Block_Id:
		BlastBlockNotes	
		BlastBlockValue
		BlastBlockModelBlock
		BlastBlock
	Updates the following tables to remove references to the deleted BlastBlock record:
		Digblock
	Errors are raised if:
		The blast block does not exist
		Another error occurred while deleting blast block and related details
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateModelBlockPartialValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateModelBlockPartialValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateModelBlockPartialValue]
GO

CREATE Procedure [dbo].[AddOrUpdateModelBlockPartialValue]

(@Model_Block_Id Varchar(31),
@Sequence_No Int,
@Model_Block_Partial_Field_Id Varchar(31),
@Field_Value Float,
@Order_No Int = Null)
--With Encryption

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the model block partial record exists */
	If Exists (Select * From ModelBlockPartial Where Model_Block_Id = @Model_Block_Id And Sequence_No = @Sequence_No)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Order_No Is Not Null And @Model_Block_Partial_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Model_Block_Partial_Field_Id = Model_Block_Partial_Field_Id
			From ModelBlockPartialField
			Where Order_No = @Order_No
		End

		/* If the field exists */
		If Exists (Select * From ModelBlockPartialField Where Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id)
		Begin
			/* If the value is not null */
			If (@Field_Value Is Not Null)
			Begin
				/* If this forecast field is not already populated */
				If Not Exists (Select *
				From ModelBlockPartialValue
				Where Model_Block_Id = @Model_Block_Id
				And Sequence_No = @Sequence_No
				And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into ModelBlockPartialValue
					 (Model_Block_Id, Sequence_No, Model_Block_Partial_Field_Id, Field_Value)
					Values (@Model_Block_Id, @Sequence_No, @Model_Block_Partial_Field_Id, @Field_Value)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update ModelBlockPartialValue
					Set	Field_Value = @Field_Value
					Where Model_Block_Id = @Model_Block_Id
					And Sequence_No = @Sequence_No
					And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From ModelBlockPartialValue
				Where Model_Block_Id = @Model_Block_Id
				And Sequence_No = @Sequence_No
				And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given model block partial field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given model block partial record does not exist', 16, 1)
	End

	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

GO

GRANT EXECUTE ON dbo.AddOrUpdateModelBlockPartialValue TO CoreBlockModelManager



/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateModelBlockPartialValue">
 <Procedure>
	Adds a new record or updates an existing record in the ModelBlockPartialValue table if a @Field_Value value is specified.
	If the @Field_Value value is not specified and the record exists in the ModelBlockPartialValue table the record is deleted.
	If the @Model_Block_Partial_Field_Id is not specified it is determined from the ModelBlockPartialField table using the @Order_No value. 
	Errors raised if:
		The given model block partial record does not exist
		The given model block partial field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateModelBlockPartialNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateModelBlockPartialNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateModelBlockPartialNotes]
GO

CREATE Procedure [dbo].[AddOrUpdateModelBlockPartialNotes]

(@Model_Block_Id Varchar(31),
 @Sequence_No Int,
 @Model_Block_Partial_Field_Id Varchar(31),
 @Notes Varchar(1023),
 @Order_No Int = Null)

With Encryption As

Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction Model_Block_Partial_Notes

	/* If the model block partial exists */
	If Exists (Select * From ModelBlockPartial Where Model_Block_Id = @Model_Block_Id And Sequence_No = @Sequence_No)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Model_Block_Partial_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Model_Block_Partial_Field_Id = Model_Block_Partial_Field_Id
			From ModelBlockPartialField
			Where Order_No = @Order_No
		End

		/* If the model block partial field exists */
		If Exists (Select * From ModelBlockPartialField Where Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id)
		Begin
			/* If the value is not null */
			If (@Notes Is Not Null)
			Begin
				/* If this model block partial field is not already populated */
				If Not Exists (Select * From ModelBlockPartialNotes
				Where Model_Block_Id = @Model_Block_Id
				And Sequence_No = @Sequence_No
				And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into ModelBlockPartialNotes
					 (Model_Block_Id, Sequence_No, Model_Block_Partial_Field_Id, Notes)
					Values (@Model_Block_Id, @Sequence_No, @Model_Block_Partial_Field_Id, @Notes)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update ModelBlockPartialNotes
					Set	Notes = @Notes
					Where Model_Block_Id = @Model_Block_Id
					And Sequence_No = @Sequence_No
					And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From ModelBlockPartialNotes
				Where Model_Block_Id = @Model_Block_Id
				And Sequence_No = @Sequence_No
				And Model_Block_Partial_Field_Id = @Model_Block_Partial_Field_Id
			End
		End
		Else
		Begin
			Raiserror('The given model block partial field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given model block partial field does not exist', 16, 1)
	End

	Commit Transaction Model_Block_Partial_Notes
	Set Transaction Isolation Level Read Committed

	If @@Error = 0
		Set @ELC_Proc_Is_Error = 0

	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
End

GO

GRANT EXECUTE ON dbo.AddOrUpdateModelBlockPartialNotes TO CoreBlockModelManager



/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateModelBlockPartialNotes">
 <Procedure>
	Adds a new record or updates an existing record in the ModelBlockPartialNotes table if a @Notes value is specified.
	If the @Notes value is not specified and the record exists in the ModelBlockPartialNotes table the record is deleted.
	If the @Model_Block_Partial_Field_Id is not specified it is determined from the ModelBlockPartialField table using the @Order_No value. 
	Errors raised if:
		The given model block partial record does not exist
		The given model block partial field record does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockModelBlock.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockModelBlock]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockModelBlock]
GO



CREATE Procedure [dbo].[AddOrUpdateDigblockModelBlock]

(@Digblock_Id Varchar(31),
@Model_Block_Id Int,
@Percentage_In_Model_Block Real = Null,
@Percentage_In_Digblock Real = Null)

With Encryption As

Declare @Count Int

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If at least one percentage is set */
	If ((@Percentage_In_Model_Block Is Not Null) Or (@Percentage_In_Digblock Is Not Null))
	Begin
		/* Check to see whether the digblock - model block link already exists */
		Select @Count = Count(*)
		From DigblockModelBlock
		Where Digblock_Id = @Digblock_Id
		And Model_Block_Id = @Model_Block_Id
	
		/* If it does not */
		If (@Count = 0)
		Begin
			/* Insert a new record */
			Insert Into DigblockModelBlock
			 (Digblock_Id, Model_Block_Id, Percentage_In_Model_Block, Percentage_In_Digblock)
			Values (@Digblock_Id, @Model_Block_Id, Coalesce(@Percentage_In_Model_Block, 1), Coalesce(@Percentage_In_Digblock, 1))
		End
		Else
		Begin
			/* Otherwise, Update the existing record */
			Update DigblockModelBlock
			Set	Percentage_In_Model_Block = Coalesce(@Percentage_In_Model_Block, 1),
				Percentage_In_Digblock = Coalesce(@Percentage_In_Digblock, 1)
			Where Digblock_Id = @Digblock_Id
			And Model_Block_Id = @Model_Block_Id
		End

		/* If the percentage of the digblock which is within the model block is not given */
		If (@Percentage_In_Model_Block Is Null)
		Begin
			/* Calculate this value for all model blocks related to this digblock */
			Update DMB
			Set	Percentage_In_Model_Block = Percentage_In_Digblock /	(Select Sum(Percentage_In_Digblock)
											From DigblockModelBlock DMB2, ModelBlock MB2
											Where DMB2.Digblock_Id = DMB.Digblock_Id
											And DMB2.Model_Block_Id = MB2.Model_Block_Id
											And MB2.Block_Model_Id = MB.Block_Model_Id)
			From DigblockModelBlock DMB, ModelBlock MB
			Where DMB.Model_Block_Id = MB.Model_Block_Id
			And DMB.Digblock_Id = @Digblock_Id
		End

		/* If the percentage of the model block which is within the digblock is not given */
		If (@Percentage_In_Digblock Is Null)
		Begin
			/* Calculate this value for all digblocks related to this model block */
			Update DMB
			Set	Percentage_In_Digblock = Percentage_In_Model_Block /	(Select Sum(Percentage_In_Model_Block)
											From DigblockModelBlock DMB2, ModelBlock MB2
											Where DMB2.Model_Block_Id = DMB.Model_Block_Id
											And DMB2.Model_Block_Id = MB2.Model_Block_Id
											And MB2.Block_Model_Id = MB.Block_Model_Id)
			From DigblockModelBlock DMB, ModelBlock MB
			Where DMB.Model_Block_Id = MB.Model_Block_Id
			And DMB.Model_Block_Id = @Model_Block_Id
		End

		If @@Error = 0
			Set @ELC_Proc_Is_Error = 0

	End
	Else
	Begin
		Raiserror ('A linking percentage must be given', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockModelBlock">
 <Procedure>
	Adds a new record or updates and existing record in the DigblockModelBlock.
	If the percentage of the digblock which is within the model block is not given this value is calculated for all model blocks related to this digblock
	If the percentage of the model block which is within the digblock is not given this value is calculated for all digblocks related to this model block
	Errors raised if:
		Neither the @Percentage_In_Model_Block nor the @Percentage_In_Digblock values are specified
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockMaterialType.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockMaterialType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockMaterialType]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockMaterialType]

(@Digblock_Id Varchar(31),
@Material_Type_Group_Id Int,
@Material_Type_Id Int)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock exists */
	If Exists (Select * From Digblock Where Digblock_Id = @Digblock_Id)
	Begin
		/* If the material type exists */
		If Exists (Select * From MaterialTypeGroup Where Material_Type_Group_Id = @Material_Type_Group_Id)
		Begin
			/* If the material type exists, or is null */
			If ((Exists (Select * From MaterialType Where Material_Type_Id = @Material_Type_Id)) Or (@Material_Type_Id Is Null))
			Begin
				/* If the value is not null */
				If (@Material_Type_Id Is Not Null)
				Begin
					/* If this material type group is not already populated */
					If Not Exists (Select * From DigblockMaterialType Where Digblock_Id = @Digblock_Id And Material_Type_Group_Id = @Material_Type_Group_Id)
					Begin
						/* Insert a new value for the field */
						Insert Into DigblockMaterialType
						 (Digblock_Id, Material_Type_Group_Id, Material_Type_Id)
						Values (@Digblock_Id, @Material_Type_Group_Id, @Material_Type_Id)
					End
					Else
					Begin
						/* Update the value */
						Update DigblockMaterialType
						Set	Material_Type_Id = @Material_Type_Id
						Where Digblock_Id = @Digblock_Id
						And Material_Type_Group_Id = @Material_Type_Group_Id
					End

				End
				Else
				Begin
					/* Delete any existing value */
					Delete From DigblockMaterialType
					Where Digblock_Id = @Digblock_Id
					And Material_Type_Group_Id = @Material_Type_Group_Id
				End

				If @@Error = 0
					Set @ELC_Proc_Is_Error = 0

			End
			Else
			Begin
				Raiserror('The given material type does not exist', 16, 1)
			End
		End
		Else
		Begin
			Raiserror('The given material type group does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockMaterialType">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockMaterialType table if a Material_Type_Id is specified.
	Deletes a record in the DigblockMaterialType table if there is a record for the specified Digblock_Id and Material_Group_Id
	but the Material_Type_Id is not specified
	Errors raised if:
		The given digblock does not exist
		The given material type group does not exist
		The given material type does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyActualFieldNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockSurveyActualFieldNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetDigblockSurveyActualFieldNotes]
GO

CREATE Procedure [dbo].[GetDigblockSurveyActualFieldNotes]

(@Digblock_Survey_Actual_Id int,
 @Digblock_Survey_Actual_Field_Id Varchar(31),
 @Notes VarChar(1023) Output)

With Encryption As
Begin
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	/* If the digblock survey actual exists */
	If Exists (Select 1 From DigblockSurveyActual Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id)
	Begin
		/* If the digblock survey actual field exists */
		If Exists (Select * From DigblockSurveyActualField Where Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @Notes = Notes
			From DigblockSurveyActualNotes
			Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
			And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id
		End
		Else
		Begin
			Raiserror ('The given digblock survey actual field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock survey actual does not exist', 16, 1)
	End

	Commit Transaction

	Set @ELC_Proc_Is_Error = 0

	Return
End
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyActualFieldNotes">
 <Procedure>
	Returns Notes value for specified @Digblock_Survey_Actual_Id and @Digblock_Survey_Actual_Field_Id
	in the @Notes output variable.
	Errors are raised if:
		The given @Digblock_Survey_Actual_Id does not exist
		The given @Digblock_Survey_Actual_Field_Id field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockSurveySample.prc'
GO

If object_id('dbo.DeleteDigblockSurveySample') is not NULL
	Drop Procedure dbo.DeleteDigblockSurveySample
Go

CREATE  Procedure [dbo].[DeleteDigblockSurveySample]
(
	@Digblock_Survey_Sample_Id Int
)
WITH ENCRYPTION
AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		

	Declare @Digblock_Survey_Date Datetime
	Declare @Digblock_Survey_Shift Char(1)
	Declare @Digblock_Survey_Type_Id Int
	Declare @Is_Approved Bit
	Declare @Count Int
	Declare @Digblock_Survey_Id Int
	Declare @Digblock_Id Varchar(31)


	SELECT @TransactionName = 'DeleteDigblockSurveySample',
		@TransactionCount = @@Trancount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY

	/* Get the details about the record */
	Select @Digblock_Survey_Date = Digblock_Survey_Date,
		@Digblock_Survey_Shift = Digblock_Survey_Shift,
		@Digblock_Survey_Type_Id = Digblock_Survey_Type_Id,
		@Digblock_Id = Digblock_Id,
		@Digblock_Survey_Id = dss.Digblock_Survey_Id
	From DigblockSurveySample AS dss
		Inner Join DigblockSurvey AS ds
			ON ds.Digblock_Survey_Id = dss.Digblock_Survey_Id
	Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

	/* If the record exists */
	If (@Digblock_Survey_Date Is Not Null)
	Begin
		/* If the record does not fall in an approved month */
		If (dbo.IsInApprovedMonth (@Digblock_Survey_Date) = 0)
		Begin
			/* If the record does not fall in an approved depletion period */
			If (dbo.IsInApprovedDigblockSurveyPeriod (@Digblock_Survey_Date, @Digblock_Survey_Shift, @Digblock_Id) = 0)
			Begin
				/* Delete any related notes records */
				Delete From DigblockSurveySampleNotes
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

				/* Delete any related formula records */
				Delete From DigblockSurveySampleFormula
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

				/* Delete any related value records */
				Delete From DigblockSurveySampleValue
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

				/* Delete any related DigblockSurveySampleGrade records */
				Delete From DigblockSurveySampleGrade
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

				/* Delete the record */
				Delete From DigblockSurveySample
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id

				/* Check to see if there are any records left for this particular digblock survey */
				Select @Count = Count(*)
				From DigblockSurveySample
				Where Digblock_Survey_Id = @Digblock_Survey_Id

				/* If there are not */
				If (@Count = 0)
				Begin
					/* Delete the digblock survey altogether */
					Exec DeleteDigblockSurvey @Digblock_Survey_Id
				End
			End
			Else
			Begin
				Raiserror ('The digblock survey falls in an approved survey period', 16, 1)
			End
		End
		Else
		Begin
			Raiserror ('The digblock survey falls in an approved month', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The digblock survey sample record does not exist', 16, 1)
	End
	
	-- Event_Logging_Placeholder
		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH		
END 
GO 

GRANT EXECUTE ON dbo.DeleteDigblockSurveySample TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockSurveySample">
 <Procedure>
	Deletes records with the specified @Digblock_Survey_Sample_Id from the following tables:
		DigblockSurveySampleNotes
		DigblockSurveySampleFormula
		DigblockSurveySampleValue
		DigblockSurveySampleGrade
		DigblockSurveySample
	If there are associated records in the DigblockSurveySample table calls DeleteDigblockSurvey
	procedure to remove record.
	Errors are raised if:
		The digblock survey sample record does not exist
		The digblock survey falls in an approved month
		The digblock survey falls in an approved survey period
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockSurveySample.prc'
GO

IF OBJECT_ID('dbo.AddDigblockSurveySample') IS NOT NULL 
     DROP PROCEDURE dbo.AddDigblockSurveySample 
GO 
  
CREATE PROCEDURE dbo.AddDigblockSurveySample 
( 
	@iDigblock_Survey_Id Int,
	@iImported_Digblock_Id Varchar(31) = Null,
	@iDigblock_Id Varchar(31) = Null,
	@iMaterial_Type_Id Int = Null,
	@iIs_Tonnes_And_Grade Bit = 1,
	@iImported_Datetime Datetime = Null,
	@iUncovered_Percentage Real = Null,
	@iAvailable_Percentage Real = Null,
	@iUnavailable_Percentage Real = Null,
	@iMined_Percentage Real = Null,
	@iLost_Low_Wall_Percentage Real = Null,
	@iLost_Roof_Percentage Real = Null,
	@iLost_Floor_Percentage Real = Null,
	@iDilution_Low_Wall_Percentage Real = Null,
	@iDilution_Roof_Percentage Real = Null,
	@iDilution_Floor_Percentage Real = Null,
	@iDepleted_Tonnes Float = 0,
	@oDigblock_Survey_Sample_Id Int = Null Output
) 
WITH ENCRYPTION
AS 
BEGIN 
    SET NOCOUNT ON 
  
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(255)
		
	SELECT @TransactionName = 'AddDigblockSurveySample',
		@TransactionCount = @@Trancount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

    BEGIN TRY

		IF @iMaterial_Type_Id IS NOT NULL
		BEGIN
			IF NOT EXISTS (SELECT TOP 1 1 FROM dbo.MaterialType WHERE Material_Type_Id = @iMaterial_Type_Id)
			BEGIN
				RAISERROR ('This material type does not exist.', 16, 1)
			END
		END
		
		INSERT INTO dbo.DigblockSurveySample
		(
			Digblock_Survey_Id, Imported_Digblock_Id,
			Digblock_Id, Material_Type_Id, Is_Tonnes_And_Grade, Is_Error, Error_Description,
			Imported_Datetime, Uncovered_Percentage, Available_Percentage, Unavailable_Percentage,
			Mined_Percentage, Lost_Low_Wall_Percentage, Lost_Roof_Percentage, Lost_Floor_Percentage,
			Dilution_Low_Wall_Percentage, Dilution_Roof_Percentage,	Dilution_Floor_Percentage,
			Depleted_Tonnes
		)
		SELECT @iDigblock_Survey_Id, @iImported_Digblock_Id, @iDigblock_Id, @iMaterial_Type_Id, 
			@iIs_Tonnes_And_Grade,0,Null,
			@iImported_Datetime, @iUncovered_Percentage, @iAvailable_Percentage, @iUnavailable_Percentage,
			@iMined_Percentage, @iLost_Low_Wall_Percentage, @iLost_Roof_Percentage, @iLost_Floor_Percentage,
			@iDilution_Low_Wall_Percentage, @iDilution_Roof_Percentage,	@iDilution_Floor_Percentage,
			@iDepleted_Tonnes
		
		SELECT @oDigblock_Survey_Sample_Id = SCOPE_IDENTITY()
		

		IF @TransactionCount = 0
		BEGIN
			COMMIT TRANSACTION		
		END
	END TRY
	BEGIN CATCH
		IF @TransactionCount = 0 
		BEGIN
			ROLLBACK TRANSACTION
		END
		ELSE IF XACT_STATE() <> -1
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH		
END 
GO 
GRANT EXECUTE ON dbo.AddDigblockSurveySample TO CoreDepletionManager


/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblockSurveySample">
 <Procedure>
	Adds a record into the DigblockSurveySample table and returns the key to the record in the resultset. 
	The DigblockSurvey record is inserted if it does not exist.
	DigblockSurveySample errors and corrected and optionaly DigblockSurveySample records that are in error are deleted.
	Errors are raised if:
		The given material type does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySampleValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockSurveySampleValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockSurveySampleValue]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockSurveySampleValue]

(@Digblock_Survey_Sample_Id Int,
@Digblock_Survey_Sample_Field_Id Varchar(31),
@Field_Value Real)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock survey sample exists */
	If Exists (Select * From DigblockSurveySample Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id)
	Begin
		/* If the digblock survey sample field exists */
		If Exists (Select * From DigblockSurveySampleField Where Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
		Begin
			/* If this field is not already populated */
			If Not Exists (Select * From DigblockSurveySampleValue Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
			And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
			Begin
				/* Insert a new value for the field */
				Insert Into DigblockSurveySampleValue
				 (Digblock_Survey_Sample_Id, Digblock_Survey_Sample_Field_Id, Field_Value)
				Values (@Digblock_Survey_Sample_Id, @Digblock_Survey_Sample_Field_Id, @Field_Value)
			End
			Else
			Begin
				/* Otherwise, update the field */
				Update DigblockSurveySampleValue
				Set	Field_Value = @Field_Value
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
				And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock survey sample field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey sample does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------

GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveySampleValue">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySampleValue table.
	Errors raised if:
		The given digblock survey sample does not exist
		The given digblock survey sample field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySampleNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockSurveySampleNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockSurveySampleNotes]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockSurveySampleNotes]

(@Digblock_Survey_Sample_Id Int,
@Digblock_Survey_Sample_Field_Id Varchar(31),
@Notes Varchar(1023))

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock survey sample exists */
	If Exists (Select * From DigblockSurveySample Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id)
	Begin
		/* If the digblock survey sample field exists */
		If Exists (Select * From DigblockSurveySampleField Where Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
		Begin
			/* If this field is not already populated */
			If Not Exists (Select * From DigblockSurveySampleNotes Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
			And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
			Begin
				/* Insert a new value for the field */
				Insert Into DigblockSurveySampleNotes
				 (Digblock_Survey_Sample_Id, Digblock_Survey_Sample_Field_Id, Notes)
				Values (@Digblock_Survey_Sample_Id, @Digblock_Survey_Sample_Field_Id, @Notes)
			End
			Else
			Begin
				/* Otherwise, update the field */
				Update DigblockSurveySampleNotes
				Set	Notes = @Notes
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
				And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock survey sample field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey sample does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------




GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveySampleNotes">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySampleNotes table.
	Errors raised if:
		The given digblock survey sample does not exist
		The given digblock survey sample field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveySampleFormula.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockSurveySampleFormula]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockSurveySampleFormula]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockSurveySampleFormula]

(@Digblock_Survey_Sample_Id Int,
@Digblock_Survey_Sample_Field_Id Varchar(31),
@Formula Varchar(255),
@Raise_If_Error Bit = 1)

With Encryption As

Declare @In_Table Bit
Declare @Value Float
Declare @SQL Varchar(8000)
Declare @Is_Error Bit
Declare @Error_Description Varchar(63)

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock survey sample exists */
	If Exists (Select * From DigblockSurveySample Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id)
	Begin
		/* If the digblock survey sample field exists */
		If Exists (Select * From DigblockSurveySampleField Where Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
		Begin
			/* Begin a transaction */
			Begin Transaction Digblock_Survey_Sample_Check


			/* If this field is not already populated */
			If Not Exists (Select * From DigblockSurveySampleFormula Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
			And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id)
			Begin
				/* Insert a new value for the field */
				Insert Into DigblockSurveySampleFormula
				 (Digblock_Survey_Sample_Id, Digblock_Survey_Sample_Field_Id, Formula)
				Values (@Digblock_Survey_Sample_Id, @Digblock_Survey_Sample_Field_Id, @Formula)
			End
			Else
			Begin
				/* Otherwise, update the field */
				Update DigblockSurveySampleFormula
				Set	Formula = @Formula
				Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
				And Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id
			End

			/* Work out what the formula value actually is */
			Exec GetFormulaValue	@Formula = @Formula,
							@Value = @Value Output

			/* If an error did not occur while getting the formula */
			If (@@Error = 0)
			Begin
				/* Get the details about the field */
				Select @In_Table = In_Table
				From DigblockSurveySampleField
				Where Digblock_Survey_Sample_Field_Id = @Digblock_Survey_Sample_Field_Id
	
				/* If the field is in the table */
				If (@In_Table = 1)
				Begin
					/* Update it's value */
					Set @SQL = '
					Update DigblockSurveySample
					Set	' + @Digblock_Survey_Sample_Field_Id + ' = ' + Cast(@Value As Varchar) + '
					Where Digblock_Survey_Sample_Id = ' + Cast(@Digblock_Survey_Sample_Id As Varchar)
					Exec (@SQL)
	
					/* Set the record to an error so it can be fully checked again */
					Update DigblockSurveySample
					Set	Is_Error = 1
					Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
	
					/* Try to correct the errors again */
					Exec CorrectDigblockSurveySampleErrors
	
					Select @Is_Error = Is_Error,
					 @Error_Description = Error_Description
					From DigblockSurveySample
					Where Digblock_Survey_Sample_Id = @Digblock_Survey_Sample_Id
				End				
			End


			/* If all went OK */
			If (@Is_Error = 0)
			Begin
				Commit Transaction Digblock_Survey_Sample_Check
				If @@Error = 0
					Set @ELC_Proc_Is_Error = 0
			End
			Else
			Begin
				/* Otherwise, leave the record as an error and simply raise the error */
				Commit Transaction Digblock_Survey_Sample_Check
				--Rollback Transaction Digblock_Survey_Sample_Check
	
				If (@Raise_If_Error = 1)
				Begin
					Raiserror (@Error_Description, 16, 1)
				End
			End
		End
		Else
		Begin
			Raiserror('The given digblock survey sample field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey sample does not exist', 16, 1)
	End
	

		-------------------------------------------------------
		-- Event_Logging_Placeholder
		-------------------------------------------------------

GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveySampleFormula">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveySampleFormula table.
	Applies the @Formula field value to the DigblockSurveySample table and checks the formula by setting
	the DigblockSurveySample record to an error state and calling the procedure
	CorrectDigblockSurveySampleErrors procedure to correct the error.
	Errors raised if:
		The given digblock survey sample field does not exist
		The given digblock survey sample does not exist
		The DigblockSurveySample record cannot be corrected by the call to CorrectDigblockSurveySampleErrors
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveyActualNotes.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockSurveyActualNotes]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockSurveyActualNotes]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockSurveyActualNotes]

(@Digblock_Survey_Actual_Id Int,
@Digblock_Survey_Actual_Field_Id Varchar(31) = Null,
@Notes VarChar(1023),
@Order_No Int = Null)

With Encryption As
Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	/* If the digblock survey actual exists */
	If Exists (Select * From DigblockSurveyActual Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Digblock_Survey_Actual_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Digblock_Survey_Actual_Field_Id = Digblock_Survey_Actual_Field_Id
			From DigblockSurveyActualField
			Where Order_No = @Order_No
		End

		/* If the digblock survey actual field exists */
		If Exists (Select * From DigblockSurveyActualField Where Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
		Begin
			/* If the notes is not null */
			If (@Notes Is Not Null)
			Begin
				/* If this field is not already populated */
				If Not Exists (Select * From DigblockSurveyActualNotes Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
				Begin
					/* Insert a new notes for the field */
					Insert Into DigblockSurveyActualNotes
					 (Digblock_Survey_Actual_Id, Digblock_Survey_Actual_Field_Id, Notes)
					Values (@Digblock_Survey_Actual_Id, @Digblock_Survey_Actual_Field_Id, @Notes)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockSurveyActualNotes
					Set	Notes = @Notes
					Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
					And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing notes */
				Delete From DigblockSurveyActualNotes
				Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
				And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock survey actual field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey actual does not exist', 16, 1)
	End

	Commit Transaction


	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
	


End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveyActualNotes">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveyActualNotes table if the @Notes value is specified.
	If the order no for the field was given instead of the actual name the value of @Digblock_Survey_Actual_Field_Id is determined from the DigblockSurveyActualField table.
	Deletes a record in the DigblockSurveyActualNotes table if there is a record for the specified @Digblock_Survey_Actual_Id and @Digblock_Survey_Actual_Field_Id
	but the @Notes value is not specified
	Errors raised if:
		The given digblock survey actual does not exist
		The given digblock survey actual field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyActualFieldValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetDigblockSurveyActualFieldValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[GetDigblockSurveyActualFieldValue]
GO

CREATE Procedure [dbo].[GetDigblockSurveyActualFieldValue]

(@Digblock_Survey_Actual_Id Int,
@Digblock_Survey_Actual_Field_Id Varchar(31),
@Field_Value Float Output)

With Encryption As
	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	Begin Transaction
	Set Transaction Isolation Level Repeatable Read

	/* If the digblock survey actual exists */
	If Exists (Select 1 From DigblockSurveyActual Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id)
	Begin
		/* If the digblock survey actual field exists */
		If Exists (Select * From DigblockSurveyActualField Where Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
		Begin
			/* Return the value for the given digblock and field name */
			Select @Field_Value = Min(Field_Value)
			From DigblockSurveyActualValue
			Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
			And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id

			Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror ('The given digblock survey field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The given digblock survey does not exist', 16, 1)
	End

	Commit Transaction
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyActualFieldValue">
 <Procedure>
	Returns Field_Value value for specified @Digblock_Survey_Actual_Id and @Digblock_Survey_Actual_Field_Id
	in the @Field_Value output variable.
	Errors are raised if:
		The given @Digblock_Survey_Actual_Id does not exist
		The given @Digblock_Survey_Actual_Field_Id field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateDigblockSurveyActualValue.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddOrUpdateDigblockSurveyActualValue]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddOrUpdateDigblockSurveyActualValue]
GO

CREATE Procedure [dbo].[AddOrUpdateDigblockSurveyActualValue]

(@Digblock_Survey_Actual_Id Int,
@Digblock_Survey_Actual_Field_Id Varchar(31) = Null,
@Field_Value Float,
@Order_No Int = Null)

With Encryption As

	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	/* If the digblock survey actual exists */
	If Exists (Select 1 From DigblockSurveyActual Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id)
	Begin
		/* If the order no for the field was given instead of the actual name */
		If (@Digblock_Survey_Actual_Field_Id Is Null)
		Begin
			/* Get the field name */
			Select @Digblock_Survey_Actual_Field_Id = Digblock_Survey_Actual_Field_Id
			From DigblockSurveyActualField
			Where Order_No = @Order_No
		End

		/* If the digblock survey actual field exists */
		If Exists (Select * From DigblockSurveyActualField Where Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
		Begin
			/* If the value is not null */
			If (@Field_Value Is Not Null)
			Begin
				/* If this field is not already populated */
				If Not Exists (Select * From DigblockSurveyActualValue Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id)
				Begin
					/* Insert a new value for the field */
					Insert Into DigblockSurveyActualValue
					 (Digblock_Survey_Actual_Id, Digblock_Survey_Actual_Field_Id, Field_Value)
					Values (@Digblock_Survey_Actual_Id, @Digblock_Survey_Actual_Field_Id, @Field_Value)
				End
				Else
				Begin
					/* Otherwise, update the field */
					Update DigblockSurveyActualValue
					Set	Field_Value = @Field_Value
					Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
					And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id
				End
			End
			Else
			Begin
				/* Delete any existing value */
				Delete From DigblockSurveyActualValue
				Where Digblock_Survey_Actual_Id = @Digblock_Survey_Actual_Id
				And Digblock_Survey_Actual_Field_Id = @Digblock_Survey_Actual_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given digblock survey actual field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given digblock survey actual does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------






GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateDigblockSurveyActualValue">
 <Procedure>
	Adds a new record or updates an existing record in the DigblockSurveyActualValue table if the @Field_Value value is specified.
	If the order no for the field was given instead of the actual name the value of @Digblock_Survey_Actual_Field_Id is determined from the DigblockSurveyActualField table.
	Deletes a record in the DigblockSurveyActualValue table if there is a record for the specified @Digblock_Survey_Actual_Id and @Digblock_Survey_Actual_Field_Id
	but the @Field_Value value is not specified
	Errors raised if:
		The given digblock survey actual does not exist
		The given digblock survey actual field does not exist
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileGroupFormula.prc'
GO

If object_id('dbo.AddOrUpdateStockpileGroupFormula') is not NULL
	Drop Procedure dbo.AddOrUpdateStockpileGroupFormula
GO


Create Procedure dbo.AddOrUpdateStockpileGroupFormula
(
	@Stockpile_Group_Id			Varchar(31),
	@Stockpile_Group_Field_Id	Varchar(31) = Null,
	@Formula			Varchar(1023),
	@Order_No		Int = Null
)
With Encryption As
Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- If the digblock exists
	If Exists (Select 1 From StockpileGroup Where Stockpile_Group_Id = @Stockpile_Group_Id)
	Begin

		-- If the order no for the field was given instead of the actual name
		If (@Stockpile_Group_Field_Id Is Null)
		Begin
			Select @Stockpile_Group_Field_Id = Stockpile_Group_Field_Id
			From StockpileGroupField
			Where Order_No = @Order_No
		End

		-- If the digblock field exists
		If Exists (Select 1 From StockpileGroupField Where Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id)
		Begin

			--If the value is not null
			If (@Formula Is Not Null)
			Begin
				
				-- If this forecast field is not already populated
				If Not Exists 
					(
						Select 1 
						From StockpileGroupFormula 
						Where Stockpile_Group_Id = @Stockpile_Group_Id 
							And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
					)
				Begin
					-- Insert a new value for the field
					Insert Into StockpileGroupFormula
					(Stockpile_Group_Id, Stockpile_Group_Field_Id, Formula)
					Select @Stockpile_Group_Id, @Stockpile_Group_Field_Id, @Formula
				End
				Else
				Begin
					-- Otherwise, update the field
					Update StockpileGroupFormula
					Set	Formula = @Formula
					Where Stockpile_Group_Id = @Stockpile_Group_Id
						And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
				End
			End
			Else
			Begin
				-- Delete any existing value
				Delete From StockpileGroupFormula
				Where Stockpile_Group_Id = @Stockpile_Group_Id
					And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given stockpile group field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given stockpile group does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
End

GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileGroupFormula">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileGroupFormula table if @Formula is specified.
	If the @Formula value is not specified and the record exists in the StockpileGroupFormula table the record is deleted.
	If the @Stockpile_Group_Field_Id field is not specified it is determined from the StockpileGroupField table using the @Order_No value.
	Errors raised if:
		The given stockpile group does not exist
		The given stockpile group field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileGroupNotes.prc'
GO

If object_id('dbo.AddOrUpdateStockpileGroupNotes') is not NULL
	Drop Procedure dbo.AddOrUpdateStockpileGroupNotes
GO


Create Procedure dbo.AddOrUpdateStockpileGroupNotes
(
	@Stockpile_Group_Id			Varchar(31),
	@Stockpile_Group_Field_Id	Varchar(31) = Null,
	@Notes			Varchar(1023),
	@Order_No		Int = Null
)
With Encryption As
Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- If the digblock exists
	If Exists (Select 1 From StockpileGroup Where Stockpile_Group_Id = @Stockpile_Group_Id)
	Begin

		-- If the order no for the field was given instead of the actual name
		If (@Stockpile_Group_Field_Id Is Null)
		Begin
			Select @Stockpile_Group_Field_Id = Stockpile_Group_Field_Id
			From StockpileGroupField
			Where Order_No = @Order_No
		End

		-- If the digblock field exists
		If Exists (Select 1 From StockpileGroupField Where Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id)
		Begin

			--If the value is not null
			If (@Notes Is Not Null)
			Begin
				
				-- If this forecast field is not already populated
				If Not Exists 
					(
						Select 1 
						From StockpileGroupNotes 
						Where Stockpile_Group_Id = @Stockpile_Group_Id 
							And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
					)
				Begin
					-- Insert a new value for the field
					Insert Into StockpileGroupNotes
					(Stockpile_Group_Id, Stockpile_Group_Field_Id, Notes)
					Select @Stockpile_Group_Id, @Stockpile_Group_Field_Id, @Notes
				End
				Else
				Begin
					-- Otherwise, update the field
					Update StockpileGroupNotes
					Set	Notes = @Notes
					Where Stockpile_Group_Id = @Stockpile_Group_Id
						And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
				End
			End
			Else
			Begin
				-- Delete any existing value
				Delete From StockpileGroupNotes
				Where Stockpile_Group_Id = @Stockpile_Group_Id
					And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given stockpile group field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given stockpile group does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
End

GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileGroupNotes">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileGroupNotes table if @Notes is specified.
	If the @Notes value is not specified and the record exists in the StockpileGroupNotes table the record is deleted.
	If the @Stockpile_Group_Field_Id field is not specified it is determined from the StockpileGroupField table using the @Order_No value.
	Errors raised if:
		The given stockpile group does not exist
		The given stockpile group field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateStockpileGroupValue.prc'
GO

If object_id('dbo.AddOrUpdateStockpileGroupValue') is not NULL
	Drop Procedure dbo.AddOrUpdateStockpileGroupValue
GO


Create Procedure dbo.AddOrUpdateStockpileGroupValue
(
	@Stockpile_Group_Id			Varchar(31),
	@Stockpile_Group_Field_Id	Varchar(31) = Null,
	@Value			real,
	@Order_No		Int = Null
)
With Encryption As
Begin
	Set Nocount On

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	-- If the digblock exists
	If Exists (Select 1 From StockpileGroup Where Stockpile_Group_Id = @Stockpile_Group_Id)
	Begin

		-- If the order no for the field was given instead of the actual name
		If (@Stockpile_Group_Field_Id Is Null)
		Begin
			Select @Stockpile_Group_Field_Id = Stockpile_Group_Field_Id
			From StockpileGroupField
			Where Order_No = @Order_No
		End

		-- If the digblock field exists
		If Exists (Select 1 From StockpileGroupField Where Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id)
		Begin

			--If the value is not null
			If (@Value Is Not Null)
			Begin
				
				-- If this forecast field is not already populated
				If Not Exists 
					(
						Select 1 
						From StockpileGroupValue
						Where Stockpile_Group_Id = @Stockpile_Group_Id 
							And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
					)
				Begin
					-- Insert a new value for the field
					Insert Into StockpileGroupValue
					(Stockpile_Group_Id, Stockpile_Group_Field_Id, Field_Value)
					Select @Stockpile_Group_Id, @Stockpile_Group_Field_Id, @Value
				End
				Else
				Begin
					-- Otherwise, update the field
					Update StockpileGroupValue
					Set	Field_Value = @Value
					Where Stockpile_Group_Id = @Stockpile_Group_Id
						And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
				End
			End
			Else
			Begin
				-- Delete any existing value
				Delete From StockpileGroupValue
				Where Stockpile_Group_Id = @Stockpile_Group_Id
					And Stockpile_Group_Field_Id = @Stockpile_Group_Field_Id
			End

			If @@Error = 0
				Set @ELC_Proc_Is_Error = 0
		End
		Else
		Begin
			Raiserror('The given stockpile group field does not exist', 16, 1)
		End
	End
	Else
	Begin
		Raiserror('The given stockpile group does not exist', 16, 1)
	End
	
	-------------------------------------------------------
	-- Event_Logging_Placeholder
	-------------------------------------------------------
End

GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateStockpileGroupValue">
 <Procedure>
	Adds a new record or updates an existing record in the StockpileGroupValue table if @Value is specified.
	If the @Value value is not specified and the record exists in the StockpileGroupValue table the record is deleted.
	If the @Stockpile_Group_Field_Id field is not specified it is determined from the StockpileGroupField table using the @Order_No value.
	Errors raised if:
		The given stockpile group does not exist
		The given stockpile group field does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AdminCheckHaulage.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AdminCheckHaulage'))
	Drop Procedure dbo.AdminCheckHaulage
Go

Create Procedure dbo.AdminCheckHaulage

With Encryption
As

Begin
	-- checks the Haulage chains
	-- returns any records that are in error

	-- show all "Modified" records,
	-- that have "Approved" or "Not Approved" records as their parent
	-- ie: ...-N-M-... or ...-A-M-...
	Select *
	From Haulage As H1
	Where Haulage_State_Id = 'M'
		And (	Select Count(*)
				From Haulage As H2
				Where H2.Parent_Haulage_Id = H1.Haulage_Raw_Id
					And Haulage_State_Id In ('A', 'N')) > 0

	-- all "Approved" records must be the last record in the chain
	-- ie: ...-A-|
	Select *
	From Haulage As H1
	Where Haulage_State_Id = 'A'
		And (	Select Count(*)
				From Haulage As H2
				Where H2.Parent_Haulage_Id = H1.Haulage_Id) > 0

	-- all "Approved" records must succeed a "Not Approved" record
	-- ie: ...-N-A-|
	Select *
	From Haulage As H1
	Where Haulage_State_Id = 'A'
		And (	Select Count(*)
				From Haulage As H2
				Where H2.Parent_Haulage_Id = H1.Haulage_Id
					And H2.Haulage_State_Id = 'N') = 0
End
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AdminCheckHaulage">
 <Procedure>
	Checks the Haulage chains and returns any records that have the following errors:
		Modified records that have "Approved" or "Not Approved" records as their parent
		Approved records that are not the last record in the chain
		Approved records that succeed a record that is not flagged as "Not Approved"
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AdminCheckHaulageRaw.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.AdminCheckHaulageRaw'))
	Drop Procedure dbo.AdminCheckHaulageRaw
Go

Create Procedure dbo.AdminCheckHaulageRaw

With Encryption
As

Begin
	-- checks the HaulageRaw chains
	-- returns any records that are in error

	-- all "Correct" records must have Haulage records
	Select *
	From HaulageRaw
	Where Haulage_Raw_State_Id = 'C'
		And (	Select Count(*)
				From Haulage
				Where Haulage_Raw_Id = HaulageRaw.Haulage_Raw_Id) = 0

	-- all non-"Correct" records must not have Haulage records
	Select *
	From HaulageRaw
	Where Haulage_Raw_State_Id <> 'C'
		And (	Select Count(*)
				From Haulage
				Where Haulage_Raw_Id = HaulageRaw.Haulage_Raw_Id) > 0

	-- all "Modified" records must be parent to an "Error", "Correct" or "Modified" record
	Select *
	From HaulageRaw As HR1
	Where Haulage_Raw_State_Id = 'M'
		And (	Select Count(*)
				From HaulageRaw As HR2
				Where HR2.Parent_Haulage_Raw_Id = HR1.Haulage_Raw_Id
					And Haulage_Raw_State_Id In ('E', 'C', 'M')) = 0

	-- all "Correct" records must be the last record in the chain
	Select *
	From HaulageRaw As HR1
	Where Haulage_Raw_State_Id = 'C'
		And (	Select Count(*)
				From HaulageRaw As HR2
				Where HR2.Parent_Haulage_Raw_Id = HR1.Haulage_Raw_Id) > 0

	-- all "Error" records must be the last record in the chain
	Select *
	From HaulageRaw As HR1
	Where Haulage_Raw_State_Id = 'E'
		And (	Select Count(*)
				From HaulageRaw As HR2
				Where HR2.Parent_Haulage_Raw_Id = HR1.Haulage_Raw_Id) > 0
				
	-- all "Error" records must have HaulageRawError entries
	Select *
	From HaulageRaw As HR
	Where Haulage_Raw_State_Id = 'E'
		And (	Select Count(*)
				From HaulageRawError HRE
				Where HRE.Haulage_Raw_Id = HR.Haulage_Raw_Id) = 0
End
Go 

/*
<TAG Name="Data Dictionary" ProcedureName="AdminCheckHaulageRaw">
 <Procedure>
	Checks the HaulageRaw chains returning any records that have the following errors:
		"Correct" records that do not have Haulage records
		Non-"Correct" records that have Haulage records
		"Modified" records that are parents to records with a state other than "Error", "Correct" or "Modified" 
		"Correct" records that are not the last record in the chain
		"Error" records that are not the last record in the chain
		"Error" records that do not have HaulageRawError entries
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AdminFixUsers.prc'
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AdminFixUsers]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
	drop procedure [dbo].[AdminFixUsers]
GO

Create Procedure dbo.AdminFixUsers

With Encryption
As

Begin
	-- Routine to loop through all users within "User".
	-- Ensures the User exists within the database.
	-- If the User already exists, check the SID is correct.

	Declare @curUSER Cursor
	Declare @NT_Login VarChar(255)
	Declare @Login VarChar(255)
	Declare @SlashIndex Int
	Declare @SQL_Login VarChar(255)
	Declare @First_Name Varchar(63)
	Declare @Last_Name Varchar(63)
	Declare @User_Id Int
	Declare @Email_Address VarChar(255)
	Declare @Is_Active Bit

	Set @curUSER = Cursor Local Fast_Forward Read_Only For
		Select User_Id, NT_Login
		From [User]

	Open @curUSER

	Fetch Next From @curUSER Into @User_Id, @NT_Login
	While @@Fetch_Status = 0
	Begin
		Set @SlashIndex = CharIndex('\', @NT_Login)
		Set @SQL_Login = 'RECONCILOR_' + Upper(Left(@NT_Login, @SlashIndex-1)) + '_' + Upper(Right(@NT_Login, Len(@NT_Login)-@SlashIndex))

		If Not Exists (Select 1 From sysusers Where name = @SQL_Login)
			Or Not Exists (Select 1 From master.dbo.syslogins where name = @SQL_Login)
		Begin
			Select @NT_Login = NT_Login,
				@First_Name = First_Name,
				@Last_Name = Last_Name,
				@User_Id = User_Id,
				@Email_Address = Email_Address,
				@Is_Active = IsNull(Is_Active, 1)
			From [User]
			Where User_Id = @User_Id
		
			Exec dbo.AddOrUpdateUser
				@iNT_Login = @NT_Login,
				@iFirst_Name = @First_Name,
				@iLast_Name = @Last_Name,
				@iUser_Id = @User_Id,
				@iEmail_Address = @Email_Address,
				@iIs_Active = @Is_Active
		End
		Else
		Begin
			Exec sp_Change_Users_Login
				@Action='Update_One',
				@UserNamePattern=@SQL_Login,
				@LoginName=@SQL_Login
		End
		
		Fetch Next From @curUSER Into @User_Id, @NT_Login
	End
	Close @curUSER
End

/*
<TAG Name="Data Dictionary" ProcedureName="AdminFixUsers">
 <Procedure>
	Ensures that users within the USER_DET table is added as a User
	in the database.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AdminCheckHaulageDigblockDate.prc'
GO

If Object_Id('dbo.AdminCheckHaulageDigblockDate') Is Not Null
	Drop Procedure dbo.AdminCheckHaulageDigblockDate
Go

Create Procedure dbo.AdminCheckHaulageDigblockDate

With Encryption As

Begin
	Set NoCount On

	Select D.Start_Date, D.Start_Shift, D.End_Date, D.End_Shift, H.Haulage_Date, H.Haulage_Shift
	From Digblock As D
		Inner Join Haulage As H
		On (D.Digblock_Id = H.Source_Digblock_Id)
	Where dbo.CompareDateShift(D.Start_Date, D.Start_Shift, '>', H.Haulage_Date, H.Haulage_Shift) = 1
		Or dbo.CompareDateShift(D.End_Date, D.End_Shift, '<', H.Haulage_Date, H.Haulage_Shift) = 1
		Or D.Start_Date Is Null
End

/*
<TAG Name="Data Dictionary" ProcedureName="AdminCheckHaulageDigblockDate">
 <Procedure>
	Returns a list of Digblocks that have Haulage records for dates when the digblock is not active.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileGroupStockpileGroupId.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.UpdateStockpileGroupStockpileGroupId'))
	Drop Procedure dbo.UpdateStockpileGroupStockpileGroupId
Go

Create Procedure dbo.UpdateStockpileGroupStockpileGroupId
(
	@iOld_Stockpile_Group_Id VarChar(31),
	@iNew_Stockpile_Group_Id VarChar(31)
)

With Encryption
As

Begin
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	If (@iOld_Stockpile_Group_Id = @iNew_Stockpile_Group_Id)
	Begin
		RaisError('The old stockpile group cannot be the same as the new stockpile group.', 16, 1)
	End
	Else If Exists (	Select 1
						From StockpileGroup
						Where Stockpile_Group_Id = @iNew_Stockpile_Group_Id)
	Begin
		RaisError('The new stockpile group already exists.', 16, 1)
	End
	Else If Not Exists (Select 1
						From StockpileGroup
						Where Stockpile_Group_Id = @iOld_Stockpile_Group_Id)
	Begin
		RaisError('The old stockpile group cannot be found within the system.', 16, 1)
	End
	Else
	Begin
		Insert Into StockpileGroup
			(Stockpile_Group_Id, Description, Order_No)
		Select @iNew_Stockpile_Group_Id, Description, Order_No
		From StockpileGroup
		Where Stockpile_Group_Id = @iOld_Stockpile_Group_Id

		Update StockpileGroupStockpile
		Set Stockpile_Group_Id = @iNew_Stockpile_Group_Id
		Where Stockpile_Group_Id = @iOld_Stockpile_Group_Id

		Delete
		From StockpileGroup
		Where Stockpile_Group_Id = @iOld_Stockpile_Group_Id
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileGroupStockpileGroupId">
 <Procedure>
	Updated the table StockpileGroup and  StockpileGroupStockpile for a modified Stockpile_Group_Id.
	Errors are raised if:
		The old stockpile group cannot be the same as the new stockpile group.
		The new stockpile group already exists.
		The old stockpile group cannot be found within the system.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockSurveyActualValue.prc'
GO

If object_id('dbo.DeleteDigblockSurveyActualValue') is not Null 
     Drop Procedure dbo.DeleteDigblockSurveyActualValue 
Go 
  
Create Procedure dbo.DeleteDigblockSurveyActualValue 
( 
    @iDigblock_Survey_Actual_Id Int,
	@iDigblock_Survey_Actual_Field_Id VarChar(31)
) 

With Encryption
As 

Begin 
    Set NoCount On 

    Begin Transaction 

	Delete From DigblockSurveyActualValue
	Where Digblock_Survey_Actual_Field_Id = @iDigblock_Survey_Actual_Field_Id
		And Digblock_Survey_Actual_Id = @iDigblock_Survey_Actual_Id

    Commit Transaction 
End 
Go	





/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockSurveyActualValue">
 <Procedure>
	Deletes records with the specified Actual and Field ID from the DigblockSurveyActualValue table.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.MergeStockpiles.prc'
GO

If object_id('dbo.MergeStockpiles') is not NULL
	Drop Procedure dbo.MergeStockpiles
Go


CREATE Procedure dbo.MergeStockpiles
(
	@iDeleted_Stockpile_Id Int,
	@iDeleted_Build_Id Int,
	@iDestination_Stockpile_Id Int,
	@iDestination_Build_Id Int,
	@iMerge_Date Datetime,
	@iMerge_Shift Char(1)
)

With Encryption 
As

Begin

	Declare @Exists Bit
	Declare @Is_Active Bit
	Declare @Description Varchar(255)
	Declare @Source_Tonnes Float
	Declare @Error Int
	Declare @iGrade_Id varchar(31)
	Declare @iGrade_Value real

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	/* If the stockpile build being deleted is active */
	If (dbo.IsStockpileBuildActive (@iDeleted_Stockpile_Id, @iDeleted_Build_Id, @iMerge_Date, @iMerge_Shift) = 1)
	Begin
		/* If the destination stockpile build is active */
		If (dbo.IsStockpileBuildActive (@iDestination_Stockpile_Id, @iDestination_Build_Id, @iMerge_Date, @iMerge_Shift) = 1)
		Begin
			/* Get the tonnes and grade of the stockpile being deleted on the given date and shift */
			Create Table #STOCKPILE_BALANCE_GRADE 
			(
				Stockpile_Id Int Not Null,
				Grade_Id VarChar(31),
				Grade_Value Float
			)	

			Insert into #STOCKPILE_BALANCE_GRADE
			(
				Stockpile_Id, Grade_Id, Grade_Value
			)
			Select B.Stockpile_Id,
				BG.Grade_Id, 
				Sum(BG.Grade_Value * B.Tonnes) / Sum(B.Tonnes)
			From DataProcessStockpileBalance B
				Inner Join DataProcessStockpileBalanceGrade BG
					On B.Data_Process_Stockpile_Balance_Id = BG.Data_Process_Stockpile_Balance_Id
			Where B.Stockpile_Id = @iDeleted_Stockpile_Id
				And B.Build_Id = @iDeleted_Build_Id
				And B.Data_Process_Stockpile_Balance_Date = @iMerge_Date
				And B.Data_Process_Stockpile_Balance_Shift = @iMerge_Shift
			Group by B.Stockpile_Id, BG.Grade_Id
			Having Sum(B.Tonnes) <> 0

			Select @Source_Tonnes = Sum(B.Tonnes)
			From DataProcessStockpileBalance B
			Where Stockpile_Id = @iDeleted_Stockpile_Id
				And Build_Id = @iDeleted_Build_Id
				And Data_Process_Stockpile_Balance_Date = @iMerge_Date
				And Data_Process_Stockpile_Balance_Shift = @iMerge_Shift
			Having Sum(B.Tonnes) <> 0

			/* If the tonnes of the stockpile are greater than zero */
			If ((@Source_Tonnes > 0) And (@Source_Tonnes Is Not Null))
			Begin
				/* Start the transaction to merge the stockpile */
				Set @Error = 0
				Begin Transaction Merge_Stockpile_Transaction


				If (@Error = 0)
				Begin
					Set @Description = 'Stockpile Merge Adjustment with deleted stockpile ' + @iDeleted_Stockpile_Id + ' (Automatic)'

					/* Add a stockpile adjustment to increment the tonnes and grade on the destination stockpile */
					Exec AddStockpileAdjustment 
						@iDestination_Stockpile_Id, @iDestination_Build_Id,  Null, @iMerge_Date, 
						@iMerge_Shift, @Description,	1, 1, 1, 0, @Source_Tonnes

	
					Declare Update_Stockpile_Adjustment_Grade CURSOR FOR
					Select Stockpile_Id, Grade_Id, Grade_Value 
					From #STOCKPILE_BALANCE_GRADE

					Open Update_Stockpile_Adjustment_Grade

					Fetch Next From Update_Stockpile_Adjustment_Grade
						Into @iDestination_Stockpile_Id, @iGrade_Id, @iGrade_Value

					While @@FETCH_STATUS = 0
					Begin

						Exec AddOrUpdateStockpileAdjustmentGrade @iDestination_Stockpile_Id, @iGrade_Id, @iGrade_Value

					   -- This is executed as long as the previous fetch succeeds.
						Fetch Next From Update_Stockpile_Adjustment_Grade
							Into @iDestination_Stockpile_Id, @iGrade_Id, @iGrade_Value
					End

					Close Update_Stockpile_Adjustment_Grade
					Deallocate Update_Stockpile_Adjustment_Grade
					
					Set @Error = @@Error
				End

				If (@Error = 0)
				Begin
					Set @Description = 'Stockpile Merge Adjustment with destination stockpile ' + @iDestination_Stockpile_Id + ' (Automatic)'

					/* Add a stockpile adjustment to set the tonnes and grade of the deleted stockpile to zero */
					Exec AddStockpileAdjustment @iDeleted_Stockpile_Id, @iDeleted_Build_Id, Null, @iMerge_Date, 
							@iMerge_Shift, @Description,	0, 1, 1, 0, 0

					Set @Error = @@Error
				End

				If (@Error = 0)
				Begin
					Set @Description = 'Stockpile closed as part of merge with destination stockpile ' + @iDestination_Stockpile_Id + ' (Automatic)'

					/* Close the stockpile being deleted on that date */
					Exec Update_Stockpile_Build_State @iDeleted_Stockpile_Id, @iDeleted_Build_Id, 'CLOSED', @iMerge_Date, 
						@iMerge_Shift, @Description

					Set @Error = @@Error
				End


				/* If everything went OK */
				If (@Error = 0)
				Begin
					/* Commit the changes */
					Commit Transaction Merge_Stockpile_Transaction

					Set @ELC_Proc_Is_Error = 0
				End
				Else
				Begin
					/* Otherwise, rollback */
					Rollback Transaction Merge_Stockpile_Transaction

					Raiserror ('Could not complete merge operation', 16, 1)
				End
			End
			Else
			Begin
				Raiserror ('The stockpile being deleted has negative or zero tonnes on the merge date and shift', 16, 1)
			End
		End
		Else
		Begin
			Raiserror ('The stockpile build being added to is not active on the given date and shift', 16, 1)
		End
	End
	Else
	Begin
		Raiserror ('The stockpile build being deleted is not active on the given date and shift', 16, 1)
	End


	-- Event_Logging_Placeholder
End
GO

/*
<TAG Name="Data Dictionary" ProcedureName="MergeStockpiles">
 <Procedure>
	If the stockpile build being deleted is active and if the destination stockpile build is active,
	get the tonnes and grade of the stockpile being deleted on the given date and shift.
	If the tonnes of the stockpile are greater than zero start the transaction to merge the stockpile.
	Add a stockpile adjustment to increment the tonnes and grade on the destination stockpile and
	add a stockpile adjustment to set the tonnes and grade of the deleted stockpile to zero.
	Close the stockpile being deleted on that date.
	Errors are raised if:
		Stockpile Merge Adjustment with deleted stockpile (Automatic).
		Stockpile Merge Adjustment with destination stockpile (Automatic).
		Stockpile closed as part of merge with destination stockpile (Automatic).
		Could not complete merge operation.
		The stockpile being deleted has negative or zero tonnes on the merge date and shift.
		The stockpile build being added to is not active on the given date and shift.
		The stockpile build being deleted is not active on the given date and shift.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageByDigblock.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.DeleteHaulageByDigblock'))
	Drop Procedure dbo.DeleteHaulageByDigblock
Go

Create Procedure dbo.DeleteHaulageByDigblock
(
	@iDigblock_Id VarChar(31)
)

With Encryption
As

Begin
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- find the first haulage record
	Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
						From Haulage
						Where Source_Digblock_Id = @iDigblock_Id)
	While @Haulage_Id Is Not Null
	Begin
		Exec DeleteHaulage
			@iHaulage_Id = @Haulage_Id
		
		-- locate the next haulage record
		Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
							From Haulage
							Where Source_Digblock_Id = @iDigblock_Id)
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageByDigblock">
 <Procedure>
	Deletes records from the Haulage table related to @Haulage_Id.  Loops calling GetLastHaulageId function and DeleteHaulage
	procedure to delete the last Haulage record in the chain until all records in the chain are deleted.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageByStockpile.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.DeleteHaulageByStockpile'))
	Drop Procedure dbo.DeleteHaulageByStockpile
Go

Create Procedure dbo.DeleteHaulageByStockpile
(
	@iStockpile_Id Int,
	@iBuild_Id Int = Null,
	@iComponent_Id Int = Null
)

With Encryption
As

Begin
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- find the first haulage record
	Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
						From Haulage
						Where (	Source_Stockpile_Id = @iStockpile_Id
								And (Source_Build_Id = @iBuild_Id Or @iBuild_Id Is Null)
								And (Source_Component_Id = @iComponent_Id Or @iComponent_Id Is Null))
							Or (	Destination_Stockpile_Id = @iStockpile_Id
									And (Destination_Build_Id = @iBuild_Id Or @iBuild_Id Is Null)
									And (Destination_Component_Id = @iComponent_Id Or @iComponent_Id Is Null)))
							
	While @Haulage_Id Is Not Null
	Begin
		Exec DeleteHaulage
			@iHaulage_Id = @Haulage_Id
		
		-- locate the next haulage record
		Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
							From Haulage
							Where (	Source_Stockpile_Id = @iStockpile_Id
									And (Source_Build_Id = @iBuild_Id Or @iBuild_Id Is Null)
									And (Source_Component_Id = @iComponent_Id Or @iComponent_Id Is Null))
								Or (	Destination_Stockpile_Id = @iStockpile_Id
										And (Destination_Build_Id = @iBuild_Id Or @iBuild_Id Is Null)
										And (Destination_Component_Id = @iComponent_Id Or @iComponent_Id Is Null)))
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageByStockpile">
 <Procedure>
	Deletes records from the Haulage table related to @iStockpile_Id, @iBuild_Id and @iComponent_Id.  Loops calling GetLastHaulageId function and DeleteHaulage
	procedure to delete the last Haulage record in the chain until all records in the chain are deleted.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageAll.prc'
GO

If Exists (Select 1 From sysobjects Where id = Object_Id('dbo.DeleteHaulageAll'))
	Drop Procedure dbo.DeleteHaulageAll
Go

Create Procedure dbo.DeleteHaulageAll

With Encryption
As

Begin
	Declare @Haulage_Id Int

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- find the first haulage record
	Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
						From Haulage)
	While @Haulage_Id Is Not Null
	Begin
		Exec DeleteHaulage
			@iHaulage_Id = @Haulage_Id
		
		-- locate the next haulage record
		Set @Haulage_Id = (	Select Top 1 dbo.GetLastHaulageId(Haulage_Id)
							From Haulage)
	End

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteHaulageAll">
 <Procedure>
	Deletes all records from the Haulage table.  Loops calling GetLastHaulageId function and DeleteHaulage
	procedure to delete the last Haulage record in the chain until all records in the Haulage table are deleted.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteModelBlock.prc'
GO

If Object_Id('dbo.DeleteModelBlock') Is Not Null
	Drop Procedure dbo.DeleteModelBlock
Go

Create Procedure dbo.DeleteModelBlock
(
	@iModel_Block_Id Int
)

With Encryption
As

Begin
	-- MDH - 20-Dec-2006
	-- low performance routine to provide a simple delete facility

	Declare @curMODEL_BLOCK_PARTIAL Cursor
	Declare @Model_Block_Id Int
	Declare @Sequence_No Int
	
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Delete
	From dbo.BlastBlockModelBlock
	Where Model_Block_Id = @iModel_Block_Id

	Delete
	From dbo.DigblockModelBlock
	Where Model_Block_Id = @iModel_Block_Id

	Set @curMODEL_BLOCK_PARTIAL = Cursor Local Fast_Forward Read_Only For
		Select Model_Block_Id, Sequence_No
		From ModelBlockPartial
		Where Model_Block_Id = @iModel_Block_Id

	Open @curMODEL_BLOCK_PARTIAL
	Fetch Next From @curMODEL_BLOCK_PARTIAL Into @Model_Block_Id, @Sequence_No
	While @@Fetch_Status = 0
	Begin
		Exec dbo.DeleteModelBlockPartial
			@Model_Block_Id = @Model_Block_Id,
			@Sequence_No = @Sequence_No

		Fetch Next From @curMODEL_BLOCK_PARTIAL Into @Model_Block_Id, @Sequence_No
	End
	Close @curMODEL_BLOCK_PARTIAL

	Delete
	From ModelBlock
	Where Model_Block_Id = @iModel_Block_Id

	Commit Transaction
End
Go
GRANT EXECUTE ON dbo.DeleteModelBlock TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteModelBlock">
 <Procedure>
	Deletes records with the specified @iModel_Block_Id from the following tables:
		BlastBlockModelBlock
		DigblockModelBlock 
		ModelBlockPartial
		ModelBlock
	The ModelBlockPartial records are deleted by calling DeleteModelBlockPartial for
	each of the records with the specified @iModel_Block_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteBlockModel.prc'
GO

If Object_Id('dbo.DeleteBlockModel') Is Not Null
	Drop Procedure dbo.DeleteBlockModel
Go

Create Procedure dbo.DeleteBlockModel
(
	@iBlock_Model_Id Int
)

With Encryption
As

Begin
	-- MDH - 20-Dec-2006
	-- low performance routine to provide a simple delete facility

	Declare @curMODEL_BLOCK Cursor
	Declare @Model_Block_Id Int
	
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @curMODEL_BLOCK = Cursor Local Fast_Forward Read_Only For
		Select Model_Block_Id
		From ModelBlock
		Where Block_Model_Id = @iBlock_Model_Id

	Open @curMODEL_BLOCK
	Fetch Next From @curMODEL_BLOCK Into @Model_Block_Id
	While @@Fetch_Status = 0
	Begin
		Exec dbo.DeleteModelBlock
			@iModel_Block_Id = @Model_Block_Id

		Fetch Next From @curMODEL_BLOCK Into @Model_Block_Id
	End
	Close @curMODEL_BLOCK
	
	Delete
	From BlockModel
	Where Block_Model_Id = @iBlock_Model_Id

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteBlockModel">
 <Procedure>
	Deletes a record from the BlockModel table
	For each ModelBlock record with the specified @iBlock_Model_Id call DeleteModelBlock
	to remove the ModelBlock records.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteBlockModelType.prc'
GO

If Object_Id('dbo.DeleteBlockModelType') Is Not Null
	Drop Procedure dbo.DeleteBlockModelType
Go

Create Procedure dbo.DeleteBlockModelType
(
	@iBlock_Model_Type_Id Int
)

With Encryption 
As

Begin
	-- MDH - 20-Dec-2006
	-- low performance routine to provide a simple delete facility

	Declare @curBLOCK_MODEL Cursor
	Declare @Block_Model_Id Int
	
	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	Set @curBLOCK_MODEL = Cursor Local Fast_Forward Read_Only For
		Select Block_Model_Id
		From BlockModel
		Where Block_Model_Type_Id = @iBlock_Model_Type_Id

	Open @curBLOCK_MODEL
	Fetch Next From @curBLOCK_MODEL Into @Block_Model_Id
	While @@Fetch_Status = 0
	Begin
		Exec dbo.DeleteBlockModel
			@iBlock_Model_Id = @Block_Model_Id

		Fetch Next From @curBLOCK_MODEL Into @Block_Model_Id
	End
	Close @curBLOCK_MODEL

	Delete
	From BlockModelType
	Where Block_Model_Type_Id = @iBlock_Model_Type_Id

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteBlockModelType">
 <Procedure>
	Deletes a record from the BlockModelType table
	For each BlockModel record with the specified @iBlock_Model_Type_Id call DeleteBlockModel
	to remove the BlockModel records.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockBlockModelComparison.prc'
GO

IF object_id('dbo.GetDigblockBlockModelComparison') IS NOT NULL
BEGIN
	DROP PROCEDURE dbo.GetDigblockBlockModelComparison
END
GO

CREATE PROCEDURE dbo.GetDigblockBlockModelComparison
(
	@iBlock_Model_Id_One INT,
	@iBlock_Model_Id_Two INT,
	@iDigblock_Id VARCHAR(31),
	@iGrade_Visibility Bit = 1
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON

	DECLARE @TonnesId Int

	DECLARE @ModelComparison TABLE 
	(
		Grade_Id Int,
		Grade_Name VARCHAR(31) COLLATE Database_Default,
		Sequence_No INT,
		Order_No INT,
		Display_Precision INT,
		Display_Format VARCHAR(10) COLLATE Database_Default,
		Units VARCHAR(15) COLLATE Database_Default,
		Block_Model_Grade_One REAL,
		Block_Model_Grade_Two REAL
	)

	SELECT @TonnesId = -1

	--Load Tonnes & Grade for Model 1
	INSERT INTO @ModelComparison
	(
		Grade_Id, Grade_Name, Sequence_No, Order_No, Display_Precision, Display_Format, Units, Block_Model_Grade_One
	)
	SELECT @TonnesId, 'Tonnes', MBP.Sequence_No, -100, 0, 'DP', '', MBP.Tonnes
	FROM dbo.BlockModel BM
		INNER JOIN dbo.ModelBlock MB
			ON (MB.Block_Model_Id = BM.Block_Model_Id)
		INNER JOIN dbo.ModelBlockPartial MBP
			ON (MBP.Model_Block_Id = MB.Model_Block_Id)
	WHERE BM.Block_Model_Id = @iBlock_Model_Id_One
		AND MB.Code = @iDigblock_Id

	INSERT INTO @ModelComparison
	(
		Grade_Id, G.Grade_Name, Sequence_No, Order_No, Display_Precision, Display_Format, Units, Block_Model_Grade_One
	)
	SELECT G.Grade_Id, G.Grade_Name, MBP.Sequence_No, G.Order_No, G.Display_Precision, G.Display_Format, G.Units, MBPG.Grade_Value
	FROM dbo.BlockModel BM
		INNER JOIN dbo.ModelBlock MB
			ON (MB.Block_Model_Id = BM.Block_Model_Id)
		INNER JOIN dbo.ModelBlockPartial MBP
			ON (MBP.Model_Block_Id = MB.Model_Block_Id)
		INNER JOIN dbo.ModelBlockPartialGrade MBPG
			ON (MBPG.Model_Block_Id = MBP.Model_Block_Id
				AND MBPG.Sequence_No = MBP.Sequence_No)
		INNER JOIN dbo.Grade G
			ON (MBPG.Grade_Id = G.Grade_Id)
	WHERE BM.Block_Model_Id = @iBlock_Model_Id_One
		AND MB.Code = @iDigblock_Id
		AND (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

	--Load Tonnes & Grade for Model 2
	UPDATE MC
	SET MC.Block_Model_Grade_Two = MBP.Tonnes
	FROM dbo.BlockModel BM
		INNER JOIN dbo.ModelBlock MB
			ON (MB.Block_Model_Id = BM.Block_Model_Id)
		INNER JOIN dbo.ModelBlockPartial MBP
			ON (MBP.Model_Block_Id = MB.Model_Block_Id)
		INNER JOIN @ModelComparison MC
			ON (MC.Grade_Id = @TonnesId
				AND MBP.Sequence_No = MC.Sequence_No)
	WHERE BM.Block_Model_Id = @iBlock_Model_Id_Two
		AND MB.Code = @iDigblock_Id

	UPDATE MC
	SET MC.Block_Model_Grade_Two = MBPG.Grade_Value
	FROM dbo.BlockModel BM
		INNER JOIN dbo.ModelBlock MB
			ON (MB.Block_Model_Id = BM.Block_Model_Id)
		INNER JOIN dbo.ModelBlockPartial MBP
			ON (MBP.Model_Block_Id = MB.Model_Block_Id)
		INNER JOIN dbo.ModelBlockPartialGrade MBPG
			ON (MBPG.Model_Block_Id = MBP.Model_Block_Id
				AND MBPG.Sequence_No = MBP.Sequence_No)
		INNER JOIN @ModelComparison MC --Prefilters visibility
			ON (MC.Grade_Id = MBPG.Grade_Id)
	WHERE BM.Block_Model_Id = @iBlock_Model_Id_Two
		AND MB.Code = @iDigblock_Id

	--Insert 0's for missing grades
	INSERT INTO @ModelComparison
	(
		Grade_Id, G.Grade_Name, Sequence_No, Order_No, Display_Precision, 
		Display_Format, Units, Block_Model_Grade_One, Block_Model_Grade_Two
	)
	SELECT G.Grade_Id, G.Grade_Name, MC.Sequence_No, G.Order_No, G.Display_Precision, 
		G.Display_Format, G.Units, 0, 0
	FROM dbo.Grade As G
		CROSS JOIN @ModelComparison AS MC
	WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		AND NOT EXISTS
			(
				SELECT 1 
				FROM @ModelComparison As MC2
				WHERE MC2.Sequence_No = MC.Sequence_No
					AND MC2.Grade_Id = G.Grade_Id
			)

	SELECT *
	FROM @ModelComparison
	ORDER BY Order_no
END
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockBlockModelComparison">
 <Procedure>
	Returns @iBlock_Model_Id_One and @iBlock_Model_Id_Two side by side.
	for the specified @iDigblock_Id.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMinePlanPeriodType.prc'
GO

If Object_Id('dbo.GetMinePlanPeriodType') Is Not Null
	Drop Procedure dbo.GetMinePlanPeriodType
Go

Create Procedure dbo.GetMinePlanPeriodType

With Encryption
As

Begin
	Set NoCount On

	Select MPPT.Mine_Plan_Period_Type_Id, MPPT.Mine_Plan_Period_Type_Name,
		MPPTG.Mine_Plan_Period_Type_Group_Id, MPPTG.Mine_Plan_Period_Type_Group_Name
	From dbo.MinePlanPeriodType As MPPT
		Inner Join dbo.MinePlanPeriodTypeGroup As MPPTG
			On (MPPT.Mine_Plan_Period_Type_Group_Id = MPPTG.Mine_Plan_Period_Type_Group_Id)
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="GetMinePlanPeriodType">
 <Procedure>
	Returns a list mine plan period types.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AmalgamateMinePlan.prc'
GO

If Object_Id('dbo.AmalgamateMinePlan') Is Not Null
	Drop Procedure dbo.AmalgamateMinePlan
Go

Create Procedure dbo.AmalgamateMinePlan
(
	@iStart_Date DateTime = Null,
	@iEnd_Date DateTime = Null
)

With Encryption
As

Begin
	-- amalgamates the various mine plans
	-- to use:
	-- 1) you will need to populate dbo.#AMALGAMATE_MINE_PLAN_PERIOD
	--    this table will contain links to all of the mine plan period records that require merging
	--    to each individual record, you will need to describe its relative rank
	-- 2) the results will be deposited in dbo.#AMALGAMATE_MINE_PLAN_AMALGAMATED

	-- current limitations
	-- 1) Location based data only caters for one-to-one relationships
	--    ie each Mine Plan Period record can only have one Location record
	-- 2) Location based data does not take into account the hierarchies available
	--    to accurately compare, we would need:
	--    (1) a full grade control model to evaluate tonnages
	--    (2) a full location model to evaluate membership

	/*
		Requires the following tables to exist:

		Create Table dbo.#AMALGAMATE_MINE_PLAN_PERIOD
		(
			Mine_Plan_Id Int Not Null,
			Start_Date DateTime Not Null,
			Sequence_No Int Not Null,
			Rank Int Not Null,
			Constraint PK_AMALGAMATE_MINE_PLAN_PERIOD Primary Key Clustered
				(Mine_Plan_Id, Start_Date, Sequence_No),
		)

		Create Table dbo.#AMALGAMATE_MINE_PLAN_AMALGAMATED
		(
			Mine_Plan_Id Int Not Null,
			Start_Date DateTime Not Null,
			Sequence_No Int Not Null,
			Effective_Start_Date DateTime Not Null,
			Effective_End_Date DateTime Not Null,
			Ratio Float Not Null,
			Constraint PK_AMALGAMATE_MINE_PLAN_AMALGAMATED Primary Key Clustered
				(
					Mine_Plan_Id, Start_Date, Sequence_No,
					Effective_Start_Date, Effective_End_Date,
					Ratio
				)
		)
	*/

	Declare @AMALGAMATE_MINE_PLAN_AMALGAMATED Table
	(
		Mine_Plan_Id Int Not Null,
		Start_Date DateTime Not Null,
		Sequence_No Int Not Null,
		Effective_Start_Date DateTime Not Null,
		Effective_End_Date DateTime Not Null,
		Ratio Float Not Null,
		Mine_Plan_Period_Type_Id Int Not Null,
		Material_Type_Id Int Null,
		Location_Id Int Null
	)

	Declare @FILL Table
	(
		Effective_Start_Date DateTime Not Null,
		Effective_End_Date DateTime Not Null,
		Primary Key (Effective_Start_Date, Effective_End_Date)
	)

	Declare @GAP Table
	(
		Effective_Start_Date DateTime Not Null,
		Effective_End_Date DateTime Not Null,
		Primary Key (Effective_Start_Date, Effective_End_Date)
	)

	Declare @curUNIQUE Cursor
	Declare @Mine_Plan_Period_Type_Id Int
	Declare @Material_Type_Id Int
	Declare @Location_Id Int

	Declare @curMINE_PLAN_PERIOD Cursor
	Declare @Mine_Plan_Id Int
	Declare @Start_Date DateTime
	Declare @Sequence_No Int
	Declare @End_Date DateTime
	Declare @Rank Float

	Declare @Absolute_Start_Date DateTime
	Declare @Absolute_End_Date DateTime
	Declare @Effective_Start_Date DateTime
	Declare @Effective_End_Date DateTime

	Set NoCount On

	Set Transaction Isolation Level Repeatable Read
	Begin Transaction

	-- clear any possible existing records
	Delete
	From dbo.#AMALGAMATE_MINE_PLAN_AMALGAMATED

	-- perform the amalgamations

	-- define the absolute min/max dates
	Select @Absolute_Start_Date = Coalesce(@iStart_Date, Min(MPP.Start_Date)),
		@Absolute_End_Date = Coalesce(@iEnd_Date, Max(MPP.End_Date))
	From dbo.#AMALGAMATE_MINE_PLAN_PERIOD As AMPP
		Inner Join dbo.MinePlanPeriod As MPP
			On (AMPP.Mine_Plan_Id = MPP.Mine_Plan_Id
				And AMPP.Start_Date = MPP.Start_Date
				And AMPP.Sequence_No = MPP.Sequence_No)

	-- loop through each MinePlanPeriodType / MATERIAL_TYPE_Id / Location combo
	-- these are treated as separate "units"
	
	Set @curUNIQUE = Cursor Local Fast_Forward Read_Only For
		Select Distinct MPP.Mine_Plan_Period_Type_Id, MPP.Material_Type_Id, MPPL.Location_Id
		From dbo.#AMALGAMATE_MINE_PLAN_PERIOD As AMPP
			Inner Join dbo.MinePlanPeriod As MPP
				On (AMPP.Mine_Plan_Id = MPP.Mine_Plan_Id
					And AMPP.Start_Date = MPP.Start_Date
					And AMPP.Sequence_No = MPP.Sequence_No)
			Left Join dbo.MinePlanPeriodLocation As MPPL
				On (MPPL.Mine_Plan_Id = MPP.Mine_Plan_Id
					And MPPL.Start_Date = MPP.Start_Date
					And MPPL.Sequence_No = MPP.Sequence_No
					And MPPL.Location_Id = (
												-- as part of the existing limitations
												-- only retrieve the first location record available
												-- this will avoid crash conditions
												Select Top 1 MPPL2.Location_Id
												From dbo.MinePlanPeriodLocation As MPPL2
												Where MPPL2.Mine_Plan_Id = MPPL.Mine_Plan_Id
													And MPPL2.Start_Date = MPPL.Start_Date
													And MPPL2.Sequence_No = MPPL.Sequence_No
											)
					)

	Open @curUNIQUE
	Fetch Next From @curUNIQUE Into @Mine_Plan_Period_Type_Id, @Material_Type_Id, @Location_Id
	While @@Fetch_Status = 0
	Begin
		-- for each MinePlanPeriod record available
		-- in order, apply the highest ranking record through to the lowest ranking record
		-- merging in the results as we go

		Set @curMINE_PLAN_PERIOD = Cursor Local Fast_Forward Read_Only For
			Select AMPP.Mine_Plan_Id, AMPP.Start_Date, AMPP.Sequence_No, MPP.End_Date, AMPP.Rank
			From dbo.#AMALGAMATE_MINE_PLAN_PERIOD As AMPP
				Inner Join dbo.MinePlanPeriod As MPP
					On (AMPP.Mine_Plan_Id = MPP.Mine_Plan_Id
						And AMPP.Start_Date = MPP.Start_Date
						And AMPP.Sequence_No = MPP.Sequence_No)
			Where MPP.Mine_Plan_Period_Type_Id = @Mine_Plan_Period_Type_Id
				And
				(
					(MPP.Material_Type_Id = @Material_Type_Id)
					Or (@Material_Type_Id Is Null And MPP.Material_Type_Id Is Null)
				)
				And
				(
					-- match the specific location record
					-- (note: there can be only one)
					@Location_Id =
						(
							Select Top 1 Location_Id
							From dbo.MinePlanPeriodLocation As MPPL2
							Where MPPL2.Mine_Plan_Id = AMPP.Mine_Plan_Id
								And MPPL2.Start_Date = AMPP.Start_Date
								And MPPL2.Sequence_No = AMPP.Sequence_No
						)
					Or
					(
						-- or if there is no location
						-- ensure there aren't any against this record
						@Location_Id Is Null
						And Not Exists
							(
								Select 1
								From dbo.MinePlanPeriodLocation As MPPL2
								Where MPPL2.Mine_Plan_Id = AMPP.Mine_Plan_Id
									And MPPL2.Start_Date = AMPP.Start_Date
									And MPPL2.Sequence_No = AMPP.Sequence_No
							)
					)
				)
			Order By Rank Desc, Start_Date Desc, Sequence_No Desc

		-- loop through all mine plan records of the current type

		Open @curMINE_PLAN_PERIOD
		Fetch Next From @curMINE_PLAN_PERIOD Into @Mine_Plan_Id, @Start_Date, @Sequence_No, @End_Date, @Rank
		While @@Fetch_Status = 0
		Begin
			-- perform the merge
			Delete From @FILL
			Delete From @GAP

			-- determine the effective start/end dates based on the absolute limits
			Select
				@Effective_Start_Date =
					Case
						When @Absolute_Start_Date < @Start_Date Then @Start_Date
						Else @Absolute_Start_Date
					End,
				@Effective_End_Date = 
					Case
						When @Absolute_End_Date > @End_Date Then @End_Date
						Else @Absolute_End_Date
					End

			-- find the set of existing (higher ranked) records that will be affected by the date range
			-- for each of the records that will be affected by the date range, split the new record to "fit" within these gaps
			Insert Into @FILL
			(
				Effective_Start_Date, Effective_End_Date
			)
			Select Distinct
				-- ensure the effective start is trimmed
				Case
					When Effective_Start_Date < @Effective_Start_Date Then @Effective_Start_Date
					Else Effective_Start_Date
				End As Effective_Start_Date,
				-- ensure the effective end is trimmed
				Case
					When Effective_End_Date > @Effective_End_Date Then @Effective_End_Date
					Else Effective_End_Date
				End As Effective_End_Date
			From @AMALGAMATE_MINE_PLAN_AMALGAMATED
			Where dbo.GetDatePeriodRatio(@Effective_Start_Date, @Effective_End_Date, Effective_Start_Date, Effective_End_Date) > 0.0
				And Mine_Plan_Period_Type_Id = @Mine_Plan_Period_Type_Id
				And
				(
					(Material_Type_Id = @Material_Type_Id)
					Or (@Material_Type_Id Is Null And Material_Type_Id Is Null)
				)
				And
				(
					(Location_Id = @Location_Id)
					Or (@Location_Id Is Null And Location_Id Is Null)
				)
				-- ensure only records which define an actual period are used
				And @Effective_End_Date >= @Effective_Start_Date

			-- find the GAPS between the existing records
			-- if there are FILL records - then we need to find the gaps
			-- if there are no records, then simply "plonk" the record in

			If Exists (Select 1 From @FILL)
			Begin			
				-- find the gaps between existing records
				Insert Into @GAP
				(
					Effective_Start_Date, Effective_End_Date
				)
				Select
					DateAdd(Day, 1, FS.Effective_End_Date) As New_Effective_Start_Date,
					Min(FE.Effective_Start_Date) As New_Effective_End_Date
				From @FILL As FS  -- fill start
					Cross Join @FILL As FE  -- fill end
				Where DateAdd(Day, 1, FE.Effective_Start_Date) > FS.Effective_End_Date
				Group By FS.Effective_End_Date

				-- add the gap from the start date thru to the first record's start, if appropriate
				If (Select Min(Effective_Start_Date) From @FILL) > @Effective_Start_Date
				Begin
					Insert Into @GAP
					(
						Effective_Start_Date, Effective_End_Date
					)
					Select @Effective_Start_Date, Min(Effective_Start_Date)
					From @FILL
				End

				-- add the gap from the last record's end thru to the end date
				If (Select Max(Effective_End_Date) From @FILL) < @Effective_End_Date
				Begin
					Insert Into @GAP
					(
						Effective_Start_Date, Effective_End_Date
					)
					Select @Effective_Start_Date, Max(Effective_End_Date)
					From @FILL
				End
			End
			Else
			Begin
				Insert Into @GAP
				(
					Effective_Start_Date, Effective_End_Date
				)
				Select @Effective_Start_Date, @Effective_End_Date
			End

			-- create the new records based on the gaps
			Insert Into @AMALGAMATE_MINE_PLAN_AMALGAMATED
			(
				Mine_Plan_Id, Start_Date, Sequence_No,
				Effective_Start_Date, Effective_End_Date,
				Ratio,
				Mine_Plan_Period_Type_Id,
				Material_Type_Id, Location_Id
			)
			Select @Mine_Plan_Id, @Start_Date, @Sequence_No,
				Effective_Start_Date, Effective_End_Date,
				dbo.GetDatePeriodRatio(@Start_Date, @End_Date, Effective_Start_Date, Effective_End_Date),
				@Mine_Plan_Period_Type_Id, @Material_Type_Id, @Location_Id
			From @GAP
				-- ensure only records which define an actual period are used
			Where @End_Date >= @Start_Date
				And dbo.GetDatePeriodRatio(@Start_Date, @End_Date, Effective_Start_Date, Effective_End_Date) > 0.0

			Fetch Next From @curMINE_PLAN_PERIOD Into @Mine_Plan_Id, @Start_Date, @Sequence_No, @End_Date, @Rank
		End
		Close @curMINE_PLAN_PERIOD

		Fetch Next From @curUNIQUE Into @Mine_Plan_Period_Type_Id, @Material_Type_Id, @Location_Id
	End

	-- load the final result table from the in-memory copy
	Insert Into dbo.#AMALGAMATE_MINE_PLAN_AMALGAMATED
	(
		Mine_Plan_Id, Start_Date, Sequence_No,
		Effective_Start_Date, Effective_End_Date, Ratio
	)
	Select Mine_Plan_Id, Start_Date, Sequence_No,
		Effective_Start_Date, Effective_End_Date, Ratio
	From @AMALGAMATE_MINE_PLAN_AMALGAMATED

	Commit Transaction
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="AmalgamateMinePlan">
 <Procedure>
 	amalgamates the various mine plans to use:
	1) you will need to populate dbo.#AMALGAMATE_MINE_PLAN_PERIOD
	    this table will contain links to all of the mine plan period records that require merging
	    to each individual record, you will need to describe its relative rank
	 2) the results will be deposited in dbo.#AMALGAMATE_MINE_PLAN_AMALGAMATED

	 current limitations
	 1) Location based data only caters for one-to-one relationships
	    ie each Mine Plan Period record can only have one Location record
	 2) Location based data does not take into account the hierarchies available
	    to accurately compare, we would need:
	    (1) a full grade control model to evaluate tonnages
	    (2) a full location model to evaluate membership
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteBlastBlockLocation.prc'
GO

If object_id('dbo.DeleteBlastBlockLocation') is not Null 
     Drop Procedure dbo.DeleteBlastBlockLocation 
Go 

CREATE Procedure dbo.DeleteBlastBlockLocation
(
	@iBlast_Block_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteBlastBlockLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the BlastBlockLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. blast_block_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iBlast_Block_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Blast_Block Location record with the Blast_Block_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Blast_Block Location record with the  Blast_Block_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Blast_Block Location record with the  Blast_Block_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Blast_Block Location record withs the given Blast_Block_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Blast_Block Location record with the Blast_Block_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Blast_Block Location record with the  Blast_Block_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Blast_Block Location record with the  Blast_Block_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Blast_Block Location record withs the given Blast_Block_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.BlastBlockLocation
		Where Blast_Block_Id = @iBlast_Block_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.BlastBlockLocation
		Where Blast_Block_Id = @iBlast_Block_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.BlastBlockLocation
		Where Blast_Block_Id = @iBlast_Block_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.BlastBlockLocation
		Where Blast_Block_Id = @iBlast_Block_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteBlastBlockLocation">
 <Procedure>
	Delete's the record in the BlastBlockLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateCrusherLocation.prc'
GO

If object_id('dbo.AddOrUpdateCrusherLocation') is not Null 
     Drop Procedure dbo.AddOrUpdateCrusherLocation 
Go 

Create Procedure dbo.AddOrUpdateCrusherLocation
(
	@iCrusher_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin

	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.AddOrUpdateCrusherLocation
	-- Author: Jennifer Claughton
	-- Comments: Adds or updates records to the CrusherLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Only update if the Location_Id is a not child of the current Location_Id for the Crusher
	-- Parameters:
	-- 1. crusher_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) null, null, null - throw error
	--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) REFACTORING SECTION
	-- 
	-- refactors the location hierarchy 
	--
	-- Use:
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @Location_Id = passed in or calculated Location_Id from the above checks
	--
	-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
	--     (store in: @LOCATION_TYPE_HIERARCHY)
	-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
	-- (c) within the crusher location table, find all records which are children of this location_id - and remove everything else
	--     -> Delete from CrusherLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
	-- (d) if there are children in the crusher location table (or this locid already exists) of this location_id - do nothing at all
	--     a. check for # records from CrusherLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
	--     b. if there are records, don't do anything !
	--        else insert the new location_id/location_type_id
	------------------------------------------------------------------------------------------------*/

	Declare @Message VarChar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	Declare @LOCATION_TYPE_HIERARCHY Table 
	(
		Location_Type_Id TINYINT Not Null,
		Primary Key (Location_Type_Id)
	)

	Declare @CHILD_LOCATION_HIERARCHY Table 
	(
		Location_Id Int Not Null,
		Primary Key (Location_Id)
	)

	------------------------------
	-- LOOKUP & VALIDATION SECTION 
	-- 
	-- (1) Get the valid Location_Id and Location_Type_Id from the inserted parameters.
	------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record.'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record.'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record.'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record.'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) null, null, null - throw error
						--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
						--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
						Set @Message = 'The minimum set parameters has not been met.'
						RaisError (@Message, 16, 1)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End

	
	----------------------
	-- REFACTORING SECTION
	-- 
	-- Refactors the location hierarchy based on the Location_Id and Location_Type_Id
	-- -------------------
	
	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin

		-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
		--     (store in: @LOCATION_TYPE_HIERARCHY)
		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeParentLocationTypeList(@Location_Type_Id)

		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeChildLocationTypeList(@Location_Type_Id)

		-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
		Insert Into @CHILD_LOCATION_HIERARCHY
		(
			Location_Id
		)
		Select Location_Id 
		From dbo.GetLocationChildLocationList(@Location_Id)

		-- (c) within the crusher location table, find all records which are children of this location_id 
		--     - and remove everything else
		--    Delete from CrusherLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
		Delete
		From dbo.CrusherLocation 
		Where Location_Id Not In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
			And	Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPE_HIERARCHY) 
			And Crusher_Id = @iCrusher_Id 
			And	Location_Id <> @Location_Id

		-- (d) if there are children in the crusher location table (or this Location_Id already exists) for this location_id 
		--		- do nothing at all
		--     a. check for the number of records from CrusherLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
		--     b. if there are records, don't do anything !
		--        else insert the new location_id/location_type_id
		If Not Exists
			(
				Select 1 
				From dbo.CrusherLocation 
				Where
					(
						Location_Id In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
						Or Location_Id = @Location_Id
					)
					And Crusher_Id = @iCrusher_Id
			)
		Begin
			-- Insert the relevant record
			Insert Into dbo.CrusherLocation
			(
				Crusher_Id, Location_Type_Id, Location_Id
			)
			Values
			(
				@iCrusher_Id, @Location_Type_Id, @Location_Id
			)
		End
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder
End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateCrusherLocation">
 <Procedure>
	Adds a new record or updates and existing record in the CrusherLocation table.
	Errors raised if:
		The minimum set parameters has not been met.
		The Location Name @iLocation_Name does not match the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteCrusherLocation.prc'
GO

If object_id('dbo.DeleteCrusherLocation') is not Null 
     Drop Procedure dbo.DeleteCrusherLocation 
Go 

CREATE Procedure dbo.DeleteCrusherLocation
(
	@iCrusher_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteCrusherLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the CrusherLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. crusher_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iCrusher_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Crusher Location record with the Crusher_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Crusher Location record with the  Crusher_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Crusher Location record with the  Crusher_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Crusher Location record withs the given Crusher_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Crusher Location record with the Crusher_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Crusher Location record with the  Crusher_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Crusher Location record with the  Crusher_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Crusher Location record withs the given Crusher_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.CrusherLocation
		Where Crusher_Id = @iCrusher_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.CrusherLocation
		Where Crusher_Id = @iCrusher_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.CrusherLocation
		Where Crusher_Id = @iCrusher_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.CrusherLocation
		Where Crusher_Id = @iCrusher_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteCrusherLocation">
 <Procedure>
	Delete's the record in the CrusherLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateModelBlockLocation.prc'
GO

If object_id('dbo.AddOrUpdateModelBlockLocation') is not Null 
     Drop Procedure dbo.AddOrUpdateModelBlockLocation 
Go 

Create Procedure dbo.AddOrUpdateModelBlockLocation
(
	@iModel_Block_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin

	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.AddOrUpdateModelBlockLocation
	-- Author: Jennifer Claughton
	-- Comments: Adds or updates records to the ModelBlockLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Only update if the Location_Id is a not child of the current Location_Id for the Model_Block
	-- Parameters:
	-- 1. model_block_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) null, null, null - throw error
	--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) REFACTORING SECTION
	-- 
	-- refactors the location hierarchy 
	--
	-- Use:
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @Location_Id = passed in or calculated Location_Id from the above checks
	--
	-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
	--     (store in: @LOCATION_TYPE_HIERARCHY)
	-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
	-- (c) within the model_block location table, find all records which are children of this location_id - and remove everything else
	--     -> Delete from ModelBlockLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
	-- (d) if there are children in the model_block location table (or this locid already exists) of this location_id - do nothing at all
	--     a. check for # records from ModelBlockLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
	--     b. if there are records, don't do anything !
	--        else insert the new location_id/location_type_id
	------------------------------------------------------------------------------------------------*/

	Declare @Message VarChar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	Declare @LOCATION_TYPE_HIERARCHY Table 
	(
		Location_Type_Id TINYINT Not Null,
		Primary Key (Location_Type_Id)
	)

	Declare @CHILD_LOCATION_HIERARCHY Table 
	(
		Location_Id Int Not Null,
		Primary Key (Location_Id)
	)

	------------------------------
	-- LOOKUP & VALIDATION SECTION 
	-- 
	-- (1) Get the valid Location_Id and Location_Type_Id from the inserted parameters.
	------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record.'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record.'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record.'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record.'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) null, null, null - throw error
						--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
						--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
						Set @Message = 'The minimum set parameters has not been met.'
						RaisError (@Message, 16, 1)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End

	
	----------------------
	-- REFACTORING SECTION
	-- 
	-- Refactors the location hierarchy based on the Location_Id and Location_Type_Id
	-- -------------------
	
	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin

		-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
		--     (store in: @LOCATION_TYPE_HIERARCHY)
		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeParentLocationTypeList(@Location_Type_Id)

		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeChildLocationTypeList(@Location_Type_Id)

		-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
		Insert Into @CHILD_LOCATION_HIERARCHY
		(
			Location_Id
		)
		Select Location_Id 
		From dbo.GetLocationChildLocationList(@Location_Id)

		-- (c) within the model_block location table, find all records which are children of this location_id 
		--     - and remove everything else
		--    Delete from ModelBlockLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
		Delete
		From dbo.ModelBlockLocation 
		Where Location_Id Not In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
			And	Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPE_HIERARCHY) 
			And Model_Block_Id = @iModel_Block_Id 
			And	Location_Id <> @Location_Id

		-- (d) if there are children in the model_block location table (or this Location_Id already exists) for this location_id 
		--		- do nothing at all
		--     a. check for the number of records from ModelBlockLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
		--     b. if there are records, don't do anything !
		--        else insert the new location_id/location_type_id
		If Not Exists
			(
				Select 1 
				From dbo.ModelBlockLocation 
				Where
					(
						Location_Id In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
						Or Location_Id = @Location_Id
					)
					And Model_Block_Id = @iModel_Block_Id
			)
		Begin
			-- Insert the relevant record
			Insert Into dbo.ModelBlockLocation
			(
				Model_Block_Id, Location_Type_Id, Location_Id
			)
			Values
			(
				@iModel_Block_Id, @Location_Type_Id, @Location_Id
			)
		End
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder
End
Go

GRANT EXECUTE ON dbo.AddOrUpdateModelBlockLocation TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateModelBlockLocation">
 <Procedure>
	Adds a new record or updates and existing record in the ModelBlockLocation table.
	Errors raised if:
		The minimum set parameters has not been met.
		The Location Name @iLocation_Name does not match the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteModelBlockLocation.prc'
GO

If object_id('dbo.DeleteModelBlockLocation') is not Null 
     Drop Procedure dbo.DeleteModelBlockLocation 
Go 

CREATE Procedure dbo.DeleteModelBlockLocation
(
	@iModel_Block_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteModelBlockLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the ModelBlockLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. model_block_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iModel_Block_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Model_Block Location record with the Model_Block_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Model_Block Location record with the  Model_Block_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Model_Block Location record with the  Model_Block_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Model_Block Location record withs the given Model_Block_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Model_Block Location record with the Model_Block_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Model_Block Location record with the  Model_Block_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Model_Block Location record with the  Model_Block_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Model_Block Location record withs the given Model_Block_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.ModelBlockLocation
		Where Model_Block_Id = @iModel_Block_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.ModelBlockLocation
		Where Model_Block_Id = @iModel_Block_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.ModelBlockLocation
		Where Model_Block_Id = @iModel_Block_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.ModelBlockLocation
		Where Model_Block_Id = @iModel_Block_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
GO

GRANT EXECUTE ON dbo.DeleteModelBlockLocation TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteModelBlockLocation">
 <Procedure>
	Delete's the record in the ModelBlockLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockLocation.prc'
GO

If object_id('dbo.DeleteDigblockLocation') is not Null 
     Drop Procedure dbo.DeleteDigblockLocation 
Go 

CREATE Procedure dbo.DeleteDigblockLocation
(
	@iDigblock_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteDigblockLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the DigblockLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. digblock_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iDigblock_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Digblock Location record with the Digblock_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Digblock Location record with the  Digblock_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Digblock Location record with the  Digblock_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Digblock Location record withs the given Digblock_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Digblock Location record with the Digblock_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Digblock Location record with the  Digblock_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Digblock Location record with the  Digblock_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Digblock Location record withs the given Digblock_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.DigblockLocation
		Where Digblock_Id = @iDigblock_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.DigblockLocation
		Where Digblock_Id = @iDigblock_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.DigblockLocation
		Where Digblock_Id = @iDigblock_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.DigblockLocation
		Where Digblock_Id = @iDigblock_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go

GRANT EXECUTE ON dbo.DeleteDigblockLocation TO CoreDigblockManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="DeleteDigblockLocation">
 <Procedure>
	Delete's the record in the DigblockLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateMillLocation.prc'
GO

If object_id('dbo.AddOrUpdateMillLocation') is not Null 
     Drop Procedure dbo.AddOrUpdateMillLocation 
Go 

Create Procedure dbo.AddOrUpdateMillLocation
(
	@iMill_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin

	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.AddOrUpdateMillLocation
	-- Author: Jennifer Claughton
	-- Comments: Adds or updates records to the MillLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Only update if the Location_Id is a not child of the current Location_Id for the Mill
	-- Parameters:
	-- 1. mill_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) null, null, null - throw error
	--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) REFACTORING SECTION
	-- 
	-- refactors the location hierarchy 
	--
	-- Use:
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @Location_Id = passed in or calculated Location_Id from the above checks
	--
	-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
	--     (store in: @LOCATION_TYPE_HIERARCHY)
	-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
	-- (c) within the mill location table, find all records which are children of this location_id - and remove everything else
	--     -> Delete from MillLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
	-- (d) if there are children in the mill location table (or this locid already exists) of this location_id - do nothing at all
	--     a. check for # records from MillLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
	--     b. if there are records, don't do anything !
	--        else insert the new location_id/location_type_id
	------------------------------------------------------------------------------------------------*/

	Declare @Message VarChar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	Declare @LOCATION_TYPE_HIERARCHY Table 
	(
		Location_Type_Id TINYINT Not Null,
		Primary Key (Location_Type_Id)
	)

	Declare @CHILD_LOCATION_HIERARCHY Table 
	(
		Location_Id Int Not Null,
		Primary Key (Location_Id)
	)

	------------------------------
	-- LOOKUP & VALIDATION SECTION 
	-- 
	-- (1) Get the valid Location_Id and Location_Type_Id from the inserted parameters.
	------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record.'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record.'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record.'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record.'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) null, null, null - throw error
						--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
						--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
						Set @Message = 'The minimum set parameters has not been met.'
						RaisError (@Message, 16, 1)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End

	
	----------------------
	-- REFACTORING SECTION
	-- 
	-- Refactors the location hierarchy based on the Location_Id and Location_Type_Id
	-- -------------------
	
	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin

		-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
		--     (store in: @LOCATION_TYPE_HIERARCHY)
		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeParentLocationTypeList(@Location_Type_Id)

		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeChildLocationTypeList(@Location_Type_Id)

		-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
		Insert Into @CHILD_LOCATION_HIERARCHY
		(
			Location_Id
		)
		Select Location_Id 
		From dbo.GetLocationChildLocationList(@Location_Id)

		-- (c) within the mill location table, find all records which are children of this location_id 
		--     - and remove everything else
		--    Delete from MillLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
		Delete
		From dbo.MillLocation 
		Where Location_Id Not In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
			And	Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPE_HIERARCHY) 
			And Mill_Id = @iMill_Id 
			And	Location_Id <> @Location_Id

		-- (d) if there are children in the mill location table (or this Location_Id already exists) for this location_id 
		--		- do nothing at all
		--     a. check for the number of records from MillLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
		--     b. if there are records, don't do anything !
		--        else insert the new location_id/location_type_id
		If Not Exists
			(
				Select 1 
				From dbo.MillLocation 
				Where
					(
						Location_Id In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
						Or Location_Id = @Location_Id
					)
					And Mill_Id = @iMill_Id
			)
		Begin
			-- Insert the relevant record
			Insert Into dbo.MillLocation
			(
				Mill_Id, Location_Type_Id, Location_Id
			)
			Values
			(
				@iMill_Id, @Location_Type_Id, @Location_Id
			)
		End
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder
End
Go
/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateMillLocation">
 <Procedure>
	Adds a new record or updates and existing record in the MillLocation table.
	Errors raised if:
		The minimum set parameters has not been met.
		The Location Name @iLocation_Name does not match the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMillLocation.prc'
GO

If object_id('dbo.DeleteMillLocation') is not Null 
     Drop Procedure dbo.DeleteMillLocation 
Go 

CREATE Procedure dbo.DeleteMillLocation
(
	@iMill_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteMillLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the MillLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. mill_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iMill_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Mill Location record with the Mill_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Mill Location record with the  Mill_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Mill Location record with the  Mill_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Mill Location record withs the given Mill_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Mill Location record with the Mill_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Mill Location record with the  Mill_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Mill Location record with the  Mill_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Mill Location record withs the given Mill_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.MillLocation
		Where Mill_Id = @iMill_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.MillLocation
		Where Mill_Id = @iMill_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.MillLocation
		Where Mill_Id = @iMill_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.MillLocation
		Where Mill_Id = @iMill_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteMillLocation">
 <Procedure>
	Delete's the record in the MillLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteStockpileLocation.prc'
GO

If object_id('dbo.DeleteStockpileLocation') is not Null 
     Drop Procedure dbo.DeleteStockpileLocation 
Go 

CREATE Procedure dbo.DeleteStockpileLocation
(
	@iStockpile_Id Int,
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteStockpileLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the StockpileLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. stockpile_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iStockpile_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Stockpile Location record with the Stockpile_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Stockpile Location record with the  Stockpile_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Stockpile Location record with the  Stockpile_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Stockpile Location record withs the given Stockpile_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Stockpile Location record with the Stockpile_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Stockpile Location record with the  Stockpile_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Stockpile Location record with the  Stockpile_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Stockpile Location record withs the given Stockpile_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.StockpileLocation
		Where Stockpile_Id = @iStockpile_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.StockpileLocation
		Where Stockpile_Id = @iStockpile_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.StockpileLocation
		Where Stockpile_Id = @iStockpile_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.StockpileLocation
		Where Stockpile_Id = @iStockpile_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteStockpileLocation">
 <Procedure>
	Delete's the record in the StockpileLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateWeightometerLocation.prc'
GO

If object_id('dbo.AddOrUpdateWeightometerLocation') is not Null 
     Drop Procedure dbo.AddOrUpdateWeightometerLocation 
Go 

Create Procedure dbo.AddOrUpdateWeightometerLocation
(
	@iWeightometer_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin

	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.AddOrUpdateWeightometerLocation
	-- Author: Jennifer Claughton
	-- Comments: Adds or updates records to the WeightometerLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Only update if the Location_Id is a not child of the current Location_Id for the Weightometer
	-- Parameters:
	-- 1. weightometer_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) null, null, null - throw error
	--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) REFACTORING SECTION
	-- 
	-- refactors the location hierarchy 
	--
	-- Use:
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @Location_Id = passed in or calculated Location_Id from the above checks
	--
	-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
	--     (store in: @LOCATION_TYPE_HIERARCHY)
	-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
	-- (c) within the weightometer location table, find all records which are children of this location_id - and remove everything else
	--     -> Delete from WeightometerLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
	-- (d) if there are children in the weightometer location table (or this locid already exists) of this location_id - do nothing at all
	--     a. check for # records from WeightometerLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
	--     b. if there are records, don't do anything !
	--        else insert the new location_id/location_type_id
	------------------------------------------------------------------------------------------------*/

	Declare @Message VarChar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	Declare @LOCATION_TYPE_HIERARCHY Table 
	(
		Location_Type_Id TINYINT Not Null,
		Primary Key (Location_Type_Id)
	)

	Declare @CHILD_LOCATION_HIERARCHY Table 
	(
		Location_Id Int Not Null,
		Primary Key (Location_Id)
	)

	------------------------------
	-- LOOKUP & VALIDATION SECTION 
	-- 
	-- (1) Get the valid Location_Id and Location_Type_Id from the inserted parameters.
	------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record.'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record.'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record.'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record.'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) null, null, null - throw error
						--     (g) location_type_id is not null, location_name is null, location_id is null - throw error
						--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
						Set @Message = 'The minimum set parameters has not been met.'
						RaisError (@Message, 16, 1)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End

	
	----------------------
	-- REFACTORING SECTION
	-- 
	-- Refactors the location hierarchy based on the Location_Id and Location_Type_Id
	-- -------------------
	
	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin

		-- (a) using the location_type_id (@Location_Type_Id), find the location-type-hierarchy that we're interested in
		--     (store in: @LOCATION_TYPE_HIERARCHY)
		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeParentLocationTypeList(@Location_Type_Id)

		Insert Into @LOCATION_TYPE_HIERARCHY
		(
			Location_Type_Id
		)
		Select Location_Type_Id 
		From GetLocationTypeChildLocationTypeList(@Location_Type_Id)

		-- (b) store all children of @Location_Id into @CHILD_LOCATION_HIERARCHY
		Insert Into @CHILD_LOCATION_HIERARCHY
		(
			Location_Id
		)
		Select Location_Id 
		From dbo.GetLocationChildLocationList(@Location_Id)

		-- (c) within the weightometer location table, find all records which are children of this location_id 
		--     - and remove everything else
		--    Delete from WeightometerLocation where not in @CHILD_LOCATION_HIERARCHY and in @LOCATION_TYPE_HIERARCHY
		Delete
		From dbo.WeightometerLocation 
		Where Location_Id Not In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
			And	Location_Type_Id In (Select Location_Type_Id From @LOCATION_TYPE_HIERARCHY) 
			And Weightometer_Id = @iWeightometer_Id 
			And	Location_Id <> @Location_Id

		-- (d) if there are children in the weightometer location table (or this Location_Id already exists) for this location_id 
		--		- do nothing at all
		--     a. check for the number of records from WeightometerLocation where in @CHILD_LOCATION_HIERARCHY or Location_Id exists
		--     b. if there are records, don't do anything !
		--        else insert the new location_id/location_type_id
		If Not Exists
			(
				Select 1 
				From dbo.WeightometerLocation 
				Where
					(
						Location_Id In (Select Location_Id From @CHILD_LOCATION_HIERARCHY) 
						Or Location_Id = @Location_Id
					)
					And Weightometer_Id = @iWeightometer_Id
			)
		Begin
			-- Insert the relevant record
			Insert Into dbo.WeightometerLocation
			(
				Weightometer_Id, Location_Type_Id, Location_Id
			)
			Values
			(
				@iWeightometer_Id, @Location_Type_Id, @Location_Id
			)
		End
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder
End
Go


/*
<TAG Name="Data Dictionary" ProcedureName="AddOrUpdateWeightometerLocation">
 <Procedure>
	Adds a new record or updates and existing record in the WeightometerLocation table.
	Errors raised if:
		The minimum set parameters has not been met.
		The Location Name @iLocation_Name does not match the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record.
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteWeightometerLocation.prc'
GO

If object_id('dbo.DeleteWeightometerLocation') is not Null 
     Drop Procedure dbo.DeleteWeightometerLocation 
Go 

CREATE Procedure dbo.DeleteWeightometerLocation
(
	@iWeightometer_Id VarChar(31),
	@iLocation_Type_Id TINYINT,
	@iLocation_Name VarChar(31) = Null,
	@iLocation_Id Int = Null
)

With Encryption 
As

Begin
	/*------------------------------------------------------------------------------------------------
	-- Name: dbo.DeleteWeightometerLocation
	-- Author: Jennifer Claughton
	-- Comments: Deletes records from the WeightometerLocation table.
	-- Running through 2 sections
	-- 1. Validation of the parameters
	-- 2. Delete:
	--
	-- Parameters:
	-- 1. weightometer_id - must always be passed in (key field, ok)
	-- 2. location_type_id - optional
	-- 3. location_name - optional
	-- 4. location_id - optional
	-- 
	-- (1) LOOKUP & VALIDATION SECTION
	-- Get the Location_Id and Location_Type_Id
	-- (1) Get the Location_Id and Location_Type_Id
	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--     (b) location_type_id is not null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--     (c) location_type_id is not null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_type_id
	--         - look up the location_name
	--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (d) location_type_id is not null, location_name is not null, location_id is null
	--         - look up the location_id from the location_name/location_type_id
	--         - throw error if the location_id isn't found
	--     (e) location_type_id is null, location_name is not null, location_id is not null
	--         - use the provided location_id
	--         - look up the location_name from the provided location_id
	--         - throw error if the looked up location_name doesn't match the provided location_name
	--     (f) location_type_id is not null, location_name is null, location_id is null
	--         - use the provided location_type_Id
	--         - throw an error if the location_type_id does not exist
	--     (g) null, null, null
	--         - do no checks
	--     (h) location_type_id is null, location_name is not null, location_id is null - throw error
	--
	-- (2) DELETING SECTION
	-- @Location_Type_Id = passed in or calculated Location_Type_Id from the above checks
	-- @iWeightometer_Id = passed in
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Weightometer Location record with the Weightometer_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Weightometer Location record with the  Weightometer_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Weightometer Location record with the  Weightometer_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Weightometer Location record withs the given Weightometer_Id
	------------------------------------------------------------------------------------------------*/

	Declare @Message Varchar(255)
	Declare @Location_Id Int
	Declare @Location_Type_Id TINYINT
	Declare @ELC_Proc_Is_Error Bit

	Set @ELC_Proc_Is_Error = 1
	Set NoCount On

	Set Transaction Isolation Level Serializable
	Begin Transaction

	----------------------------------
	-- (1) LOOKUP & VALIDATION SECTION
	--
	-- Get the Location_Id and Location_Type_Id
	----------------------------------

	-- if: (a) location_type_id is null, location_name is null, location_id is not null
	--         - use the location_id
	--         - look up the location_type_id
	If (@iLocation_Type_Id Is Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
	Begin
		Set @Location_Id = @iLocation_Id

		Select @Location_Type_Id = Location_Type_Id 
		From dbo.Location 
		Where Location_Id = @iLocation_Id
	End
	Else
	Begin
		--     (b) location_type_id is not null, location_name is null, location_id is not null
		--         - use the location_id
		--         - look up the location_type_id
		--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
		If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null And @iLocation_Id Is Not Null)
		Begin
			If Not Exists 
				(
					Select 1 
					From dbo.Location 
					Where Location_Id = @iLocation_Id 
						And Location_Type_Id = @iLocation_Type_Id
				)
			Begin
				Set @Message = 'The Location Type "' + @iLocation_Type_Id + '" does not match the Location record'
				RaisError (@Message, 16, 1)
			End
			Else
			Begin
				Set @Location_Id = @iLocation_Id
				Set @Location_Type_Id = @iLocation_Type_Id 
			End
		End
		Else
		Begin
			--     (c) location_type_id is not null, location_name is not null, location_id is not null
			--         - use the provided location_id
			--         - look up the location_type_id
			--         - look up the location_name
			--         - throw error if the looked up location_type_id doesn't match the provided location_type_id
			--         - throw error if the looked up location_name doesn't match the provided location_name
			If	(@iLocation_Type_Id Is Not Null and @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
			Begin
				If Not Exists 
					(
						Select 1 
						From dbo.Location 
						Where Location_Id = @iLocation_Id 
							And Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					)
				Begin
					Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match the Location record'
					RaisError (@Message, 16, 1)
				End
				Else
				Begin
					Set @Location_Id = @iLocation_Id
					Set @Location_Type_Id = @iLocation_Type_Id 
				End
			End
			Else
			Begin
				--     (d) location_type_id is not null, location_name is not null, location_id is null
				--         - look up the location_id from the location_name/location_type_id
				--         - throw error if the location_id isn't found
				If	(@iLocation_Type_Id Is Not Null And @iLocation_Name Is Not Null And @iLocation_Id Is Null)
				Begin
					If Not Exists 
						(
							Select 1 
							From dbo.Location 
							Where Location_Type_Id = @iLocation_Type_Id
								And Name = @iLocation_Name
						)
					Begin
						Set @Message = 'The Location Type "' +@iLocation_Type_Id + '" or the Location Name "' + @iLocation_Name + '" does not match a the Location record'
						RaisError (@Message, 16, 1)
					End
					Else
					Begin
						Select @Location_Id = Location_Id,
							@Location_Type_Id = Location_Type_Id
						From dbo.Location
						Where Location_Type_Id = @iLocation_Type_Id
							And Name = @iLocation_Name
					End
				End
				Else
				Begin
					--     (e) location_type_id is null, location_name is not null, location_id is not null
					--         - use the provided location_id
					--         - look up the location_name from the provided location_id
					--         - throw error if the looked up location_name doesn't match the provided location_name
					If	(@iLocation_Type_Id Is Null And @iLocation_Name Is Not Null and @iLocation_Id Is Not Null)
					Begin
						If Not Exists
							(
								Select 1
								From dbo.Location
								Where Location_Id = @iLocation_Id
									And Name = @iLocation_Name
							)
						Begin
							Set @Message = 'The Location Name "' + @iLocation_Name + '" does not match the Location record'
							RaisError (@Message, 16, 1)
						End
						Else
						Begin
							Select @Location_Id = Location_Id,
								@Location_Type_Id = Location_Type_Id
							From dbo.Location
							Where Location_Id = @iLocation_Id 
								And	Name = @iLocation_Name
						End
					End
					Else
					Begin
						--     (f) location_type_id is not null, location_name is null, location_id is null
						--         - use the provided location_type_Id
						--         - throw an error if the location_type_id does not exist
						If (@iLocation_Type_Id Is Not Null And @iLocation_Name Is Null and @iLocation_Id Is Null)
						Begin
							If Not Exists
								(
									Select 1
									From dbo.LocationType
									Where Location_Type_Id = @iLocation_Type_Id
								)
							Begin
								Set @Message = 'The Location Type ID "' + @iLocation_Type_Id + '" does not exist'
								RaisError (@Message, 16, 1)
							End
							Else
							Begin
								Set @Location_Type_Id = @iLocation_Type_Id
							End
						End
						Else
						Begin
								--     (h) location_type_id is null, location_name is not null, location_id is null 
								--         - throw error
							If (@iLocation_Type_Id Is Null And @iLocation_Name Is not Null and @iLocation_Id Is Null)
							Begin
								Set @Message = 'The minimum parameters is not met'
								RaisError (@Message, 16, 1)
							End
						--(f)
						End
					--(e)
					End
				--(d)
				End
			--(c)			
			End
		--(b)
		End
	--(a)
	End


	-----------------------
	-- (2) DELETING SECTION
	--
	-- a) If both Location_Type_Id and Location_Id is not null 
	--		- delete the Weightometer Location record with the Weightometer_Id, Location_Type_Id and Location_Id 
	-- b) If location_Type_Id is not null and Location_Id is null
	--		- delete the Weightometer Location record with the  Weightometer_Id and Location_Type_Id
	-- c) If location_Type_Id is null and Location_Id is not null
	--		- delete the Weightometer Location record with the  Weightometer_Id and Location_Id
	-- a) If both Location_Type_Id and Location_Id is null 
	--		- delete all the Weightometer Location record withs the given Weightometer_Id

	If (@Location_Id Is Not Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.WeightometerLocation
		Where Weightometer_Id = @iWeightometer_Id
			And Location_Id = @Location_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Not Null)
	Begin
		Delete 
		From dbo.WeightometerLocation
		Where Weightometer_Id = @iWeightometer_Id
			And Location_Type_Id = @Location_Type_Id
	End

	If (@Location_Id Is Not Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.WeightometerLocation
		Where Weightometer_Id = @iWeightometer_Id
			And Location_Id = @Location_Id
	End

	If (@Location_Id Is Null and @Location_Type_Id Is Null)
	Begin
		Delete 
		From dbo.WeightometerLocation
		Where Weightometer_Id = @iWeightometer_Id
	End

	Commit Transaction
	
	-- Event_Logging_Placeholder

End
Go


/*
<TAG Name="Data Dictionary" ProcedureName="DeleteWeightometerLocation">
 <Procedure>
	Delete's the record in the WeightometerLocation table.
	Errors raised if:
		The minimum parameters is not met.
		The Location Type ID @iLocation_Type_Id does not exist
		The Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match a the Location record
		The Location Type @iLocation_Type_Id or the Location Name @iLocation_Name does not match the Location record
		The Location Type @iLocation_Type_Id does not match the Location record
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteLocationType.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.DeleteLocationType'))
	Drop Procedure dbo.DeleteLocationType
Go

CREATE Procedure dbo.DeleteLocationType
(
	@iLocation_Type_Id TINYINT = Null
)

With Encryption 
As

Begin

	Declare @Message Varchar(255)

	Declare @ELC_Proc_Is_Error Bit
	Set @ELC_Proc_Is_Error = 1

	Set Nocount On

	-- If the given location type exists
	If Not Exists (Select 1 From LocationType Where Location_Type_Id = @iLocation_Type_Id)
	Begin
		Raiserror ('The given location type does not exist', 16, 1)
	End
	Else
	Begin

		-- If the location type exists as a parent location type ID
		If Exists (Select 1 From LocationType Where Parent_Location_Type_Id = @iLocation_Type_Id)
		Begin
			Set @Message = 'There are other location type records which depend on this ' + @iLocation_Type_Id
			Raiserror (@Message, 16, 1)
		End
		Else
		Begin

			-- If the location type exists in Location then do not delete
			If Exists (Select 1 From Location Where Location_Type_Id = @iLocation_Type_Id)
			Begin
				Set @Message = 'There are other location records which depend on this ' + @iLocation_Type_Id
				Raiserror (@Message, 16, 1)
			End
			Else
			Begin
				-- Delete the location type record
				Delete From LocationType
				Where Location_Type_Id = @iLocation_Type_Id

				Set @ELC_Proc_Is_Error = 0
			End
		End
	End

	-- Event_Logging_Placeholder
End
GO
GRANT EXECUTE ON dbo.DeleteLocationType TO CoreUtilityManager

 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteLocationType">
 <Procedure>
	Deletes a record from the LocationType table.
	Errors are raised if:
		There are other location records which depend on this @iLocation_Type_Id
		There are other location type records which depend on this @iLocation_Type_Id
		The given location type does not exist
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetReconcilorYearList.prc'
GO

IF OBJECT_ID('dbo.GetReconcilorYearList') IS NOT NULL 
     DROP PROCEDURE dbo.GetReconcilorYearList 
GO 
  
CREATE PROCEDURE dbo.GetReconcilorYearList 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    SELECT Year(Haulage_Date) As Year,
		Convert(DateTime, '01-01-' + Convert(varchar, Year(Haulage_Date))) As YearDate
	FROM dbo.HAULAGE
	GROUP BY Year(Haulage_Date)
	ORDER BY Year(Haulage_Date) Desc
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetReconcilorYearList TO CoreUtilityManager


/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetReconcilorYearList">
 <Procedure>
	Returns a list of years that have data inside of reconcilor
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveyActualForDigblock.PRC'
GO

IF OBJECT_ID('dbo.GetDigblockSurveyActualForDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockSurveyActualForDigblock 
GO 
  
CREATE PROCEDURE dbo.GetDigblockSurveyActualForDigblock
( 
    @iDigblock_Survey_Id INT,
	@iDigblock_Id VARCHAR(31) 
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    SELECT Digblock_Survey_Id, Digblock_Survey_Summary_Id,
		Digblock_Id, Tonnes, Description
	FROM dbo.DigblockSurveyActual AS A
	WHERE A.Digblock_Survey_Id = @iDigblock_Survey_Id
		AND A.Assigned_Digblock_Id = @iDigblock_Id
  
    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockSurveyActualForDigblock TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveyActualForDigblock">
 <Procedure>
	Returns the list of haulage assignments made for that digblock over
	a digblock survey period.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockSurveySummary.prc'
GO

IF OBJECT_ID('dbo.AddDigblockSurveySummary') IS NOT NULL 
     DROP PROCEDURE dbo.AddDigblockSurveySummary
GO 
  
CREATE PROCEDURE dbo.AddDigblockSurveySummary
( 
	@iDigblock_Survey_Id INT,
	@iDigblock_Id VARCHAR(31),
	@oDigblock_Survey_Summary_Id INT = NULL OUTPUT,
	@iHaulage_Tonnes FLOAT,
	@iSurvey_Tonnes FLOAT,
	@iDigblock_Approved_Removed_Tonnes FLOAT, 
	@iDigblock_Unapproved_Removed_Tonnes FLOAT
) 
WITH ENCRYPTION AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
	
	DECLARE @MaxRecordNo INT  

    BEGIN TRY
		--if a record for this digblock in this survey date and shift does not exist
		IF EXISTS 
			(
				SELECT * 
				FROM dbo.DigblockSurveySummary AS DS
				WHERE Digblock_Survey_Id = @iDigblock_Survey_Id
					AND Digblock_Id = @iDigblock_Id
			)
		BEGIN
			Raiserror ('A record already exists for this digblock in this period', 16, 1)
		END

		SELECT @MaxRecordNo = Max(Record_No)
		FROM dbo.DigblockSurveySummary AS DSS
		WHERE Digblock_Survey_Id = @iDigblock_Survey_Id

		--Insert the new blank record into the digblock survey summary table
		INSERT INTO dbo.DigblockSurveySummary
		(
			Digblock_Survey_Id, Digblock_Id, Digblock_Start_Tonnes, Record_No,
			Haulage_Tonnes, Survey_Tonnes,
			Digblock_Approved_Removed_Tonnes, Digblock_Unapproved_Removed_Tonnes	
		)
		SELECT @iDigblock_Survey_Id, D.Digblock_Id, D.Start_Tonnes, IsNull(@MaxRecordNo, 1),
			@iHaulage_Tonnes, @iSurvey_Tonnes,
			@iDigblock_Approved_Removed_Tonnes, @iDigblock_Unapproved_Removed_Tonnes
		FROM dbo.Digblock AS D
		WHERE D.Digblock_Id = @iDigblock_Id

		SET @oDigblock_Survey_Summary_Id = Scope_Identity()
		
		COMMIT TRANSACTION 
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	
END 
GO 

/*
<TAG Name="Data Dictionary" ProcedureName="AddDigblockSurveySummary">
 <Procedure>
	Adds a record into the DigblockSurveySummary table.
	If Digblock_Survey_Type is not specified and there is only 1 Digblock_Survey_Type in the DigblockSurveyType
	Errors are raised if:
		A record already exists for this digblock in this period
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateModelBlock.prc'
GO

If Exists (Select * From sysobjects Where ID = Object_Id('dbo.UpdateModelBlock'))
	Drop Procedure dbo.UpdateModelBlock
Go

Create Procedure dbo.UpdateModelBlock
(
	@iModel_Block_Id Int,
	@iBlock_Model_Id Int,
	@iCode VarChar(31),
	@iX Float,
	@iY Float,
	@iZ Float,
	@iX_Inc Real,
	@iY_Inc Real,
	@iZ_Inc Real,
	@iUpdate_Block_Model_Id Bit = 0,
	@iUpdate_Code Bit = 0,
	@iUpdate_X Bit = 0,
	@iUpdate_Y Bit = 0,
	@iUpdate_Z Bit = 0,
	@iUpdate_X_Inc Bit = 0,
	@iUpdate_Y_Inc Bit = 0,
	@iUpdate_Z_Inc Bit = 0
)

With Encryption 
As

Begin 

	If @iUpdate_Block_Model_Id = 1 And Not Exists (Select Top 1 1 From dbo.BlockModel Where Block_Model_Id = @iBlock_Model_Id)
	Begin
		RaisError('An invalid block model id was supplied',16,1)
	End

	Update dbo.ModelBlock
	Set Block_Model_Id = Case When @iUpdate_Block_Model_Id = 1 Then @iBlock_Model_Id Else Block_Model_Id End,
		Code = Case When @iUpdate_Code = 1 Then @iCode Else Code End,
		X = Case When @iUpdate_X = 1 Then @iX Else X End,
		Y = Case When @iUpdate_Y = 1 Then @iY Else Y End,
		Z = Case When @iUpdate_Z = 1 Then @iZ Else Z End,
		X_Inc = Case When @iUpdate_X_Inc = 1 Then @iX_Inc Else X_Inc End,
		Y_Inc = Case When @iUpdate_Y_Inc = 1 Then @iY_Inc Else Y_Inc End,
		Z_Inc = Case When @iUpdate_Z_Inc = 1 Then @iZ_Inc Else Z_Inc End
	Where Model_Block_Id = @iModel_Block_Id

End

GO

GRANT EXECUTE ON dbo.UpdateModelBlock TO CoreBlockModelManager


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMaterialTypeLocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
-- Mark Holst 10-Jul-2008

IF OBJECT_ID('dbo.AddMaterialTypeLocation') IS NOT NULL
     DROP PROCEDURE dbo.AddMaterialTypeLocation  
GO 
  
CREATE PROCEDURE dbo.AddMaterialTypeLocation 
(
	@iMaterialTypeId INT,
	@iLocationId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddMaterialTypeLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF @iMaterialTypeId IS NULL OR @iLocationId IS NULL
		BEGIN
			RaisError ('The location id and material type id can not be null',16,1)
		END
	
		IF EXISTS
		(
			SELECT TOP 1 1 
			FROM dbo.MaterialTypeLocation
			WHERE Material_Type_Id = @iMaterialTypeId
			AND @iLocationId = Location_Id
		)
		BEGIN
			RaisError ('The material type is already associated with this location',16,1)
		END

		INSERT INTO dbo.MaterialTypeLocation
		(
			Material_Type_Id, Location_Id
		)
		SELECT @iMaterialTypeId, @iLocationId
		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
Go 
GRANT EXECUTE ON dbo.AddMaterialTypeLocation TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddMaterialTypeLocation">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMaterialTypeLocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
-- Mark Holst 10-Jul-2008

IF OBJECT_ID('dbo.DeleteMaterialTypeLocation') IS NOT NULL
     DROP PROCEDURE dbo.DeleteMaterialTypeLocation  
GO 
  
CREATE PROCEDURE dbo.DeleteMaterialTypeLocation 
(
	@iMaterialTypeId INT,
	@iLocationId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteMaterialTypeLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
		(
			SELECT TOP 1 1 
			FROM dbo.MaterialTypeLocation
			WHERE Material_Type_Id = @iMaterialTypeId
			AND @iLocationId = Location_Id
		)
		BEGIN
			RaisError ('The material type/location combination does not exist',16,1)
		END

		DELETE FROM dbo.MaterialTypeLocation
		WHERE Material_Type_Id = @iMaterialTypeId
			AND @iLocationId = Location_Id
		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteMaterialTypeLocation TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteMaterialTypeLocation">
 <Procedure>
	Deletes the material type location if it exists.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialTypeNotes.prc'
GO

IF OBJECT_ID('dbo.GetMaterialTypeNotes') IS NOT NULL 
     DROP PROCEDURE dbo.GetMaterialTypeNotes
GO 
  
CREATE PROCEDURE dbo.GetMaterialTypeNotes
( 
    @iMaterialTypeId INT,
    @iMaterialTypeFieldId VARCHAR(31)
) 
AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
    
    SELECT Notes
    FROM dbo.MaterialTypeNotes
	WHERE Material_Type_Id = @iMaterialTypeId
		AND Material_Type_Field_Id = @iMaterialTypeFieldId
    
    COMMIT TRANSACTION
END
GO

GRANT EXECUTE ON dbo.GetMaterialTypeNotes TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialTypeNotes">
 <Procedure>
	Return the notes value for the specified material type and field value
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddMaterialCategory.prc'
GO

IF OBJECT_ID('dbo.AddMaterialCategory') IS NOT NULL
     DROP PROCEDURE dbo.AddMaterialCategory  
GO 
  
CREATE PROCEDURE dbo.AddMaterialCategory
(
    @iMaterialCategoryId Varchar(31),
	@iParentMaterialCategoryId Varchar(31) = Null,
	@iDescription Varchar(255) = Null
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddMaterialCategory',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		If Exists 
			(
				Select 1
				From dbo.MaterialCategory 
				Where MaterialCategoryId = @iMaterialCategoryId
			)
		Begin
			RaisError('A Material type with the same name already exists', 16, 1)
		End

		--Check that the parent does not already have a child
		If Exists
			(
				Select 1 
				From dbo.MaterialCategory	
				Where ParentMaterialCategoryId = @iParentMaterialCategoryId
					And MaterialCategoryId <> @iMaterialCategoryId
			)
		Begin
			RaisError('The parent Material category already has a child Material category. Multiple children is currently not suppported.', 16, 1)
		End

		-- Insert the new record
		Insert Into dbo.MaterialCategory
		(
			MaterialCategoryId, ParentMaterialCategoryId, Description
		)
		Select @iMaterialCategoryId, @iParentMaterialCategoryId, @iDescription

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddMaterialCategory TO CoreUtilityManager
GO


/*
<TAG Name="Data Dictionary" ProcedureName="AddMaterialCategory">
 <Procedure>
	Adds a record to the MaterialCategory table.
	Errors raised if:
		An existing Material type has the same parent Material type
		A Material type with the same name already exists
		Parent Material type already has a child
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteMaterialCategory.prc'
GO

IF OBJECT_ID('dbo.DeleteMaterialCategory') IS NOT NULL
     DROP PROCEDURE dbo.DeleteMaterialCategory  
GO 
  
CREATE PROCEDURE dbo.DeleteMaterialCategory 
(
	@iMaterialCategoryId VARCHAR(31)
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Message Varchar(255)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteMaterialCategory',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- If the given Material type exists
		If Not Exists (Select 1 From MaterialCategory Where MaterialCategoryId = @iMaterialCategoryId)
		Begin
			Raiserror ('The given material category does not exist', 16, 1)
		End

		-- If the Material type exists as a parent Material type ID
		If Exists (Select 1 From MaterialCategory Where ParentMaterialCategoryId = @iMaterialCategoryId)
		Begin
			Set @Message = 'There are other material categories records which depend on ' + @iMaterialCategoryId
			Raiserror (@Message, 16, 1)
		End

		-- If the Material type exists in Material then do not delete
		If Exists (Select 1 From dbo.MaterialType Where Material_Category_Id = @iMaterialCategoryId)
		Begin
			Set @Message = 'There are material type records which depend on the category ' + @iMaterialCategoryId
			Raiserror (@Message, 16, 1)
		End
		
		-- Delete the Material type record
		Delete From MaterialCategory
		Where MaterialCategoryId = @iMaterialCategoryId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.DeleteMaterialCategory TO CoreUtilityManager
GO
 /*
<TAG Name="Data Dictionary" ProcedureName="DeleteMaterialCategory">
 <Procedure>
	Deletes a record from the MaterialCategory table.
	Errors are raised if:
		There are other Material records which depend on this @iMaterialCategoryId
		There are other Material type records which depend on this @iMaterialCategoryId
		The given Material type does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialCategory.prc'
GO

IF OBJECT_ID('dbo.GetMaterialCategory') IS NOT NULL
     DROP PROCEDURE dbo.GetMaterialCategory  
GO 
  
CREATE PROCEDURE dbo.GetMaterialCategory
(
	@iMaterialCategoryId Varchar(31)
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetMaterialCategory',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		Select MaterialCategoryId As Material_Category_Id,
			ParentMaterialCategoryId AS Parent_Material_Category_Id,
			Description
		From MaterialCategory
		Where MaterialCategoryId = @iMaterialCategoryId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetMaterialCategory TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialCategory">
 <Procedure>
	Returns the material category @iMaterialCategoryId from the MaterialCategory table.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialCategoryList.prc'
GO

IF OBJECT_ID('dbo.GetMaterialCategoryList') IS NOT NULL
     DROP PROCEDURE dbo.GetMaterialCategoryList  
GO 
  
CREATE PROCEDURE dbo.GetMaterialCategoryList
(
	@iParentMaterialCategoryId Varchar(31) = Null 
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetMaterialCategoryList',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- Get the list of Material categorys in the system
		Select MC.MaterialCategoryId As Material_Category_Id, 
		MC.Description, 
		MC.ParentMaterialCategoryId As Parent_Material_Category_Id,
			PMC.Description As Parent_Material_Description
		From MaterialCategory As MC
			Left Outer Join MaterialCategory As PMC
				On MC.ParentMaterialCategoryId = PMC.MaterialCategoryId
		Where (@iParentMaterialCategoryId = '0' 
				And MC.ParentMaterialCategoryId Is Null)
			Or (MC.ParentMaterialCategoryId = @iParentMaterialCategoryId)
			Or (@iParentMaterialCategoryId Is Null)  

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetMaterialCategoryList TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialCategoryList">
 <Procedure>
	Returns a list of Material categories in the system. If a Parent Material
	Category ID is passed in with a value of 0 then only parent level Material categories
	are passed through.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateMaterialCategory.prc'
GO

IF OBJECT_ID('dbo.UpdateMaterialCategory') IS NOT NULL
     DROP PROCEDURE dbo.UpdateMaterialCategory  
GO 
  
CREATE PROCEDURE dbo.UpdateMaterialCategory
( 
    @iMaterialCategoryId varchar(31),
	@iParentMaterialCategoryId varchar(31) = NULL,
	@iDescription varchar(255)
)  
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateMaterialCategory',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		If Not Exists 
			(
				Select 1 
				From dbo.MaterialCategory 
				Where MaterialCategoryId = @iMaterialCategoryId
			)
		Begin
			Raiserror ('The given material category does not exist', 16, 1)
		End

		--If the parent is set to itself
		If @iParentMaterialCategoryId = @iMaterialCategoryId
		Begin
			Raiserror ('The parent material category can not reference itself', 16, 1)
		End 

		-- If the given parent material category does not exist
		If Not Exists 
			(
				Select 1 
				From dbo.MaterialCategory 
				Where MaterialCategoryId = @iParentMaterialCategoryId
					Or @iParentMaterialCategoryId is NULL
			)
		Begin
			Raiserror ('The given parent material category does not exist', 16, 1)
		End

		--If they are trying to do a circular reference then raise error
		If Exists
			(
				Select 1 
				From dbo.GetMaterialCategoryChildMaterialCategoryList(@iMaterialCategoryId)
				Where MaterialCategoryId = @iParentMaterialCategoryId
			)
		Begin
			Raiserror ('The parent category specified is a child of one of the children for this category.', 16, 1)
		End

		--Check that the parent does not already have a child
		If Exists
			(
				Select 1 
				From dbo.MaterialCategory	
				Where ParentMaterialCategoryId = @iParentMaterialCategoryId
					And MaterialCategoryId <> @iMaterialCategoryId
			)
		Begin
			RaisError('The parent material already has a child material category. Multiple children is currently not supported.', 16, 1)
		End

		--Update material_Type
		Update dbo.MaterialCategory
		Set	ParentMaterialCategoryId = @iParentMaterialCategoryId,
			Description = @iDescription
		Where MaterialCategoryId = @iMaterialCategoryId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.UpdateMaterialCategory TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="UpdateMaterialCategory">
 <Procedure>
	Update the details of Material category @iMaterialCategoryId.
	Errors are raised if:
		The given parent material category does not exist
		The given material category does not exist
		The parent material category id is equal to its own material category id
		Parent material category already has a child
 </Procedure>
</TAG>
*/ 


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.getdigblocksurveysummarytonnesfordigblock.prc'
GO

IF OBJECT_ID('dbo.GetDigblockSurveySummaryTonnesForDigblock') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockSurveySummaryTonnesForDigblock 
GO 
  
CREATE PROCEDURE dbo.GetDigblockSurveySummaryTonnesForDigblock
( 
    @iDigblock_Id VARCHAR(31)
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 

    BEGIN TRY
		SELECT SPD.Digblock_Survey_Id, SPD.Start_Date, SPD.Start_Shift,
			SPD.Digblock_Survey_Date AS End_Date, SPD.Digblock_Survey_Shift AS End_Shift,
			Sum(DPT.Tonnes) AS Tonnes, Sum(DSA.Tonnes) AS Assigned_Tonnes
		FROM dbo.DigblockSurveySummary AS DSS
			INNER JOIN dbo.DigblockSurveyActual AS DSA
				ON (DSA.Digblock_Survey_Id = DSS.Digblock_Survey_Id
					AND DSS.Digblock_Id = DSA.Assigned_Digblock_Id)
			INNER JOIN dbo.GetDigblockSurveyPeriodDetails() AS SPD
				ON (DSS.Digblock_Survey_Id = SPD.Digblock_Survey_Id)
			INNER JOIN dbo.ShiftType AS SST
				ON (SST.Shift = SPD.Start_Shift)
			INNER JOIN dbo.ShiftType AS EST
				ON (EST.Shift = SPD.Digblock_Survey_Shift)
			LEFT OUTER JOIN dbo.DataProcessTransaction AS DPT
				INNER JOIN dbo.ShiftType AS TST
					ON (TST.Shift = DPT.Data_Process_Transaction_Shift)
				ON (DPT.Source_Digblock_Id = @iDigblock_Id
					AND dbo.GetDateShiftAsInt(DPT.Data_Process_Transaction_Date, TST.Order_No)
						>= dbo.GetDateShiftAsInt(SPD.Start_Date, SST.Order_No)
					AND dbo.GetDateShiftAsInt(DPT.Data_Process_Transaction_Date, TST.Order_No)
						<= dbo.GetDateShiftAsInt(SPD.Digblock_Survey_Date, EST.Order_No))
		WHERE DSS.Digblock_Id = @iDigblock_Id
		GROUP BY SPD.Digblock_Survey_Id, SPD.Start_Date, SPD.Start_Shift,
			SPD.Digblock_Survey_Date, SPD.Digblock_Survey_Shift
	
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		IF @@Trancount > 0 
		BEGIN
			ROLLBACK TRANSACTION
		END

		--Rethrow the exception
		DECLARE @ErrorMessage NVARCHAR(4000),
			@ErrorSeverity INT,
			@ErrorState INT

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	END CATCH	
END 
GO 
GRANT EXECUTE ON dbo.GetDigblockSurveySummaryTonnesForDigblock TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummaryTonnesForDigblock">
 <Procedure>
	Returns the recalculated tonnes and assigned tonnes for a digblock 
	within the depletion date ranges it falls under.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.getrecalcwaittime.prc'
GO

IF OBJECT_ID('dbo.GetRecalcWaitTime') IS NOT NULL 
     DROP PROCEDURE dbo.GetRecalcWaitTime
GO

CREATE PROCEDURE dbo.GetRecalcWaitTime
( 
    @iRecalcTypeId VarChar(31),
	@oWaitSeconds Int Output
)
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON

	DECLARE @RecalcStateSuccessful INT
	DECLARE @RecentFailureCount INT
	DECLARE @LastFailure DATETIME
	DECLARE @AssumedRestartSeconds INT
	DECLARE @FailureCountThreshold1 INT
	DECLARE @FailureCountThreshold2 INT
	DECLARE @Threshold1WaitSeconds INT
	DECLARE @Threshold2WaitSeconds INT

	SET @RecalcStateSuccessful = 4

	-- Setup the times and counts, and put asserts in to ensure rules are met.
	-- These could be passed in if need be, or stored in a settings table in the database.
	SET @AssumedRestartSeconds = 600	-- 10 minutes
	SET @FailureCountThreshold1 = 10
	SET @FailureCountThreshold2 = 100
	SET @Threshold1WaitSeconds = 30
	SET @Threshold2WaitSeconds = 300	-- 5 minutes

	IF (@FailureCountThreshold1 >= @FailureCountThreshold2)
	BEGIN
		RAISERROR ('The @FailureCountThreshold1 value must be less than the @FailureCountThreshold2 value',
			16,
			1)
	END

	IF (@Threshold1WaitSeconds >= @Threshold2WaitSeconds)
	BEGIN
		RAISERROR ('The @Threshold1WaitSeconds value must be less than the @Threshold2WaitSeconds value',
			16,
			1)
	END

	IF (@Threshold2WaitSeconds >= @AssumedRestartSeconds)
	BEGIN
		RAISERROR ('The @Threshold2WaitSeconds value must be less than the @AssumedRestartSeconds value',
			16,
			1)
	END

  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
    BEGIN TRANSACTION

	-- Get the number of recalc instances which have not completed successfully since the last
	--  successful recalc of this type, and since the last time the recalc 
	SELECT @RecentFailureCount = COUNT(rhf.Recalc_History_Id),
		@LastFailure = MAX(COALESCE(rhf.End_Datetime, rhf.Start_Datetime))
	FROM
		(
			SELECT TOP 1000 *
			FROM RecalcHistory AS rh
			WHERE rh.Recalc_Type_Id = @iRecalcTypeId
				AND rh.Recalc_State_Id <> @RecalcStateSuccessful
			ORDER BY rh.Recalc_History_ID DESC
		) AS rhf
	WHERE rhf.Recalc_History_Id > COALESCE(
		(
			SELECT TOP 1 RH2.Recalc_History_Id
			FROM RecalcHistory AS rh2
			WHERE rh2.Recalc_Type_Id = @iRecalcTypeId
				AND rh2.Recalc_State_Id = @RecalcStateSuccessful
			ORDER BY RH2.Recalc_History_Id DESC
		), 0)


	-- If the number of failures since the last success is less than a set amount,
	--  or the last failure occured a significant time ago
	IF ((@RecentFailureCount < @FailureCountThreshold1)
	OR (@RecentFailureCount IS NULL)
	OR (DATEDIFF(S, @LastFailure, GETDATE()) > @AssumedRestartSeconds))
	BEGIN
		-- Don't wait at all
		SET @oWaitSeconds = 0
	END
	ELSE IF (@RecentFailureCount BETWEEN @FailureCountThreshold1 AND @FailureCountThreshold2)
	BEGIN
		SET @oWaitSeconds = @Threshold1WaitSeconds
	END
  	ELSE
	BEGIN
		SET @oWaitSeconds = @Threshold2WaitSeconds
	END

    COMMIT TRANSACTION
END 
GO 

GRANT EXECUTE ON dbo.GetRecalcWaitTime TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcWaitTime">
 <Procedure>
	Calculates the number of seconds the recalc should wait before it starts, based on previous recalc failures.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updateblastdigblockview.prc'
GO

IF OBJECT_ID('dbo.UpdateBlastDigblockView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateBlastDigblockView
GO

CREATE PROCEDURE dbo.UpdateBlastDigblockView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(Max)
	DECLARE @DigblockGrades VARCHAR(Max)
	DECLARE @DigblockValues VARCHAR(Max)
	DECLARE @DigblockNotes VARCHAR(Max)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @DigblockFieldID VARCHAR(50)
	DECLARE @Grade CURSOR
	DECLARE @DigblockValue CURSOR
	DECLARE @DigblockNotesCursor CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @DigblockValue = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Digblock_Field_ID
		FROM dbo.DigblockField
		WHERE Has_Value = 1

	SET @DigblockNotesCursor = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Digblock_Field_ID
		FROM dbo.DigblockField
		WHERE Has_Notes = 1

	SET @DigblockGrades = ''
	SET @DigblockValues = ''
	SET @DigblockNotes = ''

	IF OBJECT_ID('dbo.BlastDigblockView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.BlastDigblockView
	END	
		
	SELECT @CreateView =
		'CREATE VIEW dbo.BlastDigblockView AS
		WITH DigblockGradeModel AS
		(
			SELECT dg.Digblock_ID,
				''Digblock_'' + g.Grade_Name AS Digblock_Grade_ID,
				dg.Grade_Value AS Digblock_Grade_Value
			FROM dbo.DigblockGrade AS dg
				INNER JOIN dbo.Grade AS g
					ON (dg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT d.Digblock_ID,
					d.Description,
					d.Notes,
					mt.Description AS Material_Type,
					bb.Code AS Blast_Block_Code,
					bb.Drilling_Start_Date AS Blast_Drilling_Start_Date,
					bb.Drilling_End_Date AS Blast_Drilling_End_Date,
					bb.Blasted_Date,
					bb.Completed_Date AS Blast_Completed_Date,
					bb.Notes AS Blast_Notes,
					d.Creation_Datetime,
					d.Start_Date,
					d.Start_Shift,
					d.End_Date,
					d.End_Shift,
					d.X,
					d.Y,
					d.Z,
					d.Start_Tonnes AS Grade_Control_Tonnes,
					dgm.Digblock_Grade_ID,
					dgm.Digblock_Grade_Value,
					dn.Digblock_Field_ID AS DN_Field_ID,
					dn.Notes AS Digblock_Notes,
					dv.Digblock_Field_ID AS DV_Field_ID,
					dv.Field_Value
				FROM dbo.Digblock AS d
					INNER JOIN dbo.MaterialType AS mt
						ON (d.Material_Type_ID = mt.Material_Type_ID)
					LEFT JOIN dbo.BlastBlock AS bb
						ON (d.Blast_Block_ID = bb.Blast_Block_ID)
					LEFT JOIN DigblockGradeModel AS dgm
						ON (d.Digblock_ID = dgm.Digblock_ID)
					LEFT JOIN dbo.DigblockValue AS dv
						ON (d.Digblock_ID = dv.Digblock_ID)
					LEFT JOIN dbo.DigblockNotes AS dn
						ON (d.Digblock_ID = dn.Digblock_ID)
			) AS Source
			PIVOT
			(
				SUM(Digblock_Grade_Value)
				FOR Digblock_Grade_ID IN
					(
						<%DIGBLOCK_GRADES%>
					)
			) AS DigblockGradePivot
			PIVOT
			(
				SUM(Field_Value)
				FOR DV_Field_ID IN
					(
						<%DIGBLOCK_VALUES%>
					)
			) AS DigblockValuePivot
			PIVOT
			(
				MAX(Digblock_Notes) 
				FOR DN_Field_ID In
					(
						<%DIGBLOCK_NOTES%>
					)
			) AS DigblockNotesPivot '


	-- Get grades
	OPEN @Grade
	FETCH NEXT FROM @Grade INTO
		@GradeName
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockGrades = @DigblockGrades +  '[Digblock_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END
	CLOSE @Grade
	DEALLOCATE @Grade

	-- Get Digblock Value fields
	OPEN @DigblockValue
	FETCH NEXT FROM @DigblockValue INTO
		@DigblockFieldID
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockValues = @DigblockValues +  '[' + @DigblockFieldID + '],'
		FETCH NEXT FROM @DigblockValue INTO
			@DigblockFieldID
	END
	CLOSE @DigblockValue
	DEALLOCATE @DigblockValue

	-- Get Digblock Notes fields
	OPEN @DigblockNotesCursor
	FETCH NEXT FROM @DigblockNotesCursor INTO
		@DigblockFieldID
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockNotes = @DigblockNotes +  '[' + @DigblockFieldID + '],'
		FETCH NEXT FROM @DigblockNotesCursor INTO
			@DigblockFieldID
	END
	CLOSE @DigblockNotesCursor
	DEALLOCATE @DigblockNotesCursor

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required by the pivot command
	SELECT @DigblockGrades =	CASE
									WHEN @DigblockGrades = '' THEN '[''X'']'
									ELSE LEFT(@DigblockGrades, LEN(@DigblockGrades) - 1)
								END
	SELECT @DigblockValues =	CASE
									WHEN @DigblockValues = '' THEN '[''Y'']'
									ELSE LEFT(@DigblockValues, LEN(@DigblockValues) - 1)
								END
	SELECT @DigblockNotes =	CASE
									WHEN @DigblockNotes = '' THEN '[''Z'']'
									ELSE LEFT(@DigblockNotes, LEN(@DigblockNotes) - 1)
								END

	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_GRADES%>', @DigblockGrades)
	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_NOTES%>', @DigblockNotes)
	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_VALUES%>', @DigblockValues)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.BlastDigblockView TO CoreReporting
GO






GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updateblockmodelview.prc'
GO

IF OBJECT_ID('dbo.UpdateBlockModelView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateBlockModelView
GO

CREATE PROCEDURE dbo.UpdateBlockModelView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @ModelBlockPartialGrades VARCHAR(MAX)
	DECLARE @ModelBlockPartialValues VARCHAR(MAX)
	DECLARE @ModelBlockPartialNotes VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @ModelBlockPartialFieldID VARCHAR(50)
	DECLARE @Grade CURSOR
	DECLARE @ModelBlockPartialValue CURSOR
	DECLARE @ModelBlockPartialNotesCursor CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @ModelBlockPartialValue = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Model_Block_Partial_Field_ID
		FROM dbo.ModelBlockPartialField
		WHERE Has_Value = 1

	SET @ModelBlockPartialNotesCursor = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Model_Block_Partial_Field_ID
		FROM dbo.ModelBlockPartialField
		WHERE Has_Notes = 1

	SET @ModelBlockPartialGrades = ''
	SET @ModelBlockPartialValues = ''
	SET @ModelBlockPartialNotes = ''

	IF OBJECT_ID('dbo.BlockModelView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.BlockModelView
	END	
		
	SELECT @CreateView =
		'CREATE VIEW dbo.BlockModelView AS
		WITH ModelBlockPartialGradeModel AS
		(
			SELECT mbpg.Model_Block_ID, mbpg.Sequence_No,
				''Model_Block_Partial_'' + g.Grade_Name AS Model_Block_Partial_Grade_ID,
				mbpg.Grade_Value AS Model_Block_Partial_Grade_Value
			FROM dbo.ModelBlockPartialGrade AS mbpg
				INNER JOIN dbo.Grade AS g
					ON (mbpg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT bmt.Name AS Block_Model_Type,
					bm.Name AS Block_Model_Name,
					mb.Code AS Model_Block_Code,
					mb.X, mb.Y, mb.Z,
					mb.X_Inc, mb.Y_Inc, mb.Z_Inc,
					mbp.Model_Block_ID, 
					mbp.Sequence_No AS Parital_Sequence_No, 
					mt.Description AS Material_Type,
					mbp.Tonnes,
					mbpg.Model_Block_Partial_Grade_ID,
					mbpg.Model_Block_Partial_Grade_Value,
					mbpv.Model_Block_Partial_Field_ID AS MBPV_Field_ID,
					mbpv.Field_Value,
					mbpn.Model_Block_Partial_Field_ID AS MBPN_Field_ID,
					mbpn.Notes AS Partial_Notes
				FROM dbo.BlockModelType AS bmt
					INNER JOIN dbo.BlockModel AS bm
						ON (bmt.Block_Model_Type_ID = bm.Block_Model_Type_ID)
					INNER JOIN dbo.ModelBlock AS mb
						ON (bm.Block_Model_ID = mb.Block_Model_ID)
					INNER JOIN dbo.ModelBlockPartial AS mbp
						ON (mb.Model_Block_ID = mbp.Model_Block_ID)
					LEFT JOIN dbo.MaterialType AS mt
						ON (mbp.Material_Type_ID = mt.Material_Type_ID)			
					LEFT JOIN ModelBlockPartialGradeModel AS mbpg
						ON (mbpg.Model_Block_ID = mbp.Model_Block_ID
							AND mbpg.Sequence_No = mbp.Sequence_No)
					LEFT JOIN dbo.ModelBlockPartialValue AS mbpv
						ON (mbp.Model_Block_ID = mbpv.Model_Block_ID
							AND mbp.Sequence_No = mbpv.Sequence_No)
					LEFT JOIN dbo.ModelBlockPartialNotes AS mbpn
						ON (mbp.Model_Block_ID = mbpn.Model_Block_ID
							AND mbp.Sequence_No = mbpn.Sequence_No)
			) AS Source
			PIVOT
			(
				SUM(Model_Block_Partial_Grade_Value)
				FOR Model_Block_Partial_Grade_ID In
					(
						<%MODEL_BLOCK_PARTIAL_GRADES%>
					)
			) AS ModelBlockPartialGradePivot
			PIVOT
			(
				SUM(Field_Value)
				FOR MBPV_Field_ID IN
					(
						<%MODEL_BLOCK_PARTIAL_VALUES%>
					)
			) AS ModelBlockPartialValuePivot
			PIVOT
			(
				MAX(Partial_Notes) 
				FOR MBPN_Field_ID IN
					(
						<%MODEL_BLOCK_PARTIAL_NOTES%>
					)
			) AS ModelBlockPartialValuePivot'

	-- Get grades
	OPEN @Grade

	FETCH NEXT FROM @Grade INTO
		@GradeName
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @ModelBlockPartialGrades = @ModelBlockPartialGrades +  '[Model_Block_Partial_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END

	CLOSE @Grade
	DEALLOCATE @Grade

	-- Get Model_Block_Partial Value fields
	OPEN @ModelBlockPartialValue

	FETCH NEXT FROM @ModelBlockPartialValue INTO
		@ModelBlockPartialFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @ModelBlockPartialValues = @ModelBlockPartialValues +  '[' + @ModelBlockPartialFieldID + '],'
		FETCH NEXT FROM @ModelBlockPartialValue INTO
			@ModelBlockPartialFieldID
	END

	CLOSE @ModelBlockPartialValue
	DEALLOCATE @ModelBlockPartialValue

	-- Get Model_Block_Partial Notes fields
	OPEN @ModelBlockPartialNotesCursor

	FETCH NEXT FROM @ModelBlockPartialNotesCursor INTO
		@ModelBlockPartialFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @ModelBlockPartialNotes = @ModelBlockPartialNotes +  '[' + @ModelBlockPartialFieldID + '],'
		FETCH NEXT FROM @ModelBlockPartialNotesCursor INTO
			@ModelBlockPartialFieldID
	END

	CLOSE @ModelBlockPartialNotesCursor
	DEALLOCATE @ModelBlockPartialNotesCursor

	-- Strip off the last , IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @ModelBlockPartialGrades = CASE
											WHEN @ModelBlockPartialGrades = '' THEN '[''X'']'
											ELSE LEFT(@ModelBlockPartialGrades, LEN(@ModelBlockPartialGrades) - 1)
										END
	SELECT @ModelBlockPartialValues = CASE
											WHEN @ModelBlockPartialValues = '' THEN '[''Y'']'
											ELSE LEFT(@ModelBlockPartialValues, LEN(@ModelBlockPartialValues) - 1)
										END
	SELECT @ModelBlockPartialNotes = CASE
											WHEN @ModelBlockPartialNotes = '' THEN '[''Z'']'
											ELSE LEFT(@ModelBlockPartialNotes, LEN(@ModelBlockPartialNotes) - 1)
										END

	SELECT @CreateView = REPLACE(@CreateView, '<%MODEL_BLOCK_PARTIAL_GRADES%>', @ModelBlockPartialGrades)
	SELECT @CreateView = REPLACE(@CreateView, '<%MODEL_BLOCK_PARTIAL_NOTES%>', @ModelBlockPartialNotes)
	SELECT @CreateView = REPLACE(@CreateView, '<%MODEL_BLOCK_PARTIAL_VALUES%>', @ModelBlockPartialValues)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.BlockModelView TO CoreReporting


GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updatemineplanview.prc'
GO

IF OBJECT_ID('dbo.UpdateMinePlanView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateMinePlanView
GO

CREATE PROCEDURE dbo.UpdateMinePlanView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @MinePlanPeriodGrades VARCHAR(MAX)
	DECLARE @MinePlanPeriodValues VARCHAR(MAX)
	DECLARE @MinePlanPeriodNotes VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @MinePlanFieldID VARCHAR(50)
	DECLARE @Grade CURSOR
	DECLARE @MinePlanPeriodValue CURSOR
	DECLARE @MinePlanPeriodNotesCursor CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @MinePlanPeriodValue = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Mine_Plan_Field_ID
		FROM dbo.MinePlanField
		WHERE Has_Value = 1

	SET @MinePlanPeriodNotesCursor = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Mine_Plan_Field_ID
		FROM dbo.MinePlanField
		WHERE Has_Notes = 1

	SET @MinePlanPeriodGrades = ''
	SET @MinePlanPeriodValues = ''
	SET @MinePlanPeriodNotes = ''

	IF OBJECT_ID('dbo.MinePlanView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.MinePlanView
	END	

	SELECT @CreateView =
		'CREATE VIEW dbo.MinePlanView AS
		WITH MinePlanPeriodGradeModel AS
		(
			SELECT mbpg.Mine_Plan_Period_ID,
				''Mine_Plan_Period_'' + g.Grade_Name AS Mine_Plan_Period_Grade_ID,
				mbpg.Grade_Value AS Mine_Plan_Period_Grade_Value
			FROM dbo.MinePlanPeriodGrade AS mbpg
				INNER JOIN dbo.Grade AS g
					ON (mbpg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT mp.Mine_Plan_ID,
					mpt.Name AS Mine_Plan_Type,
					mp.Name AS Mine_Plan_Name,
					mpp.Start_Date,
					mpp.End_Date,
					mt.Description AS Material_Type,
					mpp.Tonnes AS Mine_Plan_Tonnes,
					mppg.Mine_Plan_Period_Grade_ID,
					mppg.Mine_Plan_Period_Grade_Value,
					mppv.Mine_Plan_Field_ID AS MPPV_Field_ID,
					mppv.Field_Value,
					mppn.Mine_Plan_Field_ID AS MPPN_Field_ID,
					mppn.Notes AS Partial_Notes
				FROM dbo.MinePlan AS mp 
					INNER JOIN dbo.MinePlanType AS mpt
						ON (mp.Mine_Plan_Type_ID = mpt.Mine_Plan_Type_ID)
					LEFT JOIN dbo.MinePlanPeriod AS mpp
						ON (mp.Mine_Plan_ID = mpp.Mine_Plan_ID)
					LEFT JOIN dbo.MaterialType AS mt
						ON (mpp.Material_Type_ID = mt.Material_Type_ID)
					LEFT JOIN MinePlanPeriodGradeModel AS mppg
						ON (mpp.Mine_Plan_Period_ID = mppg.Mine_Plan_Period_ID)
					LEFT JOIN dbo.MinePlanPeriodNotes AS mppn
						ON (mpp.Mine_Plan_Period_ID = mppn.Mine_Plan_Period_ID)
					LEFT JOIN dbo.MinePlanPeriodValue AS mppv
						ON (mpp.Mine_Plan_Period_ID = mppv.Mine_Plan_Period_ID)
			) AS Source
			PIVOT
			(
				SUM(Mine_Plan_Period_Grade_Value) 
				FOR Mine_Plan_Period_Grade_ID In
					(
						<%MINE_PLAN_PERIOD_GRADES%>
					)
			) AS MinePlanPeriodGradePivot
			PIVOT
			(
				SUM(Field_Value)
				FOR MPPV_Field_ID In
					(
						<%MINE_PLAN_PERIOD_VALUES%>
					)
			) AS MinePlanPeriodValuePivot
			PIVOT
			(
				MAX(Partial_Notes) 
				FOR MPPN_Field_ID In
					(
						<%MINE_PLAN_PERIOD_NOTES%>
					)
			) AS MinePlanPeriodNotesPivot'

	-- Get grades
	OPEN @Grade

	FETCH NEXT FROM @Grade INTO
		@GradeName
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @MinePlanPeriodGrades = @MinePlanPeriodGrades +  '[Mine_Plan_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END

	CLOSE @Grade
	DEALLOCATE @Grade

	-- Get Mine Plan Period Value fields
	OPEN @MinePlanPeriodValue

	FETCH NEXT FROM @MinePlanPeriodValue INTO
		@MinePlanFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @MinePlanPeriodValues = @MinePlanPeriodValues +  '[' + @MinePlanFieldID + '],'
		FETCH NEXT FROM @MinePlanPeriodValue INTO
			@MinePlanFieldID
	END

	CLOSE @MinePlanPeriodValue
	DEALLOCATE @MinePlanPeriodValue

	-- Get Mine Plan Period Notes fields
	OPEN @MinePlanPeriodNotesCursor

	FETCH NEXT FROM @MinePlanPeriodNotesCursor INTO
		@MinePlanFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @MinePlanPeriodNotes = @MinePlanPeriodNotes +  '[' + @MinePlanFieldID + '],'
		FETCH NEXT FROM @MinePlanPeriodNotesCursor INTO
			@MinePlanFieldID
	END

	CLOSE @MinePlanPeriodNotesCursor
	DEALLOCATE @MinePlanPeriodNotesCursor

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @MinePlanPeriodGrades =	CASE
									WHEN @MinePlanPeriodGrades = '' THEN '[''X'']'
									ELSE LEFT(@MinePlanPeriodGrades, LEN(@MinePlanPeriodGrades) - 1)
								END
	SELECT @MinePlanPeriodValues =	CASE
									WHEN @MinePlanPeriodValues = '' THEN '[''Y'']'
									ELSE LEFT(@MinePlanPeriodValues, LEN(@MinePlanPeriodValues) - 1)
								END
	SELECT @MinePlanPeriodNotes =	CASE
									WHEN @MinePlanPeriodNotes = '' THEN '[''Z'']'
									ELSE LEFT(@MinePlanPeriodNotes, LEN(@MinePlanPeriodNotes) - 1)
								END

	SELECT @CreateView = REPLACE(@CreateView, '<%MINE_PLAN_PERIOD_GRADES%>', @MinePlanPeriodGrades)
	SELECT @CreateView = REPLACE(@CreateView, '<%MINE_PLAN_PERIOD_NOTES%>', @MinePlanPeriodNotes)
	SELECT @CreateView = REPLACE(@CreateView, '<%MINE_PLAN_PERIOD_VALUES%>', @MinePlanPeriodValues)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.MinePlanView TO CoreReporting
GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updatereconciledstockpilebalancesview.prc'
GO

IF OBJECT_ID('dbo.UpdateReconciledStockpileBalancesView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateReconciledStockpileBalancesView
GO

CREATE PROCEDURE dbo.UpdateReconciledStockpileBalancesView 
WITH ENCRYPTION 
AS

	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @DataProcessStockpileBalanceGrades VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @Grade CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @DataProcessStockpileBalanceGrades = ''

	IF OBJECT_ID('dbo.ReconciledStockpileBalancesView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.ReconciledStockpileBalancesView
	END

	SELECT @CreateView =
		'CREATE VIEW dbo.ReconciledStockpileBalancesView AS
		WITH DataProcessStockpileBalanceGradeModel AS
		(
			SELECT dpsbg.Data_Process_Stockpile_Balance_ID,
				''Data_Process_Stockpile_Balance_'' + G.Grade_Name AS Data_Process_Stockpile_Balance_Grade_ID,
				dpsbg.Grade_Value AS Data_Process_Stockpile_Balance_Grade_Value
			FROM dbo.DataProcessStockpileBalanceGrade AS dpsbg
				INNER JOIN dbo.Grade AS g
					ON (dpsbg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT dpsb.Data_Process_Stockpile_Balance_ID,
					dpsb.Data_Process_Stockpile_Balance_Date,
					dpsb.Data_Process_Stockpile_Balance_Shift,
					ss.Stockpile_Name,			
					sgs.Stockpile_Group_ID,
					ssbc.Build_ID,	
					ssbc.Component_ID,			
					dpsb.Tonnes, 
					dpsbg.Data_Process_Stockpile_Balance_Grade_ID,
					dpsbg.Data_Process_Stockpile_Balance_Grade_Value
				FROM dbo.DataProcessStockpileBalance AS dpsb
					LEFT JOIN dbo.Stockpile AS ss
						ON (dpsb.Stockpile_ID = ss.Stockpile_ID)
					LEFT JOIN dbo.MaterialType AS ssmt
						ON (ss.Material_Type_ID = SSMT.Material_Type_ID)
					LEFT JOIN dbo.StockpileGroupStockpile AS sgs
						ON (dpsb.Stockpile_ID = sgs.Stockpile_ID)
					LEFT JOIN dbo.StockpileBuildComponent AS ssbc
						ON (ss.Stockpile_ID = ssbc.Stockpile_ID)
					LEFT JOIN DataProcessStockpileBalanceGradeModel AS dpsbg
						ON (dpsb.Data_Process_Stockpile_Balance_ID = dpsbg.Data_Process_Stockpile_Balance_ID)
			) AS Source
			PIVOT
			(
				SUM(Data_Process_Stockpile_Balance_Grade_Value) 
				FOR Data_Process_Stockpile_Balance_Grade_ID IN
					(
						<%DATA_PROCESS_STOCKPILE_BALANCE_GRADES%>
					)
			) AS DataProcessStockpileBalanceGradePivot'

	-- Get grades
	OPEN @Grade

	FETCH NEXT FROM @Grade INTO
		@GradeName
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DataProcessStockpileBalanceGrades = @DataProcessStockpileBalanceGrades +  '[Data_Process_Stockpile_Balance_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END

	CLOSE @Grade
	DEALLOCATE @Grade

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @DataProcessStockpileBalanceGrades =	CASE
									WHEN @DataProcessStockpileBalanceGrades = '' THEN '[''X'']'
									ELSE LEFT(@DataProcessStockpileBalanceGrades, LEN(@DataProcessStockpileBalanceGrades) - 1)
								END

	SELECT @CreateView = REPLACE(@CreateView, '<%DATA_PROCESS_STOCKPILE_BALANCE_GRADES%>', @DataProcessStockpileBalanceGrades)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.ReconciledStockpileBalancesView TO CoreReporting

GO




GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updatereconciledtransactionsview.prc'
GO

IF OBJECT_ID('dbo.UpdateReconciledTransactionsView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateReconciledTransactionsView
GO

CREATE PROCEDURE dbo.UpdateReconciledTransactionsView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @DataProcessTransactionGrades VARCHAR(MAX)
	DECLARE @OriginalSourceDigblockGrades VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @Grade CURSOR
	
	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @DataProcessTransactionGrades = ''
	SET @OriginalSourceDigblockGrades = ''

	IF OBJECT_ID('dbo.ReconciledTransactionsView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.ReconciledTransactionsView
	END	
		
	SELECT @CreateView =
		'CREATE VIEW dbo.ReconciledTransactionsView AS
		WITH DataProcessTransactionGradeModel AS
		(
			SELECT dptg.Data_Process_Transaction_ID,
				''Data_Process_Transaction_'' + G.Grade_Name AS Data_Process_Transaction_Grade_ID,
				dptg.Grade_Value AS Data_Process_Transaction_Grade_Value
			FROM dbo.DataProcessTransactionGrade AS dptg
				INNER JOIN dbo.Grade AS g
					ON (dptg.Grade_ID = g.Grade_ID)
		),
		OriginalSourceDigblockGradeModel AS
		(
			SELECT dg.Digblock_ID,
				''Original_Digblock_'' + g.Grade_Name AS Original_Digblock_Grade_ID,
				dg.Grade_Value AS Original_Digblock_Grade_Value
			FROM dbo.DigblockGrade AS dg
				INNER JOIN dbo.Grade AS g
					ON (dg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT dpt.Data_Process_Transaction_ID,
					dpt.Data_Process_Transaction_Date AS Date,
					dpt.Data_Process_Transaction_Shift AS Shift,
					dpt.Source_Digblock_ID,
					dmt.Description AS Source_Digblock_Material_Type, 
					d.Blast_Block_ID,
					ss.Stockpile_ID AS Source_Stockpile_ID, 
					ssbc.Build_ID AS Source_Stockpile_Build_ID,
					ssbc.Component_ID AS Source_Stockpile_Component_ID,
					ssmt.Description AS Source_Stockpile_Material_Type,
					ds.Stockpile_ID AS Destination_Stockpile_ID, 
					dsbc.Build_ID AS Destination_Stockpile_Build_ID,
					dsbc.Component_ID AS Destination_Stockpile_Component_ID,
					dsmt.Description AS Destination_Stockpile_Material_Type,
					dpt.Destination_Mill_ID,
					dpt.Original_Source_Digblock_ID,
					osdmt.Description AS Original_Source_Digblock_Material_Type,
					CASE WHEN Stockpile_Adjustment_ID IS NULL THEN 0 ELSE 1 END AS Is_Stockpile_Adjustment,
					dpt.Tonnes AS Transaction_Tonnes,
					dptg.Data_Process_Transaction_Grade_ID,
					dptg.Data_Process_Transaction_Grade_Value,
					osdg.Original_Digblock_Grade_ID,
					osdg.Original_Digblock_Grade_Value
				FROM dbo.DataProcessTransaction AS dpt
					LEFT JOIN dbo.Digblock AS d
						ON (dpt.Source_Digblock_ID = d.Digblock_ID)
					LEFT JOIN dbo.MaterialType AS dmt
						ON (d.Material_Type_ID = dmt.Material_Type_ID)
					LEFT JOIN dbo.Stockpile AS ss
						ON (dpt.Source_Stockpile_ID = ss.Stockpile_ID)
					LEFT JOIN dbo.MaterialType AS ssmt
						ON (ss.Material_Type_ID = ssmt.Material_Type_ID)
					LEFT JOIN dbo.StockpileBuildComponent AS ssbc
						ON (ss.Stockpile_ID = ssbc.Stockpile_ID)
					LEFT JOIN dbo.Stockpile AS ds
						ON (dpt.Destination_Stockpile_ID = ds.Stockpile_ID)
					LEFT JOIN dbo.MaterialType AS dsmt
						ON (ds.Material_Type_ID = dsmt.Material_Type_ID)
					LEFT JOIN dbo.StockpileBuildComponent AS dsbc
						ON (ds.Stockpile_ID = dsbc.Stockpile_ID)
					LEFT JOIN dbo.Digblock AS osd
						ON (dpt.Original_Source_Digblock_ID = OSD.Digblock_ID)
					LEFT JOIN dbo.MaterialType AS osdmt
						ON (OSD.Material_Type_ID = osdmt.Material_Type_ID)
					LEFT JOIN DataProcessTransactionGradeModel AS dptg
						ON (dpt.Data_Process_Transaction_ID = dptg.Data_Process_Transaction_ID)
					LEFT JOIN OriginalSourceDigblockGradeModel AS osdg
						ON (dpt.Original_Source_Digblock_ID = osdg.Digblock_ID)
			) AS Source
			PIVOT
			(
				SUM(Data_Process_Transaction_Grade_Value) 
				FOR Data_Process_Transaction_Grade_ID In
					(
						<%DATA_PROCESS_TRANSACTION_GRADES%>
					)
			) AS DataProcessTransactionGradePivot
			PIVOT
			(
				SUM(Original_Digblock_Grade_Value)
				FOR Original_Digblock_Grade_ID In
					(
						<%ORIGINAL_SOURCE_DIGBLOCK_GRADES%>
					)
			) AS OriginalSourceDigblockGradePivot'

	-- Get grades
	OPEN @Grade

	FETCH NEXT FROM @Grade INTO
	 @GradeName
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DataProcessTransactionGrades = @DataProcessTransactionGrades +  '[Data_Process_Transaction_' + @GradeName + '],'
		SET @OriginalSourceDigblockGrades = @OriginalSourceDigblockGrades +  '[Original_Digblock_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END

	CLOSE @Grade
	DEALLOCATE @Grade

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @DataProcessTransactionGrades =	CASE
													WHEN @DataProcessTransactionGrades = '' THEN '[''X'']'
													ELSE LEFT(@DataProcessTransactionGrades, LEN(@DataProcessTransactionGrades) - 1)
												END
	SELECT @OriginalSourceDigblockGrades =	CASE
													WHEN @OriginalSourceDigblockGrades = '' THEN '[''Y'']'
													ELSE LEFT(@OriginalSourceDigblockGrades, LEN(@OriginalSourceDigblockGrades) - 1)
												END

	SELECT @CreateView = REPLACE(@CreateView, '<%DATA_PROCESS_TRANSACTION_GRADES%>', @DataProcessTransactionGrades)
	SELECT @CreateView = REPLACE(@CreateView, '<%ORIGINAL_SOURCE_DIGBLOCK_GRADES%>', @OriginalSourceDigblockGrades)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.ReconciledTransactionsView TO CoreReporting

GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updatereconciliationsummarybydigblockview.prc'
GO

IF OBJECT_ID('dbo.UpdateReconciliationSummaryByDigblockView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateReconciliationSummaryByDigblockView
GO

CREATE PROCEDURE dbo.UpdateReconciliationSummaryByDigblockView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @DigblockGrades VARCHAR(MAX)
	DECLARE @DigblockValues VARCHAR(MAX)
	DECLARE @DigblockNotes VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @DigblockFieldID VARCHAR(50)
	DECLARE @Grade CURSOR
	DECLARE @DigblockValue CURSOR
	DECLARE @DigblockNotesCursor CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @DigblockValue = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Digblock_Field_ID
		FROM dbo.DigblockField
		WHERE Has_Value = 1

	SET @DigblockNotesCursor = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Distinct Digblock_Field_ID
		FROM dbo.DigblockField
		WHERE Has_Notes = 1

	SET @DigblockGrades = ''
	SET @DigblockValues = ''
	SET @DigblockNotes = ''

	IF OBJECT_ID('dbo.ReconciliationSummaryByDigblockView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.ReconciliationSummaryByDigblockView
	END	
		
	SELECT @CreateView =
		'CREATE VIEW dbo.ReconciliationSummaryByDigblockView AS
		WITH DigblockGradeModel AS
		(
			SELECT dg.Digblock_ID,
				''Digblock_'' + g.Grade_Name AS Digblock_Grade_ID,
				dg.Grade_Value AS Digblock_Grade_Value
			FROM dbo.DigblockGrade AS dg
				INNER JOIN dbo.Grade AS g
					ON (dg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT bb.Code AS Blast_Block_Code,
					d.Digblock_ID,
					mt.Description AS Material_Type,			
					bb.Drilling_Start_Date AS Blast_Drilling_Start_Date,
					bb.Drilling_End_Date AS Blast_Drilling_End_Date,
					bb.Blasted_Date,
					bb.Completed_Date AS Blast_Completed_Date,
					d.Start_Date,
					d.Start_Shift,
					d.End_Date,
					d.End_Shift,
					d.X,
					d.Y,
					d.Z,
					d.Start_Tonnes AS Grade_Control_Tonnes,
					dg.Digblock_Grade_ID,
					dg.Digblock_Grade_Value,
					dn.Digblock_Field_ID AS DN_Field_ID,
					dn.Notes AS Digblock_Notes,
					dv.Digblock_Field_ID AS DV_Field_ID,
					dv.Field_Value
				FROM dbo.Digblock AS d
					INNER JOIN dbo.MaterialType AS mt
						ON (d.Material_Type_ID = mt.Material_Type_ID)
					LEFT JOIN dbo.BlastBlock AS bb
						ON (d.Blast_Block_ID = bb.Blast_Block_ID)
					LEFT JOIN DigblockGradeModel AS dg
						ON (d.Digblock_ID = dg.Digblock_ID)
					LEFT JOIN dbo.DigblockValue AS dv
						ON (d.Digblock_ID = dv.Digblock_ID)
					LEFT JOIN dbo.DigblockNotes AS dn
						ON (d.Digblock_ID = dn.Digblock_ID)
			) AS Source
			PIVOT
			(
				SUM(Digblock_Grade_Value)
				FOR Digblock_Grade_ID IN
					(
						<%DIGBLOCK_GRADES%>
					)
			) AS DigblockGradePivot
			PIVOT
			(
				SUM(Field_Value)
				FOR DV_Field_ID IN
					(
						<%DIGBLOCK_VALUES%>
					)
			) AS DigblockValuePivot
			PIVOT
			(
				MAX(Digblock_Notes) 
				FOR DN_Field_ID IN
					(
						<%DIGBLOCK_NOTES%>
					)
			) AS DigblockNotesPivot'

	-- Get grades
	OPEN @Grade

	FETCH NEXT FROM @Grade INTO
		@GradeName
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockGrades = @DigblockGrades +  '[Digblock_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END

	CLOSE @Grade
	DEALLOCATE @Grade

	-- Get Digblock Value fields
	OPEN @DigblockValue

	FETCH NEXT FROM @DigblockValue INTO
		@DigblockFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockValues = @DigblockValues +  '[' + @DigblockFieldID + '],'
		FETCH NEXT FROM @DigblockValue INTO
			@DigblockFieldID
	END

	CLOSE @DigblockValue
	DEALLOCATE @DigblockValue

	-- Get Digblock Notes fields
	OPEN @DigblockNotesCursor

	FETCH NEXT FROM @DigblockNotesCursor INTO
		@DigblockFieldID
				
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @DigblockNotes = @DigblockNotes +  '[' + @DigblockFieldID + '],'
		FETCH NEXT FROM @DigblockNotesCursor INTO
			@DigblockFieldID
	END

	CLOSE @DigblockNotesCursor
	DEALLOCATE @DigblockNotesCursor

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @DigblockGrades =	CASE
									WHEN @DigblockGrades = '' THEN '[''X'']'
									ELSE LEFT(@DigblockGrades, LEN(@DigblockGrades) - 1)
								END
	SELECT @DigblockValues =	CASE
									WHEN @DigblockValues = '' THEN '[''Y'']'
									ELSE LEFT(@DigblockValues, LEN(@DigblockValues) - 1)
								END
	SELECT @DigblockNotes =	CASE
									WHEN @DigblockNotes = '' THEN '[''Z'']'
									ELSE LEFT(@DigblockNotes, LEN(@DigblockNotes) - 1)
								END

	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_GRADES%>', @DigblockGrades)
	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_NOTES%>', @DigblockNotes)
	SELECT @CreateView = REPLACE(@CreateView, '<%DIGBLOCK_VALUES%>', @DigblockValues)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.ReconciliationSummaryByDigblockView TO CoreReporting
GO






GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.updatestockpilesurveyview.prc'
GO

IF OBJECT_ID('dbo.UpdateStockpileSurveyView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateStockpileSurveyView
GO

CREATE PROCEDURE dbo.UpdateStockpileSurveyView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @StockpileSurveySummaryGrades VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @Grade CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @StockpileSurveySummaryGrades = ''

	IF OBJECT_ID('dbo.StockpileSurveyView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.StockpileSurveyView
	END	

	SELECT @CreateView =
		'CREATE VIEW dbo.StockpileSurveyView AS
		WITH StockpileSurveySampleGradeModel AS
		(
			SELECT sssg.Stockpile_Survey_Sample_ID,
				''Stockpile_Survey_Sample_'' + g.Grade_Name AS Stockpile_Survey_Sample_Grade_ID,
				sssg.Grade_Value AS Stockpile_Survey_Sample_Grade_Value
			FROM dbo.StockpileSurveySampleGrade AS sssg
				INNER JOIN dbo.Grade AS g
				ON (sssg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
		(
			SELECT ss.Stockpile_Survey_Date AS Date,
				ss.Stockpile_Survey_Shift AS Shift,
				sst.Description AS Stockpile_Survey_Type,
				sss.Stockpile_ID, sss.Build_ID, 
				sbc.Component_ID,
				sss.Tonnes AS Stockpile_Survey_Tonnes,
				sssg.Stockpile_Survey_Sample_Grade_Value,
				sssg.Stockpile_Survey_Sample_Grade_ID
			FROM dbo.StockpileSurvey AS ss
				INNER JOIN dbo.StockpileSurveyType AS sst
					ON (ss.Stockpile_Survey_Type_ID = sst.Stockpile_Survey_Type_ID)
				LEFT JOIN dbo.StockpileSurveySample AS sss
					ON (ss.Stockpile_Survey_Date = sss.Stockpile_Survey_Date
						AND ss.Stockpile_Survey_Shift = sss.Stockpile_Survey_Shift
						AND ss.Stockpile_Survey_Type_ID = sss.Stockpile_Survey_Type_ID)
				LEFT JOIN dbo.StockpileBuildComponent AS sbc
					ON (sss.Stockpile_ID = sbc.Stockpile_ID
						AND sss.Build_ID = sbc.Build_ID)
				LEFT JOIN StockpileSurveySampleGradeModel AS sssg
					ON (sss.Stockpile_Survey_Sample_ID = sssg.Stockpile_Survey_Sample_ID)
		) AS Source
		PIVOT
		(
			SUM(Stockpile_Survey_Sample_Grade_Value) 
			FOR Stockpile_Survey_Sample_Grade_ID In
				(
					<%STOCKPILE_SURVEY_SUMMARY_GRADES%>
				)
		) AS StockpileSurveySampleGradePivot;'

	-- Get grades
	OPEN @Grade
	FETCH NEXT FROM @Grade INTO
		@GradeName
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @StockpileSurveySummaryGrades = @StockpileSurveySummaryGrades +  '[Stockpile_Survey_Sample_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END
	CLOSE @Grade
	DEALLOCATE @Grade

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @StockpileSurveySummaryGrades =	CASE
													WHEN @StockpileSurveySummaryGrades = '' THEN '[''X'']'
													ELSE LEFT(@StockpileSurveySummaryGrades, LEN(@StockpileSurveySummaryGrades) - 1)
												END

	SELECT @CreateView = REPLACE(@CreateView, '<%STOCKPILE_SURVEY_SUMMARY_GRADES%>', @StockpileSurveySummaryGrades)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.StockpileSurveyView TO CoreReporting

GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateHaulageView.prc'
GO

IF OBJECT_ID('dbo.UpdateHaulageView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateHaulageView
GO

CREATE PROCEDURE dbo.UpdateHaulageView 
WITH ENCRYPTION 
AS
BEGIN
	DECLARE @CreateView VARCHAR(MAX)


	IF OBJECT_ID('dbo.HaulageView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.HaulageView
	END	

	SET @CreateView = '
	CREATE VIEW dbo.HaulageView
	AS
	SELECT H.Haulage_ID,
		H.Haulage_Date AS Date,
		H.Haulage_Shift AS Shift,
		H.Source_Digblock_ID,
		BB.Code AS Source_Blast_Block_Code,
		MT.Description AS Source_Digblock_Material_Type,
		SS.Stockpile_Name AS Source_Stockpile_ID,
		SSBC.Build_ID AS Source_Stockpile_Build_ID,
		SSBC.Component_ID AS Source_Stockpile_Component_ID,
		SSMT.Description AS Source_Stockpile_Material_Type,
		DS.Stockpile_Name AS Destination_Stockpile_ID,
		DSBC.Build_ID AS Destination_Stockpile_Build_ID,
		DSBC.Component_ID AS Destination_Stockpile_Component_ID,
		DSMT.Description AS Destination_Stockpile_Material_Type,
		H.Destination_Crusher_ID,
		H.Tonnes AS Haulage_Tonnes,
		H.Loads AS Haulage_Loads,
		H.Truck_ID,
		H.Added_Datetime
	FROM dbo.HAULAGE AS H
		LEFT JOIN dbo.digblock D
			ON (H.Source_Digblock_ID = D.Digblock_ID)
		LEFT JOIN dbo.MaterialType MT
			ON (D.Material_Type_ID = MT.Material_Type_ID)
		LEFT JOIN dbo.BlastBLOCK BB
			ON (D.Blast_Block_ID = BB.Blast_Block_ID)
		LEFT JOIN dbo.Stockpile SS
			ON (H.Source_Stockpile_ID = SS.Stockpile_ID)
		LEFT JOIN dbo.MaterialType SSMT
			ON (SS.Material_Type_ID = SSMT.Material_Type_ID)
		LEFT JOIN dbo.StockpileBuildComponent SSBC
			ON (SS.Stockpile_ID = SSBC.Stockpile_ID)
		LEFT JOIN dbo.stockpile DS
			ON (H.Destination_Stockpile_ID = DS.Stockpile_ID)
		LEFT JOIN dbo.MaterialType DSMT
			ON (DS.Material_Type_ID = DSMT.Material_Type_ID)
		LEFT JOIN dbo.StockpileBuildComponent DSBC
			ON (DS.Stockpile_ID = DSBC.Stockpile_ID)
	'
	
	EXEC (@CreateView)
	GRANT SELECT ON dbo.HaulageView TO CoreReporting
END
GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateWeightometerSampleReportView.PRC'
GO

IF OBJECT_ID('dbo.UpdateWeightometerSampleReportView') IS NOT NULL
	DROP PROCEDURE dbo.UpdateWeightometerSampleReportView
GO

CREATE PROCEDURE dbo.UpdateWeightometerSampleReportView 
WITH ENCRYPTION 
AS


	SET NOCOUNT ON
	
	DECLARE @CreateView VARCHAR(MAX)
	DECLARE @WeightometerSampleGrades VARCHAR(MAX)
	DECLARE @GradeName VARCHAR(50)
	DECLARE @Grade CURSOR

	SET @Grade = CURSOR LOCAL FORWARD_ONLY FOR
		SELECT Grade_Name
		FROM dbo.Grade
		WHERE Is_Visible = 1

	SET @WeightometerSampleGrades = ''

	IF OBJECT_ID('dbo.WeightometerSampleReportView') IS NOT NULL
	BEGIN
		DROP VIEW dbo.WeightometerSampleReportView
	END	

	SELECT @CreateView =
		'CREATE VIEW dbo.WeightometerSampleReportView AS
		WITH WeightometerSampleGradeModel AS
		(
			SELECT wsg.Weightometer_Sample_ID,
				''Weightometer_Sample_'' + g.Grade_Name AS Weightometer_Sample_Grade_ID,
				wsg.Grade_Value AS Weightometer_Sample_Grade_Value
			FROM dbo.WeightometerSampleGrade AS wsg
				INNER JOIN dbo.Grade AS g
					ON (wsg.Grade_ID = g.Grade_ID)
		)
		SELECT *
		FROM
			(
				SELECT ws.Weightometer_Sample_ID,
					ws.Weightometer_Sample_Date AS Date,
					ws.Weightometer_Sample_Shift AS Shift,
					ss.Stockpile_Name AS Source_Stockpile_ID,
					ssbc.Build_ID AS Source_Stockpile_Build_ID,
					ssbc.Component_ID AS Source_Stockpile_Component_ID,
					wfp.Source_Mill_ID,
					wfp.Source_Crusher_ID,
					ws.Destination_Stockpile_ID,
					dsbc.Build_ID AS Destination_Stockpile_Build_ID,
					dsbc.Component_ID AS Destination_Stockpile_Component_ID,
					wfp.Destination_Mill_ID,
					wfp.Destination_Crusher_ID,
					ws.Tonnes AS Weightometer_Sample_Tonnes,
					ws.Corrected_Tonnes AS Weightometer_Sample_Corrected_Tonnes,
					wsg.Weightometer_Sample_Grade_ID,
					wsg.Weightometer_Sample_Grade_Value
				FROM dbo.WeightometerSample AS ws
					LEFT JOIN dbo.Stockpile AS ss
						ON (ws.Source_Stockpile_ID = ss.Stockpile_ID)
					LEFT JOIN dbo.StockpileBuildComponent AS ssbc
						ON (ws.Source_Stockpile_ID = ssbc.Stockpile_ID)
					LEFT JOIN dbo.StockpileBuildComponent AS dsbc
						ON (ws.Destination_Stockpile_ID = dsbc.Stockpile_ID)
					LEFT JOIN WeightometerSampleGradeModel AS wsg
						ON (ws.Weightometer_Sample_ID = wsg.Weightometer_Sample_ID)
					LEFT JOIN dbo.WeightometerFlowPeriod AS wfp
						ON (ws.Weightometer_ID = wfp.Weightometer_ID
							AND ws.Weightometer_Sample_Date <= wfp.End_Date)
			) AS Source
			PIVOT
			(
				SUM(Weightometer_Sample_Grade_Value) 
				FOR Weightometer_Sample_Grade_ID In
					(
						<%WEIGHTOMETER_SAMPLE_GRADES%>
					)
			) AS WeightometerSampleGradePivot'

	-- Get grades
	OPEN @Grade
	FETCH NEXT FROM @Grade INTO
		@GradeName
	WHILE (@@Fetch_Status = 0) 
	BEGIN
		SET @WeightometerSampleGrades = @WeightometerSampleGrades +  '[Weightometer_Sample_' + @GradeName + '],'
		FETCH NEXT FROM @Grade INTO
			@GradeName
	END
	CLOSE @Grade
	DEALLOCATE @Grade

	-- Strip off the last ,IF string IS empty substitute dummy parameter 
	-- required BY the PIVOT command
	SELECT @WeightometerSampleGrades =	CASE
												WHEN @WeightometerSampleGrades = '' THEN '[''X'']'
												ELSE LEFT(@WeightometerSampleGrades, LEN(@WeightometerSampleGrades) - 1)
											END

	SELECT @CreateView = REPLACE(@CreateView, '<%WEIGHTOMETER_SAMPLE_GRADES%>', @WeightometerSampleGrades)

	EXEC (@CreateView)
	GRANT SELECT ON dbo.WeightometerSampleReportView TO CoreReporting

GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockSurveySummary.prc'
GO

IF OBJECT_ID('dbo.GetDigblockSurveySummary') IS NOT NULL 
     DROP PROCEDURE dbo.GetDigblockSurveySummary  
GO 
  
CREATE PROCEDURE dbo.GetDigblockSurveySummary 
( 
    @iDigblock_Survey_Summary_Id INT,
    @iNT_Login VARCHAR(255) = NULL
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 

	DECLARE @Previous_Id INT
	DECLARE @Next_Id INT
	DECLARE @Record_Count INT
		
	-- Info for page navigation	
	-- Total Records
	SELECT @Record_Count = Count(DS.Digblock_Survey_Id)
	FROM dbo.DigblockSurveySummary AS DS
		INNER JOIN dbo.DigblockSurveySummary AS DSS
			ON (DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id)
	WHERE DSS.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
		AND DS.NT_Login = IsNull(@iNT_Login, DS.NT_Login)
						
	-- Previous
	SELECT TOP 1 @Previous_Id = DS.Digblock_Survey_Summary_Id
	FROM dbo.DigblockSurveySummary AS DS
		INNER JOIN dbo.DigblockSurveySummary AS DSS
			ON (DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id)
	WHERE DSS.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id			
		AND DS.Record_No < DSS.Record_No
		AND DS.NT_Login = IsNull(@iNT_Login, DS.NT_Login)
	ORDER BY DS.Digblock_Survey_Id, DS.Record_No DESC
			
	-- Next
	SELECT TOP 1 @Next_Id = DS.Digblock_Survey_Summary_Id
	FROM dbo.DigblockSurveySummary AS DS
		INNER JOIN dbo.DigblockSurveySummary AS DSS
			ON (DS.Digblock_Survey_Id = DSS.Digblock_Survey_Id)
	WHERE DSS.Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id			
		AND DS.Record_No > DSS.Record_No
		AND DS.NT_Login = IsNull(@iNT_Login, DS.NT_Login)
	ORDER BY DS.Digblock_Survey_Id, DS.Record_No

	-- Record Info
	SELECT Digblock_Survey_Id, Digblock_Id, NT_Login, Record_No, 
		IsNull(@Previous_Id, 0) AS Previous_Id, IsNull(@Next_Id, 0) AS Next_Id, 
		IsNull(@Record_Count, 0) as Total
	FROM dbo.DigblockSurveySummary
	WHERE Digblock_Survey_Summary_Id = @iDigblock_Survey_Summary_Id
END 
GO
GRANT EXECUTE ON dbo.GetDigblockSurveySummary TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockSurveySummary">
 <Procedure>
	Returns the raw summary information with no cached tonnage values.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteDigblockModelBlock.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
-- Mark Holst 10-Jul-2008

IF OBJECT_ID('dbo.DeleteDigblockModelBlock') IS NOT NULL
     DROP PROCEDURE dbo.DeleteDigblockModelBlock  
GO 
  
CREATE PROCEDURE dbo.DeleteDigblockModelBlock
(
	@iDigblockId VARCHAR(31),
	@iModelBlockId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteDigblockModelBlock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		IF NOT EXISTS (SELECT 1 FROM dbo.DigblockModelBlock WHERE Model_Block_Id = @iModelBlockId AND Digblock_Id = @iDigblockId)
		BEGIN
			RaisError ('The combination of digblock id and model block id does not exist in the system',16,1)
		END

		DELETE FROM dbo.DigblockModelBlock
		WHERE Digblock_Id = @iDigblockId
		AND Model_Block_Id = @iModelBlockId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddBlockModel TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteDigblockModelBlock">
 <Procedure>
	Deletes the Digblock Model Block record provided by the parameters.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddDigblockModelBlock.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
-- Mark Holst 10-Jul-2008

IF OBJECT_ID('dbo.AddDigblockModelBlock') IS NOT NULL
     DROP PROCEDURE dbo.AddDigblockModelBlock  
GO 
  
CREATE PROCEDURE dbo.AddDigblockModelBlock
(
	@iDigblockId VARCHAR(31),
	@iModelBlockId INT,
	@iPercentageInModelBlock REAL = 1,
	@iPercentageInDigblock REAL = 1
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddDigblockModelBlock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- code goes here

		IF NOT EXISTS (SELECT 1 FROM dbo.Digblock WHERE Digblock_Id = @iDigblockId)
		BEGIN
			RaisError ('The digblock does not exist in the system',16,1)
		END

		IF NOT EXISTS (SELECT 1 FROM dbo.ModelBlock WHERE Model_Block_Id = @iModelBlockId)
		BEGIN
			RaisError ('The model block id does not exist in the system',16,1)
		END

		INSERT INTO dbo.DigblockModelBlock
		(
			Digblock_Id, Model_Block_Id, Percentage_In_Model_Block, Percentage_In_Digblock
		)
		SELECT @iDigblockId, @iModelBlockId, @iPercentageInModelBlock, @iPercentageInDigblock

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddDigblockModelBlock TO CoreBlockModelManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddDigblockModelBlock">
 <Procedure>
	Adds a record to DigblockModelBlock
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetCalcVirtualQueueMinimumEntry.prc'
GO

 IF OBJECT_ID('dbo.GetCalcVirtualQueueMinimumEntry') IS NOT NULL
	DROP PROCEDURE dbo.GetCalcVirtualQueueMinimumEntry  
GO 
  
CREATE PROCEDURE dbo.GetCalcVirtualQueueMinimumEntry 
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT Min(Calc_Date) As TransactionDate
		FROM dbo.CALCVIRTUALFLOWQUEUE AS Q
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetCalcVirtualQueueMinimumEntry TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetCalcVirtualQueueMinimumEntry">
 <Procedure>
	Returns the minimum transaction date in the Calc Virtual Flow Queue.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteCalcVirtualFlowQueueDate.prc'
GO

IF OBJECT_ID('dbo.DeleteCalcVirtualFlowQueueDate') IS NOT NULL
	DROP PROCEDURE dbo.DeleteCalcVirtualFlowQueueDate  
GO 
  
CREATE PROCEDURE dbo.DeleteCalcVirtualFlowQueueDate 
(
	@iTransactionDate DATETIME
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DELETE Q
		FROM dbo.CALCVIRTUALFLOWQUEUE AS Q
		WHERE Q.Calc_Date = @iTransactionDate
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteCalcVirtualFlowQueueDate TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteCalcVirtualFlowQueueDate">
 <Procedure>
	Removes all instances of the passed in transaction date from the Calc Virtual Flow queue.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetMaterialParentHierarchy.prc'
GO

IF OBJECT_ID('dbo.GetMaterialParentHierarchy') IS NOT NULL
     DROP PROCEDURE dbo.GetMaterialParentHierarchy 
GO 
  
CREATE PROCEDURE dbo.GetMaterialParentHierarchy
(
	@iMaterialId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here
	Declare @Material Table
	(
		MaterialId Int,
		MaterialCategoryId Varchar(31),
		Name Varchar(255),
		OrderNo Int Identity(1, 1)
	)

	Declare @MaterialId Int
		
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetMaterialParentHierarchy',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		 --This query is inclusive but make sure it exists
		Select @MaterialId = @iMaterialId
		From dbo.Material
		Where MaterialId = @iMaterialId

		While @MaterialId Is Not Null
		Begin
			-- Insert this parent material
			Insert Into @material
			(
				MaterialId, MaterialCategoryId, Name
			)
			Select MaterialId, MaterialCategoryId, Name
			From dbo.Material
			Where MaterialId = @MaterialId	

			Select @MaterialId = ParentMaterialId
			From dbo.Material
			Where MaterialId = @MaterialId
		End

		Select M.*, MC.Description As MaterialCategoryDescription
		From @material As M
			Inner Join dbo.MaterialCategory As MC
				On (M.MaterialCategoryId = MC.MaterialCategoryId)
		Order by OrderNo * -1
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetMaterialParentHierarchy TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetMaterialParentHierarchy">
 <Procedure>
	Returns the parental heirarchy of materials for material id provided.
	This heirarchy will include the material passed in but not its children.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetPotentialReportDataExceptions.prc'
GO

IF OBJECT_ID('dbo.GetPotentialReportDataExceptions') IS NOT NULL
	DROP PROCEDURE dbo.GetPotentialReportDataExceptions
GO
CREATE PROCEDURE dbo.GetPotentialReportDataExceptions 

WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 

	-- Update existing values and insert new
	-- Leave records in stage table to ease debugging
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateBhpbioReconciliationMovement',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		DECLARE @IsDataException BIT
		DECLARE @noHaulageErrors INT
		DECLARE @noDataExceptions INT
		DECLARE @noImportsRunning INT
		DECLARE @noL1RecalcEntries INT
		DECLARE @noL2RecalcEntries INT

		SET @IsDataException = 0

		EXEC dbo.GetNoHaulageErrors 
			@No_Errors = @noHaulageErrors OUTPUT
		EXEC dbo.GetDataExceptionCount 
			@oNum_Exceptions = @noDataExceptions OUTPUT		
		EXEC dbo.GetImportsRunningCount 
			@oNumImportsRunning = @noImportsRunning OUTPUT     

		SELECT @noL1RecalcEntries = COUNT(DISTINCT Recalc_Date)   
		FROM dbo.RecalcL1queue     

		SELECT @noL2RecalcEntries = COUNT(DISTINCT Recalc_Date)   
		FROM dbo.RecalcL2queue     

		IF (@noHaulageErrors > 0     
			OR @noDataExceptions > 0    
			OR @noImportsRunning > 0    
			OR @noL1RecalcEntries > 0    
			OR @noL2RecalcEntries > 0)   
		BEGIN    
			SET @IsDataException = 1     
		END     

		SELECT @IsDataException AS IsDataException,
			@noHaulageErrors AS HaulageErrorCount,
			@noDataExceptions as DataExceptionCount,
			@noImportsRunning AS RunningImportCount  ,
			@noL1RecalcEntries AS L1RecalcEntryCount,
			@noL2RecalcEntries AS L2RecalcEntryCount
		 
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.GetPotentialReportDataExceptions TO CoreReporting
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.UpdateStockpileAdjustment.prc'
GO

 If object_id('dbo.UpdateStockpileAdjustment') is not Null 
     Drop Procedure dbo.UpdateStockpileAdjustment 
Go 
  
Create Procedure dbo.UpdateStockpileAdjustment 
( 
	@iStockpile_Adjustment_Id Int,
    @iStockpile_Id Int,
	@iBuild_Id Int,
	@iComponent_Id Int = Null,
	@iAdjustment_Date Datetime,
	@iAdjustment_Shift Char(1),
	@iDescription Varchar(255),
	@iIs_Add_Or_Remove Bit,
	@iIs_Tonnes_Adjustment Bit,
	@iIs_Grades_Adjustment Bit,
	@iIs_Manual Bit = 1,
	@iTonnes Float = Null,
	@iStockpile_Survey_Sample_Id Int = Null,
	@iIs_Stockpile_Transfer Bit = 0,
	@iSource_Stockpile_Id Int = Null,
	@iSource_Build_Id Int = Null,
	@iUse_Given_Moisture_Scaling Bit = 0
	
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
	
	Declare @tmpDate Datetime

	Begin Try
		Set @iAdjustment_Date = dbo.GetDateDay (@iAdjustment_Date)

		-- If the stockpileadjustment does not exists
		If Not Exists
			(
				Select 1
				From dbo.StockpileAdjustment
				Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
			)
		Begin
			RaisError('The stockpile adjustment does not exist', 16, 1)
		End

		-- If the stockpile does not exists
		If Not Exists
			(
				Select 1
				From dbo.Stockpile
				Where Stockpile_Id = @iStockpile_Id
			)
		Begin
			RaisError('The stockpile adjustment does not exist', 16, 1)
		End

		--If stockpile Build does not exist
		If Not Exists
			(
				Select 1 
				From dbo.StockpileBuild
				Where Stockpile_Id = @iStockpile_Id
					And Build_Id = @iBuild_Id
			)
		Begin
			RaisError('The stockpile build does not exist', 16, 1)
		End
		
		--If the stockpile component is specified and is not null
		If @iComponent_Id Is Not Null 
			And Not Exists
				(
					Select 1 
					From dbo.StockpileBuildComponent
					Where Stockpile_Id = @iStockpile_Id
						And Build_Id = @iBuild_Id
						And Component_Id = @iComponent_Id
				)
		Begin
			RaisError('The stockpile component does not exist', 16, 1)
		End

		--If the stockpile build is not active
		If (dbo.IsStockpileBuildActive (@iStockpile_Id, @iBuild_Id, @iAdjustment_Date, @iAdjustment_Shift) <> 1)
		Begin
			Raiserror ('The stockpile build is not active on this date and shift', 16, 1)
		End

		--If this is a stockpile to stockpile transfer
		If @iIs_Stockpile_Transfer = 1
		Begin
			--Validate Source Stockpile & Source Build Exist
			If Not Exists
			(
				Select 1
				From dbo.Stockpile
				Where Stockpile_Id = @iSource_Stockpile_Id
			)
			Begin
				RaisError('The source stockpile does not exist', 16, 1)
			End

			If Not Exists
			(
				Select 1 
				From dbo.StockpileBuild
				Where Stockpile_Id = @iSource_Stockpile_Id
					And Build_Id = @iSource_Build_Id
			)
			Begin
				RaisError('The source stockpile build does not exist', 16, 1)
			End

			--Ensure Source Build is active
			If (dbo.IsStockpileBuildActive (@iSource_Stockpile_Id, @iSource_Build_Id, @iAdjustment_Date, @iAdjustment_Shift) <> 1)
			Begin
				RaisError('The source stockpile build is not active on this date and shift', 16, 1)
			End
		End



		-- Check to see if this adjustment falls in an already approved month, 
		-- allowing for corrections on the last shift of approved months
		If @iAdjustment_Shift = dbo.GetLastShiftType()
		Begin
			Set @tmpDate = DateAdd(Day, 1, @iAdjustment_Date)
		End
		Else
		Begin
			Set @tmpDate = @iAdjustment_Date
		End

		If dbo.IsInApprovedMonth(@tmpDate) <> 0
		Begin
			RaisError('The adjustment falls in an already approved month', 16, 1)
		End

		-- Insert the manual adjustment record
		Update StockpileAdjustment
			Set Stockpile_Id = @iStockpile_id,
				Build_Id = @iBuild_Id,
				Component_Id = @iComponent_Id,
				Adjustment_Date = @iAdjustment_Date,
				Adjustment_Shift = @iAdjustment_Shift,
				Source_Stockpile_Id = @iSource_Stockpile_Id,
				Source_Build_Id = @iSource_Build_Id,
				Imported_DateTime = GetDate(),
				Is_Add_Or_Remove = @iIs_Add_Or_Remove,
				Is_Stockpile_Transfer = @iIs_Stockpile_Transfer,
				Is_Tonnes_Adjustment = @iIs_Tonnes_Adjustment,
				Is_Grades_Adjustment = @iIs_Grades_Adjustment,
				Is_Manual = @iIs_Manual,
				Tonnes = @iTonnes,
				Description = @iDescription,
				Stockpile_Survey_Sample_Id = @iStockpile_Survey_Sample_Id,
				Use_Given_Moisture_Scaling = @iUse_Given_Moisture_Scaling
			Where Stockpile_Adjustment_Id = @iStockpile_Adjustment_Id
				
				


		/* Raise this as an event */
		Exec dbo.RecalcL2Raise 
			@pDate = @iAdjustment_Date, 
			@pShift = @iAdjustment_Shift
	
		Commit Transaction
	End Try
	Begin Catch
		If @@Trancount > 0 
		Begin
			Rollback Transaction
		End

		--Rethrow the exception
		Declare @ErrorMessage nVarchar(4000),
			@ErrorSeverity Int,
			@ErrorState Int

		Select @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), 
			@ErrorState = ERROR_STATE()

		RaisError(@ErrorMessage, @ErrorSeverity, @ErrorState)
	End Catch
End 
Go 
GRANT EXECUTE ON dbo.UpdateStockpileAdjustment TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="UpdateStockpileAdjustment">
 <Procedure>
	updates a record in the StockpileAdjustment table.
	Raises a Level 2 Recalc for the Adjustment date and shift.
	Errors are raised if:
		The stockpileadjustment, stockpile, build or component does not exist
		The stockpile build is not active on this date and shift
		There is an existing adjustment for this stockpile build on this date and shift
		The adjustment falls in an already approved month
		The source stockpile for the transfer is not active on the given data and shift				
		The source stockpile or source build does not exist
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockExists.prc'
GO

IF OBJECT_ID('dbo.GetModelBlockExists') IS NOT NULL
     DROP PROCEDURE dbo.GetModelBlockExists
GO 
  
CREATE PROCEDURE dbo.GetModelBlockExists
(
	@iBlockModelId INT,
	@iModelBlockId INT,
	@iCode VARCHAR(31),
	@iX FLOAT,
	@iY FLOAT,
	@iZ FLOAT,
	@oExists BIT OUTPUT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SET @oExists = dbo.DoesModelBlockExist(@iBlockModelId, @iModelBlockId, @iCode, @iX, @iY, @iZ)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetModelBlockExists TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetModelBlockExists">
 <Procedure>
	Determines whether a model block already exists.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetModelBlockLocation.prc'
GO

IF OBJECT_ID('dbo.GetModelBlockLocation') IS NOT NULL
     DROP PROCEDURE dbo.GetModelBlockLocation  
GO 
  
CREATE PROCEDURE dbo.GetModelBlockLocation
(
	@iModelBlockId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Loop INT

	DECLARE @LocationStructure TABLE 
	(
		Level INT,
		ParentLocationId INT,
		LocationId INT,
		Name VARCHAR(31) COLLATE DATABASE_DEFAULT,
		LocationTypeId TINYINT,
		LocationTypeDescription VARCHAR(255) COLLATE DATABASE_DEFAULT
	)

	DECLARE @LocationTypes TABLE
	(
		LocationTypeId TINYINT,
		LocationLevel INT,
		AbsParentLocationId VARCHAR(31) COLLATE DATABASE_DEFAULT
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetModelBlockLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @Loop = 0

		-- obtain All the lowest Level heirachies in this digblock location
		INSERT INTO @LocationTypes
		(
			LocationTypeId, LocationLevel, AbsParentLocationId
		)
		SELECT h.Location_Type_Id, h.Location_Level, h.Abs_Parent_Location_Id
		FROM dbo.ModelBlockLocation AS mbl
			INNER JOIN dbo.GetLocationTypeHierarchy(0) AS h
				ON (h.Location_Type_Id = mbl.Location_Type_Id)
		WHERE mbl.Model_Block_Id = @iModelBlockId

		-- Delete the locations which are not of the max location level (bottom child)
		DELETE FROM lt
		FROM @LocationTypes AS lt
			LEFT JOIN
				(
					SELECT AbsParentLocationId, Max(LocationLevel) AS Level
					FROM @LocationTypes
					GROUP BY AbsParentLocationId
				) AS lowest
				ON (lt.AbsParentLocationId = lowest.AbsParentLocationId
					AND lowest.Level = lt.LocationLevel)
		WHERE lowest.AbsParentLocationId IS NULL

		-- from all the lowest location types, build a list.
		INSERT INTO @LocationStructure
		(
			Level, ParentLocationId, LocationId, Name, LocationTypeId, LocationTypeDescription
		)
		SELECT 0, l.Parent_Location_Id, l.Location_Id, l.Name, l.Location_Type_Id, lt.Description
		FROM dbo.ModelBlockLocation AS mbl
			INNER JOIN dbo.Location AS l
				ON (mbl.Location_Id = l.Location_Id)
			INNER JOIN dbo.LocationType AS lt
				ON (l.Location_Type_Id = LT.Location_Type_Id)
		WHERE mbl.Model_Block_Id = @iModelBlockId
			AND l.Location_Type_Id IN
				(
					SELECT LocationTypeId
					FROM @LocationTypes
				)

		-- loop through each child and gather information.
		WHILE EXISTS
			(
				SELECT 1
				FROM @LocationStructure
				WHERE Level = @Loop
			)
		BEGIN
			INSERT INTO @LocationStructure
			(
				Level, ParentLocationId, LocationId, Name, LocationTypeId, LocationTypeDescription
			)
			SELECT ls.Level + 1, l.Parent_Location_Id, l.Location_Id, l.Name, l.Location_Type_Id, lt.Description
			From @LocationStructure AS ls
				INNER JOIN dbo.Location AS l
					ON (ls.ParentLocationId = l.Location_Id)
				INNER JOIN dbo.LocationType AS lt
					ON (l.Location_Type_Id = lt.Location_Type_Id)
			WHERE ls.Level = @Loop

			SET @Loop = @Loop + 1
		END

		SELECT Level, ParentLocationId, LocationId, Name, LocationTypeId, LocationTypeDescription
		FROM @LocationStructure
		ORDER BY Level DESC

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetModelBlockLocation TO CoreBlockModelManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetModelBlockLocation">
 <Procedure>
	Retrieves a record set of all locations in all Hierarchies belonging to the specified Model Block.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockModelBlockList.prc'
GO

IF OBJECT_ID('dbo.GetDigblockModelBlockList') IS NOT NULL
	DROP PROCEDURE dbo.GetDigblockModelBlockList
GO 
  
CREATE PROCEDURE dbo.GetDigblockModelBlockList
(
	@iDigblockId VARCHAR(31),
	@iModelBlockId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT Digblock_Id AS DigblockId,
			Model_Block_Id AS ModelBlockId
		FROM dbo.DigblockModelBlock
		WHERE Model_Block_Id = ISNULL(@iModelBlockId, Model_Block_Id)
			AND Digblock_Id = ISNULL(@iDigblockId, Digblock_Id)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetDigblockModelBlockList TO CoreDigblockManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetDigblockModelBlockList">
 <Procedure>
	Returns a list digblock / model block relationships.
	The two parameters are NULLable to allow dynamic filtering.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpileBuildActive.prc'
GO

IF OBJECT_ID('dbo.GetStockpileBuildActive') IS NOT NULL
     DROP PROCEDURE dbo.GetStockpileBuildActive
GO 
  
CREATE PROCEDURE dbo.GetStockpileBuildActive
(
	@iStockpileId INT,
	@iBuildId INT,
	@iDate DATETIME,
	@iShift CHAR(1),
	@oActive BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1)
	DECLARE @Active BIT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetStockpileBuildActive',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- determine the start/end dates for the build(s)
		IF @iBuildId IS NULL
		BEGIN
			SELECT TOP 1 @StartDate = Start_Date,
				@StartShift = Start_Shift
			FROM dbo.StockpileBuild
			WHERE Stockpile_Id = @iStockpileId
			ORDER BY Start_Date, dbo.GetShiftTypeOrderNo(Start_Shift)

			SELECT TOP 1 @EndDate = End_Date,
				@EndShift = End_Shift
			FROM dbo.StockpileBuild
			WHERE Stockpile_Id = @iStockpileId
			ORDER BY Start_Date DESC, dbo.GetShiftTypeOrderNo(Start_Shift) DESC
		END
		ELSE
		BEGIN
			SELECT @StartDate = Start_Date,
				@StartShift = Start_Shift,
				@EndDate = End_Date,
				@EndShift = End_Shift
			FROM dbo.StockpileBuild
			WHERE Stockpile_Id = @iStockpileId
				AND Build_Id = @iBuildId
		END

		-- determine if the date range provided falls within the date range requested
		SET @Active = 0

		IF ((dbo.CompareDateShift(@iDate, @iShift, '>=', @StartDate, @StartShift) = 1) OR (@StartDate IS NULL))
			AND ((dbo.CompareDateShift(@iDate, @iShift, '<=', @EndDate, @EndShift) = 1) OR (@EndDate IS NULL))
		BEGIN
			SET @Active = 1
		END

		-- return the result
		SET @oActive = @Active

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetStockpileBuildActive TO CoreStockpileManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetStockpileBuildActive">
 <Procedure>
	Check to see whether the stockpile build is currently active note that the @Build_Id
	is optional it is a requirement that whenever a Start_Date != NULL, the Start_Shift 
	must also be not NULL the same requirement is true for End_Date and End_Shift.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationTypeParentList.prc'
GO

 IF OBJECT_ID('dbo.GetLocationTypeParentList') IS NOT NULL
     DROP PROCEDURE dbo.GetLocationTypeParentList  
GO 
  
CREATE PROCEDURE dbo.GetLocationTypeParentList 
(
	@iLocationTypeId TINYINT,
	@iLocationTypeDescription VARCHAR(31)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount TINYINT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @LocationTypeId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetLocationTypeParentList',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @LocationTypeId = @iLocationTypeId
		IF @LocationTypeId IS NULL
		BEGIN
			SELECT @LocationTypeId = LT.Location_Type_Id
			FROM dbo.LocationType AS LT
			WHERE LT.Description = @iLocationTypeDescription
		END

		SELECT LT.Location_Type_Id, LT.Parent_Location_Type_Id, LT.Description, LT.Defines_3d_Point
		FROM dbo.GetLocationTypeParentLocationTypeList(@LocationTypeId) AS LTP
			INNER JOIN dbo.LocationType AS LT
				ON (LTP.Location_Type_Id = LT.Location_Type_Id)
		ORDER BY LT.Location_Type_Id
		
		
		--

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetLocationTypeParentList TO CoreUtilityManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetLocationTypeParentList">
 <Procedure>
	This Procedure returns the parent list of the location type with the given location type id or description.
 </Procedure>
</TAG>
*/	

--exec dbo.GetLocationTypeParentList 3, null


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationLookup.prc'
GO

IF OBJECT_ID('dbo.GetLocationLookup') IS NOT NULL
	DROP PROCEDURE dbo.GetLocationLookup
GO 
  
CREATE PROCEDURE dbo.GetLocationLookup
(
	@iRootLocationId INT,
	@iHighestLocationTypeId SMALLINT,
	@iLowestLocationTypeId SMALLINT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT l.Location_Id, l.Parent_Location_Id, l.Location_Type_Id, l.Name
		FROM dbo.GetLocationSubtreeByLocationType(@iRootLocationId, @iHighestLocationTypeId, @iLowestLocationTypeId) AS s
			INNER JOIN dbo.Location AS l
				ON (s.LocationId = l.Location_Id)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetLocationLookup TO CoreUtilityManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetLocationParentLocationId.prc'
GO

IF OBJECT_ID('dbo.GetLocationParentLocationId') IS NOT NULL
	DROP PROCEDURE dbo.GetLocationParentLocationId
GO 
  
CREATE PROCEDURE dbo.GetLocationParentLocationId 
(
	@iLocationId INT,
	@oParentLocationId INT OUTPUT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SET @oParentLocationId =
			(
				SELECT Parent_Location_Id
				FROM dbo.Location
				WHERE Location_Id = @iLocationId
			)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetLocationParentLocationId TO CoreUtilityManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.AddOrUpdateHaulageRawLocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.AddOrUpdateHaulageRawLocation') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateHaulageRawLocation 
GO 
  
CREATE PROCEDURE dbo.AddOrUpdateHaulageRawLocation
(
	@iHaulageRawId INT,
	@iSourceLocationId INT,
	@iDestinationLocationId INT,
	@iUpdateSourceLocationId BIT = 1,
	@iUpdateDestinationLocationId BIT = 1
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateHaulageRawLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF EXISTS (SELECT TOP 1 1
			FROM HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId AND
				Haulage_Raw_State_Id <> 'A')
		BEGIN
		RAISERROR('AddOrUpdateHaulageRawLocation: Raw haulage must be in the awaiting correction state.', 16, 1)
		END
		ELSE
		BEGIN
			IF EXISTS 
				(
				SELECT TOP 1 1
				FROM HaulageRawLocation
				WHERE HaulageRawId = @iHaulageRawId
				)
			BEGIN
				UPDATE HaulageRawLocation
				SET SourceLocationId = CASE WHEN (@iUpdateSourceLocationId = 1) THEN @iSourceLocationId ELSE SourceLocationId END,
					DestinationLocationId = CASE WHEN (@iUpdateDestinationLocationId = 1) THEN @iDestinationLocationId ELSE DestinationLocationId END
				WHERE HaulageRawId = @iHaulageRawId
			END
			ELSE
			BEGIN
				INSERT INTO HaulageRawLocation
				(
					HaulageRawId, SourceLocationId, DestinationLocationId
				)
				VALUES
				(
					@iHaulageRawId, @iSourceLocationId, @iDestinationLocationId
				)
			END
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddOrUpdateHaulageRawLocation TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateHaulageRawLocation">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageRawLocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.DeleteHaulageRawLocation') IS NOT NULL
     DROP PROCEDURE dbo.DeleteHaulageRawLocation  
GO 
  
CREATE PROCEDURE dbo.DeleteHaulageRawLocation 
(
	@iHaulageRawId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteHaulageRawLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		IF EXISTS
		(
			SELECT TOP 1 1
			FROM dbo.HaulageRaw
			WHERE Haulage_Raw_Id = @iHaulageRawId 
				AND Haulage_Raw_State_Id <> 'A'
		)
		BEGIN
			RAISERROR('DeleteHaulageRawLocation: Raw haulage must be in the awaiting correction state.', 16, 1)
		END
		ELSE
		BEGIN
			IF EXISTS 
			(
				SELECT TOP 1 1
				FROM dbo.HaulageRawLocation
				WHERE HaulageRawId = @iHaulageRawId
			)
			BEGIN
				DELETE FROM dbo.HaulageRawLocation WHERE HaulageRawId = @iHaulageRawId
			END
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteHaulageRawLocation TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteHaulageRawLocation">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcEventByDate.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetRecalcEventByDate') IS NOT NULL
	DROP PROCEDURE dbo.GetRecalcEventByDate  
GO 
  
CREATE PROCEDURE dbo.GetRecalcEventByDate
( 
    @iRecalcDate DATETIME,
    @iRecalcState VARCHAR(31),
    @iRecalcLevel INT
)  
WITH ENCRYPTION
AS 
BEGIN 
	-- variable declaration here

	SET NOCOUNT ON 

	BEGIN TRY
		SELECT RH.*, 
			RS.Name As Recalc_State_Name, 
			RS.Description As Recalc_State_Description
		FROM dbo.RecalcHistory As RH
			LEFT JOIN dbo.RecalcState As RS
				ON RH.Recalc_State_Id = RS.Recalc_State_Id
		WHERE ((@iRecalcLevel = 1 AND Recalc_Type_Id = 'Level 1')
				OR (@iRecalcLevel = 2 AND Recalc_Type_Id = 'Level 2')
				OR @iRecalcLevel IS NULL)
			AND (@iRecalcState = RS.Name OR @iRecalcState IS NULL)
			AND @iRecalcDate BETWEEN RH.Start_Date AND RH.End_Date
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetRecalcEventByDate TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="GetRecalcEventByDate">
 <Procedure>
	Retreives a specific Recalc History Log entry and returns it along with its Recalc State Record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetStockpilesWithAdjustments.prc'
GO

 IF OBJECT_ID('dbo.GetStockpilesWithAdjustments') IS NOT NULL
	DROP PROCEDURE dbo.GetStockpilesWithAdjustments
GO 

CREATE PROCEDURE dbo.GetStockpilesWithAdjustments
(
	@iLocationId INT = NULL
)
AS 
BEGIN 
	SET NOCOUNT ON

	BEGIN TRY
		
	SELECT Distinct sa.Stockpile_Id, s.Stockpile_Name, s.Description	
	FROM dbo.StockpileAdjustment AS sa
		INNER JOIN dbo.Stockpile AS s
			ON (sa.Stockpile_Id = s.Stockpile_Id)
		LEFT OUTER JOIN 
		(
			SELECT sp.Stockpile_Id, IsNull(sl.Location_Id, 0) AS Location_Id
			FROM dbo.Stockpile AS sp
				LEFT OUTER JOIN dbo.StockpileLocation AS sl
					ON (sp.Stockpile_Id = sl.Stockpile_Id)		
		) AS l		
			ON s.Stockpile_Id = l.Stockpile_Id			
	WHERE  (				
				@iLocationId IS NULL
					OR l.Location_Id IN 
					(	
						SELECT Location_Id
						FROM dbo.GetLocationSubtree(@iLocationId)
					)
			)
		ORDER BY Stockpile_Name
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetStockpilesWithAdjustments TO CoreStockpileManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationTypeDefaultRules.prc'
GO

IF OBJECT_ID('dbo.GetNotificationTypeDefaultRules') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationTypeDefaultRules
GO 

CREATE PROCEDURE dbo.GetNotificationTypeDefaultRules
(
	@iTypeId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY

		SELECT TypeId, PreviousSampleStateId, CurrentSampleStateId, nst.SampleTrendId,
			RaiseNotifyAttempt, RaiseReminderAttempt, nssp.Name AS PreviousSampleStateName,
			nssp.Description AS PreviousSampleStateDescription,	nssc.Name AS CurrentSampleStateName,
			nssc.Description As CurrentSampleStateDescription, nst.Name AS SampleTrendName, nst.Description AS SampleTrendDescription
		FROM dbo.NotificationTypeRegistration AS ntr
			LEFT JOIN dbo.NotificationSampleState AS nssc
				ON nssc.SampleStateId = ntr.CurrentSampleStateId
			LEFT JOIN dbo.NotificationSampleState AS nssp
				ON nssp.SampleStateId = ntr.PreviousSampleStateId
			INNER JOIN dbo.NotificationSampleTrend AS nst
				ON nst.SampleTrendId = ntr.SampleTrendId
		WHERE TypeId = @iTypeId

	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationTypeDefaultRules TO CoreNotificationManager
GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DbaClearUnusedLocations.prc'
GO

IF OBJECT_ID('dbo.DbaClearUnusedLocations') IS NOT NULL
	DROP PROCEDURE dbo.DbaClearUnusedLocations 
GO 
  
CREATE PROCEDURE dbo.DbaClearUnusedLocations
AS 
BEGIN 
	DECLARE @LocationCursor CURSOR
	DECLARE @LocationId INT
	DECLARE @IsError BIT
	DECLARE @ErrorMessage VARCHAR(255)

	-- finds locations that are no longer referenced and trys to remove them
	-- note: it's not clever enough to know about any third party configured references
	--       if you've been good and added FK relationships then this will crash but no harm done!

	SET NOCOUNT ON 

	BEGIN TRY
		SET @LocationCursor = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
			SELECT Location_Id
			FROM dbo.Location
			ORDER BY Location_Id DESC

		OPEN @LocationCursor
		FETCH NEXT FROM @LocationCursor INTO @LocationId
		WHILE @@FETCH_STATUS = 0
		BEGIN
			Print 'Trying: ' + CONVERT(VARCHAR(16), @LocationId)
			
			EXEC dbo.TryDeleteLocation
				@iLocationId = @LocationId,
				@iName = NULL,
				@iLocationTypeId = NULL,
				@iParentLocationName = NULL,
				@oIsError = @IsError OUTPUT,
				@oErrorMessage = @ErrorMessage OUTPUT

			IF @IsError = 0
			BEGIN
				PRINT 'Deleted: ' + CONVERT(VARCHAR(16), @LocationId)
			END

			FETCH NEXT FROM @LocationCursor INTO @LocationId
		END
		CLOSE @LocationCursor
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO


GO


Print 'Code: ReconcilorCore->schema\Procedures\dbo.getstockpilegrouplistbylocation.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetStockpileGroupListByLocation') IS NOT NULL
     DROP PROCEDURE dbo.GetStockpileGroupListByLocation  
GO 
  
CREATE PROCEDURE dbo.GetStockpileGroupListByLocation
(
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetStockpileGroupListByLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF @iLocationId IS NOT NULL
		BEGIN
			SELECT sgs.Stockpile_Group_Id 
			FROM dbo.StockpileGroupStockpile AS sgs
				INNER JOIN dbo.StockpileLocation AS sl
					ON sgs.Stockpile_Id = sl.Stockpile_Id
				INNER JOIN dbo.GetLocationSubtree(@iLocationId) AS l
					ON l.Location_Id = sl.Location_Id
			GROUP BY sgs.Stockpile_Group_Id
		END
		ELSE
		BEGIN
			SELECT Stockpile_Group_Id
			FROM dbo.StockpileGroup
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetStockpileGroupListByLocation TO CoreUtilityManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetStockpileGroupListByLocation">
 <Procedure>
	Returns all stockpile groups which have stockpiles in them for a particular location.
	Required by notification module.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationInstance  
GO 
  
CREATE PROCEDURE dbo.GetNotificationInstance
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.GetNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT InstanceId
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RAISERROR('The Notification does not exist.', 16, 1)
		END

		-- return the base instance information
		SELECT ni.Name, ni.TypeId, nt.Name AS TypeName, ni.Description, nr.Name AS RuleName,
		    ni.Active, ni.Reminder, ni.ReminderMinutes, ni.CheckStateMinutes, ni.OwnerUserId,
		    ni.Threshold, ni.Version
		FROM dbo.NotificationInstance AS ni
			INNER JOIN dbo.NotificationType AS nt
				ON (nt.TypeId = ni.TypeId)
			INNER JOIN dbo.NotificationRule AS nr
				ON (ni.RuleId = nr.RuleId)
		WHERE ni.InstanceId = @iInstanceId

		-- return the state information
		SELECT CurrentValue, PreviousValue, LastNotified
		FROM dbo.NotificationInstanceState
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstances.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstances') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationInstances  
GO 
  
CREATE PROCEDURE dbo.GetNotificationInstances
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 
  
	BEGIN TRY
		-- return the instance information
		SELECT i.InstanceId, i.Name AS InstanceName, i.Active, i.OwnerUserId As InstanceOwner,
			t.TypeId, t.Name AS TypeName
		FROM dbo.NotificationInstance AS i
			INNER JOIN dbo.NotificationType AS t
				ON (t.TypeId = i.TypeId)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstances TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationTypeRegistration.prc'
GO

IF OBJECT_ID('dbo.GetNotificationTypeRegistration') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationTypeRegistration
GO 

CREATE PROCEDURE dbo.GetNotificationTypeRegistration
(
	@iTypeName VARCHAR(64)
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iTypeName IS NULL
		BEGIN
			RAISERROR('The Type Name must not be null.', 16, 1)
		END

		SELECT currentState.Name AS CurrentSampleState,
			previousState.Name AS PreviousSampleState,
			trend.Name AS SampleTrend,
			r.RaiseNotifyAttempt, r.RaiseReminderAttempt
		FROM dbo.NotificationType AS t
			INNER JOIN dbo.NotificationTypeRegistration AS r
				ON (t.TypeId = r.TypeId)
			INNER JOIN dbo.NotificationSampleState AS currentState
				ON (currentState.SampleStateId = r.CurrentSampleStateId)
			LEFT OUTER JOIN dbo.NotificationSampleState AS previousState
				ON (previousState.SampleStateId = r.PreviousSampleStateId)
			LEFT OUTER JOIN dbo.NotificationSampleTrend AS trend
				ON (trend.SampleTrendId = r.SampleTrendId)
		WHERE t.Name = @iTypeName
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationTypeRegistration TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.SaveNotificationInstanceState.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceState') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceState
GO 
  
CREATE PROCEDURE dbo.SaveNotificationInstanceState
(
	@iInstanceId INT,
	@iPreviousValue XML,
	@iCurrentValue XML,
	@iLastNotified DATETIME
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.SaveNotificationInstanceState',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RAISERROR('The notification cannot be found.', 16, 1)
		END

		-- perform a classic 'upsert'
		IF EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceState
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			UPDATE dbo.NotificationInstanceState
			SET CurrentValue = @iCurrentValue,
				PreviousValue = @iPreviousValue,
				LastNotified = @iLastNotified
			WHERE InstanceId = @iInstanceId
		END
		ELSE
		BEGIN
			INSERT INTO dbo.NotificationInstanceState
				(InstanceId, CurrentValue, PreviousValue, LastNotified)
			VALUES
				(@iInstanceId, @iCurrentValue, @iPreviousValue, @iLastNotified)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceState TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceSubscription.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceSubscription') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationInstanceSubscription  
GO 
  
CREATE PROCEDURE dbo.GetNotificationInstanceSubscription 
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)


	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetNotificationInstanceSubscription',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		-- return user based entries
		SELECT u.FirstName, u.LastName, u.EmailAddress, u.UserId
		FROM dbo.SecurityUser AS u
			INNER JOIN dbo.NotificationInstanceSubscription AS s
				ON (u.UserId = s.UserId)
		WHERE s.InstanceId = @iInstanceId

		-- return non-user based email entries
		SELECT EmailAddress
		FROM dbo.NotificationInstanceSubscription
		WHERE UserId IS NULL
			AND InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceSubscription TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceOwner.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceOwner') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceOwner
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceOwner
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT u.FirstName, u.LastName, u.EmailAddress
		FROM dbo.SecurityUser AS u
			INNER JOIN dbo.NotificationInstance AS i
				ON (u.UserId = i.OwnerUserId)
		WHERE i.InstanceId = @iInstanceId

	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceOwner TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceHaulage.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceHaulage') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceHaulage
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceHaulage
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT LocationId
		FROM dbo.NotificationInstanceHaulage
		WHERE InstanceId = @iInstanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceHaulage TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationSampleStates.prc'
GO

IF OBJECT_ID('dbo.GetNotificationSampleStates') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationSampleStates
GO 
  
CREATE PROCEDURE dbo.GetNotificationSampleStates
WITH ENCRYPTION
AS
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT SampleStateId, Name, Description
		FROM dbo.NotificationSampleState
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationSampleStates TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationSampleTrends.prc'
GO

IF OBJECT_ID('dbo.GetNotificationSampleTrends') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationSampleTrends
GO 
  
CREATE PROCEDURE dbo.GetNotificationSampleTrends
WITH ENCRYPTION
AS
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT SampleTrendId, Name, Description
		FROM dbo.NotificationSampleTrend
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationSampleTrends TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationTypes.prc'
GO

IF OBJECT_ID('dbo.GetNotificationTypes') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationTypes
GO 
  
CREATE PROCEDURE dbo.GetNotificationTypes
WITH ENCRYPTION
AS
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT TypeId, Name, Description
		FROM dbo.NotificationType
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationTypes TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceVersion.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceVersion') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationInstanceVersion  
GO 
  
CREATE PROCEDURE dbo.GetNotificationInstanceVersion
(
	@iInstanceId INT,
	@oVersion BINARY(8) OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 
  
	BEGIN TRY
		SET @oVersion =
			(
				SELECT Version
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceVersion TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.ActivateNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.ActivateNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.ActivateNotificationInstance
GO 

CREATE PROCEDURE dbo.ActivateNotificationInstance
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'ActivateNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RAISERROR('The instance does not exist.', 16, 1)
		END

		UPDATE dbo.NotificationInstance
		SET Active = 1
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ActivateNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.AddNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.AddNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.AddNotificationInstance
GO 

CREATE PROCEDURE dbo.AddNotificationInstance
(
	@iTypeName VARCHAR(64),
	@iName VARCHAR(64),
	@iDescription VARCHAR(MAX),
	@iRuleName VARCHAR(64),
	@iReminder BIT,
	@iReminderMinutes INT,
	@iCheckStateMinutes INT,
	@iOwnerUserId INT,
	@iThreshold XML,
	@oInstanceId INT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	-- note: Active, Version are excluded on purpose
	-- these are managed by other routines / methods

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO dbo.NotificationInstance
		(
			TypeId, Name, Description, RuleId, Active, Reminder, ReminderMinutes,
			CheckStateMinutes, OwnerUserId, Threshold
		)
		SELECT t.TypeId, @iName, @iDescription, r.RuleId, 1, @iReminder, @iReminderMinutes,
			@iCheckStateMinutes, @iOwnerUserId, @iThreshold
		FROM dbo.NotificationType AS t
			CROSS JOIN dbo.NotificationRule AS r
		WHERE t.Name = @iTypeName
			AND r.Name = @iRuleName

		SET @oInstanceId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DeactivateNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.DeactivateNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.DeactivateNotificationInstance
GO 

CREATE PROCEDURE dbo.DeactivateNotificationInstance
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeactivateNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RAISERROR('The instance does not exist.', 16, 1)
		END

		UPDATE dbo.NotificationInstance
		SET Active = 0
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeactivateNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DeleteNotificationInstanceState.prc'
GO

IF OBJECT_ID('dbo.DeleteNotificationInstanceState') IS NOT NULL
     DROP PROCEDURE dbo.DeleteNotificationInstanceState  
GO 
  
CREATE PROCEDURE dbo.DeleteNotificationInstanceState
(
	@iInstanceId INT
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteNotificationInstanceState',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		DELETE 
		FROM dbo.NotificationInstanceState
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteNotificationInstanceState TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteNotificationInstanceState">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.UpdateNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.UpdateNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.UpdateNotificationInstance
GO 
  
CREATE PROCEDURE dbo.UpdateNotificationInstance
(
	@iInstanceId INT,
	@iUpdateName BIT,
	@iName VARCHAR(64),
	@iUpdateDescription BIT,
	@iDescription VARCHAR(MAX),
	@iUpdateRuleName BIT,
	@iRuleName VARCHAR(64),
	@iUpdateReminder BIT,
	@iReminder BIT,
	@iUpdateReminderMinutes BIT,
	@iReminderMinutes INT,
	@iUpdateCheckStateMinutes BIT,
	@iCheckStateMinutes INT,
	@iUpdateOwnerUserId BIT,
	@iOwnerUserId INT,
	@iUpdateThreshold BIT,
	@iThreshold XML
)
WITH ENCRYPTION
AS 
BEGIN 
	-- note: Active, TypeId, Version are excluded on purpose
	-- these are managed by other routines / methods

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RAISERROR('The instance does not exist.', 16, 1)
		END

		IF (@iUpdateRuleName = 1) AND NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationRule
				WHERE Name = @iRuleName
			)
		BEGIN
			RAISERROR('The rule name does not exist.', 16, 1)
		END

		UPDATE dbo.NotificationInstance
		SET	Name = (CASE WHEN @iUpdateName = 1 THEN @iName ELSE Name END),
			Description = (CASE WHEN @iUpdateDescription = 1 THEN @iDescription ELSE Description END),
			RuleId =
				(
					CASE
						WHEN @iUpdateRuleName = 1
							THEN (SELECT RuleId FROM dbo.NotificationRule WHERE Name = @iRuleName)
						ELSE RuleId
					END
				),
			Reminder = (CASE WHEN @iUpdateReminder = 1 THEN @iReminder ELSE Reminder END),
			ReminderMinutes = (CASE WHEN @iUpdateReminderMinutes = 1 THEN @iReminderMinutes ELSE ReminderMinutes END),
			CheckStateMinutes = (CASE WHEN @iUpdateCheckStateMinutes = 1 THEN @iCheckStateMinutes ELSE CheckStateMinutes END),
			OwnerUserId = (CASE WHEN @iUpdateOwnerUserId = 1 THEN @iOwnerUserId ELSE OwnerUserId END),
			Threshold = (CASE WHEN @iUpdateThreshold = 1 THEN @iThreshold ELSE Threshold END)
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DbaNotificationCreateTypeRegistrations.prc'
GO

IF OBJECT_ID('dbo.DbaNotificationCreateTypeRegistrations') IS NOT NULL
     DROP PROCEDURE dbo.DbaNotificationCreateTypeRegistrations  
GO 
  
CREATE PROCEDURE dbo.DbaNotificationCreateTypeRegistrations 
(
	@iTypeName VARCHAR(64)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Load TABLE
	(
		PreviousState VARCHAR(64) COLLATE DATABASE_DEFAULT NULL,
		CurrentState VARCHAR(64) COLLATE DATABASE_DEFAULT NOT NULL,
		Trend VARCHAR(64) COLLATE DATABASE_DEFAULT NULL,
		RaiseNotifyAttempt BIT NOT NULL,
		RaiseRemindAttempt BIT NOT NULL
	)
	DECLARE @Records INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.DbaNotificationCreateTypeRegistrations',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Load
			(PreviousState, CurrentState, Trend, RaiseNotifyAttempt, RaiseRemindAttempt)
		SELECT 'AtThreshold', 'NegativeThreshold', 'NegativeTrend', 1, 0
		UNION ALL
		SELECT 'NegativeThreshold', 'NegativeThreshold', 'NegativeTrend', 0, 1
		UNION ALL
		SELECT 'PositiveThreshold', 'PositiveThreshold', 'NegativeTrend', 0, 0
		UNION ALL
		SELECT 'PositiveThreshold', 'AtThreshold', 'NegativeTrend', 0, 0
		UNION ALL
		SELECT 'PositiveThreshold', 'NegativeThreshold', 'NegativeTrend', 1, 0
		UNION ALL
		SELECT 'AtThreshold', 'AtThreshold', 'NoTrend', 0, 0
		UNION ALL
		SELECT 'NegativeThreshold', 'NegativeThreshold', 'NoTrend', 0, 1
		UNION ALL
		SELECT 'PositiveThreshold', 'PositiveThreshold', 'NoTrend', 0, 0
		UNION ALL
		SELECT 'AtThreshold', 'PositiveThreshold', 'PositiveTrend', 0, 0
		UNION ALL
		SELECT 'NegativeThreshold', 'PositiveThreshold', 'PositiveTrend', 0, 0
		UNION ALL
		SELECT 'NegativeThreshold', 'AtThreshold', 'PositiveTrend', 0, 0
		UNION ALL
		SELECT 'NegativeThreshold', 'NegativeThreshold', 'PositiveTrend', 0, 1
		UNION ALL
		SELECT 'PositiveThreshold', 'PositiveThreshold', 'PositiveTrend', 0, 0
		UNION ALL
		SELECT NULL, 'PositiveThreshold', NULL, 0, 0
		UNION ALL
		SELECT NULL, 'AtThreshold', NULL, 0, 0
		UNION ALL
		SELECT NULL, 'NegativeThreshold', NULL, 1, 0

		SET @Records = 
			(
				SELECT COUNT(1)
				FROM @Load
			)

		INSERT INTO dbo.NotificationTypeRegistration
			(TypeId, PreviousSampleStateId, CurrentSampleStateId, SampleTrendId, RaiseNotifyAttempt, RaiseReminderAttempt)
		SELECT t.TypeId, previousState.SampleStateId, currentState.SampleStateId, st.SampleTrendId, l.RaiseNotifyAttempt, l.RaiseRemindAttempt
		FROM @Load AS l
			INNER JOIN dbo.NotificationType AS t
				ON (t.Name = @iTypeName)
			INNER JOIN dbo.NotificationSampleState AS currentState
				ON (currentState.Name = l.CurrentState)
			LEFT OUTER JOIN dbo.NotificationSampleState AS previousState
				ON (previousState.Name = l.PreviousState)
			LEFT OUTER JOIN dbo.NotificationSampleTrend AS st
				ON (st.Name = l.Trend)

		PRINT CONVERT(VARCHAR(12), @@RowCount) + ' out of ' + CONVERT(VARCHAR(12), @Records) + ' notification type registrations inserted.'

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO



GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.SaveNotificationInstanceHaulage.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceHaulage') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceHaulage
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceHaulage
(
	@iInstanceId INT,
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceHaulage',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceHaulage
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceHaulage
				(InstanceId, LocationId)
			VALUES
				(@iInstanceId, @iLocationId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceHaulage
			SET LocationId = @iLocationId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceHaulage TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DeleteNotificationInstanceEmailSubscription.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.DeleteNotificationInstanceEmailSubscription') IS NOT NULL
     DROP PROCEDURE dbo.DeleteNotificationInstanceEmailSubscription  
GO 
  
CREATE PROCEDURE dbo.DeleteNotificationInstanceEmailSubscription 
(
	@iInstanceId INT,
	@iEmailAddress VARCHAR(256)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteNotificationInstanceEmailSubscription',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RaisError('The instance does not exist', 16, 1)
		END

		DELETE 
		FROM dbo.NotificationInstanceSubscription
		WHERE InstanceId = @iInstanceId
			AND EmailAddress = @iEmailAddress

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteNotificationInstanceEmailSubscription TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteNotificationInstanceEmailSubscription">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DeleteNotificationInstanceUserSubscription.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.DeleteNotificationInstanceUserSubscription') IS NOT NULL
     DROP PROCEDURE dbo.DeleteNotificationInstanceUserSubscription  
GO 
  
CREATE PROCEDURE dbo.DeleteNotificationInstanceUserSubscription
(
	@iInstanceId INT,
	@iUserId INT
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteNotificationInstanceUserSubscription',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.NotificationInstance
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			RaisError('The instance does not exist', 16, 1)
		END

		DELETE 
		FROM dbo.NotificationInstanceSubscription
		WHERE InstanceId = @iInstanceId
			AND UserId = @iUserId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteNotificationInstanceUserSubscription TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteNotificationInstanceUserSubscription">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.SaveNotificationInstanceSubscription.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.SaveNotificationInstanceSubscription') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceSubscription  
GO 
  
CREATE PROCEDURE dbo.SaveNotificationInstanceSubscription
(
	@iInstanceId INT,
	@iUserId INT,
	@iEmailAddress VARCHAR(256),
	@oInstanceSubscriptionId INT OUTPUT
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceSubscription',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- code goes here
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		IF 
			(
				(
					@iUserId IS NULL
					AND @iEmailAddress IS NULL
				)	
				OR
				(
					@iUserId IS NOT NULL
					AND @iEmailAddress IS NOT NULL
				)	
			)		
		BEGIN
			RAISERROR('The User Id or Email Address must be provided.', 16, 1)
		END

		INSERT INTO dbo.NotificationInstanceSubscription
		(
			InstanceId, Userid, EmailAddress
		)
		SELECT @iInstanceId, @iUserId, @iEmailAddress

		SET @oInstanceSubscriptionId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceSubscription TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.SaveNotificationInstanceSubscription">
 <Procedure>
	Saves a notification instance subscription
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceImport.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceImport') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceImport
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceImport
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT ImportId
		FROM dbo.NotificationInstanceImport
		WHERE InstanceId = @iInstanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceImport TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.SaveNotificationInstanceImport.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceImport') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceImport
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceImport
(
	@iInstanceId INT,
	@iImportId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceImport',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceImport
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceImport
				(InstanceId, ImportId)
			VALUES
				(@iInstanceId, @iImportId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceImport
			SET ImportId = @iImportId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceImport TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.GetNotificationInstanceNegativeStockpile.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceNegativeStockpile') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceNegativeStockpile
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceNegativeStockpile
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT StockpileSelectionType, StockpileId, StockpileGroupId, LocationId
		FROM dbo.NotificationInstanceNegativeStockpile
		WHERE InstanceId = @iInstanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceNegativeStockpile TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.SaveNotificationInstanceNegativeStockpile.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceNegativeStockpile') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceNegativeStockpile
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceNegativeStockpile
(
	@iInstanceId INT,
	@iStockpileSelectionType VARCHAR(31),
	@iStockpileId INT,
	@iStockpileGroupId VARCHAR(31),
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceNegativeStockpile',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceNegativeStockpile
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceNegativeStockpile
				(InstanceId, StockpileSelectionType, StockpileId, StockpileGroupId, LocationId)
			VALUES
				(@iInstanceId, @iStockpileSelectionType, @iStockpileId, @iStockpileGroupId, @iLocationId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceNegativeStockpile
			SET StockpileSelectionType = @iStockpileSelectionType,
				StockpileId = @iStockpileId,
				StockpileGroupId = @iStockpileGroupId,
				LocationId = @iLocationId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceNegativeStockpile TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.getnotificationinstancecrusher.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceCrusher') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceCrusher
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceCrusher
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT CrusherId, LocationId
		FROM dbo.NotificationInstanceCrusher
		WHERE InstanceId = @iInstanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceCrusher TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.getnotificationinstancemill.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceMill') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceMill
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceMill
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT MillId, LocationId
		FROM dbo.NotificationInstanceMill
		WHERE InstanceId = @iInstanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceMill TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.savenotificationinstancecrusher.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceCrusher') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceCrusher
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceCrusher
(
	@iInstanceId INT,
	@iCrusherId VARCHAR(31),
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceCrusher',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceCrusher
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceCrusher
				(InstanceId, CrusherId, LocationId)
			VALUES
				(@iInstanceId, @iCrusherId, @iLocationId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceCrusher
			SET CrusherId = @iCrusherId,
				LocationId = @iLocationId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceCrusher TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.savenotificationinstancemill.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceMill') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceMill
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceMill
(
	@iInstanceId INT,
	@iMillId VARCHAR(31),
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceMill',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceMill
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceMill
				(InstanceId, MillId, LocationId)
			VALUES
				(@iInstanceId, @iMillId, @iLocationId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceMill
			SET MillId = @iMillId,
				LocationId = @iLocationId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceMill TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.savenotificationinstanceaudit.prc'
GO

IF OBJECT_ID('dbo.SaveNotificationInstanceAudit') IS NOT NULL
     DROP PROCEDURE dbo.SaveNotificationInstanceAudit
GO 

CREATE PROCEDURE dbo.SaveNotificationInstanceAudit
(
	@iInstanceId INT,
	@iAuditTypeId INT,
	@iAuditTypeGroupId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SaveNotificationInstanceAudit',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.NotificationInstanceAudit
				WHERE InstanceId = @iInstanceId
			)
		BEGIN
			INSERT INTO dbo.NotificationInstanceAudit
				(InstanceId, AuditTypeId, AuditTypeGroupId)
			VALUES
				(@iInstanceId, @iAuditTypeId, @iAuditTypeGroupId)
		END
		ELSE
		BEGIN
			UPDATE dbo.NotificationInstanceAudit
			SET AuditTypeId = @iAuditTypeId,
				AuditTypeGroupId = @iAuditTypeGroupId
			WHERE InstanceId = @iInstanceId
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SaveNotificationInstanceAudit TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.getnotificationinstanceaudit.prc'
GO

IF OBJECT_ID('dbo.GetNotificationInstanceAudit') IS NOT NULL
	DROP PROCEDURE dbo.GetNotificationInstanceAudit
GO 

CREATE PROCEDURE dbo.GetNotificationInstanceAudit
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF @iInstanceId IS NULL
		BEGIN
			RAISERROR('The Instance Id must not be null.', 16, 1)
		END

		SELECT AuditTypeId, AuditTypeGroupId
		FROM dbo.NotificationInstanceAudit
		WHERE InstanceId = @iInstanceId
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationInstanceAudit TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\notification\dbo.GetNotificationRecalcTransactions.prc'
GO

IF OBJECT_ID('dbo.GetNotificationRecalcTransactions') IS NOT NULL
     DROP PROCEDURE dbo.GetNotificationRecalcTransactions  
GO 
  
CREATE PROCEDURE dbo.GetNotificationRecalcTransactions

WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @StartDateTime DATETIME
	DECLARE @StartDate DATETIME
	DECLARE @EndDate DATETIME
	DECLARE @EndDateTime DATETIME
	DECLARE @RecalcState VARCHAR(31)
	DECLARE @CurrentProcessingDate DATETIME
	DECLARE @CurrentProcessingShift CHAR(1)
	DECLARE @NewEndDate DATETIME
	DECLARE @NewEndShift CHAR(1)
	DECLARE @CurrentL2Date DATETIME
	DECLARE @Cursor CURSOR
	DECLARE @InnerCursor CURSOR

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetNakedL1Transactions',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
	CREATE TABLE #SuccessfulL2Occurence
	(
		ProcessedTime DATETIME,
		ProcessedDate DATETIME
	)

	SET @Cursor = CURSOR LOCAL FOR
	SELECT Start_Datetime, Start_Date, End_Date, End_Datetime, Current_Processing_Date, Current_Processing_Shift, rs2.Name
	FROM dbo.RecalcHistory AS rh
		INNER JOIN dbo.RecalcState AS rs2
			ON rs2.Recalc_State_Id = rh.Recalc_State_Id
	WHERE Recalc_Type_Id = 'Level 2'
		AND rs2.Name IN ('Cancelled','Fail','Success')
	ORDER BY End_DateTime DESC

	OPEN @Cursor
	FETCH NEXT FROM @Cursor INTO @StartDateTime, @StartDate, @EndDate, @EndDateTime, @CurrentProcessingDate,@CurrentProcessingShift, @RecalcState
	WHILE @@FETCH_STATUS = 0
	BEGIN
		
		-- If this one hasn't succeeded, then get the last date it succeeded for.
		IF @RecalcState <> 'Success'
		BEGIN
		EXEC GetPreviousDateShift
			@Date = @CurrentProcessingDate,
			@Shift = @CurrentProcessingShift, 
			@Previous_Date = @NewEndDate, 
			@Previous_Shift = @NewEndShift
		END
		ELSE
		BEGIN
			SET @NewEndDate = @EndDate
		END

		SET @InnerCursor = CURSOR LOCAL FOR
		SELECT Start_Date FROM dbo.GetDateRAngeList(@StartDate,@NewEndDate,'DAY',1)

		OPEN @InnerCursor
		FETCH NEXT FROM @InnerCursor INTO @CurrentL2Date
		WHILE @@FETCH_STATUS = 0
		BEGIN

			--Make sure we insert the latest L2.
			IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM #SuccessfulL2Occurence
				WHERE ProcessedDate = @CurrentL2Date
				And ProcessedTime > @EndDateTime
			)
			BEGIN

				DELETE FROM #SuccessfulL2Occurence
				WHERE ProcessedDate = @CurrentL2Date

				INSERT INTO #SuccessfulL2Occurence
				(
					ProcessedDate, ProcessedTime
				)
				SELECT @CurrentL2Date, @EndDateTime
			END

			FETCH NEXT FROM @InnerCursor INTO @CurrentL2Date
		END
		
		CLOSE @InnerCursor

		FETCH NEXT FROM @Cursor INTO @StartDateTime, @StartDate, @EndDate, @EndDateTime,@CurrentProcessingDate,@CurrentProcessingShift, @RecalcState
	END

	CLOSE @Cursor
	DEALLOCATE @Cursor

		SELECT vw.L1EndDateTime As L1ProcessedTime,l2.ProcessedTime As L2ProcessedTime, vw.L1TransactionDate, COUNT(DISTINCT l2.ProcessedTime) AS l2RecalcCount,
			COUNT(DISTINCT fl1.Start_Datetime) AS l1Failures
		FROM
			(
			SELECT Max(l1.End_Datetime) AS L1EndDateTime,
				l1.Current_Processing_Date AS L1TransactionDate
			FROM dbo.RecalcHistory AS l1
				INNER JOIN dbo.RecalcState AS rs
					ON rs.Recalc_State_Id = l1.Recalc_State_Id
					AND rs.Name = 'Success'		
			WHERE l1.Recalc_Type_Id = 'Level 1'
			GROUP BY l1.Current_Processing_Date
			) AS vw
				--Get the L1 dates which have later on failed, and have no successful l1 event after them.
				LEFT JOIN dbo.RecalcHistory AS fl1
					ON fl1.Start_Date = vw.L1TransactionDate
					AND fl1.Start_Datetime > vw.L1EndDateTime
					AND fl1.Recalc_Type_Id = 'Level 1'
					AND fl1.Recalc_State_Id IN (SELECT Recalc_State_Id FROM dbo.RecalcState WHERE Name <> 'Success')
				LEFT OUTER JOIN #SuccessfulL2Occurence AS l2
					ON (vw.L1EndDateTime <= l2.ProcessedTime
						AND vw.L1TransactionDate = l2.ProcessedDate)
		GROUP BY vw.L1EndDateTime,vw.L1TransactionDate,l2.ProcessedTime
		ORDER BY vw.L1TransactionDate


		DROP TABLE #SuccessfulL2Occurence

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetNotificationRecalcTransactions TO CoreNotificationManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetNotificationRecalcTransactions">
 <Procedure>
	
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorCore->Schema\Procedures\Notification\dbo.DeleteNotificationInstance.prc'
GO

IF OBJECT_ID('dbo.DeleteNotificationInstance') IS NOT NULL
     DROP PROCEDURE dbo.DeleteNotificationInstance
GO 

CREATE PROCEDURE dbo.DeleteNotificationInstance
(
	@iInstanceId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	-- note: Active, Version are excluded on purpose
	-- these are managed by other routines / methods

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteNotificationInstance',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		DELETE FROM dbo.NotificationInstanceImport
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstanceHaulage
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstanceCrusher
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstanceMill
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstanceNegativeStockpile
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstanceAudit
		WHERE InstanceId = @iInstanceId

		DELETE FROM dbo.NotificationInstanceState
		WHERE InstanceId = @iInstanceId
		
		DELETE FROM dbo.NotificationInstance
		WHERE InstanceId = @iInstanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteNotificationInstance TO CoreNotificationManager
GO


GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.DeleteHaulageResolutionQueueEntry.prc'
GO

 IF OBJECT_ID('dbo.DeleteHaulageResolutionQueueEntry') IS NOT NULL
     DROP PROCEDURE dbo.DeleteHaulageResolutionQueueEntry  
GO 
  
CREATE PROCEDURE dbo.DeleteHaulageResolutionQueueEntry
(
	@iHaulageResolutionQueueId INT
) 
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	-- variable declarations go here

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteHaulageResolutionQueueEntry',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		DELETE FROM dbo.HaulageResolutionQueue
		WHERE @iHaulageResolutionQueueId = HaulageResolutionQueueId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteHaulageResolutionQueueEntry TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteHaulageResolutionQueueEntry">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetHaulageResolutionQueue.prc'
GO

IF OBJECT_ID('dbo.GetHaulageResolutionQueue') IS NOT NULL
     DROP PROCEDURE dbo.GetHaulageResolutionQueue
GO 
  
CREATE PROCEDURE dbo.GetHaulageResolutionQueue
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @HaulageResolutionQueueId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetHaulageResolutionQueue',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
			
		SELECT HaulageResolutionQueueId, HaulageRawId, Haulage_Raw_State_Id AS HaulageRawStateId
		FROM dbo.HaulageResolutionQueue AS hrq
			INNER JOIN dbo.HaulageRaw AS hr
				ON hrq.HaulageRawId = hr.Haulage_Raw_Id
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetHaulageResolutionQueue TO CoreHaulageManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetHaulageResolutionQueue">
 <Procedure>
	
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDataTransactionTonnesFlowDetails.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetDataTransactionTonnesFlowDetails') IS NOT NULL
	DROP PROCEDURE dbo.GetDataTransactionTonnesFlowDetails  
GO 
  
CREATE PROCEDURE dbo.GetDataTransactionTonnesFlowDetails 
(
	@iDataTransactionTonnesId BigInt
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		Select 
			Coalesce(DTTF.Source_Digblock_Id, SS.Stockpile_Name, DTTF.Source_Crusher_Id, DTTF.Source_Mill_Id) As Source,
			Coalesce(DS.Stockpile_Name, DTTF.Destination_Mill_Id, DTTF.Destination_Crusher_Id) As Destination, 
			Case 
				When WS.Weightometer_Id Is Not Null Then
					'Weightometer: ' + WS.Weightometer_Id
				When H.Truck_Id Is Not Null Then
					'Truck: ' + H.Truck_Id
			End As Equipment,
			WS.Weightometer_Sample_Id, H.Haulage_Id
		From dbo.DataTransactionTonnesFlow As DTTF
			Left Outer Join dbo.Stockpile As SS
				On (SS.Stockpile_Id = DTTF.Source_Stockpile_Id)
			Left Outer Join dbo.Stockpile As DS
				On (DS.Stockpile_Id = DTTF.Destination_Stockpile_Id)	
			Left Outer Join dbo.WeightometerSample As WS
				On (WS.Weightometer_Sample_Id = DTTF.Weightometer_Sample_Id)
			Left Outer Join dbo.Haulage As H
				On (H.Haulage_Id = DTTF.Haulage_Id)
		Where DTTF.Data_Transaction_Tonnes_Id = @iDataTransactionTonnesId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetDataTransactionTonnesFlowDetails TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetDataTransactionTonnesFlowDetails">
 <Procedure>
	Returns the flow chain for a Data Transaction Tonnes record.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetDigblockTransactionList.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetDigblockTransactionList') IS NOT NULL
	DROP PROCEDURE dbo.GetDigblockTransactionList  
GO 
  
CREATE PROCEDURE dbo.GetDigblockTransactionList
(
	@iDigblockId Varchar(31),
	@iStartDate DateTime = Null,
	@iEndDate DateTime = Null
)
WITH ENCRYPTION
AS 
BEGIN 
	-- variable declaration here

	SET NOCOUNT ON 

	BEGIN TRY
		Select DPT.Data_Process_Transaction_Date As TransactionDate, ST.Shift,
			IsNull(DPT.Source_Digblock_Id, SS.Stockpile_Name) As Source,
			IsNull(DS.Stockpile_Name, DPT.Destination_Mill_Id) As Destination, 
			DPT.Tonnes, 
			DPT.Data_Transaction_Tonnes_Id
		From dbo.DataProcessTransaction As DPT
			Inner Join dbo.ShiftType As ST
				On (ST.Shift = DPT.Data_Process_Transaction_Shift)
			Left Outer Join dbo.Stockpile As SS
				On (SS.Stockpile_Id = DPT.Source_Stockpile_Id)
			Left Outer Join dbo.Stockpile As DS
				On (DS.Stockpile_Id = DPT.Destination_Stockpile_Id)
		Where DPT.Original_Source_Digblock_Id = @iDigblockId	
			And (DPT.Data_Process_Transaction_Date >= @iStartDate 
				Or @iStartDate Is Null)
			And (DPT.Data_Process_Transaction_Date <= @iEndDate 
				Or @iEndDate Is Null)
		Order by DPT.Data_Process_Transaction_Date ASC, ST.Order_No
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetDigblockTransactionList TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetDigblockTransactionList">
 <Procedure>
	Get all transactions related to a particular digblock tracking it as far as it can.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorCore->Schema\Procedures\dbo.GetRecalcOpenningGenealogyRecords.prc'
GO

-- dependencies on: Snowden.Common 1.0.5.0 and SQL Server 2005
IF OBJECT_ID('dbo.GetRecalcOpenningGenealogyRecords') IS NOT NULL
	DROP PROCEDURE dbo.GetRecalcOpenningGenealogyRecords  
GO 
  
CREATE PROCEDURE dbo.GetRecalcOpenningGenealogyRecords 
(
	@iProcessingDate DateTime,
	@iProcessingShift Char(1),
	@iOpenningHistoryId Int
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		Declare @previousDate DateTime
		Declare @previousShift Char(1)
		Declare @processingShiftOrderNo Int
		Declare @joinColumns Varchar(255)
		Declare @seed Int

		Create Table #Genealogy
		(
			Id bigint identity(1, 1),
			Recalc_History_Id int,
			Original_Data_Process_Transaction_Left_Id bigint,
			Data_Process_Transaction_Left_Date datetime,
			Data_Process_Transaction_Left_Shift	char Collate Database_Default,
			Original_Transaction_Date datetime,
			Original_Transaction_Shift char Collate Database_Default,
			Original_Transaction_Shift_Order_No Int,
			Data_Process_Transaction_Id bigint,
			Data_Transaction_Tonnes_Id bigint,
			Source_Digblock_Id varchar(31) Collate Database_Default,
			Source_Crusher_Id Varchar(31) Collate Latin1_General_CI_AS Null,
			Source_Stockpile_Id Int Null,
			Stockpile_Id int,
			Build_Id int,
			Component_Id int,
			Tonnes_Left float

			Primary Key(Stockpile_Id, Build_Id, Component_Id, Original_Data_Process_Transaction_Left_Id)
		)

		Create Table #Grades
		(
			Stockpile_Id int,
			Build_Id int,
			Component_Id int,
			Original_Data_Process_Transaction_Left_Id bigint,
			Grade_Name Varchar(31) Collate Database_Default,
			Grade_Value float
		)

		--Get Previous Shift
		Exec dbo.GetPreviousDateShift
			@Date = @iProcessingDate,
			@Shift = @iProcessingShift,
			@Previous_Date = @previousDate Output,
			@Previous_Shift = @previousShift Output

		--Get order no and Pivot Join columns
		Select @processingShiftOrderNo = dbo.GetShiftTypeOrderNo(@iProcessingShift),
			@joinColumns = '#Genealogy.Stockpile_Id = #Grades.Stockpile_Id '+
				'And #Genealogy.Build_Id = #Grades.Build_Id '+
				'And #Genealogy.Component_Id = #Grades.Component_Id '+
				'And #Genealogy.Original_Data_Process_Transaction_Left_Id = #Grades.Original_Data_Process_Transaction_Left_Id '

		--Work out stockpiles which
		Declare @Stockpiles Table
		(
			Stockpile_Id Int
			Primary Key (Stockpile_Id)
		)

		Insert Into @Stockpiles
		(
			Stockpile_Id
		)
		Select T.Stockpile_Id
		From dbo.StockpileStockpileTypePeriod As T
			Inner Join
				(
					Select T.Stockpile_Id, Min(IsNull(T.End_Date, '2999-01-01')) As End_Date
					From dbo.StockpileStockpileTypePeriod As T
					Group By T.Stockpile_Id
				) As D
				On (D.Stockpile_Id = T.Stockpile_Id
					And D.End_Date = IsNull(T.End_Date, '2999-01-01'))
		Where T.Stockpile_Type_Id In ('FIFO', 'LIFO')
			And (T.End_Date Is Null Or T.End_Date >= @iProcessingDate) 
		
		Insert Into #Genealogy
		(
			Recalc_History_Id, Original_Data_Process_Transaction_Left_Id, 
			Data_Process_Transaction_Left_Date, Data_Process_Transaction_Left_Shift,
			Original_Transaction_Date, Original_Transaction_Shift, Original_Transaction_Shift_Order_No,
			Data_Process_Transaction_Id, Data_Transaction_Tonnes_Id, 
			Source_Digblock_Id,	Source_Crusher_Id, Source_Stockpile_Id,
			Stockpile_Id, Build_Id, Component_Id, Tonnes_Left
		)
		--Get all the previous shift entries where stockpile has not been closed last shift
		Select DPTL.Recalc_History_Id, DPTL.Data_Process_Transaction_Left_Id AS Original_Data_Process_Transaction_Left_Id,
			@iProcessingDate As Data_Process_Transaction_Left_Date, 
			@iProcessingShift As Data_Process_Transaction_Left_Shift,
			Original_Transaction_Date, DPTL.Original_Transaction_Shift, IsNull(OST.Order_No, -1),
			DPTL.Data_Process_Transaction_Id, DPTL.Data_Transaction_Tonnes_Id,
			DPTL.Source_Digblock_Id, H.Destination_Crusher_Id, DTT.Source_Stockpile_Id,
			DPTL.Stockpile_Id, DPTL.Build_Id, DPTL.Component_Id, DPTL.Tonnes_Left
		From dbo.DataProcessTransactionLeft As DPTL
			Inner Join DataTransactionTonnes As DTT 
				On DPTL.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id 
			Left Outer Join Haulage As H 
				On DTT.Haulage_Id = H.Haulage_Id 
			Inner Join dbo.ShiftType As ST
				On (ST.Shift = DPTL.Data_Process_Transaction_Left_Shift)
			Inner Join @Stockpiles As S
				On (S.Stockpile_Id = DPTL.Stockpile_Id)
			Inner Join dbo.StockpileBuild As SB
				On (SB.Stockpile_Id = DPTL.Stockpile_Id
					And SB.Build_Id = DPTL.Build_Id)	
			Left Outer Join dbo.ShiftType As ST2
				On (ST2.Shift = SB.End_Shift)
			Left Outer Join dbo.ShiftType As OST
				On (OST.Shift = DPTL.Original_Transaction_Shift)
		Where DPTL.Data_Process_Transaction_Left_Date = @previousDate
			And DPTL.Data_Process_Transaction_Left_Shift = @previousShift
			And (SB.End_Date Is Null 
				Or dbo.GetDateShiftAsInt(SB.End_Date, ST2.Order_No) > 
					dbo.GetDateShiftAsInt(DPTL.Data_Process_Transaction_Left_Date, ST.Order_No))
		UNION ALL
		--Add new components for stockpiles that opened this shift.
		Select @iOpenningHistoryId, -1, @iProcessingDate, @iProcessingShift,
			@iProcessingDate, @iProcessingShift, @processingShiftOrderNo,
			NULL, NULL, NULL, NULL, NULL,
			SBC.Stockpile_Id, SBC.Build_Id, SBC.Component_Id, SBC.Start_Tonnes
		From dbo.StockpileBuild As SB	
			Inner Join @Stockpiles As S
				On (S.Stockpile_Id = SB.Stockpile_Id)
			Inner Join dbo.StockpileBuildComponent As SBC
				On (SB.Stockpile_Id = SBC.Stockpile_Id
					And SB.Build_Id = SBC.Build_Id)
		Where SB.Start_Date = @iProcessingDate
			And SB.Start_Shift = @iProcessingShift

		--Get Grades
		Insert Into #Grades
		(
			Stockpile_Id, Build_Id, Component_Id, Original_Data_Process_Transaction_Left_Id,
			Grade_Name, Grade_Value
		)
		Select Null, Null, Null, Null, G.Grade_Name, Null
		From dbo.Grade As G
		Union All
		Select DPTL.Stockpile_Id, DPTL.Build_Id, DPTL.Component_Id,
			DPTL.Data_Process_Transaction_Left_Id, G.Grade_Name, 
			DPTLG.Grade_Value			
		From dbo.DataProcessTransactionLeft As DPTL
			Inner Join @Stockpiles As S
				On (S.Stockpile_Id = DPTL.Stockpile_Id)
			Inner Join dbo.DataProcessTransactionLeftGrade As DPTLG
				On (DPTLG.Data_Process_Transaction_Left_Id = DPTL.Data_Process_Transaction_Left_Id)
			Inner Join dbo.Grade As G
				On (G.Grade_Id = DPTLG.Grade_Id)
			Inner Join dbo.ShiftType As ST
				On (ST.Shift = DPTL.Data_Process_Transaction_Left_Shift)
			Inner Join dbo.StockpileBuild As SB
				On (SB.Stockpile_Id = DPTL.Stockpile_Id
					And SB.Build_Id = DPTL.Build_Id)	
			Left Outer Join dbo.ShiftType As ST2
				On (ST2.Shift = SB.End_Shift)
		Where DPTL.Data_Process_Transaction_Left_Date = @previousDate
			And DPTL.Data_Process_Transaction_Left_Shift = @previousShift
			And (SB.End_Date Is Null 
				Or dbo.GetDateShiftAsInt(SB.End_Date, ST2.Order_No) > 
					dbo.GetDateShiftAsInt(DPTL.Data_Process_Transaction_Left_Date, ST.Order_No))
		Union All
		Select SBC.Stockpile_Id, SBC.Build_Id, SBC.Component_Id, 
			-1, G.Grade_Name, SBCG.Grade_Value
		From dbo.StockpileBuild As SB
			Inner Join @Stockpiles As S
				On (S.Stockpile_Id = SB.Stockpile_Id)
			Inner Join dbo.StockpileBuildComponent As SBC
				On (SB.Stockpile_Id = SBC.Stockpile_Id
					And SB.Build_Id = SBC.Build_Id)
			Inner Join dbo.StockpileBuildComponentGrade As SBCG
				On (SBCG.Stockpile_Id = SBC.Stockpile_Id
					And SBCG.Build_Id = SBC.Build_Id
					And SBCG.Component_Id = SBC.Component_Id)
			Inner Join dbo.Grade As G
				On (G.Grade_Id = SBCG.Grade_Id)
		Where SB.Start_Date = @iProcessingDate
			And SB.Start_Shift = @iProcessingShift

		Exec dbo.PivotTable
			@iTargetTable = '#Genealogy',
			@iPivotTable = '#Grades',
			@iJoinColumns = @joinColumns,
			@iPivotColumn = 'Grade_Name',
			@iPivotValue = 'Grade_Value',
			@iPivotType = 'float'
		
		--Work out seed
		Select @seed = IsNull(Max(Data_Process_Transaction_Left_Id), 0)
		From dbo.DataProcessTransactionLeft

		Select Id + @seed As Data_Process_Transaction_Left_Id, *
		From #Genealogy

		Drop Table #Genealogy
		Drop Table #Grades
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetRecalcOpenningGenealogyRecords TO CoreRecalc

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetRecalcOpenningGenealogyRecords">
 <Procedure>
	Returns the openning genealogy records for all genealogical stockpiles for the given processing shift. 
	This is called by the Recalc before beginning to process transactions.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportHaulage.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportHaulage') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportHaulage
GO

CREATE VIEW dbo.BhpbioImportHaulage
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//HaulageSource/Haulage/HaulageDate)[1]', 'DATETIME') AS HaulageDate,
	r.SourceRow.value('(//HaulageSource/Haulage/HaulageShift)[1]', 'CHAR(1)') AS HaulageShift,
	r.SourceRow.value('(//HaulageSource/Haulage/Source)[1]', 'VARCHAR(63)') AS Source,
	r.SourceRow.value('(//HaulageSource/Haulage/SourceMineSite)[1]', 'VARCHAR(2)') AS SourceMineSite,
	r.SourceRow.value('(//HaulageSource/Haulage/Destination)[1]', 'VARCHAR(63)') AS Destination,
	r.SourceRow.value('(//HaulageSource/Haulage/DestinationMineSite)[1]', 'VARCHAR(2)') AS DestinationMinesite,
	r.SourceRow.value('(//HaulageSource/Haulage/Tonnes)[1]', 'FLOAT') AS Tonnes,
	r.SourceRow.value('(//HaulageSource/Haulage/Loads)[1]', 'INT') AS Loads,
	r.SourceRow.value('(//HaulageSource/Haulage/Truck)[1]', 'VARCHAR(31)') AS Truck,
	r.SourceRow.value('(//HaulageSource/Haulage/Type)[1]', 'VARCHAR(255)') AS Type,
	r.DestinationRow.value('(//HaulageDestination/Haulage/HaulageRawId)[1]', 'INT') AS HaulageRawId,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Haulage'
	AND t.Name = 'Haulage'
GO

GRANT SELECT ON dbo.BhpbioImportHaulage TO CoreReporting
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportHaulageNotes.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportHaulageNotes') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportHaulageNotes
GO

CREATE VIEW dbo.BhpbioImportHaulageNotes
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/HaulageDate)[1]', 'DATETIME') AS HaulageDate,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/HaulageShift)[1]', 'CHAR(1)') AS HaulageShift,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/Source)[1]', 'VARCHAR(63)') AS Source,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/SourceMineSite)[1]', 'VARCHAR(2)') AS SourceMineSite,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/Destination)[1]', 'VARCHAR(63)') AS Destination,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/DestinationMineSite)[1]', 'VARCHAR(2)') AS DestinationMinesite,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/Truck)[1]', 'VARCHAR(31)') AS Truck,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/Type)[1]', 'VARCHAR(255)') AS Type,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/FieldId)[1]', 'VARCHAR(31)') AS FieldId,
	r.SourceRow.value('(//HaulageSource/HaulageNotes/Notes)[1]', 'VARCHAR(255)') AS Notes,
	r.DestinationRow.value('(//HaulageDestination/HaulageNotes/HaulageRawId)[1]', 'INT') AS HaulageRawId,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Haulage'
	AND t.Name = 'HaulageNotes'
GO

GRANT SELECT ON dbo.BhpbioImportHaulageNotes TO CoreReporting
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportHaulageValue.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportHaulageValue') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportHaulageValue
GO

CREATE VIEW dbo.BhpbioImportHaulageValue
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//HaulageSource/HaulageValue/HaulageDate)[1]', 'DATETIME') AS HaulageDate,
	r.SourceRow.value('(//HaulageSource/HaulageValue/HaulageShift)[1]', 'CHAR(1)') AS HaulageShift,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Source)[1]', 'VARCHAR(63)') AS Source,
	r.SourceRow.value('(//HaulageSource/HaulageValue/SourceMineSite)[1]', 'VARCHAR(2)') AS SourceMineSite,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Destination)[1]', 'VARCHAR(63)') AS Destination,
	r.SourceRow.value('(//HaulageSource/HaulageValue/DestinationMineSite)[1]', 'VARCHAR(2)') AS DestinationMinesite,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Truck)[1]', 'VARCHAR(31)') AS Truck,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Type)[1]', 'VARCHAR(255)') AS Type,
	r.SourceRow.value('(//HaulageSource/HaulageValue/FieldId)[1]', 'VARCHAR(31)') AS FieldId,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Mine)[1]', 'VARCHAR(255)') AS Mine,
	r.SourceRow.value('(//HaulageSource/HaulageValue/Value)[1]', 'VARCHAR(255)') AS Value,
	r.DestinationRow.value('(//HaulageDestination/HaulageValue/HaulageRawId)[1]', 'INT') AS HaulageRawId,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Haulage'
	AND t.Name = 'HaulageValue'
GO

GRANT SELECT ON dbo.BhpbioImportHaulageValue TO CoreReporting
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportHaulageGrade.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportHaulageGrade') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportHaulageGrade
GO

CREATE VIEW dbo.BhpbioImportHaulageGrade
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/HaulageDate)[1]', 'DATETIME') AS HaulageDate,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/HaulageShift)[1]', 'CHAR(1)') AS HaulageShift,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/Source)[1]', 'VARCHAR(63)') AS Source,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/SourceMineSite)[1]', 'VARCHAR(2)') AS SourceMineSite,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/Destination)[1]', 'VARCHAR(63)') AS Destination,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/DestinationMineSite)[1]', 'VARCHAR(2)') AS DestinationMinesite,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/Truck)[1]', 'VARCHAR(31)') AS Truck,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/Type)[1]', 'VARCHAR(255)') AS Type,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/GradeName)[1]', 'VARCHAR(31)') AS GradeName,
	r.SourceRow.value('(//HaulageSource/HaulageGrade/Value)[1]', 'VARCHAR(255)') AS Value,
	r.DestinationRow.value('(//HaulageDestination/HaulageGrade/HaulageRawId)[1]', 'INT') AS HaulageRawId,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Haulage'
	AND t.Name = 'HaulageGrade'
GO

GRANT SELECT ON dbo.BhpbioImportHaulageGrade TO CoreReporting
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportProductionTransaction.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportProductionTransaction') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportProductionTransaction
GO

CREATE VIEW dbo.BhpbioImportProductionTransaction
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//ProductionSource/Transaction/TransactionDate)[1]', 'DATETIME') AS TransactionDate,
	r.SourceRow.value('(//ProductionSource/Transaction/Source)[1]', 'VARCHAR(63)') AS Source,
	r.SourceRow.value('(//ProductionSource/Transaction/SourceMineSite)[1]', 'VARCHAR(2)') AS SourceMineSite,
	r.SourceRow.value('(//ProductionSource/Transaction/SourceLocationType)[1]', 'VARCHAR(63)') AS SourceLocationType,
	r.SourceRow.value('(//ProductionSource/Transaction/Destination)[1]', 'VARCHAR(63)') AS Destination,
	r.SourceRow.value('(//ProductionSource/Transaction/DestinationMineSite)[1]', 'VARCHAR(2)') AS DestinationMineSite,
	r.SourceRow.value('(//ProductionSource/Transaction/DestinationType)[1]', 'VARCHAR(63)') AS DestinationType,
	r.SourceRow.value('(//ProductionSource/Transaction/Type)[1]', 'VARCHAR(255)') AS Type,
	r.SourceRow.value('(//ProductionSource/Transaction/SampleSource)[1]', 'VARCHAR(MAX)') AS SampleSource,
	r.SourceRow.value('(//ProductionSource/Transaction/SampleTonnes)[1]', 'FLOAT') AS SampleTonnes,
	r.SourceRow.value('(//ProductionSource/Transaction/Tonnes)[1]', 'FLOAT') AS Tonnes,
	r.SourceRow.value('(//ProductionSource/Transaction/FinesPercent)[1]', 'REAL') AS FinesPercent,
	r.SourceRow.value('(//ProductionSource/Transaction/LumpPercent)[1]', 'REAL') AS LumpPercent,
	CONVERT(XML, r.SourceRow.value('(//ProductionSource/Transaction/Grades)[1]', 'VARCHAR(MAX)')) AS Grades,
	r.DestinationRow.value('(//ProductionDestination/Transaction/WeightometerSampleId)[1]', 'INT') AS WeightometerSampleId,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Production'
	AND t.Name = 'Transaction'
GO

GRANT SELECT ON dbo.BhpbioImportProductionTransaction TO CoreReporting
GO

/* testing
SELECT * FROM dbo.BhpbioImportProductionTransaction
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.Bhpbioimportstockpile.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportStockpile') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportStockpile
GO

CREATE VIEW dbo.BhpbioImportStockpile
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//StockpileSource/Stockpile/StockpileName)[1]', 'VARCHAR(255)') AS StockpileName,
	r.SourceRow.value('(//StockpileSource/Stockpile/Mine)[1]', 'VARCHAR(255)') AS Mine,
	r.SourceRow.value('(//StockpileSource/Stockpile/StockpileGroup)[1]', 'VARCHAR(255)') AS StockpileGroup,
	r.SourceRow.value('(//StockpileSource/Stockpile/MaterialType)[1]', 'VARCHAR(255)') AS MaterialType,
	r.SourceRow.value('(//StockpileSource/Stockpile/Description)[1]', 'VARCHAR(255)') AS Description,
	r.SourceRow.value('(//StockpileSource/Stockpile/StartTonnes)[1]', 'FLOAT') AS StartTonnes,
	r.SourceRow.value('(//StockpileSource/Stockpile/StartDate)[1]', 'DATETIME') AS StartDate,
	r.SourceRow.value('(//StockpileSource/Stockpile/StartShift)[1]', 'CHAR(1)') AS StartShift,
	r.SourceRow.value('(//StockpileSource/Stockpile/EndDate)[1]', 'DATETIME') AS EndDate,
	r.SourceRow.value('(//StockpileSource/Stockpile/EndShift)[1]', 'CHAR(1)') AS EndShift,
	r.SourceRow.value('(//StockpileSource/Stockpile/StockpileAlgorithm)[1]', 'VARCHAR(255)') AS StockpileAlgorithm,
	r.SourceRow.value('(//StockpileSource/Stockpile/IsVisible)[1]', 'BIT') As IsVisible,
	r.SourceRow.value('(//StockpileSource/Stockpile/IsInReports)[1]', 'BIT') AS IsInReports,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Stockpile'
	AND t.Name = 'Stockpile'
GO

GRANT SELECT ON dbo.BhpbioImportStockpile TO CoreReporting
GO
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Views\dbo.BhpbioImportBlock.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportBlock') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportBlock
GO

CREATE VIEW dbo.BhpbioImportBlock
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/Site)[1]', 'VARCHAR(9)') AS Site,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/Orebody)[1]', 'VARCHAR(2)') AS OreBody,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/Pit)[1]', 'VARCHAR(10)') AS Pit,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/Bench)[1]', 'VARCHAR(4)') AS Bench,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/PatternNumber)[1]', 'VARCHAR(4)') AS PatternNumber,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/BlockName)[1]', 'VARCHAR(14)') AS BlockName,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/ModelName)[1]', 'VARCHAR(13)') AS ModelName,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/ModelOreType)[1]', 'VARCHAR(8)') AS ModelOreType,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/BlockNumber)[1]', 'VARCHAR(2)') AS BlockNumber,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/GeoType)[1]', 'VARCHAR(9)') AS GeoType,
	r.SourceRow.value('xs:dateTime((//BlockModelSource/BlastModelBlockWithPointAndGrade/BlockedDate)[1])', 'DATETIME') AS BlockedDate,
	r.SourceRow.value('xs:dateTime((//BlockModelSource/BlastModelBlockWithPointAndGrade/BlastedDate)[1])', 'DATETIME') AS BlastedDate,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/CentroidEasting)[1]', 'FLOAT') AS CentroidEasting,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/CentroidNorthing)[1]', 'FLOAT') AS CentroidNorthing,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/CentroidRL)[1]', 'FLOAT') AS CentroidRL,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/ModelVolume)[1]', 'FLOAT') AS ModelVolume,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/ModelTonnes)[1]', 'FLOAT') AS ModelTonnes,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/ModelDensity)[1]', 'FLOAT') AS ModelDensity,
	r.SourceRow.value('(//BlockModelSource/BlastModelBlockWithPointAndGrade/LastModifiedUser)[1]', 'VARCHAR(50)') AS LastModifiedUser,
	r.SourceRow.value('xs:dateTime((//BlockModelSource/BlastModelBlockWithPointAndGrade/LastModifiedDate)[1])', 'DATETIME') AS LastModifiedDate,
	r.DestinationRow.value('(//BlockModelDestination/BlastModelBlockWithPointAndGrade/DigblockId)[1]', 'VARCHAR(31)') AS DigblockId,
	r.DestinationRow.value('(//BlockModelDestination/BlastModelBlockWithPointAndGrade/BlockModelId)[1]', 'INT') AS BlockModelId,
	r.DestinationRow.value('(//BlockModelDestination/BlastModelBlockWithPointAndGrade/ModelBlockId)[1]', 'INT') AS ModelBlockId,
	r.DestinationRow.value('(//BlockModelDestination/BlastModelBlockWithPointAndGrade/SequenceNo)[1]', 'INT') AS SequenceNo,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Blocks'
	AND t.Name = 'BlastModelBlockWithPointAndGrade'
GO

GRANT SELECT ON dbo.BhpbioImportBlock TO CoreReporting
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\views\dbo.bhpbioimportstocpkileadjustment.viw'
GO

IF OBJECT_ID('dbo.BhpbioImportStockpileAdjustment') IS NOT NULL 
     DROP VIEW dbo.BhpbioImportStockpileAdjustment
GO

CREATE VIEW dbo.BhpbioImportStockpileAdjustment
AS
SELECT r.ImportSyncRowId,
	r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/Mine)[1]', 'VARCHAR(MAX)') AS Mine,
	r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/StockpileName)[1]', 'VARCHAR(MAX)') AS StockpileName,
	Cast(r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/StockpileAdjustmentDate)[1]', 'VARCHAR(MAX)') AS Datetime) AS StockpileAdjustmentDate,
	r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/StockpileAdjustmentShift)[1]', 'VARCHAR(MAX)') AS StockpileAdjustmentShift,
	r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/StockpileAdjustmentType)[1]', 'VARCHAR(MAX)') AS StockpileAdjustmentType,
	r.SourceRow.value('(//StockpileAdjustmentSource/StockpileAdjustment/StockpileAdjustmentTonnes)[1]', 'FLOAT') AS StockpileAdjustmentTonnes,
	r.RootImportSyncRowId, r.IsCurrent
FROM dbo.ImportSyncRow AS r
	INNER JOIN dbo.Import AS i
		ON (r.ImportId = i.ImportId)
	INNER JOIN dbo.ImportSyncTable AS t
		ON (r.ImportSyncTableId = t.ImportSyncTableId)
WHERE i.ImportName = 'Stockpile Adjustment'
	AND t.Name = 'StockpileAdjustment'
GO

GRANT SELECT ON dbo.BhpbioImportStockpileAdjustment TO CoreReporting
GO



GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportLocation.UDF'
GO

IF OBJECT_ID('dbo.GetBhpbioReportLocation') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioReportLocation
Go 

CREATE FUNCTION dbo.GetBhpbioReportLocation
(
	@iLocationId INT
)
RETURNS @Location TABLE
(
	LocationId INT
	PRIMARY KEY (LocationId)
)
BEGIN
	DECLARE @LocationId INT
	
	SET @LocationId = @iLocationId

	-- works around for defects where the UI sentinels are passed through to here
	IF @LocationId <= 0
	BEGIN
		SET @LocationId = NULL
	END

	-- when the LocationId is NULL then the full subtree is returned anyway
	INSERT INTO @Location
		(LocationId)
	SELECT @LocationId
	WHERE @LocationId IS NOT NULL
	UNION ALL
	SELECT Location_Id
	FROM dbo.GetLocationChildLocationList(@LocationId)
	WHERE Location_ID IS NOT NULL
	
	RETURN
END

GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportBreakdown.UDF'
GO

IF OBJECT_ID('dbo.GetBhpbioReportBreakdown') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioReportBreakdown
Go 

CREATE FUNCTION dbo.GetBhpbioReportBreakdown
(
	@iBreakDown VARCHAR(31),
	@iStartDate DATETIME,
	@iEndDate DATETIME,
	@iValidateStartDate BIT
)
RETURNS @ReportDate TABLE
(
	DateFrom DATETIME,
	DateTo DATETIME,
	CalendarDate DATETIME,	
	PRIMARY KEY CLUSTERED (CalendarDate),
	UNIQUE NONCLUSTERED (DateFrom, DateTo)
)
BEGIN
	DECLARE @SystemStartDate DATETIME
	DECLARE @Step INT
	DECLARE @Interval VARCHAR(31)
	DECLARE @StartDate DATETIME
	DECLARE @EndDate DATETIME
	
	SET @SystemStartDate = dbo.GetSystemStartDate()
	
	IF @iBreakDown = 'QUARTER'
	BEGIN
		SET @Step = 3
		SET @Interval = 'MONTH'
		SET @StartDate = @iStartDate
		SET @EndDate = @iEndDate
	END
	ELSE IF @iBreakDown = 'MONTH'
	BEGIN
		SET @Step = 1
		SET @Interval = @iBreakDown
		SET @StartDate = @iStartDate
		SET @EndDate = @iEndDate
	END
	ELSE IF @iBreakDown = 'YEAR'
	BEGIN
		SET @Step = 1
		SET @Interval = @iBreakDown
		SET @StartDate = @iStartDate
		SET @EndDate = @iEndDate
	END
	ELSE
	BEGIN
		SET @Step = 1
		SET @Interval = NULL
		SET @StartDate = @iStartDate
		SET @EndDate = @iEndDate
	END
	
	IF @Interval IS NULL
	BEGIN
		INSERT INTO @ReportDate
			(DateFrom, DateTo, CalendarDate)
		SELECT @StartDate, @EndDate, @StartDate
	END 
	ELSE
	BEGIN
	
		INSERT INTO @ReportDate
			(DateFrom, DateTo, CalendarDate)
		Select This_Date,
			Case @Interval
				When 'QUARTER' Then DateAdd(Day, -1, DateAdd(Month, @Step, This_Date))
				When 'MONTH' Then DateAdd(Day, -1, DateAdd(Month, @Step, This_Date))
				When 'YEAR' Then DateAdd(Day, -1, DateAdd(Year, @Step, This_Date))
				Else Null
			End,
			This_Date
		From dbo.GetDateList(@StartDate, @EndDate, @Interval, @Step)
		Group By This_Date
	END
	
	IF @iValidateStartDate = 1 AND @StartDate < @SystemStartDate
	BEGIN
		-- Delete any records where the end date is before
		DELETE RD
		FROM @ReportDate AS RD
		WHERE RD.DateTo < @SystemStartDate

		UPDATE RD
		SET RD.DateFrom = @SystemStartDate
		FROM @ReportDate AS RD
		WHERE RD.DateFrom < @SystemStartDate AND RD.DateTo > @SystemStartDate
	END

	RETURN
END
GO

--select * from dbo.GetBhpbioReportBreakdown(NULL, '2008-01-01', '2008-03-31', 1)
--select * from dbo.GetBhpbioReportBreakdown('YEAR', '1997-01-01', '2008-12-31', 1)

GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportHighGrade.udf'
GO

IF OBJECT_ID('dbo.GetBhpbioReportHighGrade') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioReportHighGrade
Go 

CREATE FUNCTION dbo.GetBhpbioReportHighGrade
()
RETURNS @HighGradeMaterialType TABLE
(
	MaterialTypeId INT,
	Description VARCHAR(63) COLLATE DATABASE_DEFAULT,
	Abbreviation VARCHAR(15) COLLATE DATABASE_DEFAULT,
	PRIMARY KEY (MaterialTypeId)
)
BEGIN
	INSERT INTO @HighGradeMaterialType
		(MaterialTypeId, Description, Abbreviation)
	SELECT Material_Type_Id, Description, Abbreviation
	FROM dbo.MaterialType
	WHERE Material_Category_Id = 'Designation'
		AND Description IN ('High Grade', 'Bene Feed', 'Bene Product')

	RETURN
END
GO

--select * from dbo.GetBhpbioReportHighGrade()

GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioWeightometerSampleSource.udf'
GO

IF OBJECT_ID('dbo.GetBhpbioWeightometerSampleSource') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioWeightometerSampleSource
Go 

CREATE FUNCTION dbo.GetBhpbioWeightometerSampleSource
(
	@iLocationId INT,
	@iDateFrom DATETIME,
	@iDateTo DATETIME
)
RETURNS @SampleSource TABLE
(
	LocationId INT,
	MonthPeriod DATETIME,
	SampleSource VARCHAR(255) COLLATE DATABASE_DEFAULT
	PRIMARY KEY (LocationId, MonthPeriod, SampleSource)
)
BEGIN
	DECLARE @CrusherActuals VARCHAR(31)
	DECLARE @UndilutedRakes VARCHAR(31)
	DECLARE @PortActuals VARCHAR(31)
	DECLARE @ShuttleGrades VARCHAR(31)
	SET @CrusherActuals = 'CRUSHER ACTUALS'
	SET @UndilutedRakes = 'UNDILUTED RAKES'
	SET @PortActuals = 'PORT ACTUALS'
	SET @ShuttleGrades = 'SHUTTLE'

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	-- Setup the Locations
	INSERT INTO @Location
		(LocationId, ParentLocationId)
	SELECT LocationId, ParentLocationId
	FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, 0, 'Site')

	INSERT INTO @SampleSource
		(LocationId, MonthPeriod, SampleSource)
	SELECT L.LocationId, dbo.GetDateMonth(WS.Weightometer_Sample_Date) As MonthPeriod, WSN.Notes
	FROM @Location AS L
		INNER JOIN dbo.CrusherLocation AS CL
			ON (CL.Location_Id = L.LocationId)
		INNER JOIN dbo.WeightometerFlowPeriod AS WFP
			ON (WFP.Source_Crusher_Id = CL.Crusher_Id)
		INNER JOIN dbo.WeightometerSample AS WS
			ON (WS.Weightometer_Id = WFP.Weightometer_Id)
		INNER JOIN dbo.WeightometerSampleNotes AS WSN
			ON (WSN.Weightometer_Sample_Field_Id = 'SampleSource'
				AND WS.Weightometer_Sample_Id = WSN.Weightometer_Sample_Id)
	WHERE WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
		AND WSN.Notes IN (@CrusherActuals)
	GROUP BY dbo.GetDateMonth(WS.Weightometer_Sample_Date), L.LocationId, WSN.Notes
	/*
	INSERT INTO @SampleSource
		(LocationId, MonthPeriod, SampleSource)
	SELECT L.LocationId, dbo.GetDateMonth(WS.Weightometer_Sample_Date) As MonthPeriod, WSN.Notes
	FROM @Location AS L
		INNER JOIN dbo.WeightometerLocation AS WL
			ON (WL.Location_Id = L.LocationId)
		INNER JOIN dbo.WeightometerSample AS WS
			ON (WL.Weightometer_Id = WS.Weightometer_Id)
		LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
			ON (WFPV.Weightometer_Id = WS.Weightometer_Id
				AND (WS.Weightometer_Sample_Date > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
				AND (WS.Weightometer_Sample_Date < WFPV.End_Date Or WFPV.End_Date IS NULL))	
		INNER JOIN dbo.StockpileGroupStockpile AS SGS
			ON (SGS.Stockpile_Id = Coalesce(WFPV.Destination_Stockpile_Id, WS.Destination_Stockpile_Id))
		INNER JOIN dbo.WeightometerSampleNotes AS WSN
			ON (WSN.Weightometer_Sample_Field_Id = 'SampleSource'
				AND WS.Weightometer_Sample_Id = WSN.Weightometer_Sample_Id)
		LEFT JOIN @SampleSource AS SS
			ON (SS.LocationID = L.LocationId
				AND SS.MonthPeriod = dbo.GetDateMonth(WS.Weightometer_Sample_Date))
	WHERE WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
		AND WSN.Notes IN (@ShuttleGrades)
		AND SGS.Stockpile_Group_Id in ('HUB Train Rake', 'Port Train Rake')
		AND SS.SampleSource IS NULL
	GROUP BY dbo.GetDateMonth(WS.Weightometer_Sample_Date), L.LocationId, WSN.Notes	
*/
	INSERT INTO @SampleSource
		(LocationId, MonthPeriod, SampleSource)
	SELECT L.LocationId, dbo.GetDateMonth(WS.Weightometer_Sample_Date) As MonthPeriod, WSN.Notes
	FROM @Location AS L
		INNER JOIN dbo.WeightometerLocation AS WL
			ON (WL.Location_Id = L.LocationId)
		INNER JOIN dbo.WeightometerSample AS WS
			ON (WL.Weightometer_Id = WS.Weightometer_Id)
		LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
			ON (WFPV.Weightometer_Id = WS.Weightometer_Id
				AND (WS.Weightometer_Sample_Date > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
				AND (WS.Weightometer_Sample_Date < WFPV.End_Date Or WFPV.End_Date IS NULL))	
		INNER JOIN dbo.StockpileGroupStockpile AS SGS
			ON (SGS.Stockpile_Id = Coalesce(WFPV.Source_Stockpile_Id, WS.Source_Stockpile_Id))
		INNER JOIN dbo.WeightometerSampleNotes AS WSN
			ON (WSN.Weightometer_Sample_Field_Id = 'SampleSource'
				AND WS.Weightometer_Sample_Id = WSN.Weightometer_Sample_Id)
		LEFT JOIN @SampleSource AS SS
			ON (SS.LocationID = L.LocationId
				AND SS.MonthPeriod = dbo.GetDateMonth(WS.Weightometer_Sample_Date))
	WHERE WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
		AND WSN.Notes IN (@ShuttleGrades)
		AND SGS.Stockpile_Group_Id in ('HUB Train Rake', 'Port Train Rake')
		AND SS.SampleSource IS NULL
	GROUP BY dbo.GetDateMonth(WS.Weightometer_Sample_Date), L.LocationId, WSN.Notes	
	
	INSERT INTO @SampleSource
		(LocationId, MonthPeriod, SampleSource)
	SELECT L.LocationId, dbo.GetDateMonth(WS.Weightometer_Sample_Date) As MonthPeriod, WSN.Notes
	FROM @Location AS L
		INNER JOIN dbo.WeightometerLocation AS WL
			ON (WL.Location_Id = L.LocationId)
		INNER JOIN dbo.WeightometerSample AS WS
			ON (WL.Weightometer_Id = WS.Weightometer_Id)
		INNER JOIN dbo.StockpileGroupStockpile AS SGS
			ON (SGS.Stockpile_Id = WS.Destination_Stockpile_Id)
		INNER JOIN dbo.WeightometerSampleNotes AS WSN
			ON (WSN.Weightometer_Sample_Field_Id = 'SampleSource'
				AND WS.Weightometer_Sample_Id = WSN.Weightometer_Sample_Id)
		LEFT JOIN @SampleSource AS SS
			ON (SS.LocationID = L.LocationId
				AND SS.MonthPeriod = dbo.GetDateMonth(WS.Weightometer_Sample_Date))
	WHERE WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
		AND WSN.Notes IN (@UndilutedRakes, @PortActuals)
		AND SGS.Stockpile_Group_Id in ('HUB Train Rake', 'Port Train Rake')
		AND SS.SampleSource IS NULL
	GROUP BY dbo.GetDateMonth(WS.Weightometer_Sample_Date), L.LocationId, WSN.Notes	
	
	-- Remove non Undiluted Rakes if are also port actuals.
	DELETE SS
	FROM @SampleSource AS SS
		INNER JOIN @SampleSource AS OSS
			ON (SS.LocationID = OSS.LocationId 
				AND SS.MonthPeriod = OSS.MonthPeriod
				AND OSS.SampleSource = @UndilutedRakes)
	WHERE SS.SampleSource = @PortActuals
	
	RETURN
END
GO

/*
select ws.*, l.name, lt.description
from dbo.GetBhpbioWeightometerSampleSource(1, '01-apr-2009', '30-jun-2009') as ws
	inner join location as l
		on l.location_id = ws.locationId
	inner join locationtype as lt
		on l.location_type_id = lt.location_type_id
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportLocationBreakdown.udf'
GO

IF Object_Id('dbo.GetBhpbioReportLocationBreakdown') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioReportLocationBreakdown
GO

CREATE FUNCTION dbo.GetBhpbioReportLocationBreakdown
(
	@iLocationId INT,
	@iGetChildLocations BIT,
	@iLowestLocationTypeDescription VARCHAR(31)
)
RETURNS @Location TABLE
(
	LocationId INT NOT NULL,
	ParentLocationId INT NULL
	PRIMARY KEY CLUSTERED (LocationId)
)
BEGIN
	-- effectively returns a Location Subtree
	-- if "GetChildLocations" = 0 then the returned ParentLocationId's are NOT resolved
	-- if         ""          = 1 then the returned ParentLocationId's ARE resolved

	DECLARE @CurrentLocationTypeId TINYINT
	DECLARE @NextLocationTypeId TINYINT
	DECLARE @BreakDownLocationTypeId TINYINT
	DECLARE @LocationId INT

	DECLARE @CurrentLevel TINYINT
	DECLARE @LowestLevel TINYINT
	
	DECLARE @ParentLocation TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	-- resolve the lowest location level we want to achieve
	SET @LowestLevel =
		(
			SELECT Location_Level
			FROM dbo.GetLocationTypeHierarchy(0) AS h
				INNER JOIN dbo.LocationType AS lt
					ON (h.Location_Type_Id = lt.Location_Type_Id)
			WHERE (@iLowestLocationTypeDescription IS NOT NULL AND lt.Description = @iLowestLocationTypeDescription)
				OR (@iLowestLocationTypeDescription IS NULL AND h.Bottom_In_Hierarchy = 1)
		)
	
	SET @LocationId = @iLocationId
	IF @LocationId <= 0 OR @LocationId IS NULL
	BEGIN
		SELECT @LocationId = Location_Id
		FROM dbo.Location
		WHERE Parent_Location_Id IS NULL
	END
	
	IF @iGetChildLocations = 1
	BEGIN
		SELECT @BreakDownLocationTypeId = LT.Location_Type_Id
		FROM dbo.Location AS L
			INNER JOIN dbo.LocationType AS LT
				ON (L.Location_Type_Id = LT.Parent_Location_Type_Id)
		WHERE L.Location_Id = @LocationId
		
		INSERT INTO @ParentLocation
			(LocationId)
		SELECT Location_Id
		FROM dbo.Location AS L
		WHERE L.Parent_Location_Id = @LocationId
	END
	
	-- determine the location id to seed the process
	SELECT @CurrentLocationTypeId = lt.Location_Type_Id
	FROM dbo.LocationType AS lt
		INNER JOIN Location AS l
			ON lt.Parent_Location_Type_Id = l.Location_Type_Id
	WHERE l.Location_Id = @LocationId

	-- determine the current location level
	SET @CurrentLevel =
		(
			SELECT Location_Level
			FROM dbo.GetLocationTypeHierarchy(0)
			WHERE Location_Type_Id = @CurrentLocationTypeId
		)

	-- add the seed record
	INSERT INTO @Location
		(LocationId, ParentLocationId)
	SELECT L.Location_Id, dbo.GetLocationTypeLocationId(L.Location_Id, @BreakDownLocationTypeId)
	FROM dbo.Location AS L
	WHERE L.Location_Id = @LocationId

	-- at each level, add all child records
	WHILE (@CurrentLocationTypeId IS NOT NULL) AND (@CurrentLevel <= @LowestLevel)
	BEGIN
		-- add all records FROM the current level
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT l.Location_Id,
			CASE	WHEN PL.LocationId IS NOT NULL THEN PL.LocationId
					WHEN CL.ParentLocationId IS NOT NULL THEN CL.ParentLocationId
					ELSE NULL
			END
		FROM dbo.Location AS l 
			INNER JOIN @Location AS CL
				ON (l.Parent_Location_Id = CL.LocationId)
			LEFT JOIN @ParentLocation AS pl
				ON (pl.LocationId = l.Location_Id)
		WHERE l.Location_Type_Id = @CurrentLocationTypeId

		-- Advance to the next lowest location type id
		SET @NextLocationTypeId = NULL
		
		SELECT @NextLocationTypeId = LT.Location_Type_Id
		FROM dbo.LocationType AS PLT
			INNER JOIN dbo.LocationType AS LT
				ON (PLT.Location_Type_Id = LT.Parent_Location_Type_Id)
		WHERE PLT.Location_Type_Id = @CurrentLocationTypeId

		SET @CurrentLocationTypeId = @NextLocationTypeId
		SET @CurrentLevel = @CurrentLevel + 1
	END

	IF @iGetChildLocations = 1
	BEGIN
		DELETE
		FROM @Location
		WHERE ParentLocationId IS NULL
	END
	
	RETURN
END
GO

/*
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(12, 0, NULL)

SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(24749, 0, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(12, 0, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(8, 0, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(1, 0, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(NULL, 0, 'SITE')

SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(24749, 1, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(12, 1, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(8, 1, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(1, 1, 'SITE')
SELECT * FROM dbo.GetBhpbioReportLocationBreakdown(NULL, 1, 'SITE')
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.getbhpbiodataexceptionlocationignorelist.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioDataExceptionLocationIgnoreList') IS NOT NULL 
     DROP FUNCTION dbo.GetBhpbioDataExceptionLocationIgnoreList
Go 

CREATE FUNCTION dbo.GetBhpbioDataExceptionLocationIgnoreList
(
	@iLocationId INT
)
-- Searches the data exceptions for their location, if they are of the provided location tree they are removed.
RETURNS @Exceptions TABLE
(
	DataExceptionId INT,
	LocationId INT,
	PRIMARY KEY (DataExceptionId)
)
BEGIN
	
	DECLARE @LocationTypeId TINYINT
	
	
	SELECT @LocationTypeId = Location_Type_Id
		FROM Location L
		WHERE Location_Id = @iLocationId
		
	INSERT INTO @Exceptions
	(DataExceptionId, LocationId)
	SELECT DataExceptionId, LocationId
	FROM BhpbioDataExceptionLocation

	IF @iLocationId IS NOT NULL AND @iLocationId > 0
	BEGIN
		DELETE E
		FROM @Exceptions As E
		WHERE dbo.GetLocationTypeLocationId(E.LocationId, @LocationTypeId) = @iLocationId
	END
	ELSE
	BEGIN
		DELETE FROM @Exceptions
	END
	
	RETURN
END

GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportActualC.udf'
GO

IF Object_Id('dbo.GetBhpbioReportActualC') IS NOT NULL
	DROP FUNCTION dbo.GetBhpbioReportActualC
GO

CREATE FUNCTION dbo.GetBhpbioReportActualC
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iGetChildLocations BIT
)
RETURNS @C TABLE
(
	CalendarDate DATETIME NOT NULL,
	DateFrom DATETIME NOT NULL,
	DateTo DATETIME NOT NULL,
	DesignationMaterialTypeId INT NOT NULL,
	LocationId INT NULL,
	SampleTonnes FLOAT NULL,
	Attribute SMALLINT NULL,
	Value FLOAT NULL
)
AS
BEGIN
	-- this DOES NOT and CAN NOT return data below the site level
	-- this is because:
	-- (1) weightometers & crushers are at the SITE level, and
	-- (2) the way Sites aggregate is based on the "Sample" tonnes method,
	--     .. hence these records need to be returned at the Site level
	-- note that data must not be returned at the Hub/Company level either

	-- 'C' - all crusher removals
	-- returns [High Grade] & [Bene Feed] as designation types

	DECLARE @Weightometer TABLE
	(
		CalendarDate DATETIME NOT NULL,
		WeightometerSampleId INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		SiteLocationId INT NULL,
		RealTonnes FLOAT NULL,
		SampleTonnes FLOAT NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		PRIMARY KEY (WeightometerSampleId, CalendarDate)
	)
	
	DECLARE @GradeLocation TABLE
	(
		CalendarDate DATETIME NOT NULL,
		SiteLocationId INT NOT NULL,
		PRIMARY KEY (SiteLocationId, CalendarDate)
	)
	
	DECLARE @SiteLocation TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @DesiredLocation TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	DECLARE @HighGradeMaterialTypeId INT
	DECLARE @BeneFeedMaterialTypeId INT
	DECLARE @SampleTonnesField VARCHAR(31)
	DECLARE @SampleSourceField VARCHAR(31)
	DECLARE @SiteLocationTypeId SMALLINT
	
	DECLARE @CSite TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		SiteLocationId INT NOT NULL,
		SampleTonnes FLOAT NULL,
		Attribute SMALLINT NOT NULL,
		Value FLOAT NULL,
		PRIMARY KEY (CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, SiteLocationId, Attribute)
	)
	
	SET @SampleTonnesField = 'SampleTonnes'
	SET @SampleSourceField = 'SampleSource'
	
	SET @HighGradeMaterialTypeId =
		(
			SELECT Material_Type_Id
			FROM dbo.MaterialType
			WHERE Abbreviation = 'High Grade'
				AND Material_Category_Id = 'Designation'
		)

	SET @BeneFeedMaterialTypeId = 
		(
			SELECT Material_Type_Id
			FROM dbo.MaterialType
			WHERE Abbreviation = 'Bene Feed'
				AND Material_Category_Id = 'Designation'
		)
	
	-- Setup the Locations
	-- collect at site level (this is used to ensure the site's sampled tonnes are collated)
	SET @SiteLocationTypeId =
		(
			SELECT Location_Type_Id
			FROM dbo.LocationType
			WHERE Description = 'Site'
		)
	INSERT INTO @SiteLocation
		(LocationId)
	SELECT LocationId
	FROM dbo.GetLocationSubtreeByLocationType(@iLocationId, @SiteLocationTypeId, @SiteLocationTypeId)

	-- this represents the location tree for what's desired	
	INSERT INTO @DesiredLocation
		(LocationId, ParentLocationId)
	SELECT LocationId, ParentLocationId
	FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iGetChildLocations, 'Site')
	
	-- retrieve the list of Weightometer Records to be used in the calculations
	INSERT INTO @Weightometer
		(
			CalendarDate, DateFrom, DateTo, WeightometerSampleId, SiteLocationId,
			RealTonnes, SampleTonnes, DesignationMaterialTypeId
		)
	SELECT b.CalendarDate, b.DateFrom, b.DateTo, w.WeightometerSampleId, l.LocationId,
		-- calculate the REAL tonnes
		CASE
			WHEN w.UseAsRealTonnes = 1
				THEN ISNULL(ws.Corrected_Tonnes, ws.Tonnes)
			ELSE NULL
		END AS RealTonnes,
		-- calculate the SAMPLE tonnes
		-- if a sample tonnes hasn't been provided then use the actual tonnes recorded for the transaction
		-- not all flows will have this recorded (in particular CVF corrected plant balanced records)
		CASE BeneFeed
			WHEN 1 THEN ISNULL(ws.Corrected_Tonnes, ws.Tonnes)
			ELSE ISNULL(wsv.Field_Value, 0.0)
		END AS SampleTonnes,
		-- return the Material Type based on whether it is bene feed
		CASE w.BeneFeed
			WHEN 1 THEN @BeneFeedMaterialTypeId
			WHEN 0 THEN @HighGradeMaterialTypeId
		END AS MaterialTypeId
	FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1) AS b
		INNER JOIN dbo.WeightometerSample AS ws
			ON (ws.Weightometer_Sample_Date BETWEEN b.DateFrom AND b.DateTo)
		INNER JOIN
			(
				-- collect the weightometer sample id's for all movements from the crusher
				-- these are used to ease lookup and ensure uniqueness of the weightometer_sample_ids returned
				SELECT dttf.Weightometer_Sample_Id AS WeightometerSampleId, 1 AS UseAsRealTonnes,
					CASE
						WHEN m.Mill_Id IS NOT NULL
							THEN 1
						ELSE 0
					END AS BeneFeed, l.LocationId
				FROM dbo.DataTransactionTonnes AS dtt
					INNER JOIN dbo.DataTransactionTonnesFlow AS dttf
						ON (dttf.Data_Transaction_Tonnes_Id = dtt.Data_Transaction_Tonnes_Id)
					INNER JOIN dbo.CrusherLocation AS cl
						ON (dttf.Source_Crusher_Id = cl.Crusher_Id)
					LEFT JOIN dbo.Mill AS m
						ON (dttf.Destination_Stockpile_Id = m.Stockpile_Id)
					INNER JOIN @SiteLocation AS l
						ON (cl.Location_Id = l.LocationId)
				WHERE dtt.Data_Transaction_Tonnes_Date BETWEEN @iDateFrom AND @iDateTo
					AND dttf.Destination_Crusher_Id IS NULL  -- ignore crusher to crusher feeds
				GROUP BY dttf.Weightometer_Sample_Id, m.Mill_Id, l.LocationId
				UNION 
				-- collect weightometer sample id's for all movements to train rakes
				-- (by definition it's always delivers to train rake stockpiles...
				--  the grades (but not the tonnes) from these weightometers samples are important to us)
				SELECT dttf.Weightometer_Sample_Id, 0, 0, l.LocationId
				FROM dbo.DataTransactionTonnes AS dtt
					INNER JOIN dbo.DataTransactionTonnesFlow AS dttf
						ON (dttf.Data_Transaction_Tonnes_Id = dtt.Data_Transaction_Tonnes_Id)
					INNER JOIN dbo.WeightometerSample AS ws
						ON (dttf.Weightometer_Sample_Id = ws.Weightometer_Sample_Id)
					INNER JOIN dbo.StockpileGroupStockpile AS sgs
						ON (sgs.Stockpile_Id = dttf.Destination_Stockpile_Id)
					INNER JOIN dbo.WeightometerLocation AS wl
						ON (ws.Weightometer_Id = wl.Weightometer_Id)
					INNER JOIN @SiteLocation AS l
						ON (wl.Location_Id = l.LocationId)
				WHERE dtt.Data_Transaction_Tonnes_Date BETWEEN @iDateFrom AND @iDateTo
					AND sgs.Stockpile_Group_Id = 'Port Train Rake'
				GROUP BY dttf.Weightometer_Sample_Id, l.LocationId
			  ) AS w
			ON (ws.Weightometer_Sample_Id = w.WeightometerSampleId)
			-- ensure the weightometer belongs to the required location
		INNER JOIN dbo.WeightometerLocation AS wl
			ON (wl.Weightometer_Id = ws.Weightometer_Id)
		INNER JOIN @SiteLocation AS l
			ON (l.LocationId = wl.Location_Id)
		LEFT OUTER JOIN dbo.WeightometerSampleValue AS wsv
			ON (ws.Weightometer_Sample_Id = wsv.Weightometer_Sample_Id
				AND wsv.Weightometer_Sample_Field_Id = @SampleTonnesField)

	-- return the TONNES values
	-- these are literally the "best tonnes" provided by the weightometer sample
	INSERT INTO @CSite
		(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, SiteLocationId, SampleTonnes, Attribute, Value)
	SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, 
		SiteLocationId, NULL, 0, SUM(RealTonnes)
	FROM @Weightometer
	GROUP BY CalendarDate, DateFrom, DateTo, SiteLocationId, DesignationMaterialTypeId
	HAVING SUM(RealTonnes) IS NOT NULL
	
	-- Get the valid locations to be used for the grades. 
	-- This is so locations with no valid real tonnes are not included in the calc.
	INSERT INTO @GradeLocation
		(CalendarDate, SiteLocationId)
	SELECT CalendarDate, SiteLocationId
	FROM @Weightometer
	WHERE RealTonnes IS NOT NULL
	GROUP BY CalendarDate, SiteLocationId

	-- return the GRADES values
	INSERT INTO @CSite
	(
		CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId,
		SiteLocationId, SampleTonnes, Attribute, Value
	)
	SELECT w.CalendarDate, w.DateFrom, w.DateTo, w.DesignationMaterialTypeId,
		w.SiteLocationId, SUM(w.SampleTonnes), g.Grade_Id As GradeId,
		SUM(w.SampleTonnes * wsg.Grade_Value) / 
		NULLIF(SUM(CASE WHEN wsg.Grade_Value IS NULL THEN NULL ELSE w.SampleTonnes END), 0.0) As GradeValue
	FROM @Weightometer AS w
		-- check the membership with the Sample Source
		LEFT OUTER JOIN
			(
				SELECT ws.Weightometer_Sample_Id
				FROM dbo.WeightometerSample AS ws
					INNER JOIN dbo.WeightometerLocation AS wl
						ON (ws.Weightometer_Id = wl.Weightometer_Id)
					INNER JOIN dbo.WeightometerSampleNotes AS wsn
						ON (wsn.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
							AND wsn.Weightometer_Sample_Field_Id = @SampleSourceField)
					INNER JOIN dbo.GetBhpbioWeightometerSampleSource(@iLocationId, @iDateFrom, @iDateTo) AS ss
						ON (dbo.GetDateMonth(ws.Weightometer_Sample_Date) = ss.MonthPeriod
							AND wl.Location_Id = ss.LocationId
							AND wsn.Notes = ss.SampleSource)
			) AS sSource
			ON (sSource.Weightometer_Sample_Id = w.WeightometerSampleId)
		-- add the grades
		CROSS JOIN dbo.Grade AS g
		LEFT JOIN dbo.WeightometerSampleGrade AS wsg
			ON (w.WeightometerSampleId = wsg.Weightometer_Sample_Id
				AND g.Grade_Id = wsg.Grade_Id)
		INNER JOIN @GradeLocation AS gl
			ON (gl.CalendarDate = w.CalendarDate
				AND ISNULL(gl.SiteLocationId, -1) = ISNULL(w.SiteLocationId, -1))
	WHERE
		-- only include if:
		-- 1. the Material Type is Bene Feed and there is no Sample Source
		-- 2. the Material Type is High Grade and there is a matching SampleSource
		CASE
			WHEN (DesignationMaterialTypeId = @BeneFeedMaterialTypeId) AND (sSource.Weightometer_Sample_Id IS NULL) THEN 1
			WHEN (DesignationMaterialTypeId = @HighGradeMaterialTypeId) AND (sSource.Weightometer_Sample_Id IS NOT NULL) THEN 1
			ELSE 0
		END = 1
	GROUP BY w.CalendarDate, w.DateFrom, w.DateTo, g.Grade_Id, w.SiteLocationId, w.DesignationMaterialTypeId
	
	-- aggregate to the desired location
	
	-- tonnes
	INSERT INTO @C
	(
		CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId,
		LocationId, Attribute, Value
	)
	SELECT c.CalendarDate, c.DateFrom, c.DateTo, c.DesignationMaterialTypeId,
		l.ParentLocationId, c.Attribute, SUM(c.Value)
	FROM @CSite AS c
		INNER JOIN @DesiredLocation AS l
			ON (c.SiteLocationId = l.LocationId)
	WHERE c.Attribute = 0
	GROUP BY c.CalendarDate, c.DateFrom, c.DateTo, c.DesignationMaterialTypeId,
		l.ParentLocationId, c.Attribute

	-- grades	
	INSERT INTO @C
	(
		CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId,
		LocationId, SampleTonnes, Attribute, Value
	)
	SELECT cg.CalendarDate, cg.DateFrom, cg.DateTo, cg.DesignationMaterialTypeId,
		l.ParentLocationId, SUM(ct.Value), cg.Attribute,
		SUM(cg.Value * ct.Value) / NULLIF(SUM(ct.Value), 0.0)
	FROM @CSite AS cg
		INNER JOIN @DesiredLocation AS l
			ON (cg.SiteLocationId = l.LocationId)
		INNER JOIN @CSite AS ct
			ON (cg.CalendarDate = ct.CalendarDate
				AND cg.DateFrom = ct.DateFrom
				AND cg.DateTo = ct.DateTo
				AND cg.DesignationMaterialTypeId = ct.DesignationMaterialTypeId
				AND cg.SiteLocationId = ct.SiteLocationId)
	WHERE cg.Attribute > 0
		AND ct.Attribute = 0
	GROUP BY cg.CalendarDate, cg.DateFrom, cg.DateTo, cg.DesignationMaterialTypeId,
		l.ParentLocationId, cg.Attribute
		
	RETURN
END
GO

/*
SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value FROM dbo.GetBhpbioReportActualC('01-JUL-2009', '31-JUL-2009', NULL, 1, 1) where attribute in (0, 1) order by locationid
SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value FROM dbo.GetBhpbioReportActualC('01-JUL-2009', '31-JUL-2009', NULL, 1, 0) where attribute in (0, 1) order by locationid

SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 1, 0) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, NULL, 1) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 1, 1) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 1, 0) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 6, 0) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 7, 0) where Attribute = 1
SELECT * FROM dbo.GetBhpbioReportActualC('01-APR-2009', '30-JUN-2009', NULL, 6334, 0) where Attribute = 1

SELECT LocationId, ParentLocationId
FROM dbo.GetBhpbioReportLocationBreakdown(8, 1, 'Site')

SELECT LocationId, ParentLocationId
FROM dbo.GetBhpbioReportLocationBreakdown(8, 0, 'Site')

*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportActualY.udf'
GO

IF Object_Id('dbo.GetBhpbioReportActualY') IS NOT NULL
	DROP FUNCTION dbo.GetBhpbioReportActualY
GO

CREATE FUNCTION dbo.GetBhpbioReportActualY
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iGetChildLocations BIT
)
RETURNS @Y TABLE
(
	CalendarDate DATETIME NOT NULL,
	DateFrom DATETIME NOT NULL,
	DateTo DATETIME NOT NULL,
	DesignationMaterialTypeId INT NOT NULL,
	LocationId INT NULL,
	Attribute INT NULL,
	Value FLOAT NULL
)
AS
BEGIN
	-- 'y' - pit to pre-crusher stockpiles
	-- the material types must be reported accurately

	DECLARE @Haulage TABLE
	(
		CalendarDate DATETIME NOT NULL,
		HaulageId INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		ParentLocationId INT NULL,
		Tonnes FLOAT NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		PRIMARY KEY (HaulageId, CalendarDate)
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	-- setup the Locations
	INSERT INTO @Location
		(LocationId, ParentLocationId)
	SELECT LocationId, ParentLocationId
	FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iGetChildLocations, NULL)

	-- retrieve the list of Haulage Records to be used in the calculations
	INSERT INTO @Haulage
		(CalendarDate, DateFrom, DateTo, HaulageId, ParentLocationId, Tonnes, DesignationMaterialTypeId)
	SELECT rd.CalendarDate, rd.DateFrom, rd.DateTo, h.Haulage_Id, l.ParentLocationId, h.Tonnes,
		destinationStockpile.MaterialTypeId
	FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1) AS rd
		INNER JOIN dbo.Haulage AS h
			ON (h.Haulage_Date BETWEEN rd.DateFrom AND rd.DateTo)
		INNER JOIN dbo.DigblockLocation dl
			ON (dl.Digblock_Id = h.Source_Digblock_Id)
		INNER JOIN @Location AS l
			ON (l.LocationId = dl.Location_Id)
		-- join to the destination stockpile
		INNER JOIN
			(
				SELECT sl2.Stockpile_Id, sgd2.MaterialTypeId
				FROM dbo.BhpbioStockpileGroupDesignation AS sgd2
					INNER JOIN dbo.StockpileGroupStockpile AS sgs2
						ON (sgs2.Stockpile_Group_Id = sgd2.StockpileGroupId)
					INNER JOIN dbo.StockpileLocation AS sl2
						ON (sl2.Stockpile_Id = sgs2.Stockpile_Id)
			) AS destinationStockpile
			ON (destinationStockpile.Stockpile_Id = h.Destination_Stockpile_Id)
	WHERE h.Haulage_State_Id IN ('N', 'A')
		AND h.Child_Haulage_Id IS NULL
		AND h.Source_Digblock_Id IS NOT NULL

	-- return the TONNES values
	INSERT INTO @Y
		(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, ParentLocationId, 0, SUM(Tonnes)
	FROM @Haulage
	GROUP BY CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, ParentLocationId

	-- return the GRADES values
	INSERT INTO @Y
		(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT h.CalendarDate, h.DateFrom, h.DateTo, h.DesignationMaterialTypeId, h.ParentLocationId,
		g.Grade_Id, SUM(h.Tonnes * hg.Grade_Value) / NULLIF(SUM(h.Tonnes), 0.0)
	FROM @Haulage AS h
		-- add the grades
		CROSS JOIN dbo.Grade AS g
		LEFT JOIN dbo.HaulageGrade AS hg
			ON (h.HaulageId = hg.Haulage_Id
				AND g.Grade_Id = hg.Grade_Id)
	GROUP BY h.CalendarDate, h.DateFrom, h.DateTo, g.Grade_Id, h.DesignationMaterialTypeId, h.ParentLocationId
	
	RETURN
END
GO

/*
SELECT * FROM dbo.GetBhpbioReportActualY('01-APR-2008', '30-JUN-2008', 'MONTH', 1, 1)
SELECT * FROM dbo.GetBhpbioReportActualY('01-APR-2008', '30-JUN-2008', 'MONTH', 1, 0)
SELECT * FROM dbo.GetBhpbioReportActualY('01-APR-2008', '30-JUN-2008', NULL, 1, 0)
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportActualZ.udf'
GO

IF Object_Id('dbo.GetBhpbioReportActualZ') IS NOT NULL
	DROP FUNCTION dbo.GetBhpbioReportActualZ
GO

CREATE FUNCTION dbo.GetBhpbioReportActualZ
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iGetChildLocations BIT
)
RETURNS @Z TABLE
(
	CalendarDate DATETIME NOT NULL,
	DateFrom DATETIME NOT NULL,
	DateTo DATETIME NOT NULL,
	DesignationMaterialTypeId INT NOT NULL,
	LocationId INT NULL,
	Attribute INT NULL,
	Value FLOAT NULL
)
AS
BEGIN
	-- 'Z' - pre crusher stockpiles to crusher
	-- movements through the crusher must be reported as [High Grade] and [Bene Feed] only

	DECLARE @Haulage TABLE
	(
		CalendarDate DATETIME NOT NULL,
		HaulageId INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		ParentLocationId INT NULL,
		Tonnes FLOAT NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		PRIMARY KEY (HaulageId, CalendarDate)
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	DECLARE @HighGradeMaterialTypeId INT
	DECLARE @BeneFeedMaterialTypeId INT

	-- set the material types
	SET @HighGradeMaterialTypeId =
		(
			SELECT Material_Type_Id
			FROM dbo.MaterialType
			WHERE Abbreviation = 'High Grade'
				AND Material_Category_Id = 'Designation'
		)

	SET @BeneFeedMaterialTypeId =
		(
			SELECT Material_Type_Id
			FROM dbo.MaterialType
			WHERE Abbreviation = 'Bene Feed'
				AND Material_Category_Id = 'Designation'
		)
	
	-- setup the Locations
	INSERT INTO @Location
		(LocationId, ParentLocationId)
	SELECT LocationId, ParentLocationId
	FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iGetChildLocations, NULL)

	-- collect the haualge data that matches:
	-- 1. the date range specified
	-- 2. delivers to a crusher (which belongs to the location subtree specified)
	-- 3. sources from a designation stockpile group
	--
	-- for the Material Type, the following rule applies:
	-- If the Weightometer deliveres to a plant then it is BENE, otherwise it is High Grade.

	-- retrieve the list of Haulage Records to be used in the calculations
	INSERT INTO @Haulage
		(CalendarDate, DateFrom, DateTo, HaulageId, ParentLocationId, Tonnes, DesignationMaterialTypeId)
	SELECT b.CalendarDate, b.DateFrom, b.DateTo, h.Haulage_Id, l.ParentLocationId, h.Tonnes,
		CASE WHEN W.Weightometer_Id IS NOT NULL THEN @BeneFeedMaterialTypeId
				ELSE @HighGradeMaterialTypeId
		END
	FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS b
			INNER JOIN dbo.Haulage AS h
				ON (h.Haulage_Date BETWEEN b.DateFrom AND b.DateTo)
			INNER JOIN dbo.Crusher AS c
				ON (c.Crusher_Id = h.Destination_Crusher_Id)
			INNER JOIN dbo.CrusherLocation AS cl
				ON (cl.Crusher_Id = c.Crusher_Id)
			INNER JOIN @Location AS l
				ON (l.LocationId = cl.Location_Id)
			INNER JOIN dbo.Stockpile AS s
				ON (h.Source_Stockpile_Id = s.Stockpile_Id)
			INNER JOIN dbo.StockpileGroupStockpile AS sgs
				ON (sgs.Stockpile_Id = s.Stockpile_Id)
			INNER JOIN dbo.BhpbioStockpileGroupDesignation AS sgd
				ON (sgd.StockpileGroupId = sgs.Stockpile_Group_Id)
			LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
				ON (WFPV.Source_Crusher_Id = c.Crusher_Id
					AND WFPV.Destination_Mill_Id IS NOT NULL
					AND (b.DateTo > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
					AND (b.DateFrom < WFPV.End_Date Or WFPV.End_Date IS NULL))
			LEFT JOIN dbo.Weightometer AS W
				ON (W.Weightometer_Id = WFPV.Weightometer_Id)
		WHERE h.Haulage_State_Id IN ('N', 'A')
			AND h.Child_Haulage_Id IS NULL
			AND (W.Weightometer_Type_Id LIKE '%L1%' OR W.Weightometer_Type_Id IS NULL)
			AND h.Source_Stockpile_Id IS NOT NULL
			
	-- return the TONNES values
	INSERT INTO @Z
		(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, ParentLocationId, 0, SUM(Tonnes)
	FROM @Haulage
	GROUP BY CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, ParentLocationId

	-- return the GRADES values
	INSERT INTO @Z
		(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT h.CalendarDate, h.DateFrom, h.DateTo, h.DesignationMaterialTypeId, h.ParentLocationId,
		g.Grade_Id, SUM(h.Tonnes * hg.Grade_Value) / NULLIF(SUM(h.Tonnes), 0.0)
	FROM @Haulage AS h
		-- add the grades
		CROSS JOIN dbo.Grade AS g
		LEFT JOIN dbo.HaulageGrade AS hg
			ON (h.HaulageId = hg.Haulage_Id
				AND g.Grade_Id = hg.Grade_Id)
	GROUP BY h.CalendarDate, h.DateFrom, h.DateTo, g.Grade_Id, h.DesignationMaterialTypeId, h.ParentLocationId
	
	RETURN
END
GO

/*
select * FROM dbo.GetBhpbioReportActualZ('1-apr-2008', '30-apr-2008', Null, 6, 1) 
SELECT * FROM dbo.GetBhpbioReportActualZ('01-APR-2008', '30-JUN-2008', 'MONTH', 1, 1)
SELECT * FROM dbo.GetBhpbioReportActualZ('01-APR-2008', '30-JUN-2008', 'MONTH', 1, 0)
SELECT * FROM dbo.GetBhpbioReportActualZ('01-APR-2008', '30-JUN-2008', NULL, 1, 0)
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.GetBhpbioReportModel.udf'
GO

IF Object_Id('dbo.GetBhpbioReportModel') IS NOT NULL
	DROP FUNCTION dbo.GetBhpbioReportModel
GO

CREATE FUNCTION dbo.GetBhpbioReportModel
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iGetChildLocations BIT
)
RETURNS @M TABLE
(
	CalendarDate DATETIME NOT NULL,
	BlockModelId INT NOT NULL,
	DateFrom DATETIME NOT NULL,
	DateTo DATETIME NOT NULL,
	DesignationMaterialTypeId INT NOT NULL,
	LocationId INT NULL,
	Attribute SMALLINT NULL,
	Value FLOAT NULL
)
AS
BEGIN
	-- 'M' - all model movements
	-- returns all designation types

	DECLARE @Model TABLE
	(
		CalendarDate DATETIME NOT NULL,
		BlockModelId INT NOT NULL,
		ModelBlockId INT NOT NULL,
		SequenceNo INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		ParentLocationId INT NULL,
		Tonnes FLOAT NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		PRIMARY KEY (ModelBlockId, SequenceNo, BlockModelId, CalendarDate)
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	-- Setup the Locations
	INSERT INTO @Location
		(LocationId, ParentLocationId)
	SELECT LocationId, ParentLocationId
	FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iGetChildLocations, NULL)

	-- retrieve the list of Model Block Partials to be used in the calculations
	INSERT INTO @Model
		(CalendarDate, DateFrom, DateTo, BlockModelId, ModelBlockId, SequenceNo, ParentLocationId, Tonnes, DesignationMaterialTypeId)
	SELECT b.CalendarDate, b.DateFrom, b.DateTo, mb.Block_Model_Id, mbp.Model_Block_Id, mbp.Sequence_No, l.ParentLocationId,
		SUM(mbp.Tonnes * rm.MinedPercentage), oreTypeMaterial.Parent_Material_Type_Id
	FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1) AS b
		INNER JOIN dbo.BhpbioImportReconciliationMovement AS rm
			ON (rm.DateFrom >= b.DateFrom
				AND rm.DateTo <= b.DateTo)
		INNER JOIN dbo.ModelBlockLocation AS mbl
			ON (mbl.Location_Id = rm.BlockLocationId)
		INNER JOIN dbo.ModelBlock AS mb
			ON (mb.Model_Block_Id = mbl.Model_Block_Id)
		INNER JOIN dbo.ModelBlockPartial AS mbp
			ON (mbp.Model_Block_Id = mb.Model_Block_Id)
		-- filter by location
		INNER JOIN @Location AS l
			ON (mbl.Location_Id = l.LocationId)
		INNER JOIN dbo.MaterialType AS oreTypeMaterial
			ON (oreTypeMaterial.Material_Type_Id = mbp.Material_Type_Id)
	GROUP BY b.CalendarDate, b.DateFrom, b.DateTo, mb.Block_Model_Id, mbp.Model_Block_Id, mbp.Sequence_No, l.ParentLocationId,
		oreTypeMaterial.Parent_Material_Type_Id
	
	-- return the TONNES values
	INSERT INTO @M
		(CalendarDate, BlockModelId, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT CalendarDate, BlockModelId, DateFrom, DateTo, DesignationMaterialTypeId, 
		ParentLocationId, 0, SUM(Tonnes)
	FROM @Model
	GROUP BY CalendarDate, BlockModelId, DateFrom, DateTo, ParentLocationId, DesignationMaterialTypeId

	-- return the GRADES values
	INSERT INTO @M
		(CalendarDate, BlockModelId, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
	SELECT m.CalendarDate, m.BlockModelId, m.DateFrom, m.DateTo, m.DesignationMaterialTypeId,
		m.ParentLocationId, g.Grade_Id As GradeId,
		SUM(m.Tonnes * mbpg.Grade_Value) / NULLIF(SUM(m.Tonnes), 0.0) As GradeValue
	FROM @Model AS m
		-- add the grades
		CROSS JOIN dbo.Grade AS g
		LEFT JOIN dbo.ModelBlockPartialGrade AS mbpg
			ON (mbpg.Model_Block_Id = m.ModelBlockId
				AND mbpg.Sequence_No = m.SequenceNo
				AND g.Grade_Id = mbpg.Grade_Id)
	GROUP BY m.CalendarDate, m.BlockModelId, m.DateFrom, m.DateTo, g.Grade_Id, m.ParentLocationId, m.DesignationMaterialTypeId
	
	RETURN
END
GO

/*
SELECT * FROM dbo.GetBhpbioReportModel('01-APR-2008', '30-JUN-2008', 'MONTH', 1, 1)
SELECT * FROM dbo.GetBhpbioReportModel('01-APR-2008', '30-JUN-2008', 'QUARTER', 1, 0)
SELECT * FROM dbo.GetBhpbioReportModel('01-APR-2008', '30-JUN-2008', NULL, 1, 0)
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Functions\dbo.BhpbioDoesQueuedBlocksJobExist.udf'
GO

IF OBJECT_ID('dbo.BhpbioDoesQueuedBlocksJobExist') IS NOT NULL 
     DROP FUNCTION dbo.BhpbioDoesQueuedBlocksJobExist
Go 

CREATE FUNCTION dbo.BhpbioDoesQueuedBlocksJobExist
(
	@iImportId INT,
	@iSite VARCHAR(31),
	@iPit VARCHAR(31),
	@iBench VARCHAR(31)
)

RETURNS BIT
AS 
BEGIN
	DECLARE @Exists BIT
		
	IF EXISTS (SELECT *
				FROM dbo.Import I
					INNER JOIN dbo.ImportJob IJ
						ON (IJ.ImportID = I.ImportID)
					INNER JOIN dbo.ImportJobParameter IJP_S
						ON (IJ.ImportJobId = IJP_S.ImportJobId)
					INNER JOIN dbo.ImportParameter IP_S
						ON (IJP_S.ImportParameterID = IP_S.ImportParameterID
							AND IP_S.ParameterName = 'Site')
					INNER JOIN dbo.ImportJobParameter IJP_P
						ON (IJ.ImportJobId = IJP_P.ImportJobId)
					INNER JOIN dbo.ImportParameter IP_P
						ON (IJP_P.ImportParameterID = IP_P.ImportParameterID
							AND IP_P.ParameterName = 'Pit')
					INNER JOIN dbo.ImportJobParameter IJP_B
						ON (IJ.ImportJobId = IJP_B.ImportJobId)
					INNER JOIN dbo.ImportParameter IP_B
						ON (IJP_B.ImportParameterID = IP_B.ImportParameterID
							AND IP_B.ParameterName = 'Bench')
					INNER JOIN dbo.ImportJobStatus IJS
						ON (IJS.ImportJobStatusId = IJ.ImportJobStatusId
							AND IJS.ImportJobStatusName = 'QUEUED')
				WHERE I.ImportID = @iImportId
					AND IJP_S.ParameterValue = @iSite
					AND IJP_P.ParameterValue = @iPit
					AND IJP_B.ParameterValue = ISNULL(@iBench, IJP_B.ParameterValue))
		BEGIN
			SET @Exists = 1
		END
		ELSE
		BEGIN
			SET @Exists = 0
		END
	
	RETURN @Exists
END
GO

GRANT EXECUTE ON dbo.BhpbioDoesQueuedBlocksJobExist TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioApprovalDigblockList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioApprovalDigblockList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioApprovalDigblockList  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioApprovalDigblockList
(
	@iLocationId INT,
	@iMonthFilter DATETIME,
	@iRecordLimit INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @LocationId INT
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @MonthDate DATETIME
	DECLARE @EndMonthDate DATETIME
	DECLARE @HauledFieldId VARCHAR(31)
	DECLARE @SurveyedFieldId VARCHAR(31)
	
	DECLARE @Results TABLE
	(
		DigblockId VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
		MaterialTypeDescription VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
		ApprovalMonth DATETIME NULL,
		MiningTonnes FLOAT NULL,
		GeologyTonnes FLOAT NULL,
		GradeControlTonnes FLOAT NULL,
		HauledTonnes FLOAT NULL,
		SurveyedTonnes FLOAT NULL,
		BestTonnes FLOAT NULL,
		CorrectedTonnes FLOAT NULL,
		RemainingTonnes FLOAT NULL,
		MinedPercent FLOAT NULL,
		BlockLocationId INT NULL,
		Approved BIT NULL,
		SignoffUser VARCHAR(512) COLLATE DATABASE_DEFAULT NULL
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioApprovalDigblockList',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		DECLARE @MaterialCategory VARCHAR(31)
		SET @MaterialCategory = 'Designation'
		
		SET @HauledFieldId = 'HauledTonnes'
		SET @SurveyedFieldId = 'GroundSurveyTonnes'
		SET @MonthDate = dbo.GetDateMonth(@iMonthFilter)
		SET @EndMonthDate = DateAdd(Day, -1, DateAdd(Month, 1, @MonthDate))

		INSERT INTO @Location
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)
		
		SET @LocationId = @iLocationId
		IF @LocationId IS NOT NULL AND @LocationId < 0
		BEGIN
			SET @LocationId = NULL
		END
		

		-- Insert the inital data of a digblock id, and any approvals including the sign off person.
		INSERT INTO @Results
			(
				DigblockId, ApprovalMonth, Approved, SignoffUser, MinedPercent, BlockLocationId, 
				CorrectedTonnes, BestTonnes, HauledTonnes, SurveyedTonnes, RemainingTonnes, 
				MaterialTypeDescription
			)
		SELECT d.Digblock_Id, 
			@iMonthFilter,
			CASE WHEN a.DigblockId IS NOT NULL THEN 1 ELSE 0 END,
			CASE 
				WHEN u.UserId IS NOT NULL THEN u.FirstName + ' ' + u.LastName
				WHEN u.UserId IS NULL AND a.UserId IS NOT NULL THEN 'Unknown User'
				ELSE ''
			END,
			RM.MinedPercentage, 
			DL.Location_Id,
			processed.Corrected,
			field.Best,
			field.Hauled,
			field.Survey,
			-cumlative.Best,
			MT.Description
		FROM dbo.Digblock AS D
			INNER JOIN dbo.MaterialType AS MT
				ON (MT.Material_Type_Id = D.Material_Type_Id)
			INNER JOIN dbo.DigblockLocation AS DL
				ON (D.Digblock_Id = DL.Digblock_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = DL.Location_Id)
			LEFT JOIN dbo.BhpbioApprovalDigblock AS a
				ON d.Digblock_Id = a.DigblockId
					AND @MonthDate = a.ApprovedMonth
			LEFT JOIN dbo.SecurityUser AS u
				ON a.UserId = u.UserId
			LEFT JOIN dbo.BhpbioImportReconciliationMovement AS RM
				ON (RM.DateFrom >= @MonthDate
					AND RM.DateTo <= @EndMonthDate
					AND DL.Location_Id = RM.BlockLocationId)
			LEFT JOIN
				(
					SELECT DPT.Source_Digblock_Id As DigblockId,
						Coalesce(Sum(DPT.Tonnes), 0) As Corrected
					FROM dbo.DataProcessTransaction AS DPT
					WHERE DPT.Data_Process_Transaction_Date BETWEEN @MonthDate AND @EndMonthDate
					GROUP BY DPT.Source_Digblock_Id
				) AS processed
					ON D.Digblock_Id = processed.DigblockId
			LEFT JOIN
				(
					SELECT h.Source_Digblock_Id As DigblockId,
						Coalesce(Sum(h.Tonnes), 0) As Best,
						Coalesce(Sum(hauled.Field_Value), 0) As Hauled,
						Coalesce(Sum(survey.Field_Value), 0) As Survey
					FROM dbo.Haulage AS h
						LEFT JOIN dbo.HaulageValue AS hauled
							ON h.Haulage_Id = hauled.Haulage_Id
								AND hauled.Haulage_Field_Id = @HauledFieldId
						LEFT JOIN dbo.HaulageValue AS survey
							ON h.Haulage_Id = survey.Haulage_Id
								AND survey.Haulage_Field_Id = @SurveyedFieldId
					WHERE h.Haulage_Date BETWEEN @MonthDate AND @EndMonthDate
						AND h.Haulage_State_Id IN ('N', 'A')
						AND h.Child_Haulage_Id IS NULL
					GROUP BY h.Source_Digblock_Id	
				) AS field
					ON D.Digblock_Id = field.DigblockId
			LEFT JOIN
				(
					SELECT h.Source_Digblock_Id As DigblockId,
						Coalesce(Sum(h.Tonnes), 0) As Best
					FROM dbo.Haulage AS h
					WHERE h.Haulage_Date <= @EndMonthDate
						AND h.Haulage_State_Id IN ('N', 'A')
						AND h.Child_Haulage_Id IS NULL
					GROUP BY h.Source_Digblock_Id	
				) AS cumlative
					ON D.Digblock_Id = cumlative.DigblockId
		WHERE RM.MinedPercentage IS NOT NULL 
			OR field.Survey IS NOT NULL 
			OR field.Hauled IS NOT NULL 
			OR field.Best IS NOT NULL
			OR processed.Corrected IS NOT NULL

		-- Get the haulage and moved block tonnes
		UPDATE r
		SET MiningTonnes = model.Mining * r.MinedPercent,
			GradeControlTonnes = model.GradeControl * r.MinedPercent,
			GeologyTonnes = model.Geology * r.MinedPercent,
			RemainingTonnes = model.GradeControl + RemainingTonnes
		FROM @Results AS r
			LEFT JOIN 
				(
					SELECT r.DigblockId,
						Sum(CASE WHEN BM.Name = 'Mining' THEN MBP.Tonnes ELSE NULL END) AS Mining,
						Sum(CASE WHEN BM.Name = 'Grade Control' THEN MBP.Tonnes ELSE NULL END) As GradeControl,
						Sum(CASE WHEN BM.Name = 'Geology' THEN MBP.Tonnes ELSE NULL END) As Geology
					FROM @Results AS R
						INNER JOIN dbo.ModelBlockLocation AS MBL
							ON (R.BlockLocationId = MBL.Location_Id)
						INNER JOIN dbo.ModelBlock AS MB
							ON (MBL.Model_Block_Id = MB.Model_Block_Id)
						INNER JOIN dbo.BlockModel AS BM
							ON (BM.Block_Model_Id = MB.Block_Model_Id)
						INNER JOIN dbo.ModelBlockPartial AS MBP
							ON (MB.Model_Block_Id = MBP.Model_Block_Id)
						INNER JOIN dbo.GetMaterialsByCategory(@MaterialCategory) AS MC
							ON (MC.MaterialTypeId = MBP.Material_Type_Id)
						INNER JOIN dbo.MaterialType AS MT
							ON (MC.RootMaterialTypeId = MT.Material_Type_Id)
						--INNER JOIN dbo.GetBhpbioReportHighGrade() AS BRHG
						--	ON (BRHG.MaterialTypeId = MT.Material_Type_Id)
					GROUP BY R.DigblockId
				) AS model
					ON r.DigblockId = model.DigblockId

		IF @iRecordLimit IS NOT NULL
		BEGIN
			SET ROWCOUNT @iRecordLimit
		END
		
		-- Return the results					
		SELECT DigblockId, MaterialTypeDescription, MiningTonnes, GeologyTonnes, GradeControlTonnes, HauledTonnes,
				SurveyedTonnes, BestTonnes, CorrectedTonnes, RemainingTonnes, Approved, SignoffUser
		FROM @Results
		ORDER BY DigblockId

		IF @iRecordLimit IS NOT NULL
		BEGIN
			SET ROWCOUNT 0
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioApprovalDigblockList TO BhpbioGenericManager
GO

--EXEC dbo.GetBhpbioApprovalDigblockList  4, '1-SEP-2008', NULL


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioApprovalBlock.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioApprovalBlock') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioApprovalBlock  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioApprovalBlock 
(
	@iDigblockId VARCHAR(31),
	@oIsApproved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @ReturnValue BIT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'IsBhpbioApprovalBlock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- If the block has ever been approved, return true
		IF EXISTS	(
					SELECT TOP 1 1
					FROM dbo.BhpbioApprovalDigblock
					WHERE DigblockId = @iDigblockId
					)
		BEGIN
			SET @ReturnValue = 1
		END
		ELSE
		BEGIN
			SET @ReturnValue = 0
		END
		
		SET @oIsApproved = @ReturnValue

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioApprovalBlock TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioApprovalLocation.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioApprovalLocation') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioApprovalLocation  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioApprovalLocation 
(
	@iLocationId INT,
	@iMonth DATETIME,
	@iTagId VARCHAR(124),
	@iTagGroupId VARCHAR(124),
	@oIsApproved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	
	DECLARE @MonthDate DATETIME
	DECLARE @ReturnValue BIT
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'IsBhpbioApprovalLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @MonthDate = dbo.GetDateMonth(@iMonth)

		IF EXISTS
			(
				SELECT TOP 1 1 
				FROM dbo.BhpbioApprovalData AS a
					INNER JOIN dbo.BhpbioReportDataTags AS brdt
						ON brdt.TagId = a.TagId
				WHERE a.ApprovedMonth = @MonthDate 
					AND (a.TagId = @iTagId OR @iTagId IS NULL)
					AND (
							brdt.TagGroupId = @iTagGroupId 
						OR 
							( @iTagGroupId IS NULL AND brdt.TagGroupId <> 'F1Factor')
						)
			)
		BEGIN
			-- we have a "possible" match
			-- continue to invoke a location check
			IF EXISTS
				(
					SELECT TOP 1 1 
					FROM dbo.BhpbioApprovalData AS a
						INNER JOIN dbo.BhpbioReportDataTags AS brdt
							ON brdt.TagId = a.TagId
						INNER JOIN GetLocationSubtree(@iLocationId) AS t
							ON a.LocationId = t.Location_Id
					WHERE a.ApprovedMonth = @MonthDate 
						AND (a.TagId = @iTagId OR @iTagId IS NULL)
						AND (
							brdt.TagGroupId = @iTagGroupId 
						OR 
							( @iTagGroupId IS NULL AND brdt.TagGroupId <> 'F1Factor')
						)
				)
			BEGIN
				SET @ReturnValue = 1
			END
			ELSE
			BEGIN
				SET @ReturnValue = 0
			END
		END
		ELSE
		BEGIN
			SET @ReturnValue = 0
		END

		SET @oIsApproved = @ReturnValue

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioApprovalLocation TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioApprovalBlockDate.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioApprovalBlockDate') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioApprovalBlockDate  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioApprovalBlockDate 
(
	@iDigblockId VARCHAR(31),
	@iMonth DATETIME,
	@oIsApproved BIT = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ReturnValue BIT
	DECLARE @Month DATETIME
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'IsBhpbioApprovalBlockDate',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @Month = dbo.GetDateMonth(@iMonth)
		
		-- If the block has been approved for on the month, return true
		IF EXISTS	(
					SELECT TOP 1 1
					FROM dbo.BhpbioApprovalDigblock
					WHERE DigblockId = @iDigblockId
						AND ApprovedMonth = @iMonth
					)
		BEGIN
			SET @ReturnValue = 1
		END
		ELSE
		BEGIN
			SET @ReturnValue = 0
		END

		SET @oIsApproved = @ReturnValue

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioApprovalBlockDate TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioApprovalBlockLocationDate.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioApprovalBlockLocationDate') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioApprovalBlockLocationDate  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioApprovalBlockLocationDate 
(
	@iLocationId INT,
	@iMonth DATETIME,
	@oApproved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ReturnValue BIT
	DECLARE @MonthDate DATETIME
	DECLARE @EndMonthDate DATETIME

	DECLARE @Results TABLE
	(
		DigblockId VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
		Approved BIT NULL
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'IsBhpbioApprovalBlockLocationDate',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @MonthDate = dbo.GetDateMonth(@iMonth)
		SET @EndMonthDate = DateAdd(Day, -1, DateAdd(Month, 1, @MonthDate))

		INSERT INTO @Location
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)

		INSERT INTO @Results
			(
				DigblockId, Approved
			)
		SELECT d.Digblock_Id, CASE WHEN a.DigblockId IS NOT NULL THEN 1 ELSE 0 END
		FROM dbo.Digblock AS D
			INNER JOIN dbo.DigblockLocation AS DL
				ON (D.Digblock_Id = DL.Digblock_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = DL.Location_Id)
			INNER JOIN dbo.BhpbioImportReconciliationMovement AS RM
				ON (RM.DateFrom >= @MonthDate
					AND RM.DateTo <= @EndMonthDate
					AND DL.Location_Id = RM.BlockLocationId)
			LEFT JOIN dbo.BhpbioApprovalDigblock AS a
				ON d.Digblock_Id = a.DigblockId
					AND @MonthDate = a.ApprovedMonth

		-- If the block has been approved for on the month, return true
		IF EXISTS	(
					SELECT TOP 1 1
					FROM @Results
					WHERE Approved = 1
					)
		BEGIN
			SET @ReturnValue = 1
		END
		ELSE
		BEGIN
			SET @ReturnValue = 0
		END

		SET @oApproved = @ReturnValue

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioApprovalBlockLocationDate TO BhpbioGenericManager
GO

/*
DECLARE @TEST BIT
exec dbo.IsBhpbioApprovalBlockLocationDate 2615, '1-jan-2008', @TEST OUTPUT
SELECT @TEST
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioApprovalAllBlockLocationDate.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioApprovalAllBlockLocationDate') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioApprovalAllBlockLocationDate  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioApprovalAllBlockLocationDate 
(
	@iLocationId INT,
	@iMonth DATETIME,
	@oAllApproved BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ReturnValue BIT
	DECLARE @MonthDate DATETIME
	DECLARE @EndMonthDate DATETIME

	DECLARE @Results TABLE
	(
		DigblockId VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
		Approved BIT NULL
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'IsBhpbioApprovalAllBlockLocationDate',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @MonthDate = dbo.GetDateMonth(@iMonth)
		SET @EndMonthDate = DateAdd(Day, -1, DateAdd(Month, 1, @MonthDate))

		INSERT INTO @Location
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)

		INSERT INTO @Results
			(
				DigblockId, Approved
			)
		SELECT d.Digblock_Id, CASE WHEN a.DigblockId IS NOT NULL THEN 1 ELSE 0 END
		FROM dbo.Digblock AS D
			INNER JOIN dbo.DigblockLocation AS DL
				ON (D.Digblock_Id = DL.Digblock_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = DL.Location_Id)
			INNER JOIN dbo.BhpbioImportReconciliationMovement AS RM
				ON (RM.DateFrom >= @MonthDate
					AND RM.DateTo <= @EndMonthDate
					AND DL.Location_Id = RM.BlockLocationId)
			LEFT JOIN dbo.BhpbioApprovalDigblock AS a
				ON d.Digblock_Id = a.DigblockId
					AND @MonthDate = a.ApprovedMonth

		-- If the block has been approved for on the month, return true
		IF EXISTS	(
					SELECT TOP 1 1
					FROM @Results
					WHERE Approved = 0
					)
		BEGIN
			SET @ReturnValue = 0
		END
		ELSE
		BEGIN
			SET @ReturnValue = 1
		END

		SET @oAllApproved = @ReturnValue

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioApprovalAllBlockLocationDate TO BhpbioGenericManager
GO

/*
DECLARE @TEST BIT
exec dbo.IsBhpbioApprovalAllBlockLocationDate 2615, '1-jan-2008', @TEST OUTPUT
SELECT @TEST
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsBhpbioUserInLocation.prc'
GO

IF OBJECT_ID('dbo.IsBhpbioUserInLocation') IS NOT NULL
     DROP PROCEDURE dbo.IsBhpbioUserInLocation  
GO 
  
CREATE PROCEDURE dbo.IsBhpbioUserInLocation 
(
	@iUserId INT,
	@iLocationId INT,
	@oIsInLocation BIT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 
  
	BEGIN TRY
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.SecurityUserRole AS ur
					INNER JOIN dbo.BhpbioSecurityRoleLocation AS rl
						ON (rl.RoleId = ur.RoleId)
					INNER JOIN dbo.GetLocationParentLocationList(@iLocationId) AS pll
						ON (pll.Location_Id = rl.LocationId)
				WHERE UserId = @iUserId
			)
		BEGIN
			SET @oIsInLocation = 1
		END
		ELSE
		BEGIN
			SET @oIsInLocation = 0
		END
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsBhpbioUserInLocation TO BhpbioGenericManager
GO

/*
DECLARE @lol int
exec dbo.IsBhpbioUserInLocation 1, 4, @lol OUTPUT
SELECT @lol
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportColorList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportColorList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportColorList  
GO 

CREATE PROCEDURE dbo.GetBhpbioReportColorList
(
	@iTagId VARCHAR(31) = NULL,
	@iShowVisible BIT = 0
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
	
		SELECT TagId, Description, IsVisible, Color, LineStyle, MarkerShape
		FROM dbo.BhpbioReportColor
		WHERE (TagId = @iTagId OR @iTagId IS NULL)
			AND (@iShowVisible = 1 AND IsVisible = 1 OR @iShowVisible = 0)
			
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioReportColorList TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioReportColor.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioReportColor') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioReportColor  
GO 
  
CREATE PROCEDURE dbo.AddOrUpdateBhpbioReportColor
(
	@iTagId VARCHAR(31),
	@iDescription VARCHAR(255) = NULL,
	@iIsVisible BIT = NULL,
	@iColor VARCHAR(255),
	@iLineStyle VARCHAR(50) = NULL,
	@iMarkerShape VARCHAR(50) = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioReportColor',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF EXISTS (SELECT 1 FROM dbo.BhpbioReportColor WHERE TagId = @iTagId)
		BEGIN 
			-- Update the color.
			UPDATE C
			SET Description = CASE WHEN @iDescription IS NULL THEN Description ELSE @iDescription END,
				IsVisible = CASE WHEN @iIsVisible IS NULL THEN IsVisible ELSE @iIsVisible END,
				Color = @iColor,
				LineStyle = @iLineStyle,
				MarkerShape = @iMarkerShape
			FROM dbo.BhpbioReportColor AS C
			WHERE TagId = @iTagId
		END
		ELSE
		BEGIN
			INSERT INTO dbo.BhpbioReportColor
				(TagId, Description, IsVisible, Color, LineStyle, MarkerShape)
			SELECT @iTagId, @iDescription, @iIsVisible, @iColor, @iLineStyle, @iMarkerShape
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddOrUpdateBhpbioReportColor TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioReportThreshold.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioReportThreshold') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioReportThreshold  
GO 
  
CREATE PROCEDURE dbo.AddOrUpdateBhpbioReportThreshold
(
	@iLocationId INT,
	@iThresholdTypeId VARCHAR(31),
	@iFieldId SMALLINT,
	@iLowThreshold FLOAT,
	@iHighThreshold FLOAT,
	@iAbsoluteThreshold BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioReportThreshold',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF EXISTS (
					SELECT 1 
					FROM dbo.BhpbioReportThreshold 
					WHERE LocationId = @iLocationId
						AND FieldId = @iFieldId
						AND ThresholdTypeId = @iThresholdTypeId
				   )
		BEGIN 
			-- Update the threshold
			UPDATE T
			SET LowThreshold = @iLowThreshold,
				HighThreshold = @iHighThreshold,
				AbsoluteThreshold = @iAbsoluteThreshold
			FROM dbo.BhpbioReportThreshold AS T
			WHERE FieldId = @iFieldId
				AND LocationId = @iLocationId
				AND ThresholdTypeId = @iThresholdTypeId
		END
		ELSE
		BEGIN
			INSERT INTO dbo.BhpbioReportThreshold
				(LocationId, FieldId, ThresholdTypeId, LowThreshold, HighThreshold, AbsoluteThreshold)
			SELECT @iLocationId, @iFieldId, @iThresholdTypeId, @iLowThreshold, @iHighThreshold, @iAbsoluteThreshold
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddOrUpdateBhpbioReportThreshold TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioReportThreshold.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioReportThreshold') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioReportThreshold
GO 

CREATE PROCEDURE dbo.DeleteBhpbioReportThreshold
(
	@iLocationId INT,
	@iThresholdTypeId VARCHAR(31),
	@iFieldId SMALLINT = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
	
		-- Error if it does not exist.
		IF NOT EXISTS (
						SELECT 1 
						FROM dbo.BhpbioReportThreshold 
						WHERE LocationId = @iLocationId
							AND (ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL)
							AND (FieldId = @iFieldId OR @iFieldId IS NULL)
					   )
		BEGIN
			RAISERROR('This reporting threshold does not exist.', 16, 1)
		END
		
		-- Delete the threshold records associated with the location (and field).
		DELETE
		FROM dbo.BhpbioReportThreshold 
		WHERE LocationId = @iLocationId
			AND (ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL)
			AND (FieldId = @iFieldId OR @iFieldId IS NULL)
	
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.DeleteBhpbioReportThreshold TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportThresholdList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportThresholdList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportThresholdList
GO 

CREATE PROCEDURE dbo.GetBhpbioReportThresholdList
(
	@iLocationId INT,
	@iThresholdTypeId VARCHAR(31),
	@iOnlyInherited BIT = 0,
	@iOnlyLocation BIT = 0
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DECLARE @CurrentLocation INT
		DECLARE @TonnesFieldId INT
		DECLARE @CurrentThresholdTypeId VARCHAR(31)
		SET @TonnesFieldId = 0
		
		DECLARE @Results TABLE
		(
			LocationId INT NULL,
			LocationName VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
			ThresholdTypeId VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
			FieldId SMALLINT NULL,
			FieldName VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
			LowThreshold FLOAT NULL,
			HighThreshold FLOAT NULL,
			AbsoluteThreshold BIT NULL
		)
		
		DECLARE @Field TABLE
		(
			FieldId SMALLINT,
			FieldName VARCHAR(31) COLLATE DATABASE_DEFAULT
		)

		-- Insert the required fields into the result set.
		INSERT INTO @Field
			(FieldId, FieldName)
		SELECT @TonnesFieldId, 'Tonnes'
		UNION
		SELECT Grade_Id, Grade_Name
		FROM dbo.Grade

		IF @iOnlyLocation = 1
		BEGIN

			SELECT TOP 1 @CurrentThresholdTypeId = ThresholdTypeId
			FROM dbo.BhpbioReportThresholdType
			WHERE ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL
			ORDER BY ThresholdTypeId ASC

			WHILE @CurrentThresholdTypeId IS NOT NULL
			BEGIN

			-- Obtain the location and threshold information for only this location id.
			INSERT INTO @Results
				(LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, LowThreshold, HighThreshold, AbsoluteThreshold)
			SELECT L.Location_Id, L.Description, TT.ThresholdTypeId, F.FieldId, F.FieldName, BRT.LowThreshold, BRT.HighThreshold, BRT.AbsoluteThreshold
			FROM @Field AS F
				INNER JOIN dbo.Location AS L
					ON (L.Location_Id = @iLocationId)
				INNER JOIN dbo.BhpbioReportThresholdType AS TT
					ON (TT.ThresholdTypeId = @CurrentThresholdTypeId)
				LEFT JOIN dbo.BhpbioReportThreshold AS BRT
					ON (L.Location_ID = BRT.LocationID
						AND TT.ThresholdTypeId = BRT.ThresholdTypeId
						AND BRT.FieldId = F.FieldID)

			SET @CurrentThresholdTypeId = (SELECT TOP 1 ThresholdTypeId
											FROM dbo.BhpbioReportThresholdType
											WHERE ThresholdTypeId > @CurrentThresholdTypeId
											AND (ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL)
											ORDER BY ThresholdTypeId ASC)
			
			END

		END

		IF @iOnlyInherited = 1 OR (@iOnlyInherited = 0 AND @iOnlyLocation = 0 )
		BEGIN
		
			SELECT TOP 1 @CurrentThresholdTypeId = ThresholdTypeId
			FROM dbo.BhpbioReportThresholdType
			WHERE ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL
			ORDER BY ThresholdTypeId ASC
					
			WHILE @CurrentThresholdTypeId IS NOT NULL
			BEGIN

					
				SET @CurrentLocation = @iLocationId
				
				-- Cycle up through the parents until we find a location which has values we get to 
				--- the top.
				WHILE @CurrentLocation IS NOT NULL
				BEGIN

					IF EXISTS (	SELECT TOP 1 1 
								FROM dbo.BhpbioReportThreshold 
								WHERE LocationId = @CurrentLocation
									AND (ThresholdTypeId = @CurrentThresholdTypeId)
							  )
					BEGIN

						-- If records exist at this level do not return anything as we are not inheriting.
						IF @CurrentLocation <> @iLocationId OR (@iOnlyLocation = 0 AND @iOnlyInherited = 0)
						BEGIN
							-- Update the records based on this location.
							INSERT INTO @Results
								(LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, LowThreshold, HighThreshold, AbsoluteThreshold)
							SELECT L.Location_Id, L.Description, TT.ThresholdTypeId, F.FieldId, F.FieldName, BRT.LowThreshold, BRT.HighThreshold, BRT.AbsoluteThreshold
							FROM @Field AS F
								INNER JOIN dbo.Location AS L
									ON (L.Location_Id = @CurrentLocation)
								INNER JOIN dbo.BhpbioReportThresholdType AS TT
									ON (TT.ThresholdTypeId = @CurrentThresholdTypeId)
								LEFT JOIN dbo.BhpbioReportThreshold AS BRT
									ON (L.Location_ID = BRT.LocationID
										AND TT.ThresholdTypeId = BRT.ThresholdTypeId
										AND BRT.FieldId = F.FieldID)
						END
						
						-- We have found our match so finish the looping
						SET @CurrentLocation = NULL
					END
				
					IF NOT EXISTS (SELECT 1 FROM dbo.Location WHERE Location_Id = @CurrentLocation)
					BEGIN
						SET @CurrentLocation = NULL
					END
					
					-- Cycle up the parent heirachy
					SELECT @CurrentLocation = L.Parent_Location_Id
					FROM dbo.Location AS L
					WHERE L.Location_Id = @CurrentLocation
				END

				SET @CurrentThresholdTypeId = (SELECT TOP 1 ThresholdTypeId
												FROM dbo.BhpbioReportThresholdType
												WHERE ThresholdTypeId > @CurrentThresholdTypeId
												AND (ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL)
												ORDER BY ThresholdTypeId ASC)


			
			END
											
		END
		
		IF (@iOnlyInherited = 0 AND @iOnlyLocation = 0 )
		BEGIN
		
			SELECT TOP 1 @CurrentThresholdTypeId = ThresholdTypeId
			FROM dbo.BhpbioReportThresholdType
			WHERE ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL
			ORDER BY ThresholdTypeId ASC
					
			WHILE @CurrentThresholdTypeId IS NOT NULL
			BEGIN
	
				IF NOT EXISTS(SELECT 1 FROM @Results WHERE ThresholdTypeId = @CurrentThresholdTypeId)	
				BEGIN		
		
				-- Obtain the location and threshold information for only this location id.
				INSERT INTO @Results
					(LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, LowThreshold, HighThreshold, AbsoluteThreshold)
				SELECT L.Location_Id, L.Description, TT.ThresholdTypeId, F.FieldId, F.FieldName,
					NULL, 
					NULL, 
					0
				FROM @Field AS F
					INNER JOIN dbo.Location AS L
						ON (L.Location_Id = @iLocationId)
					INNER JOIN dbo.BhpbioReportThresholdType AS TT
						ON (TT.ThresholdTypeId = @CurrentThresholdTypeId)
						
				END
				
				SET @CurrentThresholdTypeId = (SELECT TOP 1 ThresholdTypeId
								FROM dbo.BhpbioReportThresholdType
								WHERE ThresholdTypeId > @CurrentThresholdTypeId
								AND (ThresholdTypeId = @iThresholdTypeId OR @iThresholdTypeId IS NULL)
								ORDER BY ThresholdTypeId ASC)
			
			END
		END
		
		SELECT LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, LowThreshold, HighThreshold, AbsoluteThreshold
		FROM @Results
			
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioReportThresholdList TO BhpbioGenericManager

GO

--EXEC dbo.GetBhpbioReportThresholdList @iLocationId = 1, @iThresholdTypeId = null, @iOnlyInherited = 0, @iOnlyLocation = 0



GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportThresholdTypeList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportThresholdTypeList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportThresholdTypeList
GO 

CREATE PROCEDURE dbo.GetBhpbioReportThresholdTypeList
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
	
		SELECT ThresholdTypeId, Description
		FROM dbo.BhpbioReportThresholdType
	
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioReportThresholdTypeList TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.IsDigblockTreeUserSettingAvailable.prc'
GO

 IF OBJECT_ID('dbo.IsDigblockTreeUserSettingAvailable') IS NOT NULL
     DROP PROCEDURE dbo.IsDigblockTreeUserSettingAvailable 
GO 
  
CREATE PROCEDURE dbo.IsDigblockTreeUserSettingAvailable 
(
	@iUserId INT,
	@oSettingAvailable BIT OUTPUT
)
WITH ENCRYPTION AS
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		IF EXISTS
			(
				SELECT 1
				FROM dbo.SecurityUserSetting AS us
					INNER JOIN dbo.SecurityUserSettingType AS st
						ON (us.UserSettingTypeId = st.UserSettingTypeId)
				WHERE us.UserId = @iUserId
					AND st.Name LIKE 'Node_DigblockTree%'
			)
		BEGIN
			SET @oSettingAvailable = 1
		END
		ELSE
		BEGIN
			SET @oSettingAvailable = 0
		END
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.IsDigblockTreeUserSettingAvailable TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.IsDigblockTreeUserSettingAvailable">
 <Procedure>
	Determines if there are any digblock tree user settings for the specified user.
 </Procedure>
</TAG>
*/	



GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.SetDigblockTreeUserDefaults.prc'
GO

 IF OBJECT_ID('dbo.SetDigblockTreeUserDefaults') IS NOT NULL
     DROP PROCEDURE dbo.SetDigblockTreeUserDefaults  
GO 
  
CREATE PROCEDURE dbo.SetDigblockTreeUserDefaults
(
	@iLocationId INT,
	@iUserId INT
)
WITH ENCRYPTION AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @LocationCursor CURSOR
	DECLARE @LocationId INT
	DECLARE @LocationTypeId SMALLINT
	DECLARE @LocationLevel INT
	DECLARE @SettingTypeName VARCHAR(255)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'SetDigblockTreeUserDefaults',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- add the bottom-level call
		EXEC dbo.AddOrUpdateSecurityUserSetting
			@iUserId = @iUserId,
			@iSettingTypeName = 'Node_DigblockTree_1_0_1_Expanded',
			@iSettingValue = 'True',
			@iAutoAddSettingType = 1	

		SET @LocationCursor = CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
			SELECT l.Location_Id, lt.Location_Type_Id, lth.Location_Level
			FROM
				(
					SELECT Location_Id
					FROM dbo.GetLocationParentLocationList(@iLocationId)
					WHERE Location_Id IS NOT NULL

					UNION ALL

					SELECT @iLocationId
				) AS pll
				INNER JOIN dbo.Location AS l
					ON (pll.Location_Id = l.Location_Id)
				INNER JOIN dbo.LocationType AS lt
					ON (l.Location_Type_Id = lt.Location_Type_Id)
				INNER JOIN dbo.GetLocationTypeHierarchy(0) AS lth
					ON (lt.Location_Type_Id = lth.Location_Type_Id)
			ORDER BY lth.Location_Level

		OPEN @LocationCursor
		FETCH NEXT FROM @LocationCursor INTO @LocationId, @LocationTypeId, @LocationLevel

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SET @SettingTypeName = 'Node_DigblockTree_' + CONVERT(VARCHAR(10), @LocationLevel + 2) + '_' +
				CONVERT(VARCHAR(10), @LocationId) + '_' + CONVERT(VARCHAR(10), @LocationTypeId) + '_Expanded'

			-- add the successive-level call
			EXEC dbo.AddOrUpdateSecurityUserSetting
				@iUserId = @iUserId,
				@iSettingTypeName = @SettingTypeName,
				@iSettingValue = 'True',
				@iAutoAddSettingType = 1

			FETCH NEXT FROM @LocationCursor INTO @LocationId, @LocationTypeId, @LocationLevel
		END

		CLOSE @LocationCursor

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.SetDigblockTreeUserDefaults TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.SetDigblockTreeUserDefaults">
 <Procedure>
	Applies settings to the Digblock Tree for the existing user.
	The settings applied will allow the tree to be expanded to the node that represents the location passed in.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.ApproveBhpbioApprovalData.prc'
GO

IF OBJECT_ID('dbo.ApproveBhpbioApprovalData') IS NOT NULL
     DROP PROCEDURE dbo.ApproveBhpbioApprovalData 
GO 
  
CREATE PROCEDURE dbo.ApproveBhpbioApprovalData
(
	@iTagId VARCHAR(31),
	@iLocationId INT,
	@iApprovalMonth DATETIME,
	@iUserId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'ApproveBhpbioApprovalData',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS (SELECT 1 FROM dbo.BhpbioReportDataTags WHERE TagId = @iTagId)
		BEGIN
			RAISERROR('The tag does not exist', 16, 1)
		END
		
		IF NOT EXISTS (SELECT 1 FROM dbo.Location WHERE Location_Id = @iLocationId)
		BEGIN
			RAISERROR('The location does not exist', 16, 1)
		END
	
		IF @iApprovalMonth <> dbo.GetDateMonth(@iApprovalMonth)
		BEGIN
			RAISERROR('The date supplied is not the start of a month', 16, 1)
		END
	
		IF NOT EXISTS (SELECT 1 FROM dbo.SecurityUser WHERE UserId = @iUserId)
		BEGIN
			RAISERROR('The user id does not exist', 16, 1)
		END
		
		IF EXISTS	(
						SELECT 1 
						FROM dbo.BhpbioApprovalData 
						WHERE TagId = @iTagId 
							AND ApprovedMonth = @iApprovalMonth 
							AND LocationID = @iLocationId
					)
		BEGIN
			RAISERROR('The calculation and month provided has already been approved.', 16, 1)
		END
		
		IF NOT EXISTS	(
						SELECT TOP 1 1 
						FROM dbo.BhpbioReportDataTags AS T
							LEFT JOIN dbo.Location AS L
								ON (T.TagGroupLocationTypeId = L.Location_Type_Id
									OR T.TagGroupLocationTypeId IS NULL)
						WHERE TagId = @iTagId
							AND L.Location_ID = @iLocationId
					)
		BEGIN
			RAISERROR('The calculation cannot be approved at this location type.', 16, 1)
		END
		
		INSERT INTO dbo.BhpbioApprovalData
			(TagId, LocationId, ApprovedMonth, UserId, SignoffDate)
		SELECT @iTagId, @iLocationId, @iApprovalMonth, @iUserId, GetDate()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ApproveBhpbioApprovalData TO BhpbioGenericManager
GO

/*
BEGIN TRAN
exec dbo.ApproveBhpbioApprovalData
	@iTagId = 'F2Factor',
	@iLocationId = 3,
	@iApprovalMonth = '1-apr-2008',
	@iUserId = 1

Select * from dbo.BhpbioApprovalData where TagId = 'F2Factor'
	
ROLLBACK TRAN
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.ApproveBhpbioApprovalDigblock.prc'
GO

IF OBJECT_ID('dbo.ApproveBhpbioApprovalDigblock') IS NOT NULL
     DROP PROCEDURE dbo.ApproveBhpbioApprovalDigblock  
GO 
  
CREATE PROCEDURE dbo.ApproveBhpbioApprovalDigblock 
(
	@iDigblockId VARCHAR(31),
	@iApprovalMonth DATETIME,
	@iUserId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'ApproveBhpbioApprovalDigblock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS (SELECT 1 FROM dbo.Digblock WHERE Digblock_Id = @iDigblockId)
		BEGIN
			RAISERROR('The digblock does not exist', 16, 1)
		END
	
		IF @iApprovalMonth <> dbo.GetDateMonth(@iApprovalMonth)
		BEGIN
			RAISERROR('The date supplied is not the start of a month', 16, 1)
		END
	
		IF NOT EXISTS (SELECT 1 FROM dbo.SecurityUser WHERE UserId = @iUserId)
		BEGIN
			RAISERROR('The user id does not exist', 16, 1)
		END
		
		IF EXISTS (SELECT 1 FROM dbo.BhpbioApprovalDigblock WHERE DigblockId = @iDigblockId AND ApprovedMonth = @iApprovalMonth)
		BEGIN
			RAISERROR('The digblock and month provided has already been approved.', 16, 1)
		END
		
		INSERT INTO dbo.BhpbioApprovalDigblock
			(DigblockId, ApprovedMonth, UserId, SignoffDate)
		SELECT @iDigblockId, @iApprovalMonth, @iUserId, GetDate()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ApproveBhpbioApprovalDigblock TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UnapproveBhpbioApprovalData.prc'
GO

IF OBJECT_ID('dbo.UnapproveBhpbioApprovalData') IS NOT NULL
     DROP PROCEDURE dbo.UnapproveBhpbioApprovalData
GO 
  
CREATE PROCEDURE dbo.UnapproveBhpbioApprovalData
(
	@iTagId VARCHAR(31),
	@iLocationId INT,
	@iApprovalMonth DATETIME
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UnapproveBhpbioApprovalData',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS (SELECT 1 FROM dbo.BhpbioReportDataTags WHERE TagId = @iTagId)
		BEGIN
			RAISERROR('The tag does not exist', 16, 1)
		END
	
		IF NOT EXISTS (SELECT 1 FROM dbo.Location WHERE Location_Id = @iLocationId)
		BEGIN
			RAISERROR('The location does not exist', 16, 1)
		END
		
		IF @iApprovalMonth <> dbo.GetDateMonth(@iApprovalMonth)
		BEGIN
			RAISERROR('The date supplied is not the start of a month', 16, 1)
		END

		IF NOT EXISTS	(
							SELECT 1 
							FROM dbo.BhpbioApprovalData 
							WHERE TagId = @iTagId 
								AND ApprovedMonth = @iApprovalMonth 
									AND LocationID = @iLocationId
						)
		BEGIN
			RAISERROR('The calculation and month provided has not been approved. Please ensure this calculation has not been approved at a higher level.', 16, 1)
		END
		
		DELETE
		FROM dbo.BhpbioApprovalData
		WHERE TagId = @iTagId 
			AND ApprovedMonth = @iApprovalMonth
			AND LocationId = @iLocationId
		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UnapproveBhpbioApprovalData TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UnapproveBhpbioApprovalDigblock.prc'
GO

IF OBJECT_ID('dbo.UnapproveBhpbioApprovalDigblock') IS NOT NULL
     DROP PROCEDURE dbo.UnapproveBhpbioApprovalDigblock  
GO 
  
CREATE PROCEDURE dbo.UnapproveBhpbioApprovalDigblock
(
	@iDigblockId VARCHAR(31),
	@iApprovalMonth DATETIME
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UnapproveBhpbioApprovalDigblock',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF NOT EXISTS (SELECT 1 FROM dbo.Digblock WHERE Digblock_Id = @iDigblockId)
		BEGIN
			RAISERROR('The digblock does not exist', 16, 1)
		END
	
		IF @iApprovalMonth <> dbo.GetDateMonth(@iApprovalMonth)
		BEGIN
			RAISERROR('The date supplied is not the start of a month', 16, 1)
		END
		
		IF NOT EXISTS (SELECT 1 FROM dbo.BhpbioApprovalDigblock WHERE DigblockId = @iDigblockId AND ApprovedMonth = @iApprovalMonth)
		BEGIN
			RAISERROR('The digblock and month provided has not been approved.', 16, 1)
		END
		
		DELETE
		FROM dbo.BhpbioApprovalDigblock
		WHERE DigblockId = @iDigblockId 
			AND ApprovedMonth = @iApprovalMonth
		

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UnapproveBhpbioApprovalDigblock TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioUserLocation.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioUserLocation') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioUserLocation
GO 
  
CREATE PROCEDURE dbo.GetBhpbioUserLocation
(
	@iUserId INT,
	@oLocationId INT OUTPUT
)
AS 
BEGIN 
	SET NOCOUNT ON 
	DECLARE @Null INT

	BEGIN TRY

		--Get the location id of the user where the user is only associated
		--with a single role with a location against it.
		SELECT @oLocationId = Min(LocationId), @Null = UserId
		FROM dbo.SecurityUserRole AS ur
			INNER JOIN dbo.BhpbioSecurityRoleLocation AS rl
				ON (ur.RoleId = rl.RoleId)
		WHERE ur.UserId = @iUserId
		GROUP BY UserId
		HAVING COUNT(*) = 1

	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioUserLocation TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.GetBhpbioUserLocation">
 <Procedure>
	Returns the User's default Location based on their role.
	If the user does not belong to a role which has a mapped location, NULL is returned.
 </Procedure>
</TAG>
*/

/* testing
DECLARE @LocationId INT
EXEC dbo.GetBhpbioUserLocation 13, @LocationId OUTPUT
SELECT @LocationId
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioApprovalData.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioApprovalData') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioApprovalData
GO 
  
CREATE PROCEDURE dbo.GetBhpbioApprovalData
(
	@iMonthFilter DATETIME
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @MonthDate DATETIME
	DECLARE @TotalChildren INT
	DECLARE @LowestLocationTypeId INT

	DECLARE @LocationId INT

	DECLARE @LowestLocationSignOff TABLE
	(
		LocationId INT NOT NULL,
		TagId VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		Approved BIT NOT NULL,
		UserId INT NOT NULL,
		PRIMARY KEY (LocationId, TagId, UserId)
	)

	DECLARE @LocationMap TABLE
	(
		LocationId INT NOT NULL,
		ChildLocationId INT NOT NULL
		PRIMARY KEY (LocationId, ChildLocationId)
	)
	
	DECLARE @ReturnLocation TABLE
	(
		LocationId INT NULL,
		Children INT
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioApprovalData',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @MonthDate = dbo.GetDateMonth(@iMonthFilter)
		
		SELECT @LowestLocationTypeId = Location_Type_Id
		FROM dbo.LocationType
		WHERE Description = 'Pit'
		
		INSERT INTO @LocationMap
			(LocationId, ChildLocationId)	
		SELECT LocationId, ChildLocationId
		FROM dbo.GetLocationChildMap(NULL, @LowestLocationTypeId)

		-- Retrieve all approved locations and attach to the children nodes.
		INSERT INTO @LowestLocationSignOff
			(LocationId, TagId, Approved, UserId)
		SELECT LM.ChildLocationId, AD.TagId, 1, AD.UserId
		FROM dbo.BhpbioApprovalData AS AD
			INNER JOIN @LocationMap AS LM
				ON (AD.LocationId = LM.LocationId)
		WHERE AD.ApprovedMonth = @MonthDate
		Group By LM.ChildLocationId, AD.TagId, AD.UserId
	
		-- Obtain all the return locations and their max children
		INSERT INTO @ReturnLocation
			(LocationId, Children)
		SELECT L.LocationId, Count(1) AS Children
		FROM (
				SELECT LocationId
				FROM @LocationMap 
				GROUP BY LocationId
			 ) AS L
			INNER JOIN @LocationMap AS LM
				ON (L.LocationId = LM.LocationId)
		GROUP BY L.LocationId
		
		-- Retrieve Tag Information
		SELECT DT.TagId, DT.TagGroupId, RL.LocationId, @MonthDate AS ApprovalMonth, L.Parent_Location_Id AS ParentLocationId,
			CASE WHEN RL.Children = AT.Number THEN 1 ELSE 0 END AS Approved, 
			RL.Children, AT.Number AS NumberApproved
		FROM @ReturnLocation AS RL
			CROSS JOIN dbo.BhpbioReportDataTags AS DT
			INNER JOIN dbo.Location AS L
				ON (L.Location_Id = RL.LocationId)
			LEFT JOIN (
						SELECT LLSO.TagId, Count(1) AS Number, LM.LocationId
						FROM @LowestLocationSignOff AS LLSO
							INNER JOIN @LocationMap AS LM
								ON (LLSO.LocationId = LM.ChildLocationId)
						GROUP BY LLSO.TagId, LM.LocationId
						) AT
				ON AT.TagId = DT.TagId
					AND AT.LocationId = RL.LocationId

		-- Retrieve User Information
		SELECT L.TagId AS TagId, L.LocationId, U.UserId AS UserId, 
			U.FirstName AS FirstName, U.LastName AS LastName
		FROM (
			SELECT LLSO.TagId, LLSO.UserId, LM.LocationId
			FROM @LowestLocationSignOff AS LLSO
				INNER JOIN @LocationMap AS LM
					ON (LLSO.LocationId = LM.ChildLocationId)
				INNER JOIN @ReturnLocation AS RL
					ON (RL.LocationId = LM.LocationId)
			GROUP BY LLSO.UserId, LLSO.TagId, LM.LocationId
			) AS L
			INNER JOIN dbo.SecurityUser AS u
				ON (L.UserId = u.UserId)
			
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioApprovalData TO BhpbioGenericManager
GO

--EXEC dbo.GetBhpbioApprovalData '1-Mar-2008'
--EXEC dbo.GetBhpbioApprovalData '1-Apr-2008'


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddBhpbioProductionTransaction.prc'
GO

 IF OBJECT_ID('dbo.AddBhpbioProductionTransaction') IS NOT NULL
     DROP PROCEDURE dbo.AddBhpbioProductionTransaction  
GO 
  
CREATE PROCEDURE dbo.AddBhpbioProductionTransaction
(
	@iSiteLocationId INT,
	@iTransactionDate DATETIME,
	@iSource VARCHAR(255),
	@iSourceLocationType VARCHAR(255),
	@iDestination VARCHAR(255),
	@iDestinationType VARCHAR(255),
	@iTonnes FLOAT,
	@iFinesPercent REAL,
	@iLumpPercent REAL,
	@iGrades XML,
	@oWeightometerSampleId INT OUTPUT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @WeightometerSampleId INT
	DECLARE @WeightometerId VARCHAR(31)
	DECLARE @SourceStockpileId INT
	DECLARE @DestinationStockpileId INT

	SET NOCOUNT ON

	SELECT @TransactionName = 'AddBhpbioProductionTransaction',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		EXEC dbo.DecodeBhpbioProductionFlow
			@iSiteLocationId = @iSiteLocationId,
			@iTransactionDate = @iTransactionDate,
			@iSource = @iSource,
			@iSourceLocationType = @iSourceLocationType,
			@iDestination = @iDestination,
			@iDestinationType = @iDestinationType,
			@oWeightometerId = @WeightometerId OUTPUT,
			@oSourceStockpileId = @SourceStockpileId OUTPUT,
			@oDestinationStockpileId = @DestinationStockpileId OUTPUT
	
		-- add the weightometer sample
		EXEC dbo.AddWeightometerSample
			@iWeightometer_Id = @WeightometerId,
			@iWeightometer_Sample_Date = @iTransactionDate,
			@iWeightometer_Sample_Shift = 'D',
			@iOrder_No = NULL,
			@iTonnes = @iTonnes,
			@iCorrected_Tonnes = NULL,
			@iSource_Stockpile_Id = @SourceStockpileId,
			@iDestination_Stockpile_Id = @DestinationStockpileId,
			@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT

		-- insert directly into the grade table
		-- (note - known design kludge to trial XML bulk operations - we should normally use the AddorUpdate proc)
		INSERT INTO dbo.WeightometerSampleGrade
		(
			Weightometer_Sample_Id, Grade_Id, Grade_Value
		)
		SELECT @WeightometerSampleId,
			(
				SELECT Grade_Id
				FROM dbo.Grade
				WHERE Grade_Name = Grades.Grade.value('./@name', 'VARCHAR(31)')
			),
			Grades.Grade.value('./@value', 'REAL')
		FROM @iGrades.nodes('/Grades/Grade') AS Grades(Grade)
 
		-- store the lumps / fines values
		INSERT INTO dbo.WeightometerSampleValue
		(
			Weightometer_Sample_Id, Weightometer_Sample_Field_Id, Field_Value
		)
		SELECT @WeightometerSampleId, 'LumpPercent', @iLumpPercent
		UNION ALL
		SELECT @WeightometerSampleId, 'FinesPercent', @iFinesPercent

		-- return the Weightometer Sample Id
		SET @oWeightometerSampleId = @WeightometerSampleId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioProductionTransaction TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddBhpbioProductionTransaction">
 <Procedure>
	
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddBhpbioShippingTransactionNomination.prc'
GO

IF OBJECT_ID('dbo.AddBhpbioShippingTransactionNomination') IS NOT NULL
    DROP PROCEDURE dbo.AddBhpbioShippingTransactionNomination  
GO 
  
CREATE PROCEDURE dbo.AddBhpbioShippingTransactionNomination
(
	@iNominationKey INT,
	@iNomination INT,
	@iOfficialFinishTime DATETIME,
	@iLastAuthorisedDate DATETIME = NULL,
	@iVesselName VARCHAR(63),
	@iCustomerNo INT,
	@iCustomerName VARCHAR(63),
	@iHubLocationId INT,
	@iProductCode VARCHAR(63),
	@iTonnes FLOAT,
	@oBhpbioShippingTransactionNominationId INT OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBhpbioShippingTransactionNomination',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		EXEC dbo.AddOrUpdateBhpbioShippingTransaction
			@iNominationKey = @iNominationKey,
			@iVesselName = @iVesselName

		-- create/update the nomination record
		INSERT INTO dbo.BhpbioShippingTransactionNomination
		(
			NominationKey, Nomination, OfficialFinishTime, LastAuthorisedDate, CustomerNo, CustomerName,
			HubLocationId, ProductCode, Tonnes
		)
		SELECT @iNominationKey, @iNomination, @iOfficialFinishTime, @iLastAuthorisedDate, @iCustomerNo, @iCustomerName,
			@iHubLocationId, @iProductCode, @iTonnes

		SET @oBhpbioShippingTransactionNominationId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioShippingTransactionNomination TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddBhpbioShippingTransactionNomination">
 <Procedure>
	Adds transaction nomination records, creating parent transaction records as required.
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioShippingTransaction.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioShippingTransaction') IS NOT NULL
	DROP PROCEDURE dbo.AddOrUpdateBhpbioShippingTransaction
GO

CREATE PROCEDURE dbo.AddOrUpdateBhpbioShippingTransaction
(
	@iNominationKey INT,
	@iVesselName VARCHAR(63)
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BhpbioShippingTransactionNominationId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioShippingTransaction',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- create/update the base transaction record
		IF NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioShippingTransaction
				WHERE NominationKey = @iNominationKey
			)
		BEGIN
			INSERT INTO dbo.BhpBioShippingTransaction
			(
				NominationKey, VesselName
			)
			VALUES
			(
				@iNominationKey, @iVesselName
			)
		END
		ELSE
		BEGIN
			UPDATE dbo.BhpbioShippingTransaction
			SET VesselName = @iVesselName
			WHERE NominationKey = @iNominationKey
				AND VesselName <> @iVesselName
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioShippingTransaction TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateBhpbioShippingTransaction">
 <Procedure>
	Adds and updates the parent shipping transaction records.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade') IS NOT NULL
	DROP PROCEDURE dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade
GO

CREATE PROCEDURE dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade
(
	@iBhpbioShippingTransactionNominationId INT,
	@iGradeId SMALLINT,
	@iGradeValue REAL
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF @iGradeValue IS NULL
		BEGIN
			-- Delete the grade
			DELETE
			FROM dbo.BhpbioShippingTransactionNominationGrade
			WHERE GradeId = @iGradeId
				AND BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId
		END
		ELSE IF EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioShippingTransactionNominationGrade
				WHERE GradeId = @iGradeId
					AND BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId
			)
		BEGIN
			-- Update the grade
			UPDATE dbo.BhpbioShippingTransactionNominationGrade
			SET GradeValue = @iGradeValue
			WHERE GradeId = @iGradeId
				AND BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId
		END
		ELSE
		BEGIN
			-- Insert the grade
			INSERT INTO dbo.BhpbioShippingTransactionNominationGrade
				(BhpbioShippingTransactionNominationId, GradeId, GradeValue)
			VALUES
				(@iBhpbioShippingTransactionNominationId, @iGradeId, @iGradeValue)
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade">
 <Procedure>
	Adds, updates and deletes transaction nomination grades.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioShippingTransactionNomination.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioShippingTransactionNomination') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioShippingTransactionNomination  
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioShippingTransactionNomination
(
	@iBhpbioShippingTransactionNominationId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @NominationKey INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateBhpbioShippingTransactionNomination',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- remember the nomination key
		SET @NominationKey =
			(
				SELECT NominationKey
				FROM BhpbioShippingTransactionNomination
				WHERE BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId
			)

		-- remove the nomination
		DELETE
		FROM dbo.BhpbioShippingTransactionNomination
		WHERE BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId

		-- remove any orphan transactions
		DELETE
		FROM dbo.BhpbioShippingTransaction
		WHERE NominationKey = @NominationKey
			AND NOT EXISTS
				(
					SELECT 1
					FROM dbo.BhpbioShippingTransactionNomination
					WHERE NominationKey = @NominationKey
				)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioShippingTransactionNomination TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteBhpbioShippingTransactionNomination">
 <Procedure>
	Deletes transaction nomination records, and optionally deletes the parent transaction if there are no children attached.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UpdateBhpbioShippingTransactionNomination.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioShippingTransactionNomination') IS NOT NULL
     DROP PROCEDURE dbo.UpdateBhpbioShippingTransactionNomination  
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioShippingTransactionNomination
(
	@iBhpbioShippingTransactionNominationId INT,
	@iNominationKey INT,
	@iNomination INT,
	@iOfficialFinishTime DATETIME,
	@iLastAuthorisedDate DATETIME = NULL,
	@iVesselName VARCHAR(63),
	@iCustomerNo INT,
	@iCustomerName VARCHAR(63),
	@iHubLocationId INT,
	@iProductCode VARCHAR(63),
	@iTonnes FLOAT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateBhpbioShippingTransactionNomination',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- note that NominationKey is part of the pk so there is no chance of orphaning transaction records
		EXEC dbo.AddOrUpdateBhpbioShippingTransaction
			@iNominationKey = @iNominationKey,
			@iVesselName = @iVesselName

		-- update the nomination record
		UPDATE dbo.BhpbioShippingTransactionNomination
		SET	NominationKey = @iNominationKey,
			Nomination = @iNomination,
			OfficialFinishTime = @iOfficialFinishTime,
			LastAuthorisedDate = @iLastAuthorisedDate,
			CustomerNo = @iCustomerNo,
			CustomerName = @iCustomerName,
			HubLocationId = @iHubLocationId,
			ProductCode = @iProductCode,
			Tonnes = @iTonnes
		WHERE BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateBhpbioShippingTransactionNomination TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateBhpbioShippingTransactionNomination">
 <Procedure>
	Updates transaction nomination records as required, optionally adding transaction records as required.
 </Procedure>
</TAG>
*/	
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UpdateBhpbioReconciliationMovement.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioReconciliationMovement') IS NOT NULL
     DROP PROCEDURE dbo.UpdateBhpbioReconciliationMovement  
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioReconciliationMovement
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateBhpbioReconciliationMovement',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		-- only allow updates of digblocks where they are not an
		-- approved block.
		-- calculate the block's location id (based on Pit Code)
		;WITH LocationHierarchy (LocationId, Name, Type, ParentLocationId) AS
		(
			SELECT l.Location_Id, l.Name, lt.Description, l.Parent_Location_Id
			FROM dbo.Location AS l
				INNER JOIN dbo.LocationType AS lt
					ON (l.Location_Type_Id = lt.Location_Type_Id)
		)
		-- update existing, only where the blastblock is not approved.
		UPDATE mov
		SET	DateTo = s.DateTo,
			LastModifiedDate = s.LastModifiedDate,
			LastModifiedUser = s.LastModifiedUser,
			MinedPercentage = s.MinedPercentage
		FROM dbo.BhpbioImportReconciliationMovementStage AS s
			INNER JOIN dbo.BhpbioImportReconciliationMovement AS mov
				ON (mov.BlockNumber = s.BlockNumber
					AND mov.BlockName = s.BlockName
					AND mov.Site = s.Site
					AND mov.Orebody = s.Orebody
					AND mov.Pit = s.Pit
					AND mov.Bench = s.Bench
					AND mov.PatternNumber = s.PatternNumber
					AND mov.DateFrom = s.DateFrom)
			INNER JOIN dbo.DigblockLocation AS dl
				ON (dl.Location_Id = mov.BlockLocationId)
			LEFT OUTER JOIN dbo.BhpbioApprovalDigblock AS bad
				ON (bad.DigblockId = dl.Digblock_Id)
		WHERE bad.DigblockId IS NULL
			

		-- insert new
		INSERT INTO dbo.BhpbioImportReconciliationMovement
		(
			BlockNumber, BlockName, Site, Orebody, Pit, Bench, PatternNumber,
			DateFrom, DateTo, LastModifiedDate, LastModifiedUser, MinedPercentage
		)
		SELECT s.BlockNumber, s.BlockName, s.Site, s.Orebody, s.Pit, s.Bench, s.PatternNumber,
			s.DateFrom, s.DateTo, s.LastModifiedDate, s.LastModifiedUser, s.MinedPercentage
		FROM dbo.BhpbioImportReconciliationMovementStage AS s
			LEFT JOIN dbo.BhpbioImportReconciliationMovement AS mov
				ON (mov.BlockNumber = s.BlockNumber
					AND mov.BlockName = s.BlockName
					AND mov.Site = s.Site
					AND mov.Orebody = s.Orebody
					AND mov.Pit = s.Pit
					AND mov.Bench = s.Bench
					AND mov.PatternNumber = s.PatternNumber
					AND mov.DateFrom = s.DateFrom)
		WHERE mov.BlockNumber IS NULL
		
		-- calculate the block's location id (based on Pit Code)
		;WITH LocationHierarchy (LocationId, Name, Type, ParentLocationId) AS
		(
			SELECT l.Location_Id, l.Name, lt.Description, l.Parent_Location_Id
			FROM dbo.Location AS l
				INNER JOIN dbo.LocationType AS lt
					ON (l.Location_Type_Id = lt.Location_Type_Id)
		)
		UPDATE m
		SET BlockLocationId = blocklh.LocationId
		FROM dbo.BhpbioImportReconciliationMovement AS m
			-- note that we join here to the Block Holding system
			-- this is a work-around until BHP improve the interfaces between Blastholes & Reconcilor
			INNER JOIN dbo.BhpbioBlastBlockHolding AS b
				ON (b.Site = m.Site
					AND b.Orebody = m.Orebody
					AND b.Pit = m.Pit
					AND b.Bench = m.Bench
					AND b.PatternNumber = m.PatternNumber
					AND b.BlockName = m.BlockName)
			INNER JOIN LocationHierarchy AS sitelh
				ON (sitelh.Name = m.Site
					AND sitelh.Type = 'Site')
			INNER JOIN LocationHierarchy AS pitlh
				ON (pitlh.Name = COALESCE(b.MQ2PitCode, m.Pit)
					AND pitlh.Type = 'Pit'
					AND pitlh.ParentLocationId = sitelh.LocationId)
			INNER JOIN LocationHierarchy AS benchlh
				ON (benchlh.Name = m.Bench
					AND benchlh.Type = 'Bench'
					AND benchlh.ParentLocationId = pitlh.LocationId)
			INNER JOIN LocationHierarchy AS blastlh
				ON (blastlh.Name = m.PatternNumber
					AND blastlh.Type = 'Blast'
					AND blastlh.ParentLocationId = benchlh.LocationId)
			INNER JOIN LocationHierarchy blocklh
				ON (blocklh.Name = m.BlockName
					AND blocklh.Type = 'Block'
					AND blocklh.ParentLocationId = blastlh.LocationId)
			LEFT JOIN dbo.BhpbioApprovalData AS BADA
				ON (BADA.LocationId = pitlh.LocationId
					AND BADA.ApprovedMonth = dbo.getDateMonth(m.DateFrom))
		WHERE (BlockLocationId IS NULL
				OR BlockLocationId <> blocklh.LocationId)
			AND blocklh.LocationId IS NOT NULL
			AND BADA.LocationId IS NULL

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateBhpbioReconciliationMovement TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioReconciliationMovementStage.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioReconciliationMovementStage') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioReconciliationMovementStage  
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioReconciliationMovementStage
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DELETE
		FROM dbo.BhpbioImportReconciliationMovementStage
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioReconciliationMovementStage TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioHoldingModelBlocks.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioHoldingModelBlocks') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioHoldingModelBlocks
GO

CREATE PROCEDURE dbo.GetBhpbioHoldingModelBlocks
(
	@iSite VARCHAR(9),
	@iPit VARCHAR(10),
	@iBench VARCHAR(4)
)
AS
BEGIN
	SET NOCOUNT ON
	
	BEGIN TRY
		SELECT
			-- key fields
			b.Site, b.Orebody,
			COALESCE(b.MQ2PitCode, b.Pit) AS Pit,
			b.Bench, b.PatternNumber, b.BlockName,
			m.ModelName, m.ModelOreType,
			-- attribute fields
			b.BlockNumber, b.GeoType, b.BlockedDate, b.BlastedDate,
			b.CentroidEasting, b.CentroidNorthing,
			(
				CASE
					WHEN b.CentroidRL = 0 THEN NULL
					ELSE b.CentroidRL
				END
			) AS CentroidRL,
			m.ModelTonnes, m.LastModifiedUser, m.LastModifiedDate,
			(
				SELECT p.Number,
					p.Easting, p.Northing, p.RL
				FROM dbo.BhpbioBlastBlockPointHolding AS p
				WHERE p.BlockId = b.BlockId
					-- optimisation: only load polygon points for the geology model
					AND m.ModelName = 'Grade Control'
				FOR XML PATH, ELEMENTS, ROOT('Point')
			) AS Point,
			(
				SELECT GradeName, GradeValue
				FROM
					(
						SELECT GradeName, GradeValue
						FROM dbo.BhpbioBlastBlockModelGradeHolding AS g2
						WHERE g2.BlockId = b.BlockId
							AND g2.ModelName = m.ModelName
							AND g2.ModelOreType = m.ModelOreType
						UNION ALL
						SELECT 'Density', m2.ModelDensity AS Density
						FROM dbo.BhpbioBlastBlockModelHolding AS m2
						WHERE m2.BlockId = b.BlockId
							AND m2.ModelName = m.ModelName
							AND m2.ModelOreType = m.ModelOreType
					) AS gradesXml
				FOR XML PATH, ELEMENTS, ROOT('Grade')
			) AS Grade
		FROM dbo.BhpbioBlastBlockHolding AS b
			INNER JOIN dbo.BhpbioBlastBlockModelHolding AS m
				ON (b.BlockId = m.BlockId)
		WHERE b.Site = ISNULL(@iSite, b.Site)
			AND ISNULL(b.MQ2PitCode, b.Pit) = ISNULL(@iPit, ISNULL(b.MQ2PitCode, b.Pit))
			AND b.Bench = ISNULL(@iBench, b.Bench)
			-- these must not be NULL - otherwise we can't generate a key of any sort !
			AND b.Site IS NOT NULL  -- can't be null in source - but just in case
			AND COALESCE(b.MQ2PitCode, b.Pit) IS NOT NULL  -- can't be null in source - but just in case
			AND b.Bench IS NOT NULL  -- can't be null in source - but just in case
			AND b.BlockName IS NOT NULL  -- can't be null in source - but just in case
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetBhpbioHoldingModelBlocks TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioBlastBlockHolding.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioBlastBlockHolding') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockHolding  
GO 
    
CREATE PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockHolding
(
	@iBlockNumber VARCHAR(2),
	@iBlockName VARCHAR(14),
	@iGeoType VARCHAR(9),
	@iMQ2PitCode VARCHAR(10),
	@iBlockedDate DATETIME,
	@iBlastedDate DATETIME,
	@iSite VARCHAR(9),
	@iOrebody VARCHAR(2),
	@iPit VARCHAR(10),
	@iBench VARCHAR(4),
	@iPatternNumber VARCHAR(4),
	@iCentroidEasting FLOAT,
	@iCentroidNorthing FLOAT,
	@iCentroidRL FLOAT,
	@oBlockId INT OUTPUT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioBlastBlockHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @oBlockId = NULL

		-- BlockID is used to link Block, BlockModel, BlockModelGrade and BlockPoint records
		-- This is internally generated as part of the BlockModelInsertUpdate load import
		-- however will not agree with the BlockId value stored in the BlockHolding table
		-- Therefore the records are matched according to the Business Key which is:
		-- BlockNumber, Site, Pit, Bench and PatternNumber
		-- The BlockID is passed back from this procedure to be used in the calls to the related 
		-- tables
		
		SELECT @oBlockId = BlockId
		FROM dbo.BhpbioBlastBlockHolding AS bbh
		WHERE BlockNumber = @iBlockNumber
			AND BlockName = @iBlockName
			AND OreBody = @iOreBody
			AND Site = @iSite
			AND Pit = @iPit
			AND Bench = @iBench
			AND PatternNumber = @iPatternNumber
			
		-- Update record if it exists	
		IF @oBlockId IS NOT NULL
		BEGIN
			UPDATE dbo.BhpbioBlastBlockHolding
			SET	BlockNumber = @iBlockNumber,
				BlockName = @iBlockName,
				GeoType = @iGeoType,
				MQ2PitCode = @iMQ2PitCode,
				BlockedDate = @iBlockedDate,
				BlastedDate = @iBlastedDate,
				Site = @iSite,
				Orebody = @iOrebody,
				Pit = @iPit,
				Bench = @iBench,
				PatternNumber = @iPatternNumber,
				CentroidEasting = @iCentroidEasting,
				CentroidNorthing = @iCentroidNorthing,
				CentroidRL = @iCentroidRL
			WHERE BlockID = @oBlockId
		END
		ELSE
		-- Otherwise insert it
		BEGIN
			INSERT INTO dbo.BhpbioBlastBlockHolding
			(
				BlockNumber, BlockName, GeoType, MQ2PitCode, BlockedDate, BlastedDate, Site,
				Orebody, Pit, Bench, PatternNumber, CentroidEasting, CentroidNorthing,
				CentroidRL
			)
			VALUES
			(
				@iBlockNumber, @iBlockName, @iGeoType, @iMQ2PitCode, @iBlockedDate, @iBlastedDate, @iSite,
				@iOrebody, @iPit, @iBench, @iPatternNumber, @iCentroidEasting, @iCentroidNorthing,
				@iCentroidRL
			)

			SET @oBlockId = SCOPE_IDENTITY()
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH

END
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioBlastBlockHolding TO BhpbioGenericManager
GO

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioBlastBlockModelHolding.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioBlastBlockModelHolding') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockModelHolding  
GO 
    
CREATE PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockModelHolding
(
	@iBlockId INT,
	@iModelName VARCHAR(13),
	@iModelOreType VARCHAR(8),
	@iModelVolume FLOAT,
	@iModelTonnes FLOAT,
	@iModelDensity FLOAT,
	@iLastModifiedUser VARCHAR(50),
	@iLastModifiedDate DATETIME
)
AS
BEGIN
	DECLARE @BlockID INT
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioBlastBlockModelHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- BlockID is used to link Block, BlockModel, BlockModelGrade and BlockPoint records
		-- The Primary key for BhpbioBlastBlockModelHolding is
		-- BlockId, ModelName and ModelOreType
		SELECT @BlockId = BlockId
		FROM dbo.BhpbioBlastBlockModelHolding bbmh
		WHERE BlockId = @iBlockId 
			AND ModelName = @iModelName 
			AND ModelOreType = @iModelOreType

		-- Update record if it exists	
		IF @BlockId IS NOT NULL
		BEGIN
			UPDATE dbo.BhpbioBlastBlockModelHolding
			SET	ModelVolume = @iModelVolume,
				ModelTonnes = @iModelTonnes,
				ModelDensity = @iModelDensity,
				LastModifiedUser = @iLastModifiedUser,
				LastModifiedDate = @iLastModifiedDate
			WHERE BlockID = @iBlockId 
				AND ModelName = @iModelName 
				AND ModelOreType = @iModelOreType
		END
		ELSE
		-- Otherwise insert it
		BEGIN
			INSERT INTO dbo.BhpbioBlastBlockModelHolding
			(
				BlockID, ModelName, ModelOreType, ModelVolume,
				ModelTonnes, ModelDensity, LastModifiedUser, LastModifiedDate
			)
			VALUES
			(
				@iBlockId, @iModelName, @iModelOreType, @iModelVolume,
				@iModelTonnes, @iModelDensity, @iLastModifiedUser, @iLastModifiedDate
			)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH

End
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioBlastBlockModelHolding TO BhpbioGenericManager
GO

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioBlastBlockModelGradeHolding.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioBlastBlockModelGradeHolding') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockModelGradeHolding  
GO 
    
CREATE PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockModelGradeHolding
(
	@iBlockId INT,
	@iModelName VARCHAR(13),
	@iModelOreType VARCHAR(8),
	@iGradeName VARCHAR(5),
	@iGradeValue FLOAT
)
AS
BEGIN

	DECLARE @BlockId INT
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioBlastBlockModelGradeHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- BlockID is used to link Block, BlockModel, BlockModelGrade and BlockPoint records
		-- The Primary key for BhpbioBlastBlockModelHolding is
		-- BlockId, ModelName, ModelOreType and GradeName
		SELECT @BlockId = BlockId
		FROM dbo.BhpbioBlastBlockModelGradeHolding bbmgh
		WHERE BlockId = @iBlockId 
			AND ModelName = @iModelName 
			AND ModelOreType = @iModelOreType
			AND GradeName = @iGradeName

		-- Update record if it exists	
		IF @BlockId IS NOT NULL
		BEGIN
			UPDATE dbo.BhpbioBlastBlockModelGradeHolding
			SET	GradeValue = @iGradeValue
			WHERE BlockId = @iBlockId 
				AND ModelName = @iModelName 
				AND ModelOreType = @iModelOreType
				AND GradeName = @iGradeName
		END
		ELSE
		-- Otherwise insert it
		BEGIN
			INSERT INTO dbo.BhpbioBlastBlockModelGradeHolding
			(
				BlockId, ModelName, ModelOreType, GradeName, GradeValue
			)
			VALUES
			(
				@iBlockId, @iModelName, @iModelOreType, @iGradeName, @iGradeValue
			)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH

END
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioBlastBlockModelGradeHolding TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioBlastBlockPointHolding.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioBlastBlockPointHolding') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockPointHolding  
GO 
    
CREATE PROCEDURE dbo.AddOrUpdateBhpbioBlastBlockPointHolding
(
	@iBlockId INT,
	@iNumber VARCHAR(3),
	@iEasting FLOAT,
	@iNorthing FLOAT,
	@iRL FLOAT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioBlastBlockPointHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- BlockID is used to link Block, BlockModel, BlockModelGrade and BlockPoint records
		-- The Primary key for BhpbioBlastBlockPointHolding is
		-- BlockId, ModelName and ModelOreType


		-- Update record if it exists	
		IF EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockPointHolding bbph
				WHERE BlockId = @iBlockId 
					AND Number = @iNumber
			)
		BEGIN
			UPDATE dbo.BhpbioBlastBlockPointHolding
			SET	Easting = @iEasting,
				Northing = @iNorthing,
				RL = @iRL
			WHERE BlockId = @iBlockId
				AND Number = @iNumber
		END
		ELSE
		-- Otherwise insert it
		BEGIN
			INSERT INTO dbo.BhpbioBlastBlockPointHolding
			(
				BlockID, Number, Easting, Northing, RL
			)
			VALUES
			(
				@iBlockID, @iNumber, @iEasting, @iNorthing, @iRL
			)
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH

End
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioBlastBlockPointHolding TO BhpbioGenericManager
GO

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.getbhpbiodigblockhaulagegradeoverrange.prc'
GO

If object_id('dbo.GetBhpbioDigblockHaulageGradeOverRange') Is Not Null 
     Drop Procedure dbo.GetBhpbioDigblockHaulageGradeOverRange 
Go 
  
Create Procedure dbo.GetBhpbioDigblockHaulageGradeOverRange
( 
	@iLocationID Int,
    @iStartDate Datetime = Null,
	@iEndDate Datetime = Null,
	@iGradeID Int
) 
As 
Begin 
    Set NoCount On 
  
  
	Select H.Source_Digblock_ID As Digblock_ID, 
		Case When Sum(H.Tonnes) > 0 Then
				Sum(H.Tonnes*HG.Grade_Value) / Sum(H.Tonnes) 
			ELSE
				NULL
			END	As Tonnes
	From dbo.Haulage As H
		Inner Join 
			(
				--Eliminate double counting
				Select DL.Digblock_ID
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_ID = DL.Location_Type_ID)
					Inner Join 
						(
							Select *
							From dbo.GetLocationChildLocationList(@iLocationID) 
							Union 
							Select @iLocationID
						) As L
						On (L.Location_ID = DL.Location_ID)
				Group By DL.Digblock_ID
			) As DL
			On (DL.Digblock_ID = H.Source_Digblock_ID)
		Inner Join dbo.HaulageGrade HG
			On (HG.Haulage_ID = H.Haulage_ID
				And HG.Grade_ID = @iGradeID)
	Where H.Haulage_Date >= IsNull(@iStartDate, H.Haulage_Date)
		And H.Haulage_Date <= IsNull(@iEndDate, H.Haulage_Date)
		AND h.Haulage_State_Id IN ('N', 'A')
		AND h.Child_Haulage_Id IS NULL
		And H.Source_Digblock_Id Is Not Null
	Group By H.Source_Digblock_ID

End 
Go 
GRANT EXECUTE ON dbo.GetBhpbioDigblockHaulageGradeOverRange TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioDigblockHaulageGradeOverRange">
 <Procedure>
	Returns a list of digblocks and their total survey tonnes for a given period. 
	This is filtered by a parent location that is passed in.
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.getbhpbiodigblockmodelblockgradeoverperiod.prc'
GO

If object_id('dbo.GetBhpbioDigblockModelBlockGradeOverPeriod') Is Not Null 
     Drop Procedure dbo.GetBhpbioDigblockModelBlockGradeOverPeriod 
Go 
  
Create Procedure dbo.GetBhpbioDigblockModelBlockGradeOverPeriod
( 
    @iLocationID Int,
	@iBlockModelID Int,
	@iGradeID Int
) 
As
Begin 
    Set NoCount On 
  
    Select DL.Digblock_ID, 
		Case When Sum(MBP.Tonnes * IsNull(DMB.Percentage_In_Digblock, 1)) > 0 Then
				Sum(MBP.Tonnes * IsNull(DMB.Percentage_In_Digblock, 1) * MBPG.Grade_Value) / Sum(MBP.Tonnes * IsNull(DMB.Percentage_In_Digblock, 1)) 
			Else
				Null
			End As Tonnes
	From dbo.ModelBlock As MB
		Inner Join dbo.ModelBlockPartial As MBP
			On (MB.Model_Block_ID = MBP.Model_Block_ID)
		Inner Join dbo.DigblockModelBlock as DMB
			On (MB.Model_Block_ID = DMB.Model_Block_ID)
		Inner Join 
			(
				--Eliminate double counting
				Select DL.Digblock_ID
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_ID = DL.Location_Type_ID)
					Inner Join 
						(
							Select *
							From dbo.GetLocationChildLocationList(@iLocationID) 
							Union 
							Select @iLocationID
						) As L
						On (L.Location_ID = DL.Location_ID)
				Group By DL.Digblock_ID
			) As DL
			On (DMB.Digblock_ID = DL.Digblock_ID)
		Inner Join ModelBlockPartialGrade MBPG
			On (MBPG.Model_Block_ID = MBP.Model_Block_ID
				And MBPG.Sequence_No = MBP.Sequence_No
				And MBPG.Grade_ID = @iGradeID )
	Where MB.Block_Model_ID = @iBlockModelID
	Group By DL.Digblock_ID
  
End 
Go 
GRANT EXECUTE ON dbo.GetBhpbioDigblockModelBlockGradeOverPeriod TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioDigblockModelBlockGradeOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total tonnes according to the chosen block model. 
	This is filtered by a parent location that is passed in.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.getbhpbiodigblockreconciledgradeoverperiod.prc'
GO

If object_id('dbo.GetBhpbioDigblockReconciledGradeOverPeriod') Is Not Null 
     Drop Procedure dbo.GetBhpbioDigblockReconciledGradeOverPeriod 
Go 
  
Create Procedure dbo.GetBhpbioDigblockReconciledGradeOverPeriod 
( 
    @iLocationId Int,
	@iStartDate DateTime = Null,
	@iEndDate DateTime = Null,
	@iGradeID Int
) 
With Encryption 
As
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
    Select DPT.Source_Digblock_Id As Digblock_Id, 
		Case When Sum(DPT.Tonnes) > 0 Then
				Sum(DPT.Tonnes*DPTG.Grade_Value) / Sum(DPT.Tonnes)
			Else
				Null
			End As Tonnes
	From dbo.DataProcessTransaction As DPT
		Inner Join 
			(	
				--Eliminate double counting
				Select DL.Digblock_Id
				From dbo.DigblockLocation As DL
					Inner Join dbo.LocationType As LT
						On (LT.Location_Type_Id = DL.Location_Type_Id)
					Inner Join 
						(	
							Select Location_Id 
							From dbo.GetLocationChildLocationList(@iLocationId)
							Union All
							Select @iLocationId As Location_Id
						)  As L
						On (L.Location_Id = DL.Location_Id)
				Group By DL.Digblock_Id
			) As DL
			On (DL.Digblock_Id = DPT.Source_Digblock_Id)
		Inner Join dbo.DataProcessTransactionGrade As DPTG
			On (DPTG.Data_Process_Transaction_ID = DPTG.Data_Process_Transaction_ID
				And DPTG.Grade_ID = @iGradeID)
	Where DPT.Source_Digblock_Id Is Not Null
		And DPT.Data_Process_Transaction_Date >= IsNull(@iStartDate, DPT.Data_Process_Transaction_Date)
		And DPT.Data_Process_Transaction_Date <= IsNull(@iEndDate, DPT.Data_Process_Transaction_Date)
	Group By DPT.Source_Digblock_Id

    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetBhpbioDigblockReconciledGradeOverPeriod TO CoreDigblockManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioDigblockReconciledGradeOverPeriod">
 <Procedure>
	Returns a list of digblocks and their total reconciled tonnes for a given period. 
	This is filtered by a parent location that is passed in.	
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioAnalysisVariance.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioAnalysisVariance') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioAnalysisVariance
GO 

CREATE PROCEDURE dbo.DeleteBhpbioAnalysisVariance
(
	@iLocationId INT,
	@iVarianceType CHAR(1) = NULL
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
	
		-- Error if it does not exist.
		IF NOT EXISTS (
						SELECT 1 
						FROM dbo.BhpbioAnalysisVariance 
						WHERE LocationId = @iLocationId
							AND (VarianceType = @iVarianceType OR @iVarianceType IS NULL)
					   )
		BEGIN
			RAISERROR('This variance does not exist.', 16, 1)
		END
		
		-- Delete the variance records associated with the location (and type).
		DELETE
		FROM dbo.BhpbioAnalysisVariance 
		WHERE LocationId = @iLocationId
			AND (VarianceType = @iVarianceType OR @iVarianceType IS NULL)
	
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.DeleteBhpbioAnalysisVariance TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioAnalysisVariance.prc'
GO

IF OBJECT_ID('dbo.AddOrUpdateBhpbioAnalysisVariance') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioAnalysisVariance  
GO 

CREATE PROCEDURE dbo.AddOrUpdateBhpbioAnalysisVariance
(
	@iLocationId INT,
	@iVarianceType CHAR(1),
	@iPercentage FLOAT,
	@iColor VARCHAR(255)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioAnalysisVariance',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF EXISTS (
					SELECT 1 
					FROM dbo.BhpbioAnalysisVariance 
					WHERE LocationId = @iLocationId
						AND VarianceType = @iVarianceType
				   )
		BEGIN 
			-- Update the threshold
			UPDATE V
			SET Percentage = @iPercentage,
				Color = @iColor
			FROM dbo.BhpbioAnalysisVariance AS V
			WHERE LocationId = @iLocationId
				AND VarianceType = @iVarianceType
		END
		ELSE
		BEGIN
			INSERT INTO dbo.BhpbioAnalysisVariance
				(LocationId, VarianceType, Percentage, Color)
			SELECT @iLocationId, @iVarianceType, @iPercentage, @iColor
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
GRANT EXECUTE ON dbo.AddOrUpdateBhpbioAnalysisVariance TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioBlastBlockHolding.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioBlastBlockHolding') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioBlastBlockHolding
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioBlastBlockHolding 
(
	@iBlockName VARCHAR(14),
	@iSite VARCHAR(9),
	@iOreBody VARCHAR(2),
	@iPit VARCHAR(10),
	@iBench VARCHAR(4),
	@iPatternNumber VARCHAR(4)
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BlockId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioBlastBlockHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @BlockId =
			(
				SELECT BlockId				
				FROM dbo.BhpbioBlastBlockHolding
				WHERE BlockName = @iBlockName
					AND Site = @iSite
					AND Orebody = @iOrebody
					AND Pit = @iPit
					AND Bench = @iBench
					AND PatternNumber = @iPatternNumber
			)

		DELETE
		FROM dbo.BhpbioBlastBlockModelGradeHolding
		WHERE BlockId = @BlockId

		DELETE
		FROM dbo.BhpbioBlastBlockModelHolding
		WHERE BlockId = @BlockId

		DELETE
		FROM dbo.BhpbioBlastBlockPointHolding
		WHERE BlockId = @BlockId
		
		DELETE
		FROM dbo.BhpbioBlastBlockHolding
		WHERE BlockId = @BlockId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioBlastBlockHolding TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioMaterialLookup.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioMaterialLookup') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioMaterialLookup  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioMaterialLookup 
(
	@iMaterialCategoryId VARCHAR(31),
	@iLocationTypeId TINYINT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		-- this should later be extended to look for:
		-- (1) ANY child material types of existing material types (not required at this point)
		-- (2) ANY child category of the category provided (also not required at this point)
	
		SELECT mt.Material_Type_Id AS MaterialTypeId, mt.Abbreviation,
			l.Location_Type_Id AS LocationTypeId, l.Location_Id AS LocationId
		FROM dbo.MaterialType AS mt
			LEFT OUTER JOIN dbo.MaterialTypeLocation AS mtl
				ON (mt.Material_Type_Id = mtl.Material_Type_Id)
			LEFT OUTER JOIN dbo.Location AS l
				ON (mtl.Location_Id = l.Location_Id
					AND l.Location_Type_Id = ISNULL(@iLocationTypeId, l.Location_Type_Id))
			INNER JOIN dbo.MaterialCategory AS mc
				ON (mt.Material_Category_Id = mc.MaterialCategoryId)
		WHERE mc.MaterialCategoryId = ISNULL(@iMaterialCategoryId, mc.MaterialCategoryId)
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioMaterialLookup TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioProductionEntity.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioProductionEntity') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioProductionEntity
GO 
  
CREATE PROCEDURE dbo.GetBhpbioProductionEntity
(
	@iSiteLocationId INT,
	@iTransactionDate DATETIME,
	@iCode VARCHAR(255),
	@iType VARCHAR(255),
	@iDirection VARCHAR(255),
	@oStockpileId INT OUTPUT,
	@oCrusherId VARCHAR(31) OUTPUT,
	@oMillId VARCHAR(31) OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @StockpileId INT
	DECLARE @CrusherId VARCHAR(31)
	DECLARE @MillId VARCHAR(31)
	DECLARE @Resolved BIT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioProductionEntity',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @StockpileId = NULL
		SET @CrusherId = NULL
		SET @MillId = NULL

		EXEC dbo.BhpbioResolveBasic
			@iTransactionDate = @iTransactionDate,
			@iCode = @iCode,
			@iResolution_Target = @iDirection,
			@oResolved = @Resolved OUTPUT,
			@oDigblockId = NULL,
			@oStockpileId = @StockpileId OUTPUT,
			@oCrusherId = @CrusherId OUTPUT,
			@oMillId = @MillId OUTPUT

		IF @Resolved = 0
		BEGIN
			IF @iType = 'crusher'
			BEGIN
				-- this is a simple crusher lookup based on:
				-- 1. The Site's location recorded against the Crusher
				-- 2. The Code directly mapped to the Crusher's Id

				SET @CrusherId =
					(
						SELECT cl.Crusher_Id
						FROM dbo.CrusherLocation AS cl
							INNER JOIN dbo.Location AS l
								ON (cl.Location_Id = l.Location_Id)
						WHERE l.Location_Id = @iSiteLocationId
							AND cl.Crusher_Id = @iCode
					)
					
				IF @CrusherId IS NULL
				BEGIN
					SET @MillId =
						(
							SELECT cl.Mill_Id
							FROM dbo.MillLocation AS cl
								INNER JOIN dbo.Location AS l
									ON (cl.Location_Id = l.Location_Id)
							WHERE l.Location_Id = @iSiteLocationId
								AND cl.Mill_Id = @iCode
						)
				END
			END
			ELSE IF @iType = 'post crusher' OR @iType = 'pre crusher' 
			BEGIN
				-- this is a simple stockpile lookup based on:
				-- 1. The Site's location recorded against the Stockpile
				-- 2. The Code directly mapped to the Stockpile's Name

				SET @StockpileId = 
					(
						SELECT s.Stockpile_Id
						FROM dbo.StockpileLocation AS sl
							INNER JOIN dbo.Stockpile AS s
								ON (sl.Stockpile_Id = s.Stockpile_Id)
						WHERE sl.Location_Id = @iSiteLocationId
							AND s.Stockpile_Name = @iCode
					)
			END
			ELSE IF @iType = 'train rake'
			BEGIN
				-- this lookup is based on a specific stockpile from:
				-- 1. The Site's location recorded against the stockpile
				-- 2. The stockpile's membership with the Port Train Rake stockpile group
				-- note that regardless of code, all mappings are made to a SINGLE specific stockpile
				
				-- Compat for NJV Hub, if the direction is source then 'Hub Train Rake' stockpile group.
				
				IF @iDirection = 'SOURCE' 
				BEGIN
					SET @StockpileId =
						(
							SELECT s.Stockpile_Id
							FROM dbo.Stockpile AS s
								INNER JOIN dbo.StockpileGroupStockpile AS sgs
									ON (sgs.Stockpile_Id = s.Stockpile_Id)
								INNER JOIN dbo.StockpileGroup AS sg
									ON (sg.Stockpile_Group_Id = sgs.Stockpile_Group_Id)
								INNER JOIN dbo.StockpileLocation AS sl
									ON (sl.Stockpile_Id = s.Stockpile_Id)
								INNER JOIN dbo.Location L
									ON (l.Location_Id = sl.Location_Id)
							WHERE sl.Location_Id = dbo.GetLocationTypeLocationId(@iSiteLocationId, l.Location_Type_Id)
								AND sg.Stockpile_Group_Id = 'Hub Train Rake'
						)				
				END
				ELSE
				BEGIN
					SET @StockpileId =
						(
							SELECT s.Stockpile_Id
							FROM dbo.Stockpile AS s
								INNER JOIN dbo.StockpileGroupStockpile AS sgs
									ON (sgs.Stockpile_Id = s.Stockpile_Id)
								INNER JOIN dbo.StockpileGroup AS sg
									ON (sg.Stockpile_Group_Id = sgs.Stockpile_Group_Id)
								INNER JOIN dbo.StockpileLocation AS sl
									ON (sl.Stockpile_Id = s.Stockpile_Id)
							WHERE sl.Location_Id = @iSiteLocationId
								AND sg.Stockpile_Group_Id = 'Port Train Rake'
						)
				END
			END
		END

		-- return the results
		SET @oStockpileId = @StockpileId
		SET @oCrusherId = @CrusherId
		SET @oMillId = @MillId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioProductionEntity TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioProductionWeightometer.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioProductionWeightometer') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioProductionWeightometer
GO 
  
CREATE PROCEDURE dbo.GetBhpbioProductionWeightometer
(
	@iSourceStockpileId INT,
	@iSourceCrusherId VARCHAR(31),
	@iSourceMillId VARCHAR(31),
	@iDestinationStockpileId INT,
	@iDestinationCrusherId VARCHAR(31),
	@iDestinationMillId VARCHAR(31),
	@iTransactionDate DATETIME,
	@iSourceType VARCHAR(255),
	@iDestinationType VARCHAR(255),
	@iSiteLocationId INT,
	@oWeightometerId VARCHAR(31) OUTPUT,
	@oIsError BIT OUTPUT,
	@oErrorDescription VARCHAR(255) OUTPUT
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @WeightometerId VARCHAR(31)
	DECLARE @IsError BIT
	DECLARE @ErrorDescription VARCHAR(255)

	DECLARE @LocationTypeId SmallInt

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioProductionWeightometer',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @oWeightometerId = NULL
		SET @oIsError = 0
		SET @oErrorDescription = NULL
		
		SET @WeightometerId = NULL
		SET @IsError = 0

		-- these flows below are fixed to specific cross-site weightometers
		-- this is because these flows are a-typical and users will be interested
		-- in investigating these flows
		IF @iSourceType = 'post crusher' AND @iDestinationType = 'pre crusher'
		BEGIN
			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer AS w
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
			WHERE w.Weightometer_Id LIKE '%PostCrusherToPreCrusher'
				AND wl.Location_Id = @iSiteLocationId
		END
		ELSE IF @iSourceType = 'post crusher' AND @iDestinationType = 'post crusher'
		BEGIN
			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer AS w
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
			WHERE w.Weightometer_Id LIKE '%PostCrusherToPostCrusher'
				AND wl.Location_Id = @iSiteLocationId
		END
		ELSE IF @iSourceType = 'post crusher' AND @iDestinationType = 'crusher'
		BEGIN
			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer AS w
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
			WHERE w.Weightometer_Id LIKE '%PostCrusherToCrusher'
				AND wl.Location_Id = @iSiteLocationId
		END
		ELSE IF @iSourceType = 'post crusher' AND @iDestinationType = 'train rake'
		BEGIN
			-- resolve the weightometer based on the site
			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer AS w
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
			WHERE w.Weightometer_Id LIKE '%PostCrusherToTrainRake'
				AND wl.Location_Id = @iSiteLocationId
		END
		ELSE IF @iSourceType = 'crusher' AND @iDestinationType = 'crusher'
		BEGIN
			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer As w
				INNER JOIN dbo.WeightometerLocation As wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
				INNER JOIN dbo.WeightometerFlowPeriod As wfp
					ON (wfp.Weightometer_Id = w.Weightometer_Id)
			WHERE (w.Weightometer_Id Like '%Raw%' Or w.Weightometer_Id Not Like '%Corrected%')
				AND wl.Location_Id = @iSiteLocationId
				AND ( wfp.Source_Crusher_Id = @iSourceCrusherId
						OR wfp.Source_Mill_Id = @iSourceMillId	)
				AND ( wfp.Destination_Crusher_ID = @iDestinationCrusherId
						OR wfp.Destination_Mill_Id = @iDestinationMillId) 
		END		
		ELSE IF (@iSourceType = 'train rake')
		BEGIN
			
			SELECT @LocationTypeId = Location_Type_Id
			FROM LocationType LT
			WHERE Description = 'Hub'

			SELECT @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer As w
				INNER JOIN dbo.WeightometerLocation As wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
				INNER JOIN dbo.WeightometerFlowPeriod As wfp
					ON (wfp.Weightometer_Id = w.Weightometer_Id)
			WHERE (w.Weightometer_Id Like '%Raw%' Or w.Weightometer_Id Not Like '%Corrected%')
				AND wl.Location_Id = dbo.getlocationtypelocationid(@iSiteLocationId, @LocationTypeId)
				AND wfp.Source_Stockpile_Id IS NOT NULL
				AND (wfp.Destination_Stockpile_Id = @iDestinationStockpileId)

		END			
		ELSE IF ((@iSourceType = 'pre crusher' OR @iSourceType = 'post crusher') AND @iDestinationType = 'crusher')
			OR (@iSourceType = 'crusher' AND (@iDestinationType = 'post crusher' OR @iDestinationType = 'train rake' OR @iDestinationType = 'pre crusher'))
			OR (@iDestinationType = 'crusher')
		BEGIN
			-- these flows are typical and hence are routed through the Weightometer Flow Period system
			-- try to determine if we can use a site's weightometer based on the weightometer flow period
			-- besides - how else do you hook it up to a crusher/mill!  (stoopid wfp system)
			;WITH BhpbioWeightometerFlowPeriod (Weightometer_Id, Start_Date, End_Date, Source_Stockpile_Id, Source_Crusher_Id,
				Source_Mill_Id, Destination_Stockpile_Id, Destination_Crusher_Id, Destination_Mill_Id, Is_Calculated, Processing_Order_No) AS
			(
				SELECT wfp.Weightometer_Id,
					(
						SELECT TOP 1 DATEADD(DAY, 1, wfp2.End_Date)
						FROM dbo.WeightometerFlowPeriod AS wfp2
						WHERE wfp.Weightometer_Id = wfp2.Weightometer_Id
							AND wfp2.End_Date < ISNULL(wfp.End_Date, DATEADD(DAY, 1, wfp2.End_Date))
						ORDER BY wfp2.End_Date DESC
					) AS Start_Date,
					End_Date, Source_Stockpile_Id, Source_Crusher_Id, Source_Mill_Id, Destination_Stockpile_Id,
					Destination_Crusher_Id, Destination_Mill_Id, Is_Calculated, Processing_Order_No
				FROM dbo.WeightometerFlowPeriod AS wfp
			)
			SELECT TOP 1 @WeightometerId = w.Weightometer_Id
			FROM dbo.Weightometer AS w
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (w.Weightometer_Id = wl.Weightometer_Id)
				INNER JOIN (
						-- use the Weightometer Flow Period table to work out if any of the entries are applicable
						SELECT wfp1.Weightometer_Id, wfp1.Source_Crusher_Id, wfp1.Source_Mill_Id, wfp1.Source_Stockpile_Id, 
							wfp1.Destination_Crusher_Id, wfp1.Destination_Mill_Id, wfp1.Destination_Stockpile_Id
						FROM BhpbioWeightometerFlowPeriod AS wfp1
						WHERE 
							(
								-- match on source crusher / mill (if it is specified)
								(wfp1.Source_Crusher_Id = @iSourceCrusherId)
								OR (wfp1.Source_Mill_Id = @iSourceMillId)
								OR (wfp1.Source_Stockpile_Id = @iSourceStockpileId)
								OR
								(
									-- this enforces a Mill and Crusher to be specific
									-- if the stockpile hasn't been identified then that is ok
									-- as the source/destination can be "floating"
									wfp1.Source_Mill_Id IS NULL AND @iSourceMillId IS NULL
									AND wfp1.Source_Crusher_Id IS NULL AND @iSourceCrusherId IS NULL
									AND wfp1.Source_Stockpile_Id IS NULL
								)
							)
							AND
							(
								-- match on destination crusher / mill (if it is specified)
								(wfp1.Destination_Crusher_Id = @iDestinationCrusherId)
								OR (wfp1.Destination_Mill_Id = @iDestinationMillId)
								OR (wfp1.Destination_Stockpile_Id = @iDestinationStockpileId)
								OR
								(
									-- ditto for source (above)
									wfp1.Destination_Mill_Id IS NULL AND @iDestinationMillId IS NULL
									AND wfp1.Destination_Crusher_Id IS NULL AND @iDestinationCrusherId IS NULL
									AND wfp1.Destination_Stockpile_Id IS NULL
								)
							)
							AND (@iTransactionDate <= ISNULL(wfp1.End_Date, @iTransactionDate))
							AND (@iTransactionDate >= ISNULL(wfp1.Start_Date, @iTransactionDate))
					) wfp
					ON w.Weightometer_Id = wfp.Weightometer_Id
			WHERE wl.Location_Id = @iSiteLocationId
				AND w.Weightometer_Id Not Like '%Corrected'
			ORDER BY (
					CASE WHEN COALESCE(wfp.Source_Crusher_Id, wfp.Source_Mill_Id, Cast(wfp.Source_Stockpile_Id As Varchar)) IS NOT NULL THEN 1 ELSE 0 END
					+ CASE WHEN COALESCE(wfp.Destination_Crusher_Id, wfp.Destination_Mill_Id, Cast(wfp.Destination_Stockpile_Id As Varchar)) IS NOT NULL THEN 1 ELSE 0 END
					) DESC
					
		END

		IF @WeightometerId IS NULL
		BEGIN
			SET @IsError = 1
			SET @ErrorDescription = 'Unable to determine an appropriate weightometer.'
		END

		-- return the results
		SET @oWeightometerId = @WeightometerId
		SET @oIsError = @IsError
		SET @oErrorDescription = @ErrorDescription

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioProductionWeightometer TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioAnalysisVarianceList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioAnalysisVarianceList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioAnalysisVarianceList
GO 

CREATE PROCEDURE dbo.GetBhpbioAnalysisVarianceList
(
	@iLocationId INT,
	@iVarianceType CHAR(1) = NULL,
	@iOnlyInherited BIT = 0,
	@iOnlyLocation BIT = 0
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DECLARE @CurrentLocation INT
		DECLARE @LocationId INT
		
		DECLARE @Results TABLE
		(
			LocationId INT,
			LocationName VARCHAR(255) COLLATE DATABASE_DEFAULT,
			VarianceType CHAR(1),
			Percentage FLOAT NOT NULL,
			Color VARCHAR(255) COLLATE Database_Default NULL
		)
		
		SET @LocationId = @iLocationId
		IF @LocationId < 1
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.Location
			WHERE Parent_Location_Id IS NULL
		END
		

		IF @iOnlyLocation = 1 OR (@iOnlyInherited = 0 AND @iOnlyLocation = 0)
		BEGIN
			INSERT INTO @Results
				(LocationId, LocationName, VarianceType, Percentage, Color)
			SELECT L.Location_Id, L.Description, BAV.VarianceType, BAV.Percentage, BAV.Color
			FROM dbo.Location AS L
				INNER JOIN dbo.BhpbioAnalysisVariance AS BAV
					ON L.Location_ID = BAV.LocationID
			WHERE L.Location_ID = @LocationId
				AND (BAV.VarianceType = @iVarianceType OR @iVarianceType IS NULL)
		END
		
		IF @iOnlyInherited = 1 OR (@iOnlyInherited = 0 AND @iOnlyLocation = 0 
									AND NOT EXISTS (SELECT 1 FROM @Results))
		BEGIN
			SET @CurrentLocation = @LocationId
			
			-- Cycle up through the parents until we find a location which has values we get to 
			--- the top.
			WHILE @CurrentLocation IS NOT NULL
			BEGIN

				IF EXISTS (	SELECT TOP 1 1 
							FROM dbo.BhpbioAnalysisVariance 
							WHERE LocationId = @CurrentLocation
						  )
				BEGIN

					-- If records exist at this level do not return anything as we are not inheriting.
					IF @CurrentLocation <> @LocationId
					BEGIN

						-- Update the records based on this location.
						INSERT INTO @Results
							(LocationId, LocationName, VarianceType, Percentage, Color)
						SELECT L.Location_Id, L.Description, BAV.VarianceType, BAV.Percentage, BAV.Color
						FROM dbo.Location AS L
							INNER JOIN dbo.BhpbioAnalysisVariance AS BAV
							ON L.Location_ID = BAV.LocationID
						WHERE L.Location_ID = @CurrentLocation
							AND (BAV.VarianceType = @iVarianceType OR @iVarianceType IS NULL)
					END
					
					-- We have found our match so finish the looping
					SET @CurrentLocation = NULL
				END
			
				-- Cycle up the parent heirachy
				SELECT @CurrentLocation = L.Parent_Location_Id
				FROM dbo.Location AS L
				WHERE L.Location_Id = @CurrentLocation
			END
		END
		
		
		SELECT LocationId, LocationName, VarianceType,Percentage, Color
		FROM @Results
			
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioAnalysisVarianceList TO BhpbioGenericManager


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioModelComparisonReport.prc'
GO

IF Object_Id('dbo.GetBhpbioModelComparisonReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioModelComparisonReport
GO

CREATE PROCEDURE dbo.GetBhpbioModelComparisonReport
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iDesignationMaterialTypeId INT,
	@iTonnes BIT,
	@iGrades XML
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Tonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)

	DECLARE @Grade TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		GradeId SMALLINT NOT NULL,
		GradeValue REAL,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, GradeName, Type)
	)

	SET NOCOUNT ON

	SELECT @TransactionName = 'GetBhpbioModelComparisonReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- note: this has been split into two separate calls
		-- a new requirement (for crusher actuals) has made it such that we cannot aggregate any further beyond the base procs

		-- create the summary data
		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Grade
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, GradeName, GradeId, GradeValue
		)
		EXEC dbo.GetBhpbioReportBaseDataAsGrades
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId,
			@iGrades = @iGrades

		SELECT 'Tonnes' AS TonnesGradesTag, Type AS ModelTag, Material, Tonnes AS Value
		FROM @Tonnes
		UNION ALL
		SELECT g.GradeName, g.Type, g.Material, g.GradeValue
		FROM @Grade AS g
			INNER JOIN @Tonnes AS t
				ON (t.Type = g.Type
					AND t.CalendarDate = g.CalendarDate
					AND t.Material = g.Material)

		-- create the graph data
		DELETE FROM @Tonnes
		DELETE FROM @Grade

		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Grade
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, GradeName, GradeId, GradeValue
		)
		EXEC dbo.GetBhpbioReportBaseDataAsGrades
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId,
			@iGrades = @iGrades

		SELECT CalendarDate, 'Tonnes' AS TonnesGradesTag, Type AS ModelTag, Material, Tonnes AS Value
		FROM @Tonnes
		UNION ALL
		SELECT CalendarDate, GradeName, Type, Material, GradeValue
		FROM @Grade

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioModelComparisonReport TO BhpbioGenericManager
GO

/*
testing

EXEC dbo.GetBhpbioModelComparisonReport
	@iDateFrom = '01-APR-2009',
	@iDateTo = '30-JUN-2009',
	@iDateBreakdown = 'MONTH',
	@iLocationId = 1,
	@iIncludeBlockModels = 1,
	@iBlockModels = '<BlockModels><BlockModel>1</BlockModel><BlockModel>2</BlockModel><BlockModel>3</BlockModel></BlockModels>',
	@iIncludeActuals = 1,
	@iDesignationMaterialTypeId = NULL,
	@iTonnes = 1,
	@iGrades = '<Grades><Grade>1</Grade><Grade>2</Grade></Grades>'

*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddBhpbioMetBalancing.prc'
GO

IF OBJECT_ID('dbo.AddBhpbioMetBalancing') IS NOT NULL
     DROP PROCEDURE dbo.AddBhpbioMetBalancing
GO 
  
CREATE PROCEDURE dbo.AddBhpbioMetBalancing
(
	@iSiteCode VARCHAR(7),
	@iCalendarDate DATETIME,
	@iStartDate DATETIME,
	@iEndDate DATETIME,
	@iPlantName VARCHAR(31),
	@iStreamName VARCHAR(31),
	@iWeightometer VARCHAR(31),
	@iDryTonnes FLOAT,
	@iWetTonnes FLOAT,
	@iSplitCycle FLOAT,
	@iSplitPlant FLOAT,
	@iGrades XML,
	@oBhpbioMetBalancingId INT OUTPUT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BhpbioMetBalancingId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBhpbioMetBalancing',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- add the base record
		INSERT INTO dbo.BhpbioMetBalancing
		(
			SiteCode, CalendarDate, StartDate, EndDate, PlantName, StreamName, Weightometer,
			DryTonnes, WetTonnes, SplitCycle, SplitPlant
		)
		VALUES
		(
			@iSiteCode, @iCalendarDate, @iStartDate, @iEndDate, @iPlantName, @iStreamName, @iWeightometer,
			@iDryTonnes, @iWetTonnes, @iSplitCycle, @iSplitPlant
		)
			
		SET @BhpbioMetBalancingId = Scope_Identity()

		-- add the grade records
		IF @iGrades IS NOT NULL
		BEGIN
			INSERT INTO dbo.BhpbioMetBalancingGrade
			(
				BhpbioMetBalancingId, GradeId, GradeValue
			)
			SELECT @BhpbioMetBalancingId,
				(
					SELECT Grade_Id
					FROM dbo.Grade
					WHERE Grade_Name = Grades.Grade.value('./@Name', 'VARCHAR(31)')
				),
				Grades.Grade.value('./@Value', 'REAL')
			FROM @iGrades.nodes('/Grades/Grade') AS Grades(Grade)
		END

		-- return the id generated
		SET @oBhpbioMetBalancingId = @BhpbioMetBalancingId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioMetBalancing TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UpdateBhpbioMetBalancing.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioMetBalancing') IS NOT NULL
     DROP PROCEDURE dbo.UpdateBhpbioMetBalancing
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioMetBalancing
(
	@iBhpbioMetBalancingId INT,
	@iStartDate DATETIME,
	@iEndDate DATETIME,
	@iWeightometer VARCHAR(31),
	@iDryTonnes FLOAT,
	@iWetTonnes FLOAT,
	@iSplitCycle FLOAT,
	@iSplitPlant FLOAT,
	@iGrades XML
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'UpdateBhpbioMetBalancing',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- add the base record
		UPDATE dbo.BhpbioMetBalancing
		SET StartDate = @iStartDate,
			EndDate = @iEndDate,
			Weightometer = @iWeightometer,
			DryTonnes = @iDryTonnes,
			WetTonnes = @iWetTonnes,
			SplitCycle = @iSplitCycle,
			SplitPlant = @iSplitPlant
		WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId
			
		-- refresh the grade records
		IF @iGrades IS NOT NULL
		BEGIN
			DELETE
			FROM dbo.BhpbioMetBalancingGrade
			WHERE GradeId NOT IN
				(
					SELECT Grade_Id
					FROM dbo.Grade AS g
						INNER JOIN @iGrades.nodes('/Grades/Grade') AS Grades(Grade)
							ON (g.Grade_Name = Grades.Grade.value('./@Name', 'VARCHAR(31)'))
				)
				AND BhpbioMetBalancingId = @iBhpbioMetBalancingId	
				
			UPDATE mbg
			SET GradeValue = 
				(
					SELECT Grades.Grade.value('./@Value', 'REAL')
					FROM dbo.Grade AS g
						INNER JOIN @iGrades.nodes('/Grades/Grade') AS Grades(Grade)
							ON (g.Grade_Name = Grades.Grade.value('./@Name', 'VARCHAR(31)'))
					WHERE g.Grade_Id = mbg.GradeId
				)
			FROM dbo.BhpbioMetBalancingGrade AS mbg
			WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId	

			INSERT INTO dbo.BhpbioMetBalancingGrade
			(
				BhpbioMetBalancingId, GradeId, GradeValue
			)
			SELECT @iBhpbioMetBalancingId, g.Grade_Id, Grades.Grade.value('./@Value', 'REAL')
			FROM @iGrades.nodes('/Grades/Grade') AS Grades(Grade)
				INNER JOIN dbo.Grade AS g
					ON (g.Grade_Name = Grades.Grade.value('./@Name', 'VARCHAR(31)'))
			WHERE g.Grade_Id NOT IN
				(
					SELECT GradeId
					FROM dbo.BhpbioMetBalancingGrade
					WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId
				)
		END
		ELSE
		BEGIN
			DELETE
			FROM dbo.BhpbioMetBalancingGrade
			WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId	
		END

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateBhpbioMetBalancing TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioMetBalancing.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioMetBalancing') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioMetBalancing
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioMetBalancing
(
	@iBhpbioMetBalancingId INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BhpbioMetBalancingId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioMetBalancing',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- delete the base record & grades
		DELETE
		FROM dbo.BhpbioMetBalancingGrade
		WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId

		DELETE
		FROM dbo.BhpbioMetBalancing
		WHERE BhpbioMetBalancingId = @iBhpbioMetBalancingId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioMetBalancing TO BhpbioGenericManager
GO

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioBlastBlockHolding.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioBlastBlockHolding') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioBlastBlockHolding
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioBlastBlockHolding 
(
	@iBlockName VARCHAR(14),
	@iSite VARCHAR(9),
	@iOreBody VARCHAR(2),
	@iPit VARCHAR(10),
	@iBench VARCHAR(4),
	@iPatternNumber VARCHAR(4)
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BlockId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioBlastBlockHolding',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @BlockId =
			(
				SELECT BlockId				
				FROM dbo.BhpbioBlastBlockHolding
				WHERE BlockName = @iBlockName
					AND Site = @iSite
					AND Orebody = @iOrebody
					AND Pit = @iPit
					AND Bench = @iBench
					AND PatternNumber = @iPatternNumber
			)

		DELETE
		FROM dbo.BhpbioBlastBlockModelGradeHolding
		WHERE BlockId = @BlockId

		DELETE
		FROM dbo.BhpbioBlastBlockModelHolding
		WHERE BlockId = @BlockId

		DELETE
		FROM dbo.BhpbioBlastBlockPointHolding
		WHERE BlockId = @BlockId
		
		DELETE
		FROM dbo.BhpbioBlastBlockHolding
		WHERE BlockId = @BlockId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioBlastBlockHolding TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpMaterialTypeList.prc'
GO

 IF OBJECT_ID('dbo.GetBhpMaterialTypeList') IS NOT NULL 
     DROP PROCEDURE dbo.GetBhpMaterialTypeList
GO 
  
CREATE PROCEDURE dbo.GetBhpMaterialTypeList
( 
    @iIs_Digblock_Group BIT = NULL,
	@iIs_Stockpile_Group BIT = NULL,
	@iLocation_Id INT = NULL,
	@iMaterial_Category_Id VARCHAR(31) = NULL,
	@iParent_Material_Type_Id INT = NULL
) 
AS 
BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
    
    CREATE TABLE dbo.#MaterialTypeList
    (
		Material_Type_Id INT,
		Description VARCHAR(255) COLLATE Database_Default,
		Order_No INT,
		Abbreviation VARCHAR(31) COLLATE Database_Default,
		Parent_Material_Type_Id INT,
		Is_Waste BIT,
		Density_Conversion_Factor REAL,
		Material_Type_Group_Id INT,
		Material_Type_Group_Name VARCHAR(63) COLLATE Database_Default,
		Material_Category_Id VARCHAR(63) COLLATE Database_Default,
		Parent_Material_Category_Id VARCHAR(63) COLLATE Database_Default,
		Children INT,
		Is_Processed BIT
    )
    
  
	CREATE TABLE dbo.#MaterialType
	(
		Material_Type_Group_Id INT,
		Material_Type_Group_Name VARCHAR(63) COLLATE Database_Default,
		Material_Type_Id INT
	)

	CREATE TABLE dbo.#WasteType
	(
		Material_Type_Id INT,
		Waste_Type_Id VARCHAR(63) COLLATE Database_Default,
		Is_Waste BIT
	)

	INSERT INTO dbo.#MaterialType
	(
		Material_Type_Group_Id, Material_Type_Group_Name, Material_Type_Id
	)
	SELECT mtg.Material_Type_Group_Id, mtg.Name, mt.Material_Type_Id
	FROM dbo.MaterialType AS mt
		INNER JOIN dbo.MaterialTypeGroup AS mtg
			ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		LEFT OUTER JOIN 
		(
			SELECT m.Material_Type_Id, IsNull(ml.Location_Id, 0) AS Location_Id
			FROM dbo.MaterialType AS m
				LEFT OUTER JOIN dbo.MaterialTypeLocation AS ml 
					ON (m.Material_Type_Id = ml.Material_Type_Id)		
		) AS l
			ON mt.Material_Type_Id = l.Material_Type_Id
	WHERE mtg.Is_Stockpile_Group = IsNull(@iIs_Stockpile_Group, Is_Stockpile_Group)
		AND mtg.Is_Digblock_Group = IsNull(@iIs_Digblock_Group, Is_Digblock_Group)
		AND 
		(
			@iLocation_Id IS NULL
				OR l.Location_Id in 
				(
					SELECT Location_Id 
					FROM dbo.GetLocationSubtree(@iLocation_Id)
				)
		)
	GROUP BY mtg.Material_Type_Group_Id, mtg.Name, mt.Material_Type_Id

	INSERT INTO dbo.#WasteType	
	(
		Material_Type_Id, Waste_Type_Id, Is_Waste
	)
	SELECT mt.Material_Type_Id, 'Is_Waste_' + wt.Waste_Type_Id, mtwtp.Is_Waste
	FROM dbo.WasteType AS wt	
		CROSS JOIN dbo.MaterialType AS mt
		LEFT OUTER JOIN dbo.MaterialTypeWasteTypePeriod AS mtwtp
			ON (mt.Material_Type_Id = mtwtp.Material_Type_Id
				AND wt.Waste_Type_Id = mtwtp.Waste_Type_Id
				AND mtwtp.End_Date IS NULL)

	EXEC dbo.PivotTable
		@iTargetTable = '#MaterialType',
		@iPivotTable = '#WasteType',
		@iJoinColumns = 'dbo.#MaterialType.Material_Type_Id = dbo.#WasteType.Material_Type_Id',
		@iPivotColumn = 'Waste_Type_Id',
		@iPivotValue = 'Is_Waste',
		@iPivotType = 'BIT'

	INSERT INTO dbo.#MaterialTypeList
	(
		Material_Type_Id,
		Description,
		Order_No,
		Abbreviation,
		Parent_Material_Type_Id,
		Is_Waste,
		Density_Conversion_Factor,
		Material_Type_Group_Id,
		Material_Type_Group_Name,
		Material_Category_Id,
		Parent_Material_Category_Id,
		Children,
		Is_Processed
	)
	SELECT mt.Material_Type_Id, mt2.Description, mt2.Order_No, mt2.Abbreviation,
		mt2.Parent_Material_Type_Id, mt2.Is_Waste,
		mt2.Density_Conversion_Factor, mt.Material_Type_Group_Id, mt.Material_Type_Group_Name,
		mc.MaterialCategoryId As Material_Category_Id, 
		mc.ParentMaterialCategoryId As Parent_Material_Category_Id,
		Coalesce(c.Children,0) As Children,
		CASE WHEN mc.ParentMaterialCategoryId IS NULL THEN 1 ELSE 0 END
	FROM dbo.#MaterialType AS mt
		INNER JOIN dbo.MaterialType AS mt2
			ON (mt.Material_Type_Id = mt2.Material_Type_Id)
		LEFT JOIN dbo.MaterialCategory AS mc
			ON (mc.MaterialCategoryId = mt2.Material_Category_Id)
		LEFT JOIN
			(
			SELECT Parent_Material_Type_Id, Count(*) AS Children
			FROM dbo.MaterialType
			GROUP BY Parent_Material_Type_Id
			) AS c
			ON c.Parent_Material_Type_Id = mt2.Material_Type_Id
	WHERE (mt2.Parent_Material_Type_Id = @iParent_Material_Type_Id OR @iParent_Material_Type_Id IS NULL)
		AND (mt2.Material_Category_Id = @iMaterial_Category_Id OR @iMaterial_Category_Id IS NULL)

	--Append all the parents.
	/*
	WHILE EXISTS (SELECT TOP 1 1 FROM dbo.#MaterialTypeList WHERE Is_Processed = 0)
	BEGIN
	UPDATE CL
	SET CL.Abbreviation = PL.Abbreviation + '\' + CL.Abbreviation,
		CL.Is_Processed = 1
	FROM dbo.#MaterialTypeList AS CL
		INNER JOIN dbo.#MaterialTypeList AS PL
			ON CL.Parent_Material_Type_Id = PL.Material_Type_Id
			AND PL.Is_Processed = 1
	WHERE CL.Is_Processed = 0
	END
	*/
				
	SELECT * FROM dbo.#MaterialTypeList
	WHERE Children = 0
	
	DROP TABLE dbo.#MaterialType
	DROP TABLE dbo.#WasteType

    COMMIT TRANSACTION 
END 
GO 
GRANT EXECUTE ON dbo.GetBhpMaterialTypeList TO BhpbioGenericManager
GO
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpMaterialTypeList">
 <Procedure>
	Returns a list of material types.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioRecalcLogicHistoryTransactionLevel0.prc'
GO

If object_id('dbo.GetBhpbioRecalcLogicHistoryTransactionLevel0') Is Not Null 
     Drop Procedure dbo.GetBhpbioRecalcLogicHistoryTransactionLevel0 
Go 
  
Create Procedure dbo.GetBhpbioRecalcLogicHistoryTransactionLevel0 
( 
	@iFrom_Date Datetime ,		
	@iFrom_Shift Char(1),			
	@iTo_Date Datetime,				
	@iTo_Shift Char(1),				
	@iSource Varchar(31) = Null,			
	@iDestination Varchar(31) = Null,		
	@iTransaction_Type Varchar(31) = Null,
	@iInclude_Grades Bit = 0,
	@iSource_Type VARCHAR(31) = Null
) 
With Encryption As 
Begin 
    Set NoCount On 
  
    Set Transaction Isolation Level Repeatable Read 
    Begin Transaction 
  
		-- Create a temporary table to hold the main listing information
		Create Table dbo.#TRANSACTION_LIST
		(
			Transaction_List_Id Int Identity(1, 1) Not Null,
			Date Datetime Null,
			Shift Char(1) Collate Database_Default Null,
			Original_Source Varchar(31) Collate Database_Default Null,
			Original_Destination Varchar(31) Collate Database_Default Null,
			Transaction_Type Varchar(31) Collate Database_Default Null,
			Record_Id BigInt Null,
			Recalc_History_Id BigInt Null,
			Recalc_Logic_History_Id BigInt Null,
			Min_Data_Transaction_Tonnes_Id BigInt Null,
			Equipment Varchar(31) Collate Database_Default Null,
			Action Varchar(128) Collate Database_Default Not Null,
			Orig_Tonnes Float Null,
			New_Tonnes Float Null,
			Tonnes_Perc_Diff Real Null,
			Tonnes_Abs_Diff Float Null
			
			--Primary Key (Transaction_List_Id)
		)

		Create NonClustered Index IX_TRANSACTION_LIST_01
			On dbo.#TRANSACTION_LIST (Record_Id)

		-- Create the related grade temporary tables
		Create Table dbo.#TRANSACTION_LIST_GRADE
		(
			Transaction_List_Id Int Not Null,
			Grade_Id Int Not Null,
			Grade_Name Varchar(31) Collate Database_Default Not Null,
			Grade_Value Real Null
	
			Primary Key(Transaction_List_Id, Grade_Name)
		)  
		
		Create Table dbo.#VALID_SOURCES
		(
			Source_Id VARCHAR(31) Collate Database_Default not Null
			primary key (source_id)
		)  


		Declare @From_Shift_Order Int,
			@To_Shift_Order Int

		Select @From_Shift_Order = dbo.GetShiftTypeOrderNo(@iFrom_Shift),
			@To_Shift_Order = dbo.GetShiftTypeOrderNo(@iTo_Shift)

		-- If the option is to include haulage data
		If (IsNull(@iTransaction_Type, 'Haulage') = 'Haulage')
		Begin
			-- Insert the details for haulage records into the temporary table
			Insert Into dbo.#TRANSACTION_LIST
			(
				Date, Shift, Original_Source, Original_Destination,
				Transaction_Type, Record_Id, Min_Data_Transaction_Tonnes_Id,
				Equipment, Action, Orig_Tonnes, New_Tonnes
			)
			Select H.Haulage_Date, H.Haulage_Shift,
				Coalesce(H.Source_Digblock_Id, SS.Stockpile_Name, H.Source_Mill_Id),
				Coalesce(DS.Stockpile_Name, H.Destination_Crusher_Id, H.Destination_Mill_Id),
				'Haulage', H.Haulage_Id, RHLDTT.Min_Data_Transaction_Tonnes_Id,
				H.Truck_Id, 'Summary', H.Tonnes, 0
			From dbo.Haulage As H
				Inner Join dbo.ShiftType As ST
					On (H.Haulage_Shift = ST.Shift)
				Inner Join 
					(
						--Get the minimum DTT Id and ensure that this haulage record has 
						--a logic history record attached to it.
						Select H.Haulage_Id, Min(DTT.Data_Transaction_Tonnes_Id) As Min_Data_Transaction_Tonnes_Id
						From dbo.Haulage As H
							Left Outer Join dbo.DataTransactionTonnes As DTT
								On (DTT.Haulage_Id = H.Haulage_Id)
						Where H.Haulage_Date Between @iFrom_Date And @iTo_Date --Cut down on grouping
							And Exists 
								( 
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH
									Where RLH.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id
									Union
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH 
									Where RLH.Haulage_Id = H.Haulage_Id
								)
						Group by H.Haulage_Id
					) As RHLDTT
					On (H.Haulage_Id = RHLDTT.Haulage_Id)
				Left Outer Join dbo.Stockpile As SS
					On (H.Source_Stockpile_Id = SS.Stockpile_Id)
				Left Outer Join dbo.Stockpile As DS
					On (H.Destination_Stockpile_Id = DS.Stockpile_Id)
			Where H.Haulage_Date Between @iFrom_Date And @iTo_Date --Index Optimisation
				And dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) >= dbo.GetDateShiftAsInt(@iFrom_Date, @From_Shift_Order)
				And dbo.GetDateShiftAsInt(H.Haulage_Date, ST.Order_No) <= dbo.GetDateShiftAsInt(@iTo_Date, @To_Shift_Order)
				And (@iSource Is Null
					Or Coalesce(H.Source_Digblock_Id, Convert(Varchar, SS.Stockpile_Id), H.Source_Mill_Id) = @iSource)
				And (@iDestination Is Null
					Or Coalesce(Convert(Varchar, DS.Stockpile_Id), H.Destination_Crusher_Id, H.Destination_Mill_Id) = @iDestination)

			-- Set the new value for tonnes, based on the final version from the transaction table
			-- If the record has no DTT record (ie haulage to crusher with no weightometer sample and the Use CV tonnes setting is true)
			-- Then this is valid as being 0.
			Update TL
			Set	New_Tonnes = IsNull(
				(
					Select Sum(DPT2.Tonnes)
					From dbo.DataProcessTransaction As DPT2
						Inner Join DataTransactionTonnes DTT2
							On DPT2.Data_Transaction_Tonnes_Id = DTT2.Data_Transaction_Tonnes_Id
					Where TL.Record_Id = DTT2.Haulage_Id
				), 0)
			From #TRANSACTION_LIST As TL
			Where TL.Transaction_Type = 'Haulage'


			If @iInclude_Grades = 1 
			Begin
				--Get Original Haulage Grade
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 
					'Orig_' + G.Grade_Name, HG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.HaulageGrade As HG
						On (TL.Record_Id = HG.Haulage_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = HG.Grade_Id)
				Where TL.Transaction_Type = 'Haulage'

				--Get the new mass averaged DPT Grade
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'New_' + G.Grade_Name, 
					Sum(DPTG.Grade_Value * DPT.Tonnes) / NullIf(Sum(DPT.Tonnes), 0)
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnes As DTT
						On (TL.Record_Id = DTT.Haulage_Id)
					Inner Join dbo.DataProcessTransaction As DPT
						On (DPT.Data_Transaction_Tonnes_Id = DTT.Data_Transaction_Tonnes_Id)
					Inner Join dbo.DataProcessTransactionGrade As DPTG
						On (DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Transaction_Type = 'Haulage'
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End

		-- If the option is to include weightometer data
		If (IsNull(@iTransaction_Type, 'Weightometer') = 'Weightometer')
		Begin
			-- Insert the details for weightometer sample records into the temporary table
			Insert Into #TRANSACTION_LIST
			(
				Date, Shift, Original_Source, Original_Destination,
				Transaction_Type, Record_Id, Min_Data_Transaction_Tonnes_Id,
				Equipment, Action, Orig_Tonnes, New_Tonnes
			)
			Select WS.Weightometer_Sample_Date, WS.Weightometer_Sample_Shift,
				Coalesce(SS.Stockpile_Name, WFP.Source_Crusher_Id, WFP.Source_Mill_Id),
				Coalesce(DS.Stockpile_Name, WFP.Destination_Crusher_Id, WFP.Destination_Mill_Id),
				'Weightometer', WS.Weightometer_Sample_Id, RHLDTT.Min_Data_Transaction_Tonnes_Id,
				WS.Weightometer_Id, 'Summary', Coalesce(WS.Corrected_Tonnes, WS.Tonnes), 0
			From dbo.WeightometerSample As WS
				Inner Join dbo.ShiftType As ST
					On (WS.Weightometer_Sample_Shift = ST.Shift)
				Inner Join 
					(
						--Get the minimum DTT Id and ensure that this haulage record has 
						--a logic history record attached to it.
						Select WS.Weightometer_Sample_Id, Min(DTTF.Data_Transaction_Tonnes_Id) As Min_Data_Transaction_Tonnes_Id
						From dbo.WeightometerSample As WS
							Left Outer Join dbo.DataTransactionTonnesFlow As DTTF
								On (WS.Weightometer_Sample_Id = DTTF.Weightometer_Sample_Id)
						Where WS.Weightometer_Sample_Date Between @iFrom_Date And @iTo_Date --Cut down on grouping
							And Exists 
								( 
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH
									Where RLH.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id
									Union
									Select Top 1 1 
									From dbo.RecalcLogicHistory AS RLH 
									Where RLH.Weightometer_Sample_Id = WS.Weightometer_Sample_Id
								)
						Group by WS.Weightometer_Sample_Id
					) As RHLDTT
					On (WS.Weightometer_Sample_Id = RHLDTT.Weightometer_Sample_Id)
				Left Outer Join dbo.WeightometerFlowPeriod As WFP
					On (WS.Weightometer_Id = WFP.Weightometer_Id
						And IsNull(WFP.End_Date, '1900-01-01') = IsNull(	
							( --This sub query adds a second, theres gotta be a better way to optimise
								Select Max(WFP2.End_Date)
								From dbo.WeightometerFlowPeriod As WFP2
								Where WFP2.Weightometer_Id = WS.Weightometer_Id
									And WFP2.End_Date >= WS.Weightometer_Sample_Date
							), '1900-01-01')
						)
				Left Outer Join dbo.Stockpile As SS
					On (Coalesce(WS.Source_Stockpile_Id, WFP.Source_Stockpile_Id) = SS.Stockpile_Id)
				Left Outer Join dbo.Stockpile As DS
					On (Coalesce(WS.Destination_Stockpile_Id, WFP.Destination_Stockpile_Id) = DS.Stockpile_Id)
			Where WS.Weightometer_Sample_Date Between @iFrom_Date And @iTo_Date --Index Optimisation
				And dbo.GetDateShiftAsInt(WS.Weightometer_Sample_Date, ST.Order_No) >= dbo.GetDateShiftAsInt(@iFrom_Date, @From_Shift_Order)
				And dbo.GetDateShiftAsInt(Ws.Weightometer_Sample_Date, ST.Order_No) <= dbo.GetDateShiftAsInt(@iTo_Date, @To_Shift_Order)
				And (@iSource Is Null
					Or Coalesce(Convert(Varchar, SS.Stockpile_Id), WFP.Source_Crusher_Id, WFP.Source_Mill_Id) = @iSource)
				And (@iDestination Is Null
					Or Coalesce(Convert(Varchar, DS.Stockpile_Id), WFP.Destination_Crusher_Id, WFP.Destination_Mill_Id) = @iDestination)

			-- Set the new value for tonnes, based on the final version from the transaction table
			Update TL
			Set	New_Tonnes = AGG.Tonnes
			From dbo.#TRANSACTION_LIST As TL
				Inner Join
					(
						Select TL.Transaction_List_Id, Sum(DPT.Tonnes) As Tonnes
						From dbo.DataProcessTransaction As DPT
							Inner Join dbo.DataTransactionTonnesFlow As DTTF
								On (DPT.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id)
							Inner Join dbo.#TRANSACTION_LIST As TL
								On (TL.Record_Id = DTTF.Weightometer_Sample_Id)	
						Group By TL.Transaction_List_Id
					) As AGG
					On (TL.Transaction_List_Id = AGG.Transaction_List_Id)
			Where TL.Transaction_Type = 'Weightometer'

			-- Insert the related grade records into the grade tables
			If @iInclude_Grades = 1 
			Begin
				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id, Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'Orig_' + G.Grade_Name, WSG.Grade_Value
				From dbo.#TRANSACTION_LIST As TL
					Inner Join dbo.WeightometerSampleGrade As WSG
						On (TL.Record_Id = WSG.Weightometer_Sample_Id)
					Inner Join dbo.Grade As G
						On (G.Grade_Id = WSG.Grade_Id)
				Where TL.Transaction_Type = 'Weightometer'

				Insert Into #TRANSACTION_LIST_GRADE
				(
					Transaction_List_Id,
					Grade_Id, Grade_Name, Grade_Value
				)
				Select TL.Transaction_List_Id, G.Grade_Id, 'New_' + G.Grade_Name, 
					Sum(DPTG.Grade_Value * DPT.Tonnes) / NullIf(Sum(DPT.Tonnes), 0)
				From #TRANSACTION_LIST As TL
					Inner Join dbo.DataTransactionTonnesFlow DTTF
						On TL.Record_Id = DTTF.Weightometer_Sample_Id
					Inner Join dbo.DataProcessTransaction As DPT
						On DPT.Data_Transaction_Tonnes_Id = DTTF.Data_Transaction_Tonnes_Id
					Inner Join dbo.DataProcessTransactionGrade DPTG
						On DPT.Data_Process_Transaction_Id = DPTG.Data_Process_Transaction_Id
					Inner Join dbo.Grade As G
						On (G.Grade_Id = DPTG.Grade_Id)
				Where TL.Transaction_Type = 'Weightometer'
				Group By TL.Transaction_List_Id, G.Grade_Id, G.Grade_Name
			End
		End
			
		-------------------------------------------------------------------------
		-- Update the difference details	
		-------------------------------------------------------------------------
		Update TL
		Set	Tonnes_Perc_Diff = Round((New_Tonnes - Orig_Tonnes) / Orig_Tonnes, 8)
		From dbo.#TRANSACTION_LIST As TL
		Where Orig_Tonnes > 0
			And New_Tonnes > 0

		Update TL
		Set	Tonnes_Abs_Diff = Round(New_Tonnes - Orig_Tonnes, 2)
		From dbo.#TRANSACTION_LIST As TL

		If @iInclude_Grades = 1
		Begin
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Perc_Diff',
				Case When (TLOG.Grade_Value > 0 And TLNG.Grade_Value > 0) Then
					Round((TLNG.Grade_Value - TLOG.Grade_Value) / TLOG.Grade_Value, 8)
				Else
					Null
				End
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0

			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id,
				Grade_Id, Grade_Name, Grade_Value
			)
			Select TLOG.Transaction_List_Id,
				TLOG.Grade_Id, G.Grade_Name + '_Abs_Diff',
				TLNG.Grade_Value - TLOG.Grade_Value
			From dbo.#TRANSACTION_LIST_GRADE As TLOG
				Inner Join dbo.#TRANSACTION_LIST_GRADE As TLNG
					On (TLOG.Transaction_List_Id = TLNG.Transaction_List_Id
						And TLOG.Grade_Id = TLNG.Grade_Id)
				Inner Join dbo.Grade As G
					On (TLOG.Grade_Id = G.Grade_Id)
			Where CharIndex('Orig_', TLOG.Grade_Name) > 0
				And CharIndex('New_', TLNG.Grade_Name) > 0
			
			--Add Missing Grades to the mix to ensure maximum pivot and then pivot
			Insert Into dbo.#TRANSACTION_LIST_GRADE
			(
				Transaction_List_Id, Grade_Id, Grade_Name
			)
			Select -1, G.Grade_Id, 'Orig_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, 'New_' + G.Grade_Name
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Abs_Diff' 
			From dbo.Grade As G
			Union All
			Select -1, G.Grade_Id, G.Grade_Name + '_Perc_Diff'
			From dbo.Grade As G

			-- Pivot the grade fields as required
			Exec dbo.PivotTable
				@iTargetTable = '#TRANSACTION_LIST',
				@iPivotTable = '#TRANSACTION_LIST_GRADE',
				@iJoinColumns = '#TRANSACTION_LIST.Transaction_List_Id = #TRANSACTION_LIST_GRADE.Transaction_List_Id',
				@iPivotColumn = 'Grade_Name',
				@iPivotValue = 'Grade_Value',
				@iPivotType = 'Real'
		End
		
		If ISNULL(@iSource_Type, '2') = '2'
		begin
			insert into #VALID_SOURCES
			Select stockpile_name from dbo.stockpile
		end

		If ISNULL(@iSource_Type, '3') = '3'
		begin
			insert into #VALID_SOURCES
			Select crusher_id from dbo.crusher
		end

		If ISNULL(@iSource_Type, '1') = '1'
		begin
			insert into #VALID_SOURCES
			Select digblock_id from dbo.digblock
		end
		
		Select TL.*
		From  dbo.#TRANSACTION_LIST As TL
			Left Outer Join dbo.ShiftType As ST
				On (ST.Shift = TL.Shift)
		Where Tl.Original_Source in (Select Source_Id From dbo.#VALID_SOURCES)
		Order By Date, ST.Order_No, Min_Data_Transaction_Tonnes_Id, 
			Transaction_Type, Record_Id
			
		Drop Table dbo.#VALID_SOURCES
		Drop Table dbo.#TRANSACTION_LIST
		Drop Table dbo.#TRANSACTION_LIST_GRADE  
	
    Commit Transaction 
End 
Go 
GRANT EXECUTE ON dbo.GetBhpbioRecalcLogicHistoryTransactionLevel0 TO BhpbioGenericManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioRecalcLogicHistoryTransactionLevel0">
 <Procedure>
	Returns the base level recalc logic records and the necessary before and after comparison details.
	Transaction type is exclusively, 'Weightometer' or 'Haulage'.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReconciliationMovements.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReconciliationMovements') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReconciliationMovements
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReconciliationMovements
(
	@iLocationId AS INT = NULL
)
AS
BEGIN

	DECLARE @LocationTypeId TINYINT
	
	SELECT @LocationTypeId = Location_Type_Id
	FROM LocationType
	WHERE Description = 'Block'

	SELECT DL.Digblock_Id,
		BIRM.MinedPercentage * Sum(CASE WHEN BM.Name = 'Grade Control' THEN MBP.Tonnes ELSE NULL END) AS Depleted_Blast_Block,
		BIRM.MinedPercentage * Sum(CASE WHEN BM.Name = 'Geology' THEN MBP.Tonnes ELSE NULL END) AS Depleted_Resource,
		BIRM.MinedPercentage * Sum(CASE WHEN BM.Name = 'Mining' THEN MBP.Tonnes ELSE NULL END) AS Depleted_Reserve
	FROM dbo.BhpbioImportReconciliationMovement AS BIRM
		INNER JOIN dbo.GetLocationSubtreeByLocationType(@iLocationId, @LocationTypeId, @LocationTypeId) GLS
			ON GLS.LocationId = BIRM.BlockLocationId
		INNER JOIN dbo.DigblockLocation AS DL
			ON BIRM.BlockLocationId = DL.Location_Id
		INNER JOIN dbo.DigblockModelBlock AS DMB
			ON DMB.Digblock_Id = DL.Digblock_Id
		INNER JOIN dbo.ModelBlock AS MB
			ON DMB.Model_Block_Id = MB.Model_Block_Id
		INNER JOIN dbo.ModelBlockPartial AS MBP
			ON MBP.Model_Block_Id = MB.Model_Block_Id
		INNER JOIN dbo.BlockModel AS BM
			ON MB.Block_Model_Id = BM.Block_Model_Id
	GROUP BY DL.Digblock_Id, BIRM.MinedPercentage
			
END

GO 

GRANT EXECUTE ON dbo.GetBhpbioReconciliationMovements TO CoreDigblockManager

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioBlastByBlastReconciliation.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioBlastByBlastReconciliation') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioBlastByBlastReconciliation
GO 
  
CREATE PROCEDURE dbo.GetBhpbioBlastByBlastReconciliation
(
	@iBlastLocationId INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @HubLocationId INT
	DECLARE @HubLocationTypeId SMALLINT

	DECLARE @Result TABLE
	(
		Section VARCHAR(10) COLLATE DATABASE_DEFAULT NOT NULL,
		Type VARCHAR(11) COLLATE DATABASE_DEFAULT NOT NULL,
		Designation VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
		ModelName VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
		Tonnes FLOAT NULL,
		Volume FLOAT NULL
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioBlastByBlastReconciliation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- calculate the HUB location information
		-- this is used for the material lookups
		SET @HubLocationTypeId = 
			(
				SELECT Location_Type_Id
				FROM dbo.LocationType
				WHERE Description = 'Hub'
			)
		SET @HubLocationId = dbo.GetLocationTypeLocationId(@iBlastLocationId, @HubLocationTypeId)

		-- return the Material Designation/Model summary
		INSERT INTO @Result
		(
			Section, Type, Designation, ModelName, Tonnes, Volume
		)
		SELECT 'Absolute', 'Designation', materialRollup.Designation, bm.Name,
			ISNULL(SUM(m.Tonnes), 0.0) AS Tonnes,
			ISNULL(SUM(m.Tonnes / m.Density), 0.0) AS Volume
		FROM dbo.BlockModel AS bm
			CROSS JOIN
				(
					-- supply a rollup of the Designation
					-- that is specific to the HUB selected
					-- also, roll up the waste material types
					SELECT oreType.Material_Type_Id, designation.Abbreviation AS Designation
					FROM dbo.MaterialType AS oreType
						INNER JOIN dbo.MaterialTypeLocation AS mtl
							ON (oreType.Material_Type_Id = mtl.Material_Type_Id)
						INNER JOIN dbo.GetLocationSubtree(@HubLocationId) AS ls
							ON (ls.Location_Id = mtl.Location_Id)
						INNER JOIN dbo.MaterialType AS designation
							ON (oreType.Parent_Material_Type_Id = designation.Material_Type_Id)
					WHERE oreType.Material_Category_Id = 'OreType'
						AND designation.Material_Category_Id = 'Designation'
				) AS materialRollup
			LEFT OUTER JOIN
				(
					SELECT mb.Block_Model_Id, mbp.Tonnes, mbp.Material_Type_Id,
						mbpg.Grade_Value AS Density
					FROM dbo.ModelBlock AS mb
						CROSS JOIN dbo.Grade AS g
						INNER JOIN dbo.ModelBlockPartial AS mbp
							ON (mb.Model_Block_Id = mbp.Model_Block_Id)
						INNER JOIN dbo.ModelBlockPartialGrade AS mbpg
							ON (mbp.Model_Block_Id = mbpg.Model_Block_Id
								AND mbp.Sequence_No = mbpg.Sequence_No
								AND g.Grade_Id = mbpg.Grade_Id)
						INNER JOIN dbo.ModelBlockLocation AS mbl
							ON (mbl.Model_Block_Id = mbp.Model_Block_Id)
						INNER JOIN dbo.Location AS l
							ON (mbl.Location_Id = l.Location_Id
								AND l.Parent_Location_Id = @iBlastLocationId)
					WHERE g.Grade_Type_Id = 'Density'
				) AS m
				ON (m.Material_Type_Id = materialRollup.Material_Type_Id
					AND m.Block_Model_Id = bm.Block_Model_Id)
		GROUP BY materialRollup.Designation, bm.Name

		INSERT INTO @Result
		(
			Section, Type, Designation, ModelName, Tonnes, Volume
		)
		SELECT 'Absolute', 'Total', NULL, ModelName, SUM(Tonnes), SUM(Volume)
		FROM @Result
		WHERE Section = 'Absolute'
			AND Type = 'Designation'
		GROUP BY ModelName

		-- calculate the differences
		INSERT INTO @Result
		(
			Section, Type, Designation, ModelName, Tonnes, Volume
		)
		SELECT 'Difference', r1.Type, r1.Designation, r2.ModelName + ' - ' + r1.ModelName,
			r2.Tonnes - r1.Tonnes, r2.Volume - r1.Volume
		FROM @Result AS r1
			INNER JOIN @Result AS r2
				ON (ISNULL(r1.Designation, '') = ISNULL(r2.Designation, '')
					AND r1.Type = r2.Type
					AND r1.Section = r2.Section)
		WHERE r1.Type IN ('Designation', 'Total')
			AND
			(
				(r1.ModelName = 'Geology' AND r2.ModelName = 'Mining')
				OR (r1.ModelName = 'Geology' AND r2.ModelName = 'Grade Control')
				OR (r1.ModelName = 'Mining' AND r2.ModelName = 'Grade Control')
			)	

		-- calculate the recoveries
		INSERT INTO @Result
		(
			Section, Type, Designation, ModelName, Tonnes, Volume
		)
		SELECT 'Recovery', r1.Type, r1.Designation, r2.ModelName + ' - ' + r1.ModelName,
			r2.Tonnes / (CASE WHEN r1.Tonnes = 0.0 THEN NULL ELSE r1.Tonnes END),
			r2.Volume / (CASE WHEN r1.Volume = 0.0 THEN NULL ELSE r1.Volume END)
		FROM @Result AS r1
			INNER JOIN @Result AS r2
				ON (ISNULL(r1.Designation, '') = ISNULL(r2.Designation, '')
					AND r1.Type = r2.Type
					AND r1.Section = r2.Section)
		WHERE r1.Type IN ('Designation', 'Total')
			AND
			(
				(r1.ModelName = 'Geology' AND r2.ModelName = 'Grade Control')
				OR (r1.ModelName = 'Mining' AND r2.ModelName = 'Grade Control')
			)	

		SELECT Section, Type, Designation, ModelName, Tonnes, Volume
		FROM @Result

		-- return the Material Designation/Quality summary
		SELECT mt.Abbreviation AS Designation, bm.Name AS ModelName, g.Grade_Name AS GradeName,
			SUM(mbpg.Grade_Value * mbp.Tonnes) / (CASE WHEN SUM(mbp.Tonnes) = 0.0 THEN NULL ELSE SUM(mbp.Tonnes) END) AS GradeValue
		FROM dbo.GetMaterialsByCategory('Designation') AS mc
			INNER JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = mc.RootMaterialTypeId)
			INNER JOIN dbo.ModelBlockPartial AS mbp
				ON (mbp.Material_Type_Id = mc.MaterialTypeId)
			INNER JOIN dbo.ModelBlockLocation AS mbl
				ON (mbl.Model_Block_Id = mbp.Model_Block_Id)
			INNER JOIN dbo.Location AS l
				ON (mbl.Location_Id = l.Location_Id
					AND l.Parent_Location_Id = @iBlastLocationId)
			INNER JOIN dbo.ModelBlockPartialGrade AS mbpg
				ON (mbp.Model_Block_Id = mbpg.Model_Block_Id
					AND mbp.Sequence_No = mbpg.Sequence_No)
			INNER JOIN dbo.Grade AS g
				ON (mbpg.Grade_Id = g.Grade_Id)
			INNER JOIN dbo.ModelBlock AS mb
				ON (mb.Model_Block_Id = mbp.Model_Block_Id)
			INNER JOIN dbo.BlockModel AS bm
				ON (mb.Block_Model_Id = bm.Block_Model_Id)
		GROUP BY mt.Abbreviation, bm.Name, g.Grade_Name

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and all's well
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetBhpbioBlastByBlastReconciliation TO BhpbioGenericManager
GO

/* testing

EXEC dbo.GetBhpbioBlastByBlastReconciliation
	@iBlastLocationId = 122782

select * from dbo.location where location_id = 122782
select * from dbo.location where location_id = 114032
select * from dbo.location where location_id = 113941
select * from dbo.location where location_id = 5

-- find blasts by their model count
SELECT blast.Location_Id, COUNT(DISTINCT mb.Block_Model_Id)
FROM dbo.ModelBlock AS mb
	INNER JOIN dbo.ModelBlockPartial AS mbp
		ON (mb.Model_Block_Id = mbp.Model_Block_Id)
	INNER JOIN dbo.ModelBlockLocation AS mbl
		ON (mb.Model_Block_Id = mbl.Model_Block_Id)
	INNER JOIN dbo.Location AS block
		ON (mbl.Location_Id = block.Location_Id)
	INNER JOIN dbo.Location AS blast
		ON (block.Parent_Location_Id = blast.Location_Id)
GROUP BY blast.Location_Id
ORDER BY 2 ASC

-- find blasts by their designation count
SELECT blast.Location_Id, COUNT(DISTINCT designation.Material_Type_Id)
FROM dbo.ModelBlock AS mb
	INNER JOIN dbo.ModelBlockPartial AS mbp
		ON (mb.Model_Block_Id = mbp.Model_Block_Id)
	INNER JOIN dbo.ModelBlockLocation AS mbl
		ON (mb.Model_Block_Id = mbl.Model_Block_Id)
	INNER JOIN dbo.Location AS block
		ON (mbl.Location_Id = block.Location_Id)
	INNER JOIN dbo.Location AS blast
		ON (block.Parent_Location_Id = blast.Location_Id)
	INNER JOIN dbo.MaterialType AS oreType
		ON (mbp.Material_Type_Id = oreType.Material_Type_Id)
	INNER JOIN dbo.MaterialType AS designation
		ON (oreType.Parent_Material_Type_Id = designation.Material_Type_Id)
GROUP BY blast.Location_Id
ORDER BY 2 ASC



SELECT * FROM dbo.Digblock WHERE Digblock_Id Like '%CE-0638-0537%'
SELECT * FROM dbo.Location WHERE Name = 'CE' and location_type_id = 4
SELECT * FROM dbo.Location WHERE Name = '0638' and location_type_id = 5 and parent_location_id = 113952
SELECT * FROM dbo.Location WHERE Name = '0537' and location_type_id = 6 and parent_location_id = 114361

*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioShippingTransaction.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioShippingTransaction') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioShippingTransaction  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioShippingTransaction 
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iLocationId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioShippingTransaction',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- create a temporary table with the shipping transaction information
		SELECT stn.BhpbioShippingTransactionNominationId, stn.NominationKey, stn.Nomination, stn.OfficialFinishTime,
			stn.LastAuthorisedDate, stn.CustomerNo, stn.CustomerName, stn.HubLocationId, stn.ProductCode,
			stn.Tonnes, st.VesselName, L.Name AS HubLocationName
		INTO dbo.#ShippingTransaction
		FROM dbo.BhpbioShippingTransaction AS st
			INNER JOIN dbo.BhpbioShippingTransactionNomination AS stn
				ON (st.NominationKey = stn.NominationKey)
			INNER JOIN dbo.Location AS l
				ON (stn.HubLocationId = l.Location_Id)
		WHERE stn.OfficialFinishTime >= ISNULL(@iDateFrom, stn.OfficialFinishTime)
			AND stn.OfficialFinishTime <= ISNULL(DateAdd(millisecond, -1, dateadd(day, 1, @iDateTo)), stn.OfficialFinishTime)
			AND stn.HubLocationId IN
				(
					SELECT rl.LocationId
					FROM dbo.GetBhpbioReportLocation(@iLocationId) AS rl
				)

		-- create a temporary table with the shipping transaction grades
		SELECT t.BhpbioShippingTransactionNominationId, stng.GradeId, stng.GradeValue
		INTO dbo.#ShippingTransactionGrade
		FROM dbo.BhpbioShippingTransactionNominationGrade AS stng
			INNER JOIN dbo.#ShippingTransaction AS t
				ON (stng.BhpbioShippingTransactionNominationId = t.BhpbioShippingTransactionNominationId)

		-- Output shipping information
		SELECT BhpbioShippingTransactionNominationId, NominationKey, Nomination,
			OfficialFinishTime, LastAuthorisedDate, CustomerNo, CustomerName, HubLocationId, ProductCode,
			Tonnes, VesselName, HubLocationName
		FROM dbo.#ShippingTransaction

		SELECT BhpbioShippingTransactionNominationId, GradeId, GradeValue
		FROM dbo.#ShippingTransactionGrade

		SELECT Grade_Id AS GradeId, Grade_Name AS GradeName, Order_No AS OrderNo
		FROM dbo.Grade

		-- Clean up temporary tables
		DROP TABLE dbo.#ShippingTransaction
		DROP TABLE dbo.#ShippingTransactionGrade
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioShippingTransaction TO BhpbioGenericManager
GO
					
/*
testing

EXEC dbo.GetBhpbioShippingTransaction
	@iDateFrom = NULL,
	@iDateTo = NULL,
	@iLocationId = NULL
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioPortBalance.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioPortBalance') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioPortBalance
GO 
  
CREATE PROCEDURE dbo.GetBhpbioPortBalance
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iLocationId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioPortBalance',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- output port balancing information
		SELECT bpb.BhpbioPortBalanceId, bpb.HubLocationId, bpb.BalanceDate, bpb.Tonnes,
			l.Name AS HubLocationName
		FROM dbo.BhpbioPortBalance AS bpb
			INNER JOIN dbo.Location AS l
				ON (bpb.HubLocationId = l.Location_Id)
		WHERE bpb.BalanceDate >= ISNULL(@iDateFrom, bpb.BalanceDate)
			AND bpb.BalanceDate <= ISNULL(@iDateTo, bpb.BalanceDate)
			AND bpb.HubLocationId IN
				(
					SELECT rl.LocationId
					FROM dbo.GetBhpbioReportLocation(@iLocationId) AS rl
				)
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetBhpbioPortBalance TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioPortBlending.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioPortBlending') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioPortBlending  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioPortBlending 
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iLocationId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioPortBlending',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- create a temporary table with the port blending information
		SELECT bpb.BhpbioPortBlendingId, bpb.RakeHubLocationId, bpb.MoveHubLocationId, bpb.DestinationHubLocationId,
			bpb.StartDate, bpb.EndDate, bpb.LoadSiteLocationId, bpb.Tonnes,
			l1.Name AS MoveHubLocationName, l2.Name AS DestinationHubLocationName, l3.Name As RakeHubLocationName, l4.Name As LoadSiteLocationName
		INTO dbo.#PortBlending
		FROM dbo.BhpbioPortBlending AS bpb
			INNER JOIN dbo.Location AS l1
				ON (bpb.MoveHubLocationId = l1.Location_Id)
			INNER JOIN dbo.Location AS l2
				ON (bpb.DestinationHubLocationId = l2.Location_Id)
			INNER JOIN dbo.Location AS l3
				ON (bpb.RakeHubLocationId = l3.Location_Id)
			INNER JOIN dbo.Location AS l4
				ON (bpb.LoadSiteLocationId = l4.Location_Id)
		WHERE bpb.EndDate >= ISNULL(@iDateFrom, bpb.EndDate)
			AND bpb.StartDate <= ISNULL(@iDateTo, bpb.StartDate)
			AND EXISTS
				(
					SELECT 1
					FROM dbo.GetBhpbioReportLocation(@iLocationId) AS rl
					WHERE rl.LocationId = bpb.DestinationHubLocationId
				)

		-- create a temporary table with the port blending grades
		SELECT pbg.BhpbioPortBlendingId, pbg.GradeId, pbg.GradeValue
		INTO dbo.#PortBlendingGrade
		FROM dbo.BhpbioPortBlendingGrade AS pbg
			INNER JOIN dbo.#PortBlending AS pb
				ON (pbg.BhpbioPortBlendingId = pb.BhpbioPortBlendingId)

		-- output port blending information
		SELECT BhpbioPortBlendingId, RakeHubLocationId, MoveHubLocationId, DestinationHubLocationId,
			StartDate, EndDate, LoadSiteLocationId, Tonnes, MoveHubLocationName, 
			DestinationHubLocationName, RakeHubLocationName, LoadSiteLocationName
		FROM dbo.#PortBlending

		SELECT BhpbioPortBlendingId, GradeId, GradeValue
		FROM dbo.#PortBlendingGrade

		SELECT Grade_Id AS GradeId, Grade_Name AS GradeName, Order_No AS OrderNo
		FROM dbo.Grade

		-- Clean up temporary tables
		DROP TABLE dbo.#PortBlendingGrade
		DROP TABLE dbo.#PortBlending
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioPortBlending TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioApprovalOtherMaterial.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioApprovalOtherMaterial') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioApprovalOtherMaterial  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioApprovalOtherMaterial 
(
	@iMonthFilter DATETIME,
	@iLocationId INT
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ActualId INT
	SET @ActualId = 88
	DECLARE @ActualName VARCHAR(40)
	SET @ActualName = 'Actual'

	DECLARE @BlockModelXml VARCHAR(500)
	SET @BlockModelXml = ''
	
	DECLARE @MaterialCategoryId VARCHAR(31)
	SET @MaterialCategoryId = 'Designation'
	
	DECLARE @DateFrom DATETIME
	DECLARE @DateTo DATETIME
	SET @DateFrom = dbo.GetDateMonth(@iMonthFilter)
	SET @DateTo = DateAdd(Day, -1, DateAdd(Month, 1, @DateFrom))
		

	DECLARE @Tonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(65) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioApprovalOtherMaterial',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- Create Pivot Tables
		CREATE TABLE dbo.#Record
		(
			TagId VARCHAR(65) COLLATE DATABASE_DEFAULT NULL,
			MaterialTypeId INT NULL,
			MaterialName VARCHAR(65) COLLATE DATABASE_DEFAULT NOT NULL,
			OrderNo INT NOT NULL,
			ParentMaterialTypeId INT NULL,
			Approved BIT NULL,
			SignOff VARCHAR(65) COLLATE DATABASE_DEFAULT NULL,
			PRIMARY KEY (MaterialName)
		)

		CREATE TABLE dbo.#RecordTonnes
		(
			MaterialTypeId INT NULL,
			MaterialName VARCHAR(65) COLLATE DATABASE_DEFAULT NULL,
			ModelName VARCHAR(500) COLLATE DATABASE_DEFAULT NULL,
			Tonnes FLOAT NULL,
			OrderNo INT NULL,
			RootNode INT NULL
		)
		
		-- Updated the locations
		INSERT INTO @Location
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)
		
		-- Obtain the Block Model XML
		SELECT @BlockModelXml = @BlockModelXml + '<BlockModel id="' + CAST(Block_Model_Id AS VARCHAR) + '"/>'
		FROM dbo.BlockModel
		SET @BlockModelXml = '<BlockModels>' + @BlockModelXml + '</BlockModels>'
		
		-- load the base data
		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @DateFrom,
			@iDateTo = @DateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = 1,
			@iBlockModels = @BlockModelXml,
			@iIncludeActuals = 1,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = NULL

		-- Initial Stubs required to show up all 
		INSERT INTO dbo.#RecordTonnes
			(ModelName, OrderNo)
		SELECT Name, Block_Model_Id
		FROM dbo.BlockModel
		UNION
		SELECT @ActualName, @ActualId

		-- Put the block model tonnes in.
		INSERT INTO dbo.#RecordTonnes
			(MaterialName, ModelName, Tonnes, OrderNo)
		SELECT Material, Type, Tonnes, Coalesce(T.BlockModelId, @ActualId)
		FROM @Tonnes AS T
		WHERE T.Material NOT IN (SELECT Description FROM dbo.GetBhpbioReportHighGrade()) 
			AND T.Material IS NOT NULL

		/*
		-- Put the actuals in.
		INSERT INTO dbo.#RecordTonnes
			(MaterialName, ModelName, Tonnes, OrderNo)
		SELECT MT.Description, @ActualName, Sum(Tonnes), @ActualId
		FROM DataProcessTransaction AS DPT
			INNER JOIN dbo.Digblock AS D
				ON DPT.Source_Digblock_Id = D.Digblock_Id
			INNER JOIN dbo.GetMaterialsByCategory(@MaterialCategoryId) AS MC
					ON (MC.MaterialTypeId = D.Material_Type_Id)
			INNER JOIN dbo.MaterialType AS MT
				ON MC.RootMaterialTypeId = MT.Material_Type_Id
			INNER JOIN dbo.DigblockLocation AS DL
				ON DPT.Source_Digblock_Id = DL.Digblock_Id
			INNER JOIN @Location AS L
				ON DL.Location_Id = L.LocationId
			LEFT JOIN dbo.StockpileGroupStockpile AS SGS
				ON (SGS.Stockpile_Id = DPT.Destination_Stockpile_Id
					AND SGS.Stockpile_Group_Id = 'Rom')
		WHERE Data_Process_Transaction_Date BETWEEN @DateFrom AND @DateTo
			AND MT.Description NOT IN (SELECT Description FROM dbo.GetBhpbioReportHighGrade()) 
			AND SGS.Stockpile_Group_Id IS NULL
		GROUP BY MT.Material_Type_Id, MT.Description
		*/

		-- Add up the total ore and total waste.
		INSERT INTO dbo.#RecordTonnes
			(MaterialTypeId, MaterialName, ModelName, Tonnes, OrderNo, RootNode)
		SELECT CMT.Parent_Material_Type_Id, 'Total ' + MT.Description, 
			ModelName, Sum(Tonnes), RT.OrderNo, CMT.Parent_Material_Type_Id
		FROM dbo.#RecordTonnes AS RT
			INNER JOIN dbo.MaterialType AS CMT
				ON RT.MaterialName = CMT.Description
					AND CMT.Material_Category_Id = @MaterialCategoryId
			INNER JOIN dbo.MaterialType AS MT
				ON CMT.Parent_Material_Type_Id = MT.Material_Type_Id
		WHERE CMT.Parent_Material_Type_Id IS NOT NULL
		GROUP BY ModelName, CMT.Parent_Material_Type_Id, MT.Description, RT.OrderNo

		-- Insert the required unpivoted rows based on the rows.
		INSERT INTO dbo.#Record
			(TagId, MaterialTypeId, MaterialName, OrderNo, ParentMaterialTypeId)
		SELECT 
			CASE WHEN Parent_Material_Type_Id IS NULL THEN 
				NULL 
			ELSE 
				'OtherMaterial_' + REPLACE(MT.Description, ' ', '_')
			END,
			Coalesce(Material_Type_Id, RT.MaterialTypeId), 
			CASE WHEN Parent_Material_Type_Id IS NULL THEN 
				'Total ' + MT.Description
			ELSE 
				MT.Description
			END,
			CASE WHEN Parent_Material_Type_Id IS NULL THEN 
				((MT.Material_Type_Id * 2) + 1) * 100
			ELSE 
				Coalesce(Parent_Material_Type_Id*2, RootNode*2 + 1) * 100 + Coalesce(Material_Type_Id, 0)
			END,
			Parent_Material_Type_Id
		FROM dbo.MaterialType AS MT
			LEFT JOIN dbo.#RecordTonnes AS RT
				ON MT.Material_Type_Id = RT.MaterialTypeId
		WHERE MT.Material_Category_Id IN ('Designation', 'Classification')
			AND MT.Description NOT IN (SELECT Description FROM dbo.GetBhpbioReportHighGrade()) 
		GROUP BY Material_Type_Id, RT.MaterialName, MT.Description, Material_Type_Id, Parent_Material_Type_Id, RootNode, RT.MaterialTypeId

		-- Add any missing Record rows for each value
		INSERT INTO dbo.#RecordTonnes
			(MaterialName, ModelName, Tonnes, OrderNo)
		SELECT R.MaterialName, NT.ModelName, NT.Tonnes, NT.OrderNo
		FROM dbo.#Record AS R
			LEFT JOIN dbo.#RecordTonnes AS NT
				ON (NT.MaterialName IS NULL)
			LEFT JOIN dbo.#RecordTonnes AS RT
				ON (R.MaterialName = RT.MaterialName
					AND RT.ModelName = NT.ModelName)
		WHERE RT.MaterialName IS NULL
		
		-- Display zeros when a value is not present.
		UPDATE dbo.#RecordTonnes
		SET Tonnes = 0
		WHERE Tonnes IS NULL

		-- Pivot the blockmodel/actual tonnes into the material types
		EXEC dbo.PivotTable
			@iTargetTable = '#Record',
			@iPivotTable = '#RecordTonnes',
			@iJoinColumns = '#Record.MaterialName = #RecordTonnes.MaterialName',
			@iPivotColumn = 'ModelName',
			@iPivotValue = 'Tonnes',
			@iPivotType = 'FLOAT',
			@iPivotOrderColumn = 'OrderNo'
		
		SELECT *
		FROM dbo.#Record
		ORDER BY OrderNo
		
		DROP TABLE dbo.#Record
		DROP TABLE dbo.#RecordTonnes

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioApprovalOtherMaterial TO BhpbioGenericManager
GO

--exec dbo.GetBhpbioApprovalOtherMaterial '1-jun-2008', 1


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioPortBlending.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioPortBlending') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioPortBlending  
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioPortBlending
(
	@iBhpbioPortBlendingId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioPortBlending',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY

		-- remove the nomination
		DELETE
		FROM dbo.BhpbioPortBlending
		WHERE BhpbioPortBlendingId = @iBhpbioPortBlendingId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioPortBlending TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteBhpbioPortBlending">
 <Procedure>
	Deletes port blending records.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UpdateBhpbioPortBlending.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioPortBlending') IS NOT NULL
     DROP PROCEDURE dbo.UpdateBhpbioPortBlending  
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioPortBlending
(
    @iBhpbioPortBlendingId INT,
	@iMoveHubLocationId INT,
    @iTonnes FLOAT
)
AS
BEGIN
	SET NOCOUNT ON 

	BEGIN TRY
		-- update the blending record
		UPDATE dbo.BhpbioPortBlending
		SET	MoveHubLocationId = @iMoveHubLocationId,
			Tonnes = @iTonnes
		WHERE BhpbioPortBlendingId = @iBhpbioPortBlendingId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateBhpbioPortBlending TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateBhpbioPortBlending">
 <Procedure>
	Updates port blending records as required.
 </Procedure>
</TAG>
*/	
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddUpdateDeleteBhpbioPortBlendingGrade.prc'
GO

IF OBJECT_ID('dbo.AddUpdateDeleteBhpbioPortBlendingGrade') IS NOT NULL
	DROP PROCEDURE dbo.AddUpdateDeleteBhpbioPortBlendingGrade
GO

CREATE PROCEDURE dbo.AddUpdateDeleteBhpbioPortBlendingGrade
(
	@iBhpbioPortBlendingId INT,
	@iGradeId SMALLINT,
	@iGradeValue REAL
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.AddUpdateDeleteBhpbioPortBlendingGrade',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF @iGradeValue IS NULL
		BEGIN
			-- Delete the grade
			DELETE
			FROM dbo.BhpbioPortBlendingGrade
			WHERE GradeId = @iGradeId
				AND BhpbioPortBlendingId = @iBhpbioPortBlendingId
		END
		ELSE IF EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioPortBlendingGrade
				WHERE GradeId = @iGradeId
					AND BhpbioPortBlendingId = @iBhpbioPortBlendingId
			)
		BEGIN
			-- Update the grade
			UPDATE dbo.BhpbioPortBlendingGrade
			SET GradeValue = @iGradeValue
			WHERE GradeId = @iGradeId
				AND BhpbioPortBlendingId = @iBhpbioPortBlendingId
		END
		ELSE
		BEGIN
			-- Insert the grade
			INSERT INTO dbo.BhpbioPortBlendingGrade
				(BhpbioPortBlendingId, GradeId, GradeValue)
			VALUES
				(@iBhpbioPortBlendingId, @iGradeId, @iGradeValue)
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddUpdateDeleteBhpbioPortBlendingGrade TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddOrUpdateBhpbioShippingTransactionNominationGrade">
 <Procedure>
	Adds, updates and deletes transaction nomination grades.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddBhpbioPortBlending.prc'
GO

IF OBJECT_ID('dbo.AddBhpbioPortBlending') IS NOT NULL
    DROP PROCEDURE dbo.AddBhpbioPortBlending
GO 
  
CREATE PROCEDURE dbo.AddBhpbioPortBlending
(
	@iRakeHubLocationId INT,
    @iMoveHubLocationId INT,
    @iDestinationHubLocationId INT,
    @iStartDate DATETIME,
    @iEndDate DATETIME,
    @iLoadSiteLocationId VARCHAR(51),
    @iTonnes FLOAT,
    @oBhpbioPortBlendingId INT OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBhpbioPortBlending',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- create/update the nomination record
		INSERT INTO dbo.BhpbioPortBlending
		(
			RakeHubLocationID, MoveHubLocationID, DestinationHubLocationId, StartDate, EndDate, LoadSiteLocationId, Tonnes
		)
		SELECT @iRakeHubLocationId, @iMoveHubLocationId, @iDestinationHubLocationId, @iStartDate, @iEndDate, @iLoadSiteLocationId, @iTonnes

		SET @oBhpbioPortBlendingId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioPortBlending TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddBhpbioPortBlending">
 <Procedure>
	Adds port blending records.
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddBhpbioPortBalance.prc'
GO

IF OBJECT_ID('dbo.AddBhpbioPortBalance') IS NOT NULL
    DROP PROCEDURE dbo.AddBhpbioPortBalance
GO 
  
CREATE PROCEDURE dbo.AddBhpbioPortBalance
(

    @iHubLocationId INT,
    @iBalanceDate DATETIME,
    @iTonnes FLOAT,
    @oBhpbioPortBalanceId INT OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBhpbioPortBalance',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- create/update the nomination record
		INSERT INTO dbo.BhpbioPortBalance
		(
			HubLocationID, BalanceDate, Tonnes
		)
		SELECT @iHubLocationId, @iBalanceDate, @iTonnes

		SET @oBhpbioPortBalanceId = Scope_Identity()

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioPortBalance TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddBhpbioPortBalance">
 <Procedure>
	Adds port hub balance records.
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DeleteBhpbioPortBalance.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioPortBalance') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioPortBalance  
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioPortBalance
(
	@iBhpbioPortBalanceId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioPortBalance',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY

		-- remove the nomination
		DELETE
		FROM dbo.BhpbioPortBalance
		WHERE BhpbioPortBalanceId = @iBhpbioPortBalanceId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioPortBalance TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.DeleteBhpbioPortBalance">
 <Procedure>
	Deletes port Balance records.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.UpdateBhpbioPortBalance.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioPortBalance') IS NOT NULL
     DROP PROCEDURE dbo.UpdateBhpbioPortBalance  
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioPortBalance
(
    @iBhpbioPortBalanceId INT,
    @iTonnes FLOAT
)
AS
BEGIN
	SET NOCOUNT ON 

	BEGIN TRY
		-- update the nomination record
		UPDATE dbo.BhpbioPortBalance
		SET	Tonnes = @iTonnes
		WHERE BhpbioPortBalanceId = @iBhpbioPortBalanceId
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.UpdateBhpbioPortBalance TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.UpdateBhpbioPortBalance">
 <Procedure>
	Updates port Balance records as required.
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioDigblockPolygonWithinRangeAndBench.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioDigblockPolygonWithinRangeAndBench') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioDigblockPolygonWithinRangeAndBench
GO

CREATE PROCEDURE dbo.GetBhpbioDigblockPolygonWithinRangeAndBench
(
	@iDigblock_Id VARCHAR(31),
	@iMinX FLOAT,
	@iMaxX FLOAT,
	@iMinY FLOAT,
	@iMaxY FLOAT,
	@iZ INT
)
WITH ENCRYPTION 
AS
BEGIN
	SET NOCOUNT ON

	-- Get All Digblocks and fall within the range
	-- Return all of the Digblocks records.

	DECLARE @Bench INT
	DECLARE @BenchTypeId TINYINT
	DECLARE @DigblockLocation INT

	SELECT @DigblockLocation = Location_Id
	FROM dbo.DigblockLocation
	WHERE Digblock_Id = @iDigblock_Id

	SELECT @BenchTypeId = Location_Type_Id
	FROM dbo.LocationType
	WHERE Description = 'Bench'

	SET @Bench = dbo.GetLocationTypeLocationId(@DigblockLocation, @BenchTypeId)

	SELECT dp.Digblock_Id, dp.[Order_No], dp.X, dp.Y, dp.Z
	FROM dbo.DigblockPolygon AS dp
		INNER JOIN dbo.DigblockLocation AS dl
			ON (dl.Digblock_Id = dp.Digblock_Id)
	WHERE DP.Digblock_Id IN
		(
			SELECT DISTINCT Digblock_Id
			FROM dbo.DigblockPolygon
			WHERE x BETWEEN @iMinX AND @iMaxX
				AND Y BETWEEN @iMinY AND @iMaxY
				AND Z = @iZ
		)
		AND (@iDigblock_Id IS NULL OR (dp.Digblock_Id <> @iDigblock_Id))
		AND dbo.GetLocationTypeLocationId(dl.Location_Id, @BenchTypeId) = @Bench
END
GO

GRANT EXECUTE ON dbo.GetBhpbioDigblockPolygonWithinRangeAndBench TO CoreDepletionManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDigblockPolygonWithinRange">
 <Procedure>
	Returns the list of polygons assigned to @iDigblock_Id that vall in the range
	Specified by the parameters.
 </Procedure>
</TAG>
*/ 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioStockpileList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioStockpileList') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioStockpileList
GO

CREATE PROCEDURE dbo.GetBhpbioStockpileList
(
	@iGroup_By_Stockpile_Groups BIT = 1,
	@iStockpile_Group_Id VARCHAR(31) = NULL,
	@iStockpile_Name VARCHAR(31) = NULL,
	@iIs_Visible BIT = NULL,
	@iIs_Completed BIT = NULL,
	@iMaterial_Type_Id INT = NULL,
	@iSort_Type INT = NULL, --Between 1-4 Defined (see final result return set for definition)
	@iInclude_Grades BIT = 1, --If used = Performance Loss when many stockpiles and/or many grades exist in client system.
	@iFilterStartDate	DATETIME = NULL,
	@iFilterEndDate DATETIME = NULL,
	@iGrade_Visibility Bit = 1,
	@iTransactionStartDate DATETIME = NULL,
	@iTransactionEndDate DATETIME = NULL,
	@iLocationId INT = NULL,
	@iRecordLimit INT = NULL
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON
	
	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
		
	--Main Result SET
	CREATE TABLE dbo.#StockpileList 
	(
		Stockpile_Id INT NOT NULL, 
		Stockpile_Name VARCHAR(31) COLLATE Database_Default NULL,
		Description VARCHAR(255) COLLATE Database_Default NULL,
		Material_Type_Id INT NULL,
		Is_Completed BIT NOT NULL,
		Approved_Added_Tonnes_This_Month FLOAT NULL,
		Unapproved_Added_Tonnes_This_Month FLOAT NULL, 
		Stockpile_Added_Tonnes_This_Month FLOAT NULL,
		Removed_Tonnes_This_Month FLOAT NULL,
		Current_Tonnes FLOAT NULL, 
		Last_Adjustment_Date DATETIME,
		Last_Adjustment_Description VARCHAR(255) COLLATE Database_Default NULL,

		PRIMARY KEY (Stockpile_Id)
	)

	--For Grade Pivoting
	CREATE TABLE dbo.#StockpileListGrade 
	(
		Stockpile_Id INT NOT NULL, 
		Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Value REAL NULL,

		PRIMARY KEY (Stockpile_Id, Grade_Name)
	)
	
	--Used to enable a single lookup FROM DPT
	CREATE TABLE dbo.#TransactionSummary 
	(
		Stockpile_Id INT NOT NULL,
		Code CHAR(3) COLLATE Database_Default NOT NULL,
		Tonnes FLOAT NULL,

		PRIMARY KEY (Stockpile_Id, Code)
	)

	--Used to enable a single lookup FROM Data Process Stockpile Balance
	CREATE TABLE dbo.#BalanceSummary
	(
		Data_Process_Stockpile_Balance_Id BIGINT NOT NULL,
		Stockpile_Id INT NOT NULL,
		Tonnes FLOAT NOT NULL,

		PRIMARY KEY (Data_Process_Stockpile_Balance_Id, Stockpile_Id)
	)

	DECLARE @MonthStartDate DATETIME
	DECLARE @MonthEndDate DATETIME

	IF @iTransactionStartDate IS NOT NULL
	BEGIN
		SET @MonthStartDate = @iTransactionStartDate
	END
	ELSE
	BEGIN
		--Define the inclusive month boundary
		SET @MonthStartDate = dbo.GetDateMonth(GetDate())
	END
		
	IF @iTransactionEndDate IS NOT NULL
	BEGIN
		SET @MonthEndDate = @iTransactionEndDate
	END
	ELSE
	BEGIN
		--Define the inclusive month boundary
		SET @MonthEndDate = DateAdd(DD, -1, DateAdd(MM, 1, @MonthStartDate))
	END
	
	--Set Sort Type to default of 1 when NULL or out of range sort type is indicated
	IF Coalesce(@iSort_Type, -1) NOT BETWEEN 1 AND 4
	BEGIN 
		SET @iSort_Type = 1
	END
	
	--Ensure stockpile grouping is on when a group filter is in use, The alternative doesn't make sense, 
	IF @iStockpile_Group_Id IS NOT NULL 
	BEGIN
		SET @iGroup_By_Stockpile_Groups = 1
	END	
	
	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT @iRecordLimit
	END
	
	INSERT INTO dbo.#StockpileList
	(
		Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
	)
	SELECT s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id, 
		CASE 
			WHEN Count(csb.Build_Id) = 0 THEN 
				1 
			ELSE 
				0 
			END AS Is_Completed
	FROM dbo.Stockpile AS s	
		LEFT OUTER JOIN dbo.StockpileBuild AS csb
			ON (s.Stockpile_Id = csb.Stockpile_Id
				AND csb.Stockpile_State_Id <> 'CLOSED')
		LEFT OUTER JOIN 
		(
			SELECT sp.Stockpile_Id, IsNull(spl.Location_Id, 0) AS Location_Id
			FROM dbo.Stockpile AS sp
				LEFT OUTER JOIN dbo.StockpileLocation AS spl
					ON (sp.Stockpile_Id = spl.Stockpile_Id)		
		) AS l
			ON (s.Stockpile_Id = l.Stockpile_Id)
	WHERE s.Is_Visible = ISNULL(@iIs_Visible, s.Is_Visible)
		AND (s.Material_Type_Id = IsNull(@iMaterial_Type_Id, s.Material_Type_Id))
		AND (s.Stockpile_Name LIKE IsNull('%' + @iStockpile_Name + '%', s.Stockpile_Name))
		AND (@iStockpile_Group_Id IS NULL
			OR EXISTS 
				(
					SELECT 1
					FROM dbo.StockpileGroupStockpile AS sgs
					WHERE sgs.Stockpile_Id = s.Stockpile_Id
						AND sgs.Stockpile_Group_Id = @iStockpile_Group_Id
				)
			)
		AND ((csb.Start_Date >= IsNull(@iFilterStartDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND ((csb.Start_Date <= IsNull(@iFilterEndDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND 
			(				
				@iLocationId IS NULL
					OR l.Location_Id IN 
					(	
						SELECT Location_Id
						FROM dbo.GetLocationSubtree(@iLocationId)
					)
			)
	GROUP BY s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id
	HAVING (@iIs_Completed = 1 AND Count(csb.Build_Id) = 0)  --SB is the count of stockpile
		OR (@iIs_Completed = 0 AND Count(csb.Build_Id) > 0)  --builds for this stockpile that arent closed
		OR (@iIs_Completed IS NULL)
	
	IF @iRecordLimit IS NOT NULL
	BEGIN
		SET ROWCOUNT 0
	END

	--Summarise DPT Data for the various tonnes balances required		
	INSERT INTO dbo.#TransactionSummary
	(
		Stockpile_Id, Code, Tonnes
	)	
	--Data that IS based ON the Stockpile being the Destination
	SELECT sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END	AS Code,
		Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --JOIN to Dest
			ON (sl.Stockpile_Id = dpt.Destination_Stockpile_Id)
		INNER JOIN dbo.DataTransactionTonnes AS dtt		
			ON (dtt.Data_Transaction_Tonnes_Id = dpt.Data_Transaction_Tonnes_Id)
	WHERE dpt.Data_Process_Transaction_Date Between @MonthStartDate AND @MonthEndDate 
		AND dpt.Stockpile_Adjustment_Id IS NULL
	GROUP BY sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 
				'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END
	UNION ALL
	--Data that IS based ON the Stockpile being the Source
	SELECT sl.Stockpile_Id, 'REM' AS Code, Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --Join to Source
			ON (sl.Stockpile_Id = dpt.Source_Stockpile_Id)
	WHERE dpt.Data_Process_Transaction_Date BETWEEN @MonthStartDate AND @MonthEndDate 
		AND dpt.Stockpile_Adjustment_Id IS NULL	
	GROUP BY sl.Stockpile_Id		

	DELETE SL
	FROM dbo.#StockpileList SL
		LEFT JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id)
	WHERE dpt.Stockpile_Id IS NULL
		AND @iTransactionEndDate IS NOT NULL

	-- Obtain the Approved for the month		
	UPDATE sl
	SET Approved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'APP')

	-- Obtain the Unapproved for the month
	UPDATE sl
	SET Unapproved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'UNA')

	-- Obtain the Stockpile Added Tonnes for the month
	UPDATE sl
	SET Stockpile_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'ADD')

	-- Obtain the Removed Tonnes for the month
	UPDATE sl
	SET Removed_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'REM')	--Get the key Records for Stockpile Balance that will be used for current tonnes and grade pivoting

	--Retrieve the balance records that are used, in order to get the current tonnes
	--and also retrieve grades IF requested to (reason for the key being stored)
	INSERT INTO dbo.#BalanceSummary
	(
		Data_Process_Stockpile_Balance_Id, Stockpile_Id, Tonnes
	)
	SELECT d.Data_Process_Stockpile_Balance_Id, sl.Stockpile_Id, d.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.StockpileBuild AS b
			ON (sl.Stockpile_Id = b.Stockpile_Id)
		INNER JOIN dbo.DataProcessStockpileBalance AS d
			ON (
					b.Stockpile_Id = d.Stockpile_Id
					AND b.Build_Id = d.Build_Id
					AND
					(
						CASE WHEN @iTransactionEndDate IS NOT NULL
							AND @iTransactionEndDate < b.Last_Recalc_Date THEN
							@iTransactionEndDate
						ELSE
							b.Last_Recalc_Date
						END
					) = d.Data_Process_Stockpile_Balance_Date 
					AND
					(
						CASE WHEN @iTransactionEndDate IS NOT NULL
							AND @iTransactionEndDate < b.Last_Recalc_Date THEN
							dbo.GetLastShiftType()
						ELSE
							b.Last_Recalc_Shift 
						END
					) = d.Data_Process_Stockpile_Balance_Shift
				)

	-- Get the Current Tonnes Value by Regrouping the data
	UPDATE sl
	SET Current_Tonnes = dsb.Current_Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN
		(
			SELECT bs.Stockpile_Id,
				Sum(bs.Tonnes) AS Current_Tonnes
			FROM dbo.#BalanceSummary AS bs
			GROUP BY bs.Stockpile_Id
		
		) dsb
		ON dsb.Stockpile_Id = sl.Stockpile_Id
		
	-- Add the last adjustment date AND description
	UPDATE sl
	SET sl.Last_Adjustment_Date = 
		(
			SELECT TOP 1 sa.Adjustment_Date
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
				AND sa.Adjustment_Date < @MonthEndDate
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		),
		sl.Last_Adjustment_Description = 
		(
			SELECT Top 1 sa.Description
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
				AND sa.Adjustment_Date < @MonthEndDate
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		)
	FROM dbo.#StockpileList AS sl
							
	--Only Pivot Grades if Required to
	IF @iInclude_Grades = 1
	BEGIN
	
		--EXTRACT GRADES FROM BALANCE DATA

		--Now Populate the stockpile grades table using the balance details collected
		INSERT INTO dbo.#StockpileListGrade
		(
			Stockpile_Id, Grade_Name, 
			Grade_Value
		)
		SELECT BS.Stockpile_Id, G.Grade_Name, 
			Sum(BS.Tonnes * DPSBG.Grade_Value) / NullIf(Sum(BS.Tonnes), .00) AS Grade_Value
		FROM dbo.#BalanceSummary AS BS
			INNER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
				ON DPSBG.Data_Process_Stockpile_Balance_Id = BS.Data_Process_Stockpile_Balance_Id
			INNER JOIN dbo.Grade AS G
				ON DPSBG.Grade_Id = G.Grade_Id
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		GROUP BY BS.Stockpile_Id, G.Grade_Name

		UNION ALL

		--Dummy Grade Values Ensure All Grade are Pivoted
		SELECT -1 AS Stockpile_Id, G.Grade_Name, Null AS Grade_Value
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

		--Pivot Grades Onto Main table
		EXEC dbo.PivotTable
			@iTargetTable='#StockpileList',
			@iPivotTable='#StockpileListGrade',
			@iJoinColumns='#StockpileList.Stockpile_Id = #StockpileListGrade.Stockpile_Id',
			@iPivotColumn='Grade_Name',
			@iPivotValue='Grade_Value',
			@iPivotType='REAL'			
	END							

	-- Return the dataset with its stockpile groups if they exist (denormalised dataset here with many groups potentially)
	SELECT Coalesce(sg.Stockpile_Group_Id, 'Stockpiles NOT Grouped') AS Stockpile_Group_Id,
		sl.*, --May Include Grades
		mt.Description AS Material_Type_Description,
		mt.Native_Alternative,		
		mt.Abbreviation,		
		mtg.Order_No,		
		mt.Is_Waste			
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.MaterialType AS mt
			ON (mt.Material_Type_Id = sl.Material_Type_Id)
		INNER JOIN dbo.MaterialTypeGroup AS mtg
			ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		LEFT OUTER JOIN dbo.StockpileGroupStockpile AS sgs 
			INNER JOIN dbo.StockpileGroup AS sg
				ON (sgs.Stockpile_Group_Id = sg.Stockpile_Group_Id
					--Stockpile Ggroup Requires refiltering here, otherwise if a specific stockpile group is filtered for ealier
					--AND stockpile belongs to that group and another, the extra groups will also be returned
					AND sg.Stockpile_Group_Id = IsNull(@iStockpile_Group_Id, sg.Stockpile_Group_Id))
			--Only JOIN To stockpile GROUP IF indicated BY filter options
			ON (sgs.Stockpile_Id = CASE
									WHEN @iGroup_By_Stockpile_Groups = 0
										THEN NULL --Do not join to Stockpile group No stockpile Groups/Duplicates will be returned
									ELSE sl.Stockpile_Id --Each stockpile will be listed with each group to which it belongs
								END)
	-- Sort Type Ordering Configuration
	-- 1 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Stockpile_Name
	-- 2 = ORDER BY Coalesce(sg.Order_No, 10000), mt.Native_Alternative, sl.Stockpile_Name
	-- 3 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Description
	-- 4 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Order_No, mt.Is_Waste, mt.Abbreviation, sl.Description
	ORDER BY Coalesce(sg.Order_No, 10000), --sort position 1
		CASE @iSort_Type --sort position 2
			WHEN 1 THEN sl.Stockpile_Name
			WHEN 2 THEN mt.Native_Alternative
			WHEN 3 THEN sl.Description
			WHEN 4 THEN Cast(mtg.Order_No AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 3
			WHEN 2 THEN sl.Stockpile_Name
			WHEN 4 THEN Cast(mt.Is_Waste AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 4
			WHEN 4 THEN mt.Abbreviation
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 5
			WHEN 4 THEN sl.Description
			ELSE '0' --no further sort defined 
		END		
	
	DROP TABLE dbo.#StockpileList
	DROP TABLE dbo.#TransactionSummary
	DROP TABLE dbo.#BalanceSummary
	DROP TABLE dbo.#StockpileListGrade

	COMMIT TRANSACTION	
END
GO
GRANT EXECUTE ON dbo.GetBhpbioStockpileList TO CoreStockpileManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileList">
 <Procedure>
	Returns the list of stockpile details.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioDigblockPolygonList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioDigblockPolygonList') IS NOT NULL 
     DROP PROCEDURE dbo.GetBhpbioDigblockPolygonList 
GO
  
CREATE PROCEDURE dbo.GetBhpbioDigblockPolygonList 
( 
	@iLocationId INT,
	@iMaterialCategoryId VARCHAR(31),
	@iRootMaterialTypeId INT
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
	BEGIN TRY
		-- Returns the Digblock Polygon co-ordinates for a specified Digblock
		SELECT dp.Digblock_Id, dp.Order_No, dp.X, dp.Y, dp.Z
		FROM dbo.DigblockPolygon AS dp	
			INNER JOIN dbo.Digblock AS d
				ON (dp.Digblock_Id = d.Digblock_Id)
			-- collect the location hierarchy
			INNER JOIN dbo.DigblockLocation AS dl
				ON (dl.Digblock_Id = d.Digblock_Id)
			-- filter optionally by the material
			INNER JOIN dbo.GetMaterialsByCategory(@iMaterialCategoryId) AS mc
				ON (mc.MaterialTypeId = d.Material_Type_Id)
			INNER JOIN dbo.MaterialType AS mt
				ON (mc.RootMaterialTypeId = mt.Material_Type_Id)
		WHERE mc.RootMaterialTypeId = ISNULL(@iRootMaterialTypeId, mc.RootMaterialTypeId)
			AND dl.Location_Id IN
				(
					SELECT LocationId
					FROM dbo.GetBhpbioReportLocation(@iLocationId)
				)
		ORDER BY dp.Digblock_Id, dp.Order_No
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioDigblockPolygonList TO BhpbioGenericManager
GO
 

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioHoldingBenches.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioHoldingBenches') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioHoldingBenches
GO 

CREATE PROCEDURE dbo.GetBhpbioHoldingBenches
AS 
BEGIN 
	SET NOCOUNT ON

	BEGIN TRY
		SELECT Site, Coalesce(MQ2PitCode,Pit) AS Pit, Bench
		FROM dbo.BhpbioBlastBlockHolding
		GROUP BY Site,Coalesce(MQ2PitCode,Pit), Bench
		ORDER BY Site, Coalesce(MQ2PitCode,Pit), Bench
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END
GO

GRANT EXECUTE ON dbo.GetBhpbioHoldingBenches TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioHaulageManagementList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioHaulageManagementList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioHaulageManagementList
GO 

CREATE PROCEDURE dbo.GetBhpbioHaulageManagementList
(
	@iFilter_Start_Date Datetime,
	@iFilter_Start_Shift Char(1) = Null,
	@iFilter_End_Date Datetime,
	@iFilter_End_Shift Char(1) = Null,
	@iFilter_Source Varchar(63) = Null,
	@iFilter_Destination Varchar(63) = Null,
	@iFilter_Truck Varchar(31) = Null,
	@iShowHaulageWithApprovedChild Bit = 1,
	@iTop Bit = 0,
	@iRecordLimit Int = Null,
	@iLocation_Id Int = Null,
	@oCountRecords Int = Null Output,
	@oCountSourceStockpile Int = Null Output,
	@oCountSourceDigblock Int = Null Output,
	@oCountSourceMill Int = Null Output,
	@oCountDestinationStockpile Int = Null Output,
	@oCountDestinationCrusher Int = Null Output,
	@oCountDestinationMill Int = Null Output,
	@oSumTonnes Float = Null Output
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioHaulageManagementList',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- Get Start and End shifts are null, default them to the min and max shifts respectivly.
		If @iFilter_Start_Shift Is Null And @iFilter_End_Shift Is Null
		Begin
			SET @iFilter_Start_Shift = dbo.GetFirstShiftType()
			SET @iFilter_End_Shift = dbo.GetLastShiftType()
		End
		
		-- return summary statistics
		Select @oCountRecords = Count(h.Haulage_Id),
			@oCountSourceStockpile = Coalesce(Sum(Case When h.Source_Stockpile_Id Is Null Then 0 Else 1 End),0),
			@oCountSourceDigblock = Coalesce(Sum(Case When h.Source_Digblock_Id Is Null Then 0 Else 1 End),0),
			@oCountSourceMill = Coalesce(Sum(Case When h.Source_Mill_Id Is Null Then 0 Else 1 End),0),
			@oCountDestinationStockpile = Coalesce(Sum(Case When h.Destination_Stockpile_Id Is Null Then 0 Else 1 End),0),
			@oCountDestinationCrusher = Coalesce(Sum(Case When h.Destination_Crusher_Id Is Null Then 0 Else 1 End),0),
			@oCountDestinationMill = Coalesce(Sum(Case When h.Destination_Mill_Id Is Null Then 0 Else 1 End),0),
			@oSumTonnes = Coalesce(Sum(h.Tonnes), 0.0)
		From dbo.Haulage As h
			Left Join dbo.Stockpile As ss
				On (ss.Stockpile_Id = h.Source_Stockpile_Id)
			Left Join Stockpile As DS
				On (ds.Stockpile_Id = h.Destination_Stockpile_Id)
			Left Join dbo.DigblockLocation as dl
				on (h.Source_Digblock_Id = dl.Digblock_Id)
			Left Join dbo.StockpileLocation as sl
				on (h.Source_Stockpile_Id = sl.Stockpile_Id)
			Left Join dbo.MillLocation as ml
				on (h.source_mill_id = ml.mill_id)
			Left Join dbo.CrusherLocation As cl
				On (h.Destination_Crusher_Id = cl.Crusher_Id)
			Left Join dbo.StockpileLocation As dsl
				On (h.Destination_Stockpile_Id = dsl.Stockpile_Id)
			Left Join dbo.MillLocation as dml
				On (h.Destination_Mill_Id = dml.Mill_Id)
		Where (Coalesce(H.Source_Digblock_Id, Cast(H.Source_Stockpile_Id As Varchar), H.Source_Mill_Id) = @iFilter_Source Or @iFilter_Source Is Null)
			And (Coalesce(H.Destination_Crusher_Id, Cast(H.Destination_Stockpile_Id As Varchar), H.Destination_Mill_Id) = @iFilter_Destination Or @iFilter_Destination Is Null)
			And (Truck_Id = @iFilter_Truck Or @iFilter_Truck Is Null)
			And Haulage_State_Id = 'N'
			And (Child_Haulage_Id Is Null And @iShowHaulageWithApprovedChild = 0 Or @iShowHaulageWithApprovedChild = 1)
			And Haulage_Date BETWEEN @iFilter_Start_Date AND @iFilter_End_Date
			And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '>=', @iFilter_Start_Date, @iFilter_Start_Shift) = 1)
			And (dbo.CompareDateShift(Haulage_Date, Haulage_Shift, '<=', @iFilter_End_Date, @iFilter_End_Shift) = 1)
			AND EXISTS
				(
					SELECT top 1 1
					FROM dbo.GetLocationSubtree(@iLocation_Id) AS l2
					WHERE l2.Location_Id = dl.Location_Id
						OR l2.Location_Id = sl.Location_Id
						OR l2.Location_Id = ml.Location_Id
						OR l2.Location_Id = cl.Location_Id
						OR l2.Location_Id = dsl.Location_Id
						OR l2.Location_Id = dml.Location_Id
				)
		
		-- return actual haulage records
		Select H.Haulage_Id, H.Haulage_Date, dbo.GetShiftTypeName(H.Haulage_Shift) AS Haulage_Shift_Str, 
			Coalesce(H.Source_Digblock_Id, SS.Stockpile_Name, H.Source_Mill_Id) AS Source,
			Coalesce(DS.Stockpile_Name, H.Destination_Crusher_Id, H.Destination_Mill_Id) AS Destination,
			h.Truck_Id AS Truck, h.Tonnes,
			Case When H.Haulage_State_Id = 'N' And H.Child_Haulage_Id Is Null Then 1 Else 0 End As Editable,
			hr.Destination AS OriginalDestination
		INTO dbo.#Result
		From dbo.Haulage As h
			INNER JOIN dbo.HaulageRaw AS hr
				ON (h.Haulage_Raw_Id = hr.Haulage_Raw_Id)
			Left Join Stockpile As SS
				On SS.Stockpile_Id = H.Source_Stockpile_Id
			Left Join Stockpile As DS
				On DS.Stockpile_Id = H.Destination_Stockpile_Id
			Left Join dbo.digblocklocation As dl
				On h.source_digblock_id = dl.digblock_id
			Left Join dbo.stockpilelocation As sl
				On h.source_stockpile_id = sl.stockpile_id
			Left Join dbo.milllocation As ml
				On h.source_mill_id = ml.mill_id
			Left Join dbo.crusherlocation As cl
				On h.destination_crusher_id = cl.crusher_id
			Left Join dbo.stockpilelocation As dsl
				On h.destination_stockpile_id = dsl.stockpile_id
			Left Join dbo.milllocation as dml
				on h.destination_mill_id = dml.mill_id
		Where (Coalesce(H.Source_Digblock_Id, Cast(H.Source_Stockpile_Id As Varchar), H.Source_Mill_Id) = @iFilter_Source Or @iFilter_Source Is Null)
			And (Coalesce(H.Destination_Crusher_Id, Cast(H.Destination_Stockpile_Id As Varchar), H.Destination_Mill_Id) = @iFilter_Destination Or @iFilter_Destination Is Null)
			And (h.Truck_Id = @iFilter_Truck Or @iFilter_Truck Is Null)
			And h.Haulage_State_Id = 'N'
			And (h.Child_Haulage_Id Is Null And @iShowHaulageWithApprovedChild = 0 Or @iShowHaulageWithApprovedChild = 1)
			And h.Haulage_Date BETWEEN @iFilter_Start_Date AND @iFilter_End_Date
			And (dbo.CompareDateShift(h.Haulage_Date, h.Haulage_Shift, '>=', @iFilter_Start_Date, @iFilter_Start_Shift) = 1)
			And (dbo.CompareDateShift(h.Haulage_Date, h.Haulage_Shift, '<=', @iFilter_End_Date, @iFilter_End_Shift) = 1)
			AND EXISTS
				(
					SELECT TOP 1 1
					FROM dbo.GetLocationSubtree(@iLocation_Id) AS l2
					WHERE l2.Location_Id = dl.Location_Id
						OR l2.Location_Id = sl.Location_Id
						OR l2.Location_Id = ml.Location_Id
						OR l2.Location_Id = cl.Location_Id
						OR l2.Location_Id = dsl.Location_Id
						OR l2.Location_Id = dml.Location_Id
				)
		Order by H.Haulage_Date Desc, dbo.GetShiftTypeOrderNo(H.Haulage_Shift) Desc, Source, Destination, OriginalDestination

		IF @iRecordLimit IS NULL
		BEGIN
			SELECT *
			FROM dbo.#Result
		END
		ELSE
		BEGIN
			SELECT TOP (@iRecordLimit) *
			FROM dbo.#Result
		END

		DROP TABLE dbo.#Result

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY

	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioHaulageManagementList TO BhpbioGenericManager
GO

/*
DECLARE
	@CountRecords Int,
	@CountSourceStockpile Int,
	@CountSourceDigblock Int,
	@CountSourceMill Int,
	@CountDestinationStockpile Int,
	@CountDestinationCrusher Int,
	@CountDestinationMill Int,
	@SumTonnes Float

EXEC dbo.GetBhpbioHaulageManagementList
	@iFilter_Start_Date = '01-APR-2008',
	@iFilter_Start_Shift = 'D',
	@iFilter_End_Date = '10-DEC-2008',
	@iFilter_End_Shift = 'D',
	@iFilter_Source = NULL,
	@iFilter_Destination = Null,
	@iFilter_Truck = Null,
	@iShowHaulageWithApprovedChild = 1,
	@iTop = 0,
	@iRecordLimit = NULL,
	@iLocation_Id = 1,
	@oCountRecords = @CountRecords OUTPUT,
	@oCountSourceStockpile = @CountSourceStockpile OUTPUT,
	@oCountSourceDigblock = @CountSourceDigblock OUTPUT,
	@oCountSourceMill = @CountSourceMill OUTPUT,
	@oCountDestinationStockpile = @CountDestinationStockpile OUTPUT,
	@oCountDestinationCrusher = @CountDestinationCrusher OUTPUT,
	@oCountDestinationMill = @CountDestinationMill OUTPUT,
	@oSumTonnes = @SumTonnes OUTPUT

SELECT @CountRecords, @CountSourceStockpile, @CountSourceDigblock, @CountSourceMill,
	@CountDestinationStockpile, @CountDestinationCrusher, @CountDestinationMill, @SumTonnes
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.BhpbioDataExceptionStockpileGroupLocationMissing.prc'
GO

 IF OBJECT_ID('dbo.BhpbioDataExceptionStockpileGroupLocationMissing') IS NOT NULL
    DROP PROCEDURE dbo.BhpbioDataExceptionStockpileGroupLocationMissing
GO 
  
CREATE PROCEDURE dbo.BhpbioDataExceptionStockpileGroupLocationMissing
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @ErrorStockpiles TABLE
	(
		StockpileId INT,
		StockpileName VARCHAR(51) COLLATE DATABASE_DEFAULT
	)
	
	DECLARE @StockpilesDesignated TABLE
	(
		StockpileId Int
	)
	
	DECLARE @DataExceptionTypeId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DataExceptionStockpileGroupLocationMissing',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		
		SET @DataExceptionTypeId = (SELECT Data_Exception_Type_Id
									FROM dbo.DataExceptionType DET
									WHERE Name = 'Stockpile Not In Designation Group')
		
		INSERT INTO @StockpilesDesignated
		( StockpileId )
		SELECT S.Stockpile_Id
		FROM dbo.Stockpile S
			INNER JOIN dbo.StockpileGroupStockpile SGS 
				ON SGS.Stockpile_Id = S.Stockpile_Id
			INNER JOIN dbo.BhpbioStockpileGroupDesignation BSGD
				ON SGS.Stockpile_Group_Id = BSGD.StockpileGroupId

		INSERT INTO @StockpilesDesignated
		( StockpileId )
		SELECT S.Stockpile_Id
		FROM dbo.Stockpile S
			INNER JOIN dbo.StockpileGroupStockpile SGS
				ON SGS.Stockpile_Id = S.Stockpile_Id
			LEFT JOIN @StockpilesDesignated SD
				ON SD.StockpileId = S.Stockpile_Id
		WHERE SGS.Stockpile_Group_Id IN ('Post Crusher', 'ROM', 'Crusher Product', 'Port Train Rake', 'HUB Train Rake')
			AND SD.StockpileId IS NULL
		
		INSERT INTO @ErrorStockpiles
		( StockpileId, StockpileName )
		SELECT DPT.Source_Stockpile_Id, S.Stockpile_Name
		FROM dbo.DataProcessTransaction DPT
			INNER JOIN Stockpile S
				On S.Stockpile_Id = DPT.Source_Stockpile_Id
			LEFT JOIN dbo.Mill M
				ON M.Stockpile_Id = DPT.Source_Stockpile_Id
			LEFT JOIN @StockpilesDesignated SD
				ON SD.StockpileId = DPT.Source_Stockpile_Id			
		WHERE DPT.Source_Stockpile_Id IS NOT NULL
			AND M.Stockpile_Id IS NULL
			AND SD.StockpileId IS NULL
		GROUP BY DPT.Source_Stockpile_Id, S.Stockpile_Name
			
		INSERT INTO @ErrorStockpiles
		( StockpileId, StockpileName )
		SELECT DPT.Destination_Stockpile_Id, S.Stockpile_Name
		FROM dbo.DataProcessTransaction DPT
			INNER JOIN Stockpile S
				On S.Stockpile_Id = DPT.Destination_Stockpile_Id
			LEFT JOIN dbo.Mill M
				ON M.Stockpile_Id = DPT.Destination_Stockpile_Id
			LEFT JOIN @StockpilesDesignated SD
				ON SD.StockpileId = DPT.Destination_Stockpile_Id			
			LEFT JOIN @ErrorStockpiles ES
				On ES.StockpileId = DPT.Destination_Stockpile_Id
		WHERE DPT.Source_Stockpile_Id IS NOT NULL
			AND M.Stockpile_Id IS NULL
			AND SD.StockpileId IS NULL
			AND ES.StockpileId IS NULL
		GROUP BY DPT.Destination_Stockpile_Id, S.Stockpile_Name

		UPDATE DE
			SET Data_Exception_Status_Id = 'R'
		FROM DataException DE
			LEFT JOIN @ErrorStockpiles ES
				ON ES.StockpileId = DE.Details_XML.value('(/DocumentElement/Stockpile_Group_Designation/Stockpile_Id)[1]', 'INT')
		WHERE ES.StockpileId IS NULL
			AND DE.Data_Exception_Type_Id = @DataExceptionTypeId

		DELETE ES
		FROM @ErrorStockpiles ES
			INNER JOIN dbo.DataException DE
				ON DE.Data_Exception_Type_Id = @DataExceptionTypeId
					AND DE.Data_Exception_Status_Id IN ('A', 'D')
					AND DE.Details_XML.value('(/DocumentElement/Stockpile_Group_Designation/Stockpile_Id)[1]', 'INT') = ES.StockpileId
		
		INSERT INTO DataException
		( Data_Exception_Type_Id, Data_Exception_Date, Data_Exception_Shift, Data_Exception_Status_Id, Short_Description, Long_Description, Details_XML )
		SELECT @DataExceptionTypeId, GetDate(), dbo.GetFirstShiftType(), 'A', 'Stockpile: ' + ES.StockpileName + ', is not in a group with a relevant designation',
			'Stockpile: ' + ES.StockpileName + ', is not assigned to a group with a relevant designation. Please assign the stockpile to one of the relevant designation groups or the post crusher group.',
			'<DocumentElement><Stockpile_Group_Designation><Stockpile_Id>' + CAST(ES.StockpileId AS VARCHAR) + '</Stockpile_Id><Stockpile_Name>' + ES.StockpileName + '</Stockpile_Name></Stockpile_Group_Designation></DocumentElement>'
		FROM @ErrorStockpiles ES
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.BhpbioDataExceptionStockpileGroupLocationMissing TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.AddBhpbioPortBalance">
 <Procedure>
	Adds port hub balance records.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioUserLocationList.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioUserLocationList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioUserLocationList  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioUserLocationList 
(
	@iUserId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @ReturnValue BIT
	DECLARE @Roles TABLE
	(
		RoleId VARCHAR(31)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioUserLocationList',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY

		-- retreieve all the users roles from the 3 different types.
		INSERT INTO @Roles
			(RoleId)
		SELECT RoleId
		From dbo.SecurityUserRole
		Where UserId = @iUserId

		-- get all locations of this user.
		SELECT @iUserId AS UserId, r.RoleId, srl.LocationId, l.Name, l.Description
		FROM @Roles AS r
			INNER JOIN dbo.BhpbioSecurityRoleLocation AS srl
				ON (r.RoleId = srl.RoleId)
			INNER JOIN dbo.Location As l
				ON (l.Location_Id = srl.LocationId)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioUserLocationList TO BhpbioGenericManager
GO

--exec dbo.GetBhpbioUserLocationList 1


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioLocationRoot.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioLocationRoot') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioLocationRoot  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioLocationRoot
(
	@oLocationId INT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		SELECT @oLocationId = L.Location_Id
		FROM dbo.Location AS L
		WHERE Parent_Location_Id IS NULL
	
		SELECT L.Location_Id, L.Name, L.Description, LT.Location_Type_Id, L.Description
		FROM dbo.Location AS L
			INNER JOIN dbo.LocationType AS LT
				ON (L.Location_Type_Id = LT.Location_Type_Id)
		WHERE Parent_Location_Id IS NULL
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioLocationRoot TO BhpbioGenericManager
GO


/*
DECLARE @Id INT
EXEC dbo.GetBhpbioLocationRoot @Id OUTPUT
SELECT @Id
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.ResolveBhpbioLocationByName.prc'
GO

IF OBJECT_ID('dbo.ResolveBhpbioLocationByName') IS NOT NULL
     DROP PROCEDURE dbo.ResolveBhpbioLocationByName  
GO 
  
CREATE PROCEDURE dbo.ResolveBhpbioLocationByName
(
	@iLocationName VARCHAR(63),
	@oLocationId INT OUTPUT
)
WITH ENCRYPTION
AS 
BEGIN 
	
	DECLARE @StockpileId INT
	DECLARE @DigblockId VARCHAR(31)
	DECLARE @CrusherId VARCHAR(31)
	DECLARE @MillId VARCHAR(31)
	DECLARE @LocationId INT
	
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(40)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'ResolveBhpbioLocationByName',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	

		SELECT @StockpileId = Stockpile_Id
		FROM dbo.Stockpile
		WHERE Stockpile_Name = @iLocationName

		IF @StockpileId IS NULL
		BEGIN
			SELECT @DigblockId = Digblock_Id
			FROM dbo.Digblock
			WHERE Digblock_Id = @iLocationName
		
			IF @DigblockId IS NULL
			BEGIN	
				
				SELECT @CrusherId = Crusher_Id
				FROM dbo.Crusher
				WHERE Crusher_Id = @iLocationName

				IF @CrusherId IS NULL
				BEGIN
					SELECT @MillId = Mill_Id
					FROM dbo.Mill
					WHERE Mill_Id = @iLocationName
				END
			END
		END

		--If we still haven't resolved, then try and resolve through haulage raw.
		IF 
			(
				@MillId IS NULL AND
				@CrusherId IS NULL AND
				@DigblockId IS NULL AND
				@StockpileId IS NULL
			)
		BEGIN
			SELECT @StockpileId = hr.Stockpile_Id,
				@DigblockId = hr.Digblock_Id,
				@CrusherId = hr.Crusher_Id,
				@MillId = hr.Mill_Id
			FROM dbo.HaulageResolveBasic AS hr
			WHERE Code = @iLocationName
		END

		IF @StockpileId IS NOT NULL
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.StockpileLocation
			WHERE Stockpile_Id = @StockpileId
		END

		IF @DigblockId IS NOT NULL
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.DigblockLocation
			WHERE Digblock_Id = @DigblockId
		END

		IF @CrusherId IS NOT NULL
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.DigblockLocation
			WHERE Digblock_Id = @DigblockId
		END

		IF @MillId IS NOT NULL
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.MillLocation
			WHERE Mill_Id = @MillId
		END
		
		SET @oLocationId = @LocationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.ResolveBhpbioLocationByName TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioStockpilelocationconfiguration.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioStockpileLocationConfiguration') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioStockpileLocationConfiguration
GO 
  
CREATE PROCEDURE dbo.GetBhpbioStockpileLocationConfiguration
(
	@iLocationId INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioStockpileLocationConfiguration',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		SELECT LocationId, ImageData, PromoteStockpiles FROM dbo.BhpbioLocationStockpileConfiguration
		WHERE LocationId = @iLocationId
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioStockpileLocationConfiguration TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.AddOrUpdateBhpbioStockpileLocationConfiguration.prc'
GO

 IF OBJECT_ID('dbo.AddOrUpdateBhpbioStockpileLocationConfiguration') IS NOT NULL
     DROP PROCEDURE dbo.AddOrUpdateBhpbioStockpileLocationConfiguration
GO 
  
CREATE PROCEDURE dbo.AddOrUpdateBhpbioStockpileLocationConfiguration
(
	@iImageData VARBINARY(MAX),
	@iUpdateImageData BIT,
	@iLocationId INT,
	@iUpdatePromoteStockpiles BIT,
	@iPromoteStockpiles BIT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddOrUpdateBhpbioStockpileImageLocation',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioLocationStockpileConfiguration
				WHERE LocationId = @iLocationId
			)
		BEGIN
			INSERT INTO dbo.BhpbioLocationStockpileConfiguration
			(LocationId, ImageData, PromoteStockpiles)
			VALUES(@iLocationId, @iImageData, @iPromoteStockpiles)
		END
		ELSE
		BEGIN
			UPDATE dbo.BhpbioLocationStockpileConfiguration
			SET ImageData = CASE WHEN @iUpdateImageData = 1 THEN @iImageData ELSE ImageData END,
			PromoteStockpiles = CASE WHEN @iUpdatePromoteStockpiles = 1 THEN @iPromoteStockpiles ELSE PromoteStockpiles END
			WHERE LocationId = @iLocationId
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddOrUpdateBhpbioStockpileLocationConfiguration TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioBlastBlockHoldingMQ2PitCode.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioBlastBlockHoldingMQ2PitCode') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioBlastBlockHoldingMQ2PitCode
GO

CREATE PROCEDURE dbo.GetBhpbioBlastBlockHoldingMQ2PitCode
(
	@iBlockName VARCHAR(14),
	@iSite VARCHAR(9),
	@iOreBody VARCHAR(2),
	@iPit VARCHAR(10),
	@iBench VARCHAR(4),
	@iPatternNumber VARCHAR(4)
)
WITH ENCRYPTION
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'dbo.GetBhpbioBlastBlockHoldingMQ2PitCode',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SELECT MQ2PitCode
		FROM dbo.BhpbioBlastBlockHolding
		WHERE BlockName = @iBlockName
			AND Site = @iSite
			AND Orebody = @iOrebody
			AND Pit = @iPit
			AND Bench = @iBench
			AND PatternNumber = @iPatternNumber
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioBlastBlockHoldingMQ2PitCode TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.CalcNjvVirtualFlow.prc'
GO

IF OBJECT_ID('dbo.CalcNjvVirtualFlow') IS NOT NULL
	DROP PROCEDURE dbo.CalcNjvVirtualFlow
GO 
  
CREATE PROCEDURE dbo.CalcNjvVirtualFlow
(
	@iCalcDate DATETIME
)
AS 
BEGIN 

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 
	
		SELECT @TransactionName = 'CalcNjvVirtualFlow',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
	
	BEGIN TRY

		DECLARE @WeightometerInflowCount FLOAT
		DECLARE @Inflow FLOAT
		DECLARE @RawInflow FLOAT
		DECLARE @Outflow FLOAT
		DECLARE @Counter INT
		
		DECLARE @WeightometerInflowId AS VARCHAR(31)
		DECLARE @WeightometerOutflowId AS VARCHAR(31)
		
		DECLARE @Cur CURSOR
				
		SET @WeightometerInflowId = 'NJV-COSToOHP'
		SET @WeightometerOutflowId = 'NJV-OHPOutflow'
		
		-- GET WEIGHTOMETER INFLOW
		SELECT @Inflow = SUM(Coalesce(WS.Corrected_Tonnes, WS.Tonnes)), @RawInflow = SUM(WS.Tonnes)
		FROM WeightometerSample WS
		WHERE Weightometer_Id = @WeightometerInflowId
			AND Weightometer_Sample_Date = @iCalcDate
			AND Destination_Stockpile_Id IS NULL

		-- GET WEIGHTOMETER INFLOWVIRTUAL
		SELECT @Outflow = SUM(Coalesce(WS.Corrected_Tonnes, WS.Tonnes))
		FROM WeightometerSample WS
		WHERE Weightometer_Id = @WeightometerOutflowId
			AND Weightometer_Sample_Date = @iCalcDate
			AND Source_Stockpile_Id IS NULL

		IF @RawInflow = @Outflow
		BEGIN
			UPDATE WeightometerSample
				SET Corrected_Tonnes = NULL
			WHERE Weightometer_Id = @WeightometerInflowId
				AND Weightometer_Sample_Date = @iCalcDate
				AND Destination_Stockpile_Id IS NULL
		END
		ELSE IF Coalesce(@Inflow, 0) > 0 And Coalesce(@Outflow, 0) = 0
		BEGIN
			UPDATE WeightometerSample
				SET Corrected_Tonnes = 0
			WHERE Weightometer_Id = @WeightometerInflowId
				AND Weightometer_Sample_Date = @iCalcDate
				AND Destination_Stockpile_Id IS NULL
		END
		ELSE IF Coalesce(@Inflow, 0) = 0 AND Coalesce(@Outflow, 0) > 0
		BEGIN
			IF EXISTS (SELECT *
						FROM WeightometerSample
						WHERE Weightometer_Id = @WeightometerInflowId
							AND Weightometer_Sample_Date = @iCalcDate
							AND Destination_Stockpile_Id IS NULL)
			BEGIN
				IF @RawInflow > 0
				BEGIN
					UPDATE WeightometerSample
					SET Corrected_Tonnes = (Tonnes / @RawInflow) * @Outflow
					WHERE Weightometer_Id = @WeightometerInflowId
						AND Weightometer_Sample_Date = @iCalcDate
						AND Destination_Stockpile_Id IS NULL
				END
				ELSE
				BEGIN
					DECLARE @NoRecords INT
					SELECT @NoRecords = Count(*)
					FROM WeightometerSample
						WHERE Weightometer_Id = @WeightometerInflowId
							AND Weightometer_Sample_Date = @iCalcDate
							AND Destination_Stockpile_Id IS NULL
							
					UPDATE WeightometerSample
					SET Corrected_Tonnes = @Outflow / @NoRecords
					WHERE Weightometer_Id = @WeightometerInflowId
						AND Weightometer_Sample_Date = @iCalcDate
						AND Destination_Stockpile_Id IS NULL
				END
			END
			ELSE
			BEGIN
				EXEC AddWeightometerSample
					@iWeightometer_Id = @WeightometerInflowId,
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iTonnes = @Outflow,
					@iOrder_No = 1,
					@oWeightometer_Sample_Id = Null
			END
		END
		ELSE IF Coalesce(@Inflow, 0) <> Coalesce(@Outflow, 0)
		BEGIN
			UPDATE WeightometerSample
				SET Corrected_Tonnes = (Coalesce(Corrected_Tonnes, Tonnes, 0) / @Inflow) * @Outflow
				WHERE Weightometer_Id = @WeightometerInflowId
					AND Weightometer_Sample_Date = @iCalcDate
					AND Destination_Stockpile_Id IS NULL
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
					
		Exec RecalcL1Raise @iCalcDate
		
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.CalcNjvVirtualFlow TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.CalcNjvVirtualFlow">
 <Procedure>
	Updates the Yandi Production Data for the crushers.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportBaseDataAsTonnes.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportBaseDataAsTonnes') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportBaseDataAsTonnes
GO

CREATE PROCEDURE dbo.GetBhpbioReportBaseDataAsTonnes
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iMaterialCategoryId VARCHAR(31),
	@iRootMaterialTypeId INT
)
AS 
BEGIN
	-- for internal consumption only

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Tonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		CalendarDate DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, MaterialTypeId, Type)
	)
	
	DECLARE @Type TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		PRIMARY KEY CLUSTERED (Type)
	)

	DECLARE @MaterialType TABLE
	(
		RootMaterialTypeId INT NOT NULL,
		RootAbbreviation VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		PRIMARY KEY CLUSTERED (MaterialTypeId, RootMaterialTypeId)
	)

	DECLARE @Date TABLE
	(
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		CalendarDate DATETIME NOT NULL,
		PRIMARY KEY NONCLUSTERED (CalendarDate),
		UNIQUE CLUSTERED (DateFrom, DateTo, CalendarDate)
	)

	DECLARE @Location Table
	(
		LocationId INT NOT NULL,
		PRIMARY KEY CLUSTERED (LocationId)
	)

	DECLARE @Crusher Table
	(
		CrusherId VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		PRIMARY KEY CLUSTERED (CrusherId)
	)

	DECLARE @HighGradeMaterialTypeId INT
	DECLARE @BeneFeedMaterialTypeId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportBaseDataAsTonnes',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- perform checks
		IF dbo.GetDateMonth(@iDateFrom) <> @iDateFrom
		BEGIN
			RAISERROR('The @iDateFrom parameter must be the first day of the month.', 16, 1)
		END

		IF (dbo.GetDateMonth(@iDateTo + 1) - 1) <> @iDateTo
		BEGIN
			RAISERROR('The @iDateTo parameter must be the last day of the month.', 16, 1)
		END

		IF NOT @iMaterialCategoryId IN ('Classification', 'Designation')
		BEGIN
			RAISERROR('The Material Category parameter can only be Classification/Designation.', 16, 1)
		END

		IF @iMaterialCategoryId NOT IN ('Classification', 'Designation')
		BEGIN
			RAISERROR('Only "Classification" and "Designation" are supported as material categories.', 16, 1)
		END

		-- load Block Model
		IF @iIncludeActuals = 1
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			VALUES
				('Actual', NULL)
		END

		IF (@iIncludeBlockModels = 1) AND (@iBlockModels IS NULL)
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			SELECT Name, Block_Model_Id
			FROM dbo.BlockModel
		END
		ELSE IF (@iIncludeBlockModels = 1)
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			SELECT bm.Name, b.BlockModel.value('./@id', 'INT')
			FROM @iBlockModels.nodes('/BlockModels/BlockModel') AS b(BlockModel)
				INNER JOIN dbo.BlockModel AS bm
					ON (bm.Block_Model_Id = b.BlockModel.value('./@id', 'INT'))
		END
		
		-- load the material data
		INSERT INTO @MaterialType
			(RootMaterialTypeId, RootAbbreviation, MaterialTypeId)
		SELECT mc.RootMaterialTypeId, mt.Abbreviation, mc.MaterialTypeId
		FROM dbo.GetMaterialsByCategory(@iMaterialCategoryId) AS mc
			INNER JOIN dbo.MaterialType AS mt
				ON (mc.RootMaterialTypeId = mt.Material_Type_Id)
		WHERE mc.RootMaterialTypeId = ISNULL(@iRootMaterialTypeId, mc.RootMaterialTypeId)

		-- load the date range
		INSERT INTO @Date
			(DateFrom, DateTo, CalendarDate)
		SELECT DateFrom, DateTo, CalendarDate
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1)

		-- generate the actual + model data
		IF @iIncludeActuals = 1
		BEGIN
			INSERT INTO @Tonnes
			(
				Type, CalendarDate, MaterialTypeId, Tonnes
			)
			SELECT 'Actual', sub.CalendarDate, mc.RootMaterialTypeId, SUM(NULLIF(Tonnes, 0.0))
			FROM
				(
					-- C - z + y

					-- '+C' - all crusher removals
					SELECT CalendarDate, DesignationMaterialTypeId, SUM(Value) AS Tonnes
					FROM dbo.GetBhpbioReportActualC(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)
					WHERE Attribute = 0
					GROUP BY CalendarDate, DesignationMaterialTypeId
					
					UNION ALL

					-- '-z' - pre crusher stockpiles to crusher
					SELECT CalendarDate, DesignationMaterialTypeId, -SUM(Value) AS Tonnes
					FROM dbo.GetBhpbioReportActualZ(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)
					WHERE Attribute = 0
					GROUP BY CalendarDate, DesignationMaterialTypeId

					UNION ALL

					-- '+y' - pit to pre-crusher stockpiles
					SELECT CalendarDate, DesignationMaterialTypeId, SUM(Value)
					FROM dbo.GetBhpbioReportActualY(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)
					WHERE Attribute = 0
					GROUP BY CalendarDate, DesignationMaterialTypeId
				) AS sub
				INNER JOIN @MaterialType AS mc
					ON (mc.MaterialTypeId = sub.DesignationMaterialTypeId)
			GROUP BY sub.CalendarDate, mc.RootMaterialTypeId
		END

		IF (@iIncludeBlockModels = 1)
		BEGIN
			INSERT INTO @Tonnes
			(
				Type, CalendarDate, MaterialTypeId, Tonnes
			)
			SELECT bm.Type, m.CalendarDate, mc.RootMaterialTypeId, SUM(m.Value)
			FROM dbo.GetBhpbioReportModel(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL) AS m
				INNER JOIN @Type AS bm
					ON (m.BlockModelId = bm.BlockModelId)
				INNER JOIN @MaterialType AS mc
					ON (mc.MaterialTypeId = m.DesignationMaterialTypeId)
			WHERE m.Attribute = 0
			GROUP BY bm.Type, m.CalendarDate, mc.RootMaterialTypeId
		END

		-- return the result		
		SELECT t.Type, t.BlockModelId, d.CalendarDate,
			mt.RootAbbreviation AS Material, mt.RootMaterialTypeId AS MaterialTypeId,
			r.Tonnes
		FROM
			-- display all dates
			@Date AS d
			-- display all elisted types (block models + actual)
			CROSS JOIN @Type AS t
			-- ensure material types are represented uniformly
			CROSS JOIN
				(
					SELECT DISTINCT mt2.RootMaterialTypeId, mt2.RootAbbreviation, mt2.MaterialTypeId
					FROM @MaterialType AS mt2
						INNER JOIN @Tonnes AS r2
							ON (r2.MaterialTypeId = mt2.MaterialTypeId)
				) AS mt
			-- pivot in the results
			LEFT OUTER JOIN @Tonnes AS r
				ON (r.CalendarDate = d.CalendarDate
					AND r.MaterialTypeId = mt.MaterialTypeId
					AND r.Type = t.Type)
		ORDER BY d.CalendarDate, mt.RootAbbreviation, t.Type

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/* testing

EXEC dbo.GetBhpbioReportBaseDataAsTonnes
	@iDateFrom = '01-APR-2008',
	@iDateTo = '30-JUN-2008',
	@iDateBreakdown = NULL,
	@iLocationId = 1,
	@iIncludeBlockModels = 1,
	@iBlockModels = NULL,
	@iIncludeActuals = 1,
	@iMaterialCategoryId = 'Designation',
	@iRootMaterialTypeId = NULL
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportBaseDataAsGrades.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportBaseDataAsGrades') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportBaseDataAsGrades
GO

CREATE PROCEDURE dbo.GetBhpbioReportBaseDataAsGrades
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iMaterialCategoryId VARCHAR(31),
	@iRootMaterialTypeId INT,
	@iGrades XML
)
AS 
BEGIN
	-- for internal consumption only
	
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @HighGradeMaterialTypeId INT

	DECLARE @Grade TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		CalendarDate DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		GradeId SMALLINT NOT NULL,
		GradeValue FLOAT NULL,

		PRIMARY KEY CLUSTERED (CalendarDate, MaterialTypeId, GradeId, Type)
	)
	
	DECLARE @Type TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		PRIMARY KEY CLUSTERED (Type)
	)

	DECLARE @MaterialType TABLE
	(
		RootMaterialTypeId INT NOT NULL,
		RootAbbreviation VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		PRIMARY KEY CLUSTERED (MaterialTypeId, RootMaterialTypeId)
	)

	DECLARE @Date TABLE
	(
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		CalendarDate DATETIME NOT NULL,
		PRIMARY KEY NONCLUSTERED (CalendarDate),
		UNIQUE CLUSTERED (DateFrom, DateTo, CalendarDate)
	)

	DECLARE @GradeLookup TABLE
	(
		GradeId SMALLINT NOT NULL,
		GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		OrderNo INT NOT NULL,
		PRIMARY KEY CLUSTERED (GradeId)
	)

	DECLARE @C TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute SMALLINT NULL,
		Value FLOAT NULL
	)

	DECLARE @Y TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute SMALLINT NULL,
		Value FLOAT NULL
	)

	DECLARE @Z TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute SMALLINT NULL,
		Value FLOAT NULL
	)

	DECLARE @M TABLE
	(
		CalendarDate DATETIME NOT NULL,
		BlockModelId INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		DesignationMaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute SMALLINT NULL,
		Value FLOAT NULL
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportBaseDataAsGrades',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- perform checks
		IF dbo.GetDateMonth(@iDateFrom) <> @iDateFrom
		BEGIN
			RAISERROR('The @iDateFrom parameter must be the first day of the month.', 16, 1)
		END

		IF (dbo.GetDateMonth(@iDateTo + 1) - 1) <> @iDateTo
		BEGIN
			RAISERROR('The @iDateTo parameter must be the last day of the month.', 16, 1)
		END

		IF NOT @iMaterialCategoryId IN ('Classification', 'Designation')
		BEGIN
			RAISERROR('The Material Category parameter can only be Classification/Designation.', 16, 1)
		END

		-- load Grades
		IF @iGrades IS NULL
		BEGIN
			INSERT INTO @GradeLookup
				(GradeId, GradeName, OrderNo)
			SELECT Grade_Id, Grade_Name, Order_No
			FROM dbo.Grade
		END
		ELSE
		BEGIN
			INSERT INTO @GradeLookup
				(GradeId, GradeName, OrderNo)
			SELECT g.Grade.value('./@id', 'SMALLINT'), g2.Grade_Name, g2.Order_No
			FROM @iGrades.nodes('/Grades/Grade') AS g(Grade)
				INNER JOIN dbo.Grade AS g2
					ON (g2.Grade_Id = g.Grade.value('./@id', 'SMALLINT'))
		END

		-- load Block Model
		IF @iIncludeActuals = 1
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			VALUES
				('Actual', NULL)
		END

		IF (@iIncludeBlockModels = 1) AND (@iBlockModels IS NULL)
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			SELECT Name, Block_Model_Id
			FROM dbo.BlockModel
		END
		ELSE IF (@iIncludeBlockModels = 1)
		BEGIN
			INSERT INTO @Type
				(Type, BlockModelId)
			SELECT bm.Name, b.BlockModel.value('./@id', 'INT')
			FROM @iBlockModels.nodes('/BlockModels/BlockModel') AS b(BlockModel)
				INNER JOIN dbo.BlockModel AS bm
					ON (bm.Block_Model_Id = b.BlockModel.value('./@id', 'INT'))
		END
		
		-- load the material data
		INSERT INTO @MaterialType
			(RootMaterialTypeId, RootAbbreviation, MaterialTypeId)
		SELECT mc.RootMaterialTypeId, mt.Abbreviation, mc.MaterialTypeId
		FROM dbo.GetMaterialsByCategory(@iMaterialCategoryId) AS mc
			INNER JOIN dbo.MaterialType AS mt
				ON (mc.RootMaterialTypeId = mt.Material_Type_Id)
		WHERE mc.RootMaterialTypeId = ISNULL(@iRootMaterialTypeId, mc.RootMaterialTypeId)

		-- load the date range
		INSERT INTO @Date
			(DateFrom, DateTo, CalendarDate)
		SELECT DateFrom, DateTo, CalendarDate
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1)

		-- generate the actual + model data
		IF @iIncludeActuals = 1
		BEGIN
			INSERT INTO @C
				(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
			SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
			FROM dbo.GetBhpbioReportActualC(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)

			INSERT INTO @Y
				(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
			SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
			FROM dbo.GetBhpbioReportActualY(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)

			INSERT INTO @Z
				(CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
			SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
			FROM dbo.GetBhpbioReportActualZ(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)

			INSERT INTO @Grade
			(
				Type, CalendarDate, MaterialTypeId, GradeId, GradeValue
			)
			SELECT 'Actual', CalendarDate, RootMaterialTypeId, GradeId,
				SUM(Tonnes * GradeValue) / NULLIF(SUM(Tonnes), 0.0)
			FROM
				(
					-- High Grade = C - z(hg) + y(hg)
					-- All Grade  = y(non-hg)

					-- '+C' - all crusher removals
					SELECT g.CalendarDate, mc.RootMaterialTypeId,
						g.Attribute As GradeId, SUM(t.Value) AS Tonnes,
						-- the following value is only valid as the data is always returned at the Site level
						-- above this level (Hub/WAIO) the aggregation will properly perform real aggregations
						SUM(g.Value * NULLIF(t.Value, 0.0)) / NULLIF(SUM(t.Value), 0.0) As GradeValue
					FROM @C AS g
						INNER JOIN @C AS t
							ON (g.DesignationMaterialTypeId = t.DesignationMaterialTypeId)
						INNER JOIN @MaterialType AS mc
							ON (mc.MaterialTypeId = t.DesignationMaterialTypeId)
					WHERE g.Attribute > 0
						AND t.Attribute = 0
					GROUP BY g.CalendarDate, mc.RootMaterialTypeId, g.Attribute

					UNION ALL

					-- '-z(all)' - pre crusher stockpiles to crusher
					SELECT g.CalendarDate, mc.RootMaterialTypeId,
						g.Attribute As GradeId,
						-SUM(t.Value) AS Tonnes, SUM(g.Value * t.Value) / NULLIF(SUM(t.Value), 0.0) As GradeValue
					FROM @Z AS g
						INNER JOIN @Z AS t
							ON (g.DesignationMaterialTypeId = t.DesignationMaterialTypeId)
						INNER JOIN @MaterialType AS mc
							ON (mc.MaterialTypeId = t.DesignationMaterialTypeId)
					WHERE g.Attribute > 0
						AND t.Attribute = 0
					GROUP BY g.CalendarDate, mc.RootMaterialTypeId, g.Attribute

					UNION ALL

					-- '+y(hg)' - pit to pre-crusher stockpiles
					SELECT g.CalendarDate, mc.RootMaterialTypeId,
						g.Attribute As GradeId,
						SUM(t.Value) AS Tonnes, SUM(g.Value * t.Value) / NULLIF(SUM(t.Value), 0.0) As GradeValue
					FROM @Y AS g
						INNER JOIN @Y AS t
							ON (g.DesignationMaterialTypeId = t.DesignationMaterialTypeId)
						INNER JOIN @MaterialType AS mc
							ON (mc.MaterialTypeId = t.DesignationMaterialTypeId)
					WHERE g.Attribute > 0
						AND t.Attribute = 0
					GROUP BY g.CalendarDate, mc.RootMaterialTypeId, g.Attribute
				) AS sub
			GROUP BY CalendarDate, RootMaterialTypeId, GradeId
		END

		IF (@iIncludeBlockModels = 1)
		BEGIN
			INSERT INTO @M
				(CalendarDate, BlockModelId, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value)
			SELECT CalendarDate, BlockModelId, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
			FROM dbo.GetBhpbioReportModel(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, NULL)

			INSERT INTO @Grade
			(
				Type, CalendarDate, MaterialTypeId, GradeId, GradeValue
			)
			SELECT bm.Type, g.CalendarDate, mc.RootMaterialTypeId, g.Attribute,
				SUM(g.Value * t.Value) / SUM(t.Value)
			FROM @M AS t
				INNER JOIN @M AS g
					ON (t.DesignationMaterialTypeId = g.DesignationMaterialTypeId
						AND t.BlockModelId = g.BlockModelId)
				INNER JOIN @MaterialType AS mc
					ON (mc.MaterialTypeId = t.DesignationMaterialTypeId)
				INNER JOIN @Type AS bm
					ON (t.BlockModelId = bm.BlockModelId)
			WHERE t.Attribute = 0
				AND g.Attribute > 0
			GROUP BY bm.Type, g.CalendarDate, mc.RootMaterialTypeId, g.Attribute
		END

		-- return the result	
		SELECT t.Type, t.BlockModelId, d.CalendarDate,
			mt.RootAbbreviation AS Material, mt.RootMaterialTypeId AS MaterialTypeId,
			g.GradeName, g.GradeId, r.GradeValue
		FROM
			-- display all dates
			@Date AS d
			-- display all elisted types (block models + actual)
			CROSS JOIN @Type AS t
			-- ensure material types are represented uniformly
			CROSS JOIN
				(
					SELECT DISTINCT mt2.RootMaterialTypeId, mt2.RootAbbreviation, mt2.MaterialTypeId
					FROM @MaterialType AS mt2
						INNER JOIN @Grade AS r2
							ON (r2.MaterialTypeId = mt2.MaterialTypeId)
				) AS mt
			-- ensure all grades are represented
			CROSS JOIN @GradeLookup AS g
			-- pivot in the results
			LEFT OUTER JOIN @Grade AS r
				ON (r.CalendarDate = d.CalendarDate
					AND r.MaterialTypeId = mt.MaterialTypeId
					AND r.Type = t.Type
					AND g.GradeId = r.GradeId)
		ORDER BY d.CalendarDate, mt.RootAbbreviation, t.Type, g.OrderNo

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

/* testing

EXEC dbo.GetBhpbioReportBaseDataAsGrades
	@iDateFrom = '01-APR-2008',
	@iDateTo = '30-JUN-2008',
	@iDateBreakdown = 'QUARTER',
	@iLocationId = 4,
	@iIncludeBlockModels = 1,
	@iBlockModels = NULL,
	@iIncludeActuals = 1,
	@iMaterialCategoryId = 'Designation',
	@iRootMaterialTypeId = NULL,
	@iGrades = NULL
*/ 


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioModelComparisonReport.prc'
GO

IF Object_Id('dbo.GetBhpbioModelComparisonReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioModelComparisonReport
GO

CREATE PROCEDURE dbo.GetBhpbioModelComparisonReport
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iDesignationMaterialTypeId INT,
	@iTonnes BIT,
	@iGrades XML
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Tonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)

	DECLARE @Grade TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		GradeId SMALLINT NOT NULL,
		GradeValue REAL,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, GradeName, Type)
	)

	SET NOCOUNT ON

	SELECT @TransactionName = 'GetBhpbioModelComparisonReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- note: this has been split into two separate calls
		-- a new requirement (for crusher actuals) has made it such that we cannot aggregate any further beyond the base procs

		-- create the summary data
		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Grade
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, GradeName, GradeId, GradeValue
		)
		EXEC dbo.GetBhpbioReportBaseDataAsGrades
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId,
			@iGrades = @iGrades

		SELECT 'Tonnes' AS TonnesGradesTag, Type AS ModelTag, Material, Tonnes AS Value
		FROM @Tonnes
		UNION ALL
		SELECT g.GradeName, g.Type, g.Material, g.GradeValue
		FROM @Grade AS g
			INNER JOIN @Tonnes AS t
				ON (t.Type = g.Type
					AND t.CalendarDate = g.CalendarDate
					AND t.Material = g.Material)

		-- create the graph data
		DELETE FROM @Tonnes
		DELETE FROM @Grade

		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Grade
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, GradeName, GradeId, GradeValue
		)
		EXEC dbo.GetBhpbioReportBaseDataAsGrades
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId,
			@iGrades = @iGrades

		SELECT CalendarDate, 'Tonnes' AS TonnesGradesTag, Type AS ModelTag, Material, Tonnes AS Value
		FROM @Tonnes
		UNION ALL
		SELECT CalendarDate, GradeName, Type, Material, GradeValue
		FROM @Grade

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioModelComparisonReport TO BhpbioGenericManager
GO

/*
testing

EXEC dbo.GetBhpbioModelComparisonReport
	@iDateFrom = '01-APR-2009',
	@iDateTo = '30-JUN-2009',
	@iDateBreakdown = 'MONTH',
	@iLocationId = 1,
	@iIncludeBlockModels = 1,
	@iBlockModels = '<BlockModels><BlockModel>1</BlockModel><BlockModel>2</BlockModel><BlockModel>3</BlockModel></BlockModels>',
	@iIncludeActuals = 1,
	@iDesignationMaterialTypeId = NULL,
	@iTonnes = 1,
	@iGrades = '<Grades><Grade>1</Grade><Grade>2</Grade></Grades>'

*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioGradeRecoveryReport.prc'
GO

IF Object_Id('dbo.GetBhpbioGradeRecoveryReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioGradeRecoveryReport
GO

CREATE PROCEDURE dbo.GetBhpbioGradeRecoveryReport
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iDesignationMaterialTypeId	INT,
	@iTonnes BIT,
	@iGrades XML
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Tonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)

	DECLARE @Grade TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		GradeId SMALLINT NOT NULL,
		GradeValue REAL,
		GradePrecision INT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, GradeName, Type)
	)

	SET NOCOUNT ON

	SELECT @TransactionName = 'GetBhpbioGradeRecoveryReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- load the base data
		INSERT INTO @Tonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Grade
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, GradeName, GradeId, GradeValue
		)
		EXEC dbo.GetBhpbioReportBaseDataAsGrades
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = NULL,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId,
			@iGrades = @iGrades
			
		UPDATE BG
		SET GradePrecision = G.Display_Precision
		FROM @Grade BG
			INNER JOIN Grade G
				ON (G.Grade_Id = BG.GradeId)

		-- create the summary table

		-- generate the ABSOLUTE DATA
		-- this has no recovery calculations applied

		SELECT 'Absolute' AS Section, 'Tonnes' AS TonnesGradesTag, Type AS Model, Material AS Designation,
			SUM(Tonnes) AS Value
		FROM @Tonnes
		GROUP BY Type, Material
		HAVING @iTonnes = 1

		UNION ALL

		SELECT 'Absolute', g.GradeName, g.Type, g.Material,
			SUM(g.GradeValue * t.Tonnes) / SUM(t.Tonnes)
		FROM @Grade AS g
			INNER JOIN @Tonnes AS t
				ON (g.Type = t.Type
					AND g.CalendarDate = t.CalendarDate
					AND g.Material = t.Material)
		GROUP BY g.GradeName, g.Type, g.Material

		UNION ALL

		-- generate the DIFFERENCES (RECOVERY) DATA
		-- this shows comparisons between all permutations
		-- this may need to be filtered out somewhere at some point!
		SELECT 'Difference', 'Tonnes', t1.Type + ' - ' + t2.Type, t1.Material,
			ROUND(SUM(t1.Tonnes), -3) - ROUND(SUM(t2.Tonnes), -3)
		FROM @Tonnes AS t1
			INNER JOIN @Tonnes AS t2
				ON (t1.CalendarDate = t2.CalendarDate
					AND t1.Material = t2.Material
					AND t1.Type <> t2.Type)
		WHERE (t1.Type = 'Actual' AND t2.Type = 'Mining')
			OR (t1.Type = 'Grade Control' AND t2.Type = 'Mining')
			OR (t1.Type = 'Actual' AND t2.Type = 'Grade Control')
		GROUP BY t1.Type, t2.Type, t1.Material

		UNION ALL

		SELECT 'Difference', g1.GradeName, g1.Type + ' - ' + g2.Type, g1.Material,
			ROUND(SUM(g1.GradeValue * t1.Tonnes)/SUM(t1.Tonnes), g1.GradePrecision) - ROUND(SUM(g2.GradeValue * t2.Tonnes) / SUM(t2.Tonnes), g2.GradePrecision)
		FROM @Grade AS g1
			INNER JOIN @Tonnes AS t1
				ON (t1.Type = g1.Type
					AND t1.CalendarDate = g1.CalendarDate
					AND t1.Material = g1.Material)
			INNER JOIN @Grade AS g2
				ON (g1.CalendarDate = g2.CalendarDate
					AND g1.Material = g2.Material
					AND g1.GradeName = g2.GradeName
					AND g1.Type <> g2.Type)
			INNER JOIN @Tonnes AS t2
				ON (t2.Type = g2.Type
					AND t2.CalendarDate = g2.CalendarDate
					AND t2.Material = g2.Material)
		WHERE (t1.Type = 'Actual' AND t2.Type = 'Mining')
			OR (t1.Type = 'Grade Control' AND t2.Type = 'Mining')
			OR (t1.Type = 'Actual' AND t2.Type = 'Grade Control')
		GROUP BY g1.Type, g2.Type, g1.Material, g1.GradeName, g1.GradePrecision, g2.GradePrecision

		-- supply the GRAPH data
		SELECT 'Tonnes' AS TonnesGradesTag, Type AS ModelTag, Material AS Designation,
			SUM(Tonnes) AS Value
		FROM @Tonnes
		GROUP BY Type, Material
		HAVING @iTonnes = 1

		UNION ALL

		SELECT g.GradeName, g.Type, g.Material,
			SUM(g.GradeValue * t.Tonnes) / SUM(t.Tonnes)
		FROM @Grade AS g
			INNER JOIN @Tonnes AS t
				ON (g.CalendarDate = t.CalendarDate
					AND g.Type = t.Type
					AND g.Material = t.Material)
		GROUP BY g.GradeName, g.Type, g.Material
					
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioGradeRecoveryReport TO BhpbioGenericManager
GO

/*
testing

EXEC dbo.GetBhpbioGradeRecoveryReport
	@iDateFrom = '01-APR-2009',
	@iDateTo = '30-JUN-2009',
	@iLocationId = 1,
	@iIncludeBlockModels = 1,
	@iBlockModels = '<BlockModels><BlockModel id="1"></BlockModel><BlockModel id="2"></BlockModel><BlockModel id="3"></BlockModel></BlockModels>',
	@iIncludeActuals = 1,
	@iDesignationMaterialTypeId = NULL,
	@iTonnes = 1,
	@iGrades = '<Grades><Grade>1</Grade><Grade>2</Grade></Grades>'
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioMovementRecoveryReport.prc'
GO

IF Object_Id('dbo.GetBhpbioMovementRecoveryReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioMovementRecoveryReport
GO

CREATE PROCEDURE dbo.GetBhpbioMovementRecoveryReport
(
	@iDateTo DATETIME,
	@iLocationId INT,
	@iComparison1IsActual BIT,
	@iComparison1BlockModelId INT,
	@iComparison2IsActual BIT,
	@iComparison2BlockModelId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BlockModels XML
	DECLARE @IncludeActuals BIT
	DECLARE @IncludeBlockModels BIT

	DECLARE @Comparison TINYINT
	DECLARE @MaterialCategory VARCHAR(31)
	DECLARE @RollingPeriod TINYINT
	DECLARE @DateFrom DATETIME

	DECLARE @Tonnes TABLE
	(
		Compare1Or2 TINYINT NOT NULL,
		RollingPeriod TINYINT NOT NULL,
		MaterialCategory VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Compare1Or2, RollingPeriod, MaterialCategory)
	)

	DECLARE @TempTonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)

	DECLARE @Material TABLE
	(
		MaterialCategory VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialClassificationOrder VARCHAR(31) COLLATE DATABASE_DEFAULT,
		PRIMARY KEY CLUSTERED (MaterialCategory, Material)
	)

	SET NOCOUNT ON

	SELECT @TransactionName = 'GetBhpbioMovementRecoveryReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- loop on:
		-- Comparison1, Comparison2
		-- Designation, Classification
		-- 12 Month, 3 Month

		-- loop on Comparison1, Comparison2
		SET @Comparison = 1
		WHILE @Comparison IN (1, 2)
		BEGIN
			IF (@Comparison = 1 AND @iComparison1IsActual = 1)
				OR (@Comparison = 2 AND @iComparison2IsActual = 1)
			BEGIN	
				SET @IncludeActuals = 1
				SET @IncludeBlockModels = 0
			END
			ELSE
			BEGIN
				SET @IncludeActuals = 0
				SET @IncludeBlockModels = 1
			END

			SET @BlockModels =
				(
					SELECT [@id]
					FROM
						(
							SELECT @iComparison1BlockModelId AS [@id]
							WHERE @iComparison1IsActual = 0
								AND @Comparison = 1
							UNION ALL
							SELECT @iComparison2BlockModelId AS [@id]
							WHERE @iComparison2IsActual = 0
								AND @Comparison = 2
						) AS sub
					FOR XML PATH ('BlockModel'), ELEMENTS, ROOT('BlockModels')
				)

			-- loop on Designation, Classification
			SET @MaterialCategory = 'Designation'
			WHILE @MaterialCategory IS NOT NULL
			BEGIN
				-- loop on 12 Month, 3 Month
				SET @RollingPeriod = 12
				WHILE @RollingPeriod IN (12, 3)
				BEGIN
					SET @DateFrom =
						(
							CASE @RollingPeriod
								WHEN 3 THEN DateAdd(Month, -3, (@iDateTo + 1))
								WHEN 12 THEN DateAdd(Month, -12, (@iDateTo + 1))
								ELSE NULL
							END
						)

					INSERT INTO @TempTonnes
					(
						Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
					)
					EXEC dbo.GetBhpbioReportBaseDataAsTonnes
						@iDateFrom = @DateFrom,
						@iDateTo = @iDateTo,
						@iDateBreakdown = NULL,
						@iLocationId = @iLocationId,
						@iIncludeBlockModels = @IncludeBlockModels,
						@iBlockModels = @BlockModels,
						@iIncludeActuals = @IncludeActuals,
						@iMaterialCategoryId = @MaterialCategory,
						@iRootMaterialTypeId = NULL

					INSERT INTO @Tonnes
					(
						Compare1Or2, RollingPeriod, MaterialCategory, CalendarDate, Material, MaterialTypeId, Tonnes
					)
					SELECT @Comparison, @RollingPeriod, @MaterialCategory, CalendarDate, Material, MaterialTypeId, Sum(Tonnes)
					FROM @TempTonnes
					Group By CalendarDate, Material, MaterialTypeId

					DELETE
					FROM @TempTonnes

					-- load the next rolling period
					SET @RollingPeriod =
						(
							SELECT
								CASE @RollingPeriod
									WHEN 12 THEN 3
									WHEN 3 THEN NULL
									ELSE NULL
								END
						)
				END

				-- load the next material category
				SET @MaterialCategory = 
					(
						SELECT
							CASE @MaterialCategory
								WHEN 'Designation' THEN 'Classification'
								WHEN 'Classification' THEN NULL
								ELSE NULL
							END
					)
			END
					
			-- load the next comparison
			SET @Comparison = @Comparison + 1
		END

		-- load materials
		INSERT INTO @Material
		(MaterialCategory, Material, MaterialClassificationOrder)
		SELECT DISTINCT MaterialCategory, Material, MT.Order_No
		FROM @Tonnes T
			INNER JOIN dbo.MaterialType MT
				ON dbo.GetMaterialCategoryMaterialType(T.MaterialTypeId, 'Classification') = MT.Material_Type_Id

		-- create the summary table
		SELECT rp.RollingPeriod, c.Compare1Or2, sub.MaterialCategory, sub.Material, sub.MaterialClassificationOrder, sub.Tonnes
		FROM
			(
				SELECT 3 AS RollingPeriod
				UNION ALL
				SELECT 12
			) AS rp
			CROSS JOIN
			(
				SELECT 1 AS Compare1Or2
				UNION ALL
				SELECT 2
				UNION ALL
				SELECT 3  -- this is the total line
			) AS c
			LEFT OUTER JOIN
			(
				-- return the underlying data
				SELECT t.RollingPeriod, t.Compare1Or2, t.MaterialCategory, t.Material, MC.MaterialClassificationOrder, 
					SUM(Tonnes) AS Tonnes
				FROM @Tonnes t
					INNER JOIN @Material AS mc
						ON (mc.MaterialCategory = t.MaterialCategory
							AND MC.Material = t.Material)
				GROUP BY t.RollingPeriod, t.Compare1Or2, t.MaterialCategory, t.Material, MC.MaterialClassificationOrder

				UNION ALL

				-- return the total movement line
				SELECT t.RollingPeriod, t.Compare1Or2, 'Total Movement', NULL, MAX(MC.MaterialClassificationOrder) + 1,
					SUM(t.Tonnes) AS Tonnes
				FROM @Tonnes AS t
					INNER JOIN @Material AS mc
						ON (mc.MaterialCategory = t.MaterialCategory
							AND mc.Material = t.Material)
				WHERE t.MaterialCategory = 'Classification'
				GROUP BY t.RollingPeriod, t.Compare1Or2

				UNION ALL

				-- return the % variance line
				SELECT COALESCE(t1.RollingPeriod, t2.RollingPeriod),
					3, mc.MaterialCategory, mc.Material AS Material, MC.MaterialClassificationOrder, 
					CASE
						WHEN SUM(t2.Tonnes) <> 0 AND SUM(t1.Tonnes) <> 0
							THEN SUM(t1.Tonnes) / SUM(t2.Tonnes)
						ELSE NULL
					END AS Tonnes
				FROM @Material AS mc
					LEFT JOIN @Tonnes AS t1
						ON (mc.MaterialCategory = t1.MaterialCategory
							AND mc.Material = t1.Material
							AND t1.Compare1Or2 = 1)
					LEFT JOIN @Tonnes AS t2
						ON (mc.MaterialCategory = t2.MaterialCategory
							AND mc.Material = t2.Material
							AND t2.Compare1Or2 = 2
							AND t1.RollingPeriod = t2.RollingPeriod)
				WHERE (t2.CalendarDate = t1.CalendarDate
						OR t1.CalendarDate Is Null
						OR t2.CalendarDate Is Null)
				GROUP BY COALESCE(t1.RollingPeriod, t2.RollingPeriod),
					mc.MaterialCategory, mc.Material, mc.MaterialClassificationOrder

				UNION ALL

				SELECT COALESCE(t1.RollingPeriod, t2.RollingPeriod),
					3, 'Total Movement', NULL AS Material, Max(mc.MaterialClassificationOrder) + 1,
					CASE
						WHEN SUM(t2.Tonnes) <> 0 AND SUM(t1.Tonnes) <> 0
							THEN SUM(t1.Tonnes) / Sum(t2.Tonnes)
						ELSE NULL
					END AS Tonnes
				FROM @Material AS mc
					LEFT JOIN @Tonnes AS t1
						ON (mc.MaterialCategory = t1.MaterialCategory
							AND MC.Material = t1.Material
							AND t1.Compare1Or2 = 1)
					LEFT JOIN @Tonnes AS t2
						ON (mc.MaterialCategory = t2.MaterialCategory
							AND mc.Material = t2.Material
							AND t2.Compare1Or2 = 2
							AND t2.RollingPeriod = t1.RollingPeriod)
				WHERE (t2.CalendarDate = t1.CalendarDate
						Or t1.CalendarDate Is Null
						Or t2.CalendarDate Is Null)
					AND mc.MaterialCategory = 'Classification'
				GROUP BY COALESCE(t1.RollingPeriod, t2.RollingPeriod)
			) AS sub
			ON (rp.RollingPeriod = sub.RollingPeriod
				AND c.Compare1Or2 = sub.Compare1Or2)
		ORDER BY rp.RollingPeriod, c.Compare1Or2,
			CASE MaterialCategory
				WHEN 'Designation' THEN 1
				WHEN 'Classification' THEN 2
				ELSE 3 END,
			Material

		-- create the graph data
		SELECT rp.RollingPeriod, sub.MaterialCategory, sub.Material, sub.MaterialClassificationOrder, sub.Tonnes
		FROM
			(
				SELECT 3 AS RollingPeriod
				UNION ALL
				SELECT 12
			) AS rp
			LEFT OUTER JOIN
			(
				SELECT COALESCE(t1.RollingPeriod, t2.RollingPeriod) AS RollingPeriod,
					mc.MaterialCategory, mc.Material AS Material, mc.MaterialClassificationOrder, 
					CASE
						WHEN SUM(t2.Tonnes) <> 0 AND SUM(t1.Tonnes) <> 0
							THEN SUM(t1.Tonnes) / Sum(t2.Tonnes)
						ELSE NULL
					END AS Tonnes
				FROM @Material AS mc
					LEFT JOIN @Tonnes AS t1
						ON (mc.MaterialCategory = t1.MaterialCategory
							AND mc.Material = t1.Material
							AND t1.Compare1Or2 = 1)
					LEFT JOIN @Tonnes AS t2
						ON (mc.MaterialCategory = t2.MaterialCategory
							AND mc.Material = t2.Material
							AND t2.Compare1Or2 = 2
							AND t2.RollingPeriod = t1.RollingPeriod)
				WHERE (t2.CalendarDate = t1.CalendarDate
						OR t1.CalendarDate Is Null
						OR t2.CalendarDate Is Null)
				GROUP BY COALESCE(t1.RollingPeriod, t2.RollingPeriod),
					mc.MaterialCategory, mc.Material, mc.MaterialClassificationOrder

				UNION ALL

				SELECT COALESCE(t1.RollingPeriod, t2.RollingPeriod) AS RollingPeriod,
					'Total Movement', NULL AS Material, MAX(MC.MaterialClassificationOrder) + 1, 
					CASE
						WHEN SUM(t2.Tonnes) <> 0 AND SUM(t1.Tonnes) <> 0
							THEN SUM(t1.Tonnes) / Sum(t2.Tonnes)
						ELSE NULL
					END AS Tonnes
				FROM @Material AS mc
					LEFT JOIN @Tonnes AS t1
						ON (mc.MaterialCategory = t1.MaterialCategory
							AND mc.Material = t1.Material
							AND t1.Compare1Or2 = 1)
					LEFT JOIN @Tonnes AS t2
						ON (mc.MaterialCategory = t2.MaterialCategory
							AND mc.Material = t2.Material
							AND t2.Compare1Or2 = 2
							AND t2.RollingPeriod = t1.RollingPeriod)
				WHERE (t2.CalendarDate = t1.CalendarDate
						Or t1.CalendarDate Is Null
						Or t2.CalendarDate Is Null)
					AND mc.MaterialCategory = 'Classification'
				GROUP BY COALESCE(t1.RollingPeriod, t2.RollingPeriod)
			) AS sub
			ON (sub.RollingPeriod = rp.RollingPeriod)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioMovementRecoveryReport TO BhpbioGenericManager
GO

/* testing
EXEC dbo.GetBhpbioMovementRecoveryReport
	@iDateTo = '30-JUN-2009',
	@iLocationId = 1,
	@iComparison1IsActual = 0,
	@iComparison1BlockModelId = 1,
	@iComparison2IsActual = 0,
	@iComparison2BlockModelId = 2
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioRecoveryAnalysisReport.prc'
GO

IF Object_Id('dbo.GetBhpbioRecoveryAnalysisReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioRecoveryAnalysisReport
GO

CREATE PROCEDURE dbo.GetBhpbioRecoveryAnalysisReport
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iIncludeBlockModels BIT,
	@iBlockModels XML,
	@iIncludeActuals BIT,
	@iDesignationMaterialTypeId INT
)
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Tonnes TABLE
	(
		MaterialCategory VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type, MaterialCategory)
	)

	DECLARE @TempTonnes TABLE
	(
		Type VARCHAR(255) COLLATE DATABASE_DEFAULT NOT NULL,
		BlockModelId INT NULL,
		CalendarDate DATETIME NOT NULL,
		Material VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		Tonnes FLOAT,
		PRIMARY KEY CLUSTERED (CalendarDate, Material, Type)
	)

	SET NOCOUNT ON

	SELECT @TransactionName = 'GetBhpbioRecoveryAnalysisReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- load DESIGNATION
		INSERT INTO @TempTonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Designation',
			@iRootMaterialTypeId = @iDesignationMaterialTypeId

		INSERT INTO @Tonnes
		(
			MaterialCategory, Type, CalendarDate, Material, Tonnes
		)
		SELECT 'Designation', Type, CalendarDate, Material, Tonnes
		FROM @TempTonnes

		DELETE
		FROM @TempTonnes

		-- load CLASSIFICATION
		INSERT INTO @TempTonnes
		(
			Type, BlockModelId, CalendarDate, Material, MaterialTypeId, Tonnes
		)
		EXEC dbo.GetBhpbioReportBaseDataAsTonnes
			@iDateFrom = @iDateFrom,
			@iDateTo = @iDateTo,
			@iDateBreakdown = @iDateBreakdown,
			@iLocationId = @iLocationId,
			@iIncludeBlockModels = @iIncludeBlockModels,
			@iBlockModels = @iBlockModels,
			@iIncludeActuals = @iIncludeActuals,
			@iMaterialCategoryId = 'Classification',
			@iRootMaterialTypeId = NULL

		INSERT INTO @Tonnes
		(
			MaterialCategory, Type, CalendarDate, Material, Tonnes
		)
		SELECT 'Classification', Type, CalendarDate, Material, Tonnes
		FROM @TempTonnes

		DELETE
		FROM @TempTonnes

		-- create the summary table

		-- generate the DIFFERENCES (RECOVERY) DATA
		-- this shows comparisons between all permutations
		-- this may need to be filtered out somewhere at some point!
		SELECT t1.Type + ' - ' + t2.Type AS ComparisonType, t1.MaterialCategory, t1.Material,
			SUM(t1.Tonnes) / NULLIF(SUM(t2.Tonnes), 0.0) AS RecoveryPercent
		FROM @Tonnes AS t1
			INNER JOIN @Tonnes AS t2
				ON (t1.CalendarDate = t2.CalendarDate
					AND t1.Material = t2.Material
					AND t1.MaterialCategory = t2.MaterialCategory
					AND t1.Type <> t2.Type)
		WHERE (t1.Type = 'Mining' AND t2.Type = 'Geology')
			OR (t1.Type = 'Grade Control' AND t2.Type = 'Mining')
			OR (t1.Type = 'Actual' AND t2.Type = 'Mining')
			OR (t1.Type = 'Actual' AND t2.Type = 'Grade Control')
		GROUP BY t1.Type, t2.Type, t1.Material, t1.MaterialCategory

		-- supply the GRAPH data
		-- this is supposed to show recovery data but it doesn't make sense

		SELECT t1.Type + ' - ' + t2.Type AS ComparisonType, t1.Material AS Designation, t1.CalendarDate,
			SUM(t1.Tonnes) / NULLIF(SUM(t2.Tonnes), 0.0) AS RecoveryPercent
		FROM @Tonnes AS t1
			INNER JOIN @Tonnes AS t2
				ON (t1.CalendarDate = t2.CalendarDate
					AND t1.Material = t2.Material
					AND t1.MaterialCategory = t2.MaterialCategory
					AND t1.Type <> t2.Type)
		WHERE t1.MaterialCategory = 'Designation'
			AND
			(
				(t1.Type = 'Mining' AND t2.Type = 'Geology')
				OR (t1.Type = 'Grade Control' AND t2.Type = 'Mining')
				OR (t1.Type = 'Actual' AND t2.Type = 'Mining')
				OR (t1.Type = 'Actual' AND t2.Type = 'Grade Control')
			)
		GROUP BY t1.Type, t2.Type, t1.Material, t1.CalendarDate
					
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioRecoveryAnalysisReport TO BhpbioGenericManager
GO

/*
testing

EXEC dbo.GetBhpbioRecoveryAnalysisReport
	@iDateFrom = '01-APR-2009',
	@iDateTo = '30-JUN-2009',
	@iDateBreakdown = 'MONTH',
	@iLocationId = 1,
	@iIncludeBlockModels = 1,
	@iBlockModels = '<BlockModels><BlockModel id="1"></BlockModel><BlockModel id="2"></BlockModel><BlockModel id="3"></BlockModel></BlockModels>',
	@iIncludeActuals = 1,
	@iDesignationMaterialTypeId = NULL
	
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportAttributeProperties.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportAttributeProperties') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportAttributeProperties
GO 

CREATE PROCEDURE dbo.GetBhpbioReportAttributeProperties
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DECLARE @Attribute TABLE
		(
			AttributeId SMALLINT NOT NULL,
			AttributeName VARCHAR(31) NOT NULL,
			Description	VARCHAR(255) NOT NULL,
			OrderNo INT NOT NULL,
			Units VARCHAR(15) NOT NULL,
			DisplayPrecision INT NOT NULL,
			DisplayFormat VARCHAR(10) NOT NULL,
			GradeTypeId VARCHAR(31) NOT NULL,
			IsVisible BIT
		)

		DECLARE @TonnesFieldId INT
		SET @TonnesFieldId = 0
		
		INSERT INTO @Attribute
			(
				AttributeId, AttributeName, Description, OrderNo, Units, DisplayPrecision, 
				DisplayFormat, GradeTypeId, IsVisible
			)
		SELECT Grade_Id, Grade_Name, Description, Order_No, Units, Display_Precision, 
			Display_Format, Grade_Type_Id, Is_Visible
		FROM dbo.Grade
		UNION 
		SELECT @TonnesFieldId, 'Tonnes', 'Tonnes', 0, 't', 0, 'DP', 'Tonnes', 1

		
		SELECT AttributeId, AttributeName, Description, OrderNo, Units, DisplayPrecision, 
			DisplayFormat, GradeTypeId, IsVisible
		FROM @Attribute
		ORDER BY OrderNo
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioReportAttributeProperties TO BhpbioGenericManager
GO

--exec dbo.GetBhpbioReportAttributeProperties

			

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataBlockModel.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioReportDataBlockModel') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataBlockModel  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataBlockModel
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT,
	@iBlockModelName VARCHAR(31)
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @BlockModelId INT
	DECLARE @MaterialCategory VARCHAR(31)
	SET @MaterialCategory = 'Designation'

	DECLARE @ModelMovement TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		BlockModelId INT NOT NULL,
		ParentLocationId INT NULL,
		ModelBlockId INT NOT NULL,
		SequenceNo INT NOT NULL,
		MinedPercentage FLOAT NOT NULL,
		Tonnes FLOAT NOT NULL,
		PRIMARY KEY (CalendarDate, DateFrom, DateTo, MaterialTypeId, BlockModelId, ModelBlockId, SequenceNo)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataBlockModel',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- Get the Block Model Id from Name.
		SELECT @BlockModelId = BM.Block_Model_Id
		FROM dbo.BlockModel AS BM
		INNER JOIN dbo.BlockModelType AS BMT
			ON (BM.Block_Model_Type_Id = BMT.Block_Model_Type_Id)
		WHERE BM.Is_Default = 1
			AND BMT.Name = @iBlockModelName

		-- Insert the MBP
		INSERT INTO @ModelMovement
			(CalendarDate, DateFrom, DateTo, BlockModelId, MaterialTypeId, ParentLocationId, ModelBlockId, SequenceNo, MinedPercentage, Tonnes)
		SELECT B.CalendarDate, B.DateFrom, B.DateTo, MB.Block_Model_Id, MT.Material_Type_Id, L.ParentLocationId, 
			MBP.Model_Block_Id, MBP.Sequence_No, 
			SUM(RM.MinedPercentage), SUM(RM.MinedPercentage * MBP.Tonnes)
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.BhpbioImportReconciliationMovement AS RM
				ON (RM.DateFrom >= B.DateFrom
					AND RM.DateTo <= B.DateTo)
			INNER JOIN dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, NULL) AS L
				ON (L.LocationId = RM.BlockLocationId)
			INNER JOIN dbo.ModelBlockLocation AS MBL
				ON (L.LocationId = MBL.Location_Id)
			INNER JOIN dbo.ModelBlock AS MB
				ON (MBL.Model_Block_Id = MB.Model_Block_Id)
			INNER JOIN dbo.ModelBlockPartial AS MBP
				ON (MB.Model_Block_Id = MBP.Model_Block_Id)
			INNER JOIN dbo.GetMaterialsByCategory(@MaterialCategory) AS MC
				ON (MC.MaterialTypeId = MBP.Material_Type_Id)
			INNER JOIN dbo.MaterialType AS MT
				ON (MC.RootMaterialTypeId = MT.Material_Type_Id)
			INNER JOIN dbo.GetBhpbioReportHighGrade() AS BRHG
				ON (BRHG.MaterialTypeId = MT.Material_Type_Id)
		WHERE MB.Block_Model_Id = @BlockModelId OR @BlockModelId IS NULL
		GROUP BY B.CalendarDate, B.DateFrom, B.DateTo, MB.Block_Model_Id, MT.Material_Type_Id, 
			L.ParentLocationId, MBP.Model_Block_Id, MBP.Sequence_No

		-- Retrieve Tonnes
		SELECT MM.BlockModelId, BM.Name AS ModelName, MM.CalendarDate, MM.DateFrom, MM.DateTo, MM.MaterialTypeId, MM.ParentLocationId, SUM(MM.Tonnes) AS Tonnes
		FROM @ModelMovement AS MM
			INNER JOIN dbo.BlockModel AS BM
				ON (BM.Block_Model_Id = MM.BlockModelId)
		GROUP BY MM.CalendarDate, MM.DateFrom, MM.DateTo, MM.MaterialTypeId, MM.ParentLocationId, MM.BlockModelId, BM.Name

		-- Retrieve Grades
		SELECT MM.BlockModelId, BM.Name AS ModelName, MM.CalendarDate, MM.DateFrom, MM.DateTo, MM.ParentLocationId, MM.MaterialTypeId, G.Grade_Name As GradeName,
			SUM(MBP.Tonnes * MM.MinedPercentage * MBPG.Grade_Value) / SUM(MBP.Tonnes * MM.MinedPercentage) As GradeValue
		FROM @ModelMovement AS MM
			INNER JOIN dbo.BlockModel AS BM
				ON (BM.Block_Model_Id = MM.BlockModelId)
			INNER JOIN dbo.ModelBlockPartial AS MBP
				ON (MBP.Model_Block_Id = MM.ModelBlockId
					AND MBP.Sequence_No = MM.SequenceNo)
			INNER JOIN dbo.ModelBlockPartialGrade AS MBPG
				ON (MBP.Model_Block_Id = MBPG.Model_Block_Id
					AND MBP.Sequence_No = MBPG.Sequence_No)
			INNER JOIN dbo.Grade AS G
				ON (MBPG.Grade_Id = G.Grade_Id)
		GROUP BY MM.BlockModelId, BM.Name, MM.CalendarDate, MM.ParentLocationId, MM.DateFrom, MM.DateTo, MM.MaterialTypeId, G.Grade_Name

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataBlockModel TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataBlockModel
	@iDateFrom = '1-apr-2008',
	@iDateTo = '1-jun-2009',
	@iDateBreakdown = 'MONTH',
	@iLocationId = 1,
	@iLocationBreakdown = 'ChildLocations',
	@iBlockModelName = NULL
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataActualMineProduction.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataActualMineProduction') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataActualMineProduction  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataActualMineProduction
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @ChildLocations BIT
	
	DECLARE @MineProductionActual TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute INT NOT NULL,
		Value FLOAT NULL
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataActualMineProduction',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @MineProductionActual
			(CalendarDate, DateFrom, DateTo, MaterialTypeId, LocationId, Attribute, Value)
		SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
		FROM dbo.GetBhpbioReportActualC(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, @iChildLocations)

		SELECT CalendarDate, LocationId AS ParentLocationId, DateFrom, DateTo, MaterialTypeId, Value AS Tonnes
		FROM @MineProductionActual
		WHERE Attribute = 0
		
		SELECT mpa.CalendarDate, mpa.LocationId AS ParentLocationId, mpa.Attribute As GradeId,
			mpa.MaterialTypeId, g.Grade_Name As GradeName, mpa.Value As GradeValue
		FROM @MineProductionActual AS mpa
			INNER JOIN dbo.Grade AS g
				ON (mpa.Attribute = g.Grade_Id)
		WHERE mpa.Attribute > 0

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataActualMineProduction TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataActualMineProduction 
	@iDateFrom = '1-JUN-2009', 
	@iDateTo = '30-JUN-2009', 
	@iDateBreakdown = null,
	@iLocationId = 1,
	@iChildLocations = 0
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataActualExpitToStockpile.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataActualExpitToStockpile') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataActualExpitToStockpile 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataActualExpitToStockpile
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @ExpitToStockpile TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute INT NULL,
		Value FLOAT NULL
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataActualExpitToStockpile',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		INSERT INTO @ExpitToStockpile
			(CalendarDate, DateFrom, DateTo, MaterialTypeId, LocationId, Attribute, Value)
		SELECT Y.CalendarDate, Y.DateFrom, Y.DateTo, Y.DesignationMaterialTypeId, Y.LocationId, Y.Attribute, Y.Value
		FROM dbo.GetBhpbioReportActualY(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, @iChildLocations) AS Y
			INNER JOIN dbo.GetBhpbioReportHighGrade() AS hg
				ON (Y.DesignationMaterialTypeId = hg.MaterialTypeId)
			
		SELECT CalendarDate, LocationId AS ParentLocationId, DateFrom, DateTo, MaterialTypeId, Value AS Tonnes
		FROM @ExpitToStockpile
		WHERE Attribute = 0
		
		SELECT CalendarDate, LocationId AS ParentLocationId, Attribute As GradeId,
			MaterialTypeId, G.Grade_Name As GradeName, ISNULL(Value, 0.0) As GradeValue
		FROM @ExpitToStockpile AS ETS
			INNER JOIN dbo.Grade AS G
				ON (ETS.Attribute = G.Grade_Id)
		WHERE ETS.Attribute > 0
	
		-- if we started a new transaction that istill valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataActualExpitToStockpile TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataActualExpitToStockpile
	@iDateFrom = '1-apr-2008', 
	@iDateTo = '30-apr-2008', 
	@iDateBreakdown = NULL,
	@iLocationId = 6,
	@iChildLocations = 1
*/



GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataActualStockpileToCrusher.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataActualStockpileToCrusher') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataActualStockpileToCrusher 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataActualStockpileToCrusher
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @StockpileToCrusher TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		MaterialTypeId INT NOT NULL,
		LocationId INT NULL,
		Attribute INT NULL,
		Value FLOAT NULL
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataActualStockpileToCrusher',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @StockpileToCrusher
			(CalendarDate, DateFrom, DateTo, MaterialTypeId, LocationId, Attribute, Value)
		SELECT CalendarDate, DateFrom, DateTo, DesignationMaterialTypeId, LocationId, Attribute, Value
		FROM dbo.GetBhpbioReportActualZ(@iDateFrom, @iDateTo, @iDateBreakdown, @iLocationId, @iChildLocations)
			
		SELECT CalendarDate, LocationId AS ParentLocationId, DateFrom, DateTo, MaterialTypeId, Value AS Tonnes
		FROM @StockpileToCrusher
		WHERE Attribute = 0
		
		SELECT CalendarDate, LocationId AS ParentLocationId, Attribute As GradeId,
			MaterialTypeId, G.Grade_Name As GradeName, ISNULL(Value, 0.0) As GradeValue
		FROM @StockpileToCrusher AS STC
			INNER JOIN dbo.Grade AS G
				ON (STC.Attribute = G.Grade_Id)
		WHERE STC.Attribute > 0

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataActualStockpileToCrusher TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataActualStockpileToCrusher
	@iDateFrom = '1-apr-2008', 
	@iDateTo = '30-apr-2008', 
	@iDateBreakdown = NULL,
	@iLocationId = 6,
	@iChildLocations = 1
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataPortStockpileDelta.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataPortStockpileDelta') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataPortStockpileDelta 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataPortStockpileDelta
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @PortDelta TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		ParentLocationId INT NULL,
		LastBalanceDate DATETIME NULL,
		Tonnes FLOAT NULL,
		LastTonnes FLOAT NULL
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataPortStockpileDelta',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, NULL)
		
		INSERT INTO @PortDelta
			(CalendarDate, DateFrom, DateTo, ParentLocationId, LastBalanceDate, Tonnes, LastTonnes)
		SELECT B.CalendarDate, B.DateFrom, B.DateTo, L.ParentLocationId, BPBPREV.BalanceDate, Sum(BPB.Tonnes), Sum(BPBPREV.Tonnes)
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.BhpbioPortBalance AS BPB
				ON (BPB.BalanceDate = B.DateTo)
			INNER JOIN @Location AS L
				ON (BPB.HubLocationId = L.LocationId)
			LEFT JOIN dbo.BhpbioPortBalance AS BPBPREV
				ON (BPBPREV.BalanceDate = DateAdd(Day, -1, B.DateFrom)
					And BPB.HubLocationId = BPBPREV.HubLocationId)
		GROUP BY B.CalendarDate, B.DateFrom, B.DateTo, BPBPREV.BalanceDate, L.ParentLocationId
		
		SELECT CalendarDate, DateFrom, DateTo, NULL As MaterialTypeId, ParentLocationId,
			Coalesce(Tonnes - LastTonnes, 0) AS Tonnes
		FROM @PortDelta		
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataPortStockpileDelta TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataPortStockpileDelta
	@iDateFrom = '1-apr-2008', 
	@iDateTo = '30-apr-2008', 
	@iDateBreakdown = 'MONTH',
	@iLocationId = 4,
	@iLocationBreakdown = 'SITE'
*/
--exec dbo.GetBhpbioReportDataPortStockpileDelta @iDateFrom='2008-04-01 00:00:00',@iDateTo='2008-04-30 00:00:00',@iDateBreakdown=NULL,@iLocationId=1,@iLocationBreakdown='ChildLocations'


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataPortBlendedAdjustment.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataPortBlendedAdjustment') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataPortBlendedAdjustment 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataPortBlendedAdjustment
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @Blending TABLE
	(
		CalendarDate DATETIME,
		DateFrom DATETIME,
		DateTo DATETIME,
		BhpbioPortBlendingId INT,
		ParentLocationId INT,
		Tonnes FLOAT,
		Removal BIT
	)
		
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataPortBlendedAdjustment',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, 'SITE')

		INSERT INTO @Blending
			(CalendarDate, DateFrom, DateTo, BhpbioPortBlendingId, ParentLocationId, Tonnes, Removal)
		SELECT B.CalendarDate, B.DateFrom, B.DateTo, BPB.BhpbioPortBlendingId,
			L.ParentLocationId, BPB.Tonnes, CASE WHEN BPB.DestinationHubLocationId = L.LocationId THEN 0 ELSE 1 END
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.BhpbioPortBlending AS BPB
				ON (BPB.StartDate >= B.DateFrom
					AND BPB.EndDate <= DateAdd(Second, 59, DateAdd(Minute, 59, DateAdd(Hour, 23, B.DateTo))))
			INNER JOIN @Location AS L
				ON (BPB.DestinationHubLocationId = L.LocationId OR BPB.LoadSiteLocationId = L.LocationId)
		
		-- Obtain the Port Blending tonnes
		SELECT B.CalendarDate, B.DateFrom, B.DateTo, B.ParentLocationId, NULL AS MaterialTypeId,
			Sum(CASE WHEN B.Removal = 0 THEN B.Tonnes ELSE -B.Tonnes END) AS Tonnes
		FROM @Blending AS B
		GROUP BY B.CalendarDate, B.DateFrom, B.DateTo, B.ParentLocationId
		
		-- Obtain the Port Blending Grades
		SELECT B.CalendarDate, G.Grade_Name AS GradeName, B.ParentLocationId, NULL AS MaterialTypeId,
			SUM(B.Tonnes * BPBG.GradeValue) / NULLIF(SUM(B.Tonnes), 0) AS GradeValue
		FROM @Blending AS B
			CROSS JOIN dbo.Grade AS G
			INNER JOIN dbo.BhpbioPortBlendingGrade AS BPBG
				ON (BPBG.BhpbioPortBlendingId = B.BhpbioPortBlendingId
					AND BPBG.GradeId = G.Grade_Id)
		GROUP BY B.CalendarDate, B.ParentLocationId, G.Grade_Name
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataPortBlendedAdjustment TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataPortBlendedAdjustment
	@iDateFrom = '1-apr-2008', 
	@iDateTo = '30-apr-2008', 
	@iDateBreakdown = 'MONTH',
	@iLocationId = 4,
	@iLocationBreakdown = NULL--'SITE'
	
exec dbo.GetBhpbioReportDataPortBlendedAdjustment @iDateFrom='2008-04-01 00:00:00',@iDateTo='2008-04-30 00:00:00',@iDateBreakdown=NULL,@iLocationId=1,@iLocationBreakdown='ChildLocations'
*/

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataPortOreShipped.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataPortOreShipped') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataPortOreShipped 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataPortOreShipped
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataPortOreShipped',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, NULL)

		-- Obtain the Shipping tonnes
		SELECT B.CalendarDate, B.DateFrom, B.DateTo, NULL AS MaterialTypeId,
			L.ParentLocationId, SUM(S.Tonnes) AS Tonnes
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.BhpbioShippingTransactionNomination AS S
				ON (S.OfficialFinishTime >= B.DateFrom
					AND S.OfficialFinishTime <= DateAdd(Second, 59, DateAdd(Minute, 59, DateAdd(Hour, 23, B.DateTo))))
			INNER JOIN @Location AS L
				ON (S.HubLocationId = L.LocationId)
		GROUP BY B.CalendarDate, B.DateFrom, B.DateTo, L.ParentLocationId
		
		
		-- Obtain the Shipping Grades
		SELECT B.CalendarDate, G.Grade_Name AS GradeName, G.Grade_Id AS GradeId, NULL AS MaterialTypeId,
			L.ParentLocationId, Coalesce(SUM(SG.GradeValue * S.Tonnes) / NullIf(SUM(Tonnes), 0), 0) AS GradeValue
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.BhpbioShippingTransactionNomination AS S
				ON (S.OfficialFinishTime >= B.DateFrom
					AND S.OfficialFinishTime <= DateAdd(Second, 59, DateAdd(Minute, 59, DateAdd(Hour, 23, B.DateTo))))
			INNER JOIN @Location AS L
				ON (S.HubLocationId = L.LocationId)
			CROSS JOIN dbo.Grade AS G
			LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS SG
				ON (S.BhpbioShippingTransactionNominationId = SG.BhpbioShippingTransactionNominationId
					AND G.Grade_Id = SG.GradeId)
		GROUP BY B.CalendarDate, G.Grade_Name, G.Grade_Id, L.ParentLocationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataPortOreShipped TO BhpbioGenericManager
GO

/*
EXEC dbo.GetBhpbioReportDataPortOreShipped
	@iDateFrom = '1-apr-2008', 
	@iDateTo = '30-apr-2008', 
	@iDateBreakdown = 'MONTH',
	@iLocationId = 4,
	@iLocationBreakdown = 'SITE'
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataHistorical.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataHistorical') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataHistorical
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataHistorical
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	-- Provides a list of Tags, Tonnes and Grades for the requested period
	-- This is generated by querying directly from (and aggregating content from) dbo.BhpbioReportDataHistorical
	--
	-- Works based on the following assumptions:
	-- 1. The underlying tables has NO gaps in the data for HistoricalStartDate <= x <= SystemStartDate
	--    This applies independantly for MONTH and QUARTER.
	-- 2. That you never want to "aggregate" MONTH and QUARTER results; always return the results independently
	-- 3. The dates requested must make sense (i.e. fall on a month/quarter period)
	--    i.e. when MONTH then first-day-of-month-from to last-day-of-month-to (i.e. 01-JAN to 31-JAN)
	--         when QUARTER then then first-day-of-quarter-from to last-day-of-quarter-to  (i.e. 01-JAN to 31-MAR)
	--         when YEAR - this is simply mapped back to a quarter
	-- 4. No fancy fall-backs to mixing QUARTER and MONTH data.
	--    It is acknowledged that the MONTH data is incomplete and this is OK.
	-- 5. All content returned can be mass-aggregated; FxFACTOR tags are explicitly removed for this reason.
	--    All of this content will be further manipulated within the consuming calculation classes.

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @DataBreakdown VARCHAR(31)
	DECLARE @SystemStartDate DATETIME
	DECLARE @LocationTypeId INT
	DECLARE @LocationTypeDescription VARCHAR(31)
	SET @LocationTypeDescription = 'Pit'
		
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataHistorical',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- validate that the FROM/TO date is valid
		IF DAY(@iDateFrom) <> 1
		BEGIN
			RAISERROR('The From Date must be the first day of the month.', 16, 1)
		END
		IF DAY(@iDateTo+1) <> 1
		BEGIN
			RAISERROR('The To Date must be the last day of the month.', 16, 1)
		END

		SET @SystemStartDate =
			(
				SELECT Cast(Value AS DATETIME)
				FROM dbo.Setting 
				WHERE Setting_Id = 'SYSTEM_START_DATE'
			)

		-- if no Date Breakdown is specified then default the Data Breakdown to month
		-- although quaterly data is generally available it's a hit-and-miss exercise of data appearing / not appearing
		-- based on the dates selected.  it has been decided to "keep it consistent" by forcing it to Month
		-- note that the Date Breakdown and the Data Breakdown are different concepts;
		-- Date Breakdown represents how we want the output results to look.  One record?  By Month?  By Quarter?
		-- Data Breakdown represents at what level the data is stored at
		SET @DataBreakdown = @iDateBreakdown
		IF @DataBreakdown IS NULL
		BEGIN
			-- default to MONTH
			SET @DataBreakdown = 'MONTH'
			-- if the requested dates are QUARTER compatible then use this instead
			IF (MONTH(@iDateFrom) IN (1, 4, 7, 10)) AND (MONTH(@iDateTo) IN (3, 6, 9, 12))
			BEGIN
				SET @DataBreakdown = 'QUARTER'
			END	
		END
		ELSE IF @DataBreakdown = 'YEAR'
		BEGIN
			SET @DataBreakdown = 'QUARTER'
		END
				
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, @LocationTypeDescription)

		-- remove any locaitons which have thier parent already listed
		DELETE AL
		FROM @Location AS AL	
			INNER JOIN dbo.Location AS L
				ON (L.Location_Id = AL.LocationId)
			INNER JOIN (
						SELECT IHD.LocationId 
						FROM dbo.BhpbioReportDataHistorical AS IHD
							INNER JOIN @Location AS IL
								ON (IL.LocationId = IHD.LocationId)
						GROUP BY IHD.LocationId
						) AS HL
				ON (L.Parent_Location_Id = HL.LocationId)

		SELECT his.TagId AS CalcId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, 
			his.MaterialTypeId, SUM(Tonnes) AS Tonnes
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 0) AS b
			INNER JOIN dbo.BhpbioReportDataHistorical AS his
				ON (his.DateBreakdown = @DataBreakdown
					AND his.DateFrom >= b.DateFrom
					AND his.DateTo <= b.DateTo)
			INNER JOIN @Location AS l
				ON (l.LocationId = his.LocationId)
			LEFT JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = his.MaterialTypeId) 
		WHERE his.DateTo < @SystemStartDate
			AND (MT.Description <> 'Bene Product' OR MT.Description IS NULL)
			-- explicitly REMOVE the Factor based entries as they won't make sense in the output (they can't be aggregated)
			AND his.TagId NOT IN ('F1Factor', 'F2Factor', 'F3Factor')
		GROUP BY his.TagId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, his.MaterialTypeId

		SELECT his.TagId AS CalcId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, 
			his.MaterialTypeId, SUM(his.Tonnes) AS Tonnes, g.Grade_Name AS GradeName,
			SUM
			(
				CASE
					WHEN g.Grade_Name = 'Al2O3' THEN his.Al2O3 * his.Tonnes
					WHEN g.Grade_Name = 'Fe' THEN his.Fe * his.Tonnes
					WHEN g.Grade_Name = 'LOI' THEN his.LOI * his.Tonnes
					WHEN g.Grade_Name = 'SiO2' THEN his.SiO2 * his.Tonnes
					WHEN g.Grade_Name = 'P' THEN his.P * his.Tonnes
					ELSE NULL
				END
			) / NULLIF(SUM(his.Tonnes), 0.0) As GradeValue
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 0) AS B
			INNER JOIN dbo.BhpbioReportDataHistorical AS his
				ON (his.DateBreakdown = @DataBreakdown
					AND his.DateFrom >= b.DateFrom
					AND his.DateTo <= b.DateTo)
			INNER JOIN @Location AS l
				ON (l.LocationId = his.LocationId)
			LEFT JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = his.MaterialTypeId) 
			CROSS JOIN dbo.Grade AS g
		WHERE his.DateTo < @SystemStartDate
			AND (mt.Description <> 'Bene Product' OR mt.Description IS NULL)
			-- explicitly REMOVE the Factor based entries as they won't make sense in the output (they can't be aggregated)
			AND his.TagId NOT IN ('F1Factor', 'F2Factor', 'F3Factor')
		GROUP BY his.TagId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, his.MaterialTypeId, g.Grade_Name

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataHistorical TO BhpbioGenericManager
GO

-- TEST
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '31-mar-2007', null, null, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '1-jan-2007', 'MONTH', 7, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '31-mar-2008', 'QUARTER', 6, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2005', '1-jan-2009', 'YEAR', 7, null
--exec dbo.GetBhpbioReportDataHistorical @iDateFrom='Jan  1 1998 12:00:00:000AM',@iDateTo='Dec 31 2009 12:00:00:000AM',@iDateBreakdown='YEAR',@iLocationId=6,@iChildLocations=0
--exec dbo.GetBhpbioReportDataHistorical @iDateFrom='2009-01-01 00:00:00',@iDateTo='2009-12-31 00:00:00',@iDateBreakdown=NULL,@iLocationId=6,@iChildLocations=0

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataReview.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataReview') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataReview
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataReview 
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iLocationId INT,
	@iTagId VARCHAR(124)
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	DECLARE @PostCrusherStockpileGroupId VARCHAR(31)
	SET @PostCrusherStockpileGroupId = 'Post Crusher'
	DECLARE @MaterialCategory VARCHAR(31)
	SET @MaterialCategory = 'Designation'
	
	DECLARE @HubLocationTypeId INT
	DECLARE @SiteLocationTypeId INT

	DECLARE @StockpileDeltaHub TABLE
	(
		StockpileId INT NOT NULL,
		WeightometerSampleId INT NOT NULL,
		Tonnes FLOAT NOT NULL,
		LocationId INT NULL,
		Addition BIT NOT NULL,
		Hub VARCHAR(31) COLLATE DATABASE_DEFAULT
	)
	
	DECLARE @StockpileDeltaSite TABLE
	(
		StockpileId INT NOT NULL,
		WeightometerSampleId INT NOT NULL,
		Tonnes FLOAT NOT NULL,
		LocationId INT NULL,
		Addition BIT NOT NULL,
		Site VARCHAR(31) COLLATE DATABASE_DEFAULT
	)
				
	DECLARE @StockpileGroupId VARCHAR(31)
	DECLARE @HighGradeMaterialTypeId INT
	DECLARE @BeneFeedMaterialTypeId INT
	DECLARE @SampleTonnesField VARCHAR(31)
	DECLARE @SampleSourceField VARCHAR(31)
	
	SET @SampleTonnesField = 'SampleTonnes'
	SET @SampleSourceField = 'SampleSource'
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @HighGradeStockpileGroup TABLE
	(
		StockpileGroupId VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		PRIMARY KEY (StockpileGroupId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataReview',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		SET @HighGradeMaterialTypeId =
			(
				SELECT Material_Type_Id
				FROM dbo.MaterialType
				WHERE Abbreviation = 'High Grade'
					AND Material_Category_Id = 'Designation'
			)

		SET @BeneFeedMaterialTypeId = 
			(
				SELECT Material_Type_Id
				FROM dbo.MaterialType
				WHERE Abbreviation = 'Bene Feed'
					AND Material_Category_Id = 'Designation'
			)

		INSERT INTO @Location
			(LocationId)
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)
		
		INSERT INTO @HighGradeStockpileGroup
			(StockpileGroupId, MaterialTypeId)
		SELECT SGD.StockpileGroupId, MT.Material_Type_Id
		FROM dbo.MaterialType AS MT
			INNER JOIN dbo.BhpbioStockpileGroupDesignation AS SGD
				ON (MT.Material_Type_Id = SGD.MaterialTypeId)
		WHERE MT.Material_Category_Id = @MaterialCategory
			AND MT.Material_Type_Id IN (Select MaterialTypeId FROM dbo.GetBhpbioReportHighGrade())
			

		IF @iTagId LIKE '%MODEL'
		BEGIN
			SELECT BM.Name,  
				RM.DateFrom, RM.DateTo, MT.Description As MaterialType, MinedPercentage, MBP.Tonnes As BlockTonnes, 
				MBP.Tonnes * MinedPercentage As TonnesMoved, 
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, 
				Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI,
				RM.BlockNumber, RM.BlockName, RM.Site, RM.OreBody, RM.Pit, RM.Bench, RM.PatternNumber
			FROM dbo.BhpbioImportReconciliationMovement AS RM
				INNER JOIN @Location AS L
					ON (L.LocationId = RM.BlockLocationId)
				INNER JOIN dbo.ModelBlockLocation AS MBL
					ON (L.LocationId = MBL.Location_Id)
				INNER JOIN dbo.ModelBlock AS MB
					ON (MBL.Model_Block_Id = MB.Model_Block_Id)
				INNER JOIN dbo.BlockModel AS BM
					ON (BM.Block_Model_Id = MB.Block_Model_Id)
				INNER JOIN dbo.ModelBlockPartial AS MBP
					ON (MB.Model_Block_Id = MBP.Model_Block_Id)
				INNER JOIN dbo.GetMaterialsByCategory('Designation') AS MC
					ON (MC.MaterialTypeId = MBP.Material_Type_Id)
				INNER JOIN dbo.MaterialType AS MT
					ON (MC.RootMaterialTypeId = MT.Material_Type_Id)
				INNER JOIN dbo.GetBhpbioReportHighGrade() AS BRHG
					ON (BRHG.MaterialTypeId = MT.Material_Type_Id)
				LEFT JOIN dbo.ModelBlockPartialGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Model_Block_Id = MBP.Model_Block_Id AND FE.Sequence_No = MBP.Sequence_No)
				LEFT JOIN dbo.ModelBlockPartialGrade AS P
					ON (P.Grade_Id = 2 AND P.Model_Block_Id = MBP.Model_Block_Id AND P.Sequence_No = MBP.Sequence_No)
				LEFT JOIN dbo.ModelBlockPartialGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Model_Block_Id = MBP.Model_Block_Id AND SiO2.Sequence_No = MBP.Sequence_No)
				LEFT JOIN dbo.ModelBlockPartialGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Model_Block_Id = MBP.Model_Block_Id AND Al2O3.Sequence_No = MBP.Sequence_No)
				LEFT JOIN dbo.ModelBlockPartialGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Model_Block_Id = MBP.Model_Block_Id AND LOI.Sequence_No = MBP.Sequence_No)
			WHERE (RM.DateFrom >= @iDateFrom
				AND RM.DateTo <= @iDateTo)
				AND (CASE WHEN @iTagId Like '%GeologyModel%' AND BM.Name <> 'Geology' THEN 0
					 WHEN @iTagId Like '%MiningModel%' AND BM.Name <> 'Mining' THEN 0
					 WHEN @iTagId Like '%GradeControlModel%' AND BM.Name <> 'Grade Control' THEN 0
					 ELSE 1 END = 1)
		END
		ELSE IF @iTagId LIKE '%MineProductionActuals' --C
		BEGIN
		
			DECLARE @Weightometer TABLE
			(
				CalendarDate DATETIME NOT NULL,
				WeightometerSampleId INT NOT NULL,
				DateFrom DATETIME NOT NULL,
				DateTo DATETIME NOT NULL,
				ParentLocationId INT NULL,
				RealTonnes FLOAT NOT NULL,
				SampleTonnes FLOAT NOT NULL,
				DesignationMaterialTypeId INT NOT NULL,
				PRIMARY KEY (WeightometerSampleId, CalendarDate)
			)
		
		
		-- retrieve the list of Weightometer Records to be used in the calculations
		INSERT INTO @Weightometer
			(CalendarDate, DateFrom, DateTo, WeightometerSampleId, ParentLocationId, RealTonnes, SampleTonnes, DesignationMaterialTypeId)
		SELECT b.CalendarDate, b.DateFrom, b.DateTo, w.WeightometerSampleId, LocationId,
			-- calculate the REAL tonnes
			CASE
				WHEN w.UseAsRealTonnes = 1
					THEN ISNULL(ws.Corrected_Tonnes, ws.Tonnes)
				ELSE 0.0
			END AS RealTonnes,
			-- calculate the SAMPLE tonnes
			-- if a sample tonnes hasn't been provided then use the actual tonnes recorded for the transaction
			-- not all flows will have this recorded (in particular CVF corrected plant balanced records)
			CASE BeneFeed
				WHEN 1 THEN ISNULL(ws.Corrected_Tonnes, ws.Tonnes)
				ELSE ISNULL(wsv.Field_Value, 0.0)
			END AS SampleTonnes,
			-- return the Material Type based on whether it is bene feed
			CASE w.BeneFeed
				WHEN 1 THEN @BeneFeedMaterialTypeId
				WHEN 0 THEN @HighGradeMaterialTypeId
			END AS MaterialTypeId
		FROM dbo.GetBhpbioReportBreakdown(NULL, @iDateFrom, @iDateTo, 1) AS b
			INNER JOIN dbo.WeightometerSample AS ws
				ON (ws.Weightometer_Sample_Date BETWEEN b.DateFrom AND b.DateTo)
			INNER JOIN
				(
					-- collect the weightometer sample id's for all movements from the crusher
					-- these are used to ease lookup and ensure uniqueness of the weightometer_sample_ids returned
					SELECT dttf.Weightometer_Sample_Id AS WeightometerSampleId, 1 AS UseAsRealTonnes,
						CASE
							WHEN m.Mill_Id IS NOT NULL
								THEN 1
							ELSE 0
						END AS BeneFeed
					FROM dbo.DataTransactionTonnes AS dtt
						INNER JOIN dbo.DataTransactionTonnesFlow AS dttf
							ON (dttf.Data_Transaction_Tonnes_Id = dtt.Data_Transaction_Tonnes_Id)
						INNER JOIN dbo.CrusherLocation AS cl
							ON (dttf.Source_Crusher_Id = cl.Crusher_Id)
						LEFT JOIN dbo.Mill AS m
							ON (dttf.Destination_Stockpile_Id = m.Stockpile_Id)
						INNER JOIN @Location AS l
							ON (cl.Location_Id = l.LocationId)
					WHERE dtt.Data_Transaction_Tonnes_Date BETWEEN @iDateFrom AND @iDateTo
						AND dttf.Destination_Crusher_Id IS NULL  -- ignore crusher to crusher feeds
					GROUP BY dttf.Weightometer_Sample_Id, m.Mill_Id
					UNION 
					-- collect weightometer sample id's for all movements to train rakes
					-- (by definition it's always delivers to train rake stockpiles...
					--  the grades (but not the tonnes) from these weightometers samples are important to us)
					SELECT dttf.Weightometer_Sample_Id, 0, 0
					FROM dbo.DataTransactionTonnes AS dtt
						INNER JOIN dbo.DataTransactionTonnesFlow AS dttf
							ON (dttf.Data_Transaction_Tonnes_Id = dtt.Data_Transaction_Tonnes_Id)
						INNER JOIN dbo.WeightometerSample AS ws
							ON (dttf.Weightometer_Sample_Id = ws.Weightometer_Sample_Id)
						INNER JOIN dbo.StockpileGroupStockpile AS sgs
							ON (sgs.Stockpile_Id = dttf.Destination_Stockpile_Id)
						INNER JOIN dbo.WeightometerLocation AS wl
							ON (ws.Weightometer_Id = wl.Weightometer_Id)
						INNER JOIN @Location AS l
							ON (wl.Location_Id = l.LocationId)
					WHERE dtt.Data_Transaction_Tonnes_Date BETWEEN @iDateFrom AND @iDateTo
						AND sgs.Stockpile_Group_Id = 'Port Train Rake'
					GROUP BY dttf.Weightometer_Sample_Id
				  ) AS w
				ON (ws.Weightometer_Sample_Id = w.WeightometerSampleId)
				-- ensure the weightometer belongs to the required location
			INNER JOIN dbo.WeightometerLocation AS wl
				ON (wl.Weightometer_Id = ws.Weightometer_Id)
			INNER JOIN @Location AS l
				ON (l.LocationId = wl.Location_Id)
			LEFT OUTER JOIN dbo.WeightometerSampleValue AS wsv
				ON (ws.Weightometer_Sample_Id = wsv.Weightometer_Sample_Id
					AND wsv.Weightometer_Sample_Field_Id = @SampleTonnesField)


		SELECT WS.Weightometer_Id, WeightometerSampleId, Weightometer_Sample_Date, MT.Description, WFP.Source_Crusher_Id,
			SampleTonnes, RealTonnes, SampleSource, Fe, P, SiO2, Al2O3, LOI, ParentLocationId, S.Stockpile_Name AS Destination_Stockpile
		FROM (
			SELECT WeightometerSampleId, DesignationMaterialTypeId, ParentLocationId, NULL As SampleTonnes, RealTonnes, NULL As SampleSource, NULL AS Fe, NULL AS P, NULL AS SiO2, NULL As Al2O3, NULL As LOI
			FROM @Weightometer
			WHERE RealTonnes <> 0
			UNION ALL
			SELECT W.WeightometerSampleId, w.DesignationMaterialTypeId,
				w.ParentLocationId, w.SampleTonnes, NULL, sSource.SampleSource, 
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI
				
				
			FROM @Weightometer AS w
				-- check the membership with the Sample Source
				LEFT OUTER JOIN
					(
						SELECT ws.Weightometer_Sample_Id, ss.SampleSource
						FROM dbo.WeightometerSample AS ws
							INNER JOIN dbo.WeightometerLocation AS wl
								ON (ws.Weightometer_Id = wl.Weightometer_Id)
							INNER JOIN dbo.WeightometerSampleNotes AS wsn
								ON (wsn.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
									AND wsn.Weightometer_Sample_Field_Id = @SampleSourceField)
							INNER JOIN dbo.GetBhpbioWeightometerSampleSource(@iLocationId, @iDateFrom, @iDateTo) AS ss
								ON (dbo.GetDateMonth(ws.Weightometer_Sample_Date) = ss.MonthPeriod
									AND wl.Location_Id = ss.LocationId
									AND wsn.Notes = ss.SampleSource)
					) AS sSource
					ON (sSource.Weightometer_Sample_Id = w.WeightometerSampleId)
				-- add the grades
				LEFT JOIN dbo.WeightometerSampleGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Weightometer_Sample_Id = W.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerSampleGrade AS P
					ON (P.Grade_Id = 2 AND P.Weightometer_Sample_Id = W.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerSampleGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Weightometer_Sample_Id = W.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerSampleGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Weightometer_Sample_Id = W.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerSampleGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Weightometer_Sample_Id = W.WeightometerSampleId)			
						
			WHERE
			-- only include if:
			-- 1. the Material Type is Bene Feed and there is no Sample Source
			-- 2. the Material Type is High Grade and there is a matching SampleSource
			CASE
				WHEN (DesignationMaterialTypeId = @BeneFeedMaterialTypeId) AND (sSource.Weightometer_Sample_Id IS NULL) THEN 1
				WHEN (DesignationMaterialTypeId = @HighGradeMaterialTypeId) AND (sSource.Weightometer_Sample_Id IS NOT NULL) THEN 1
				ELSE 0
			END = 1
			) AS VALUE
				INNER JOIN dbo.WeightometerSample AS WS
					ON (WS.Weightometer_Sample_Id = VALUE.WeightometerSampleId)
				INNER JOIN dbo.MaterialType AS MT
					ON (MT.Material_Type_Id = VALUE.DesignationMaterialTypeId)
				LEFT JOIN dbo.WeightometerFlowPeriod AS WFP
					ON (WFP.Weightometer_Id = WS.Weightometer_Id)
				LEFT JOIN dbo.Stockpile AS S
					ON (S.Stockpile_Id = ws.Destination_Stockpile_Id)
					
		END
		ELSE IF @iTagId LIKE '%ExPitToOreStockpile' --y
		BEGIN
			SELECT H.Haulage_Id, H.Haulage_Date, H.Tonnes, S.Stockpile_Name As Destination_Stockpile, 
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI,
				SGS.Stockpile_Group_Id AS Destination_Stockpile_Group, H.Source_Digblock_Id,
				L.LocationId As Location_Id --, '--' As [--], *
			FROM dbo.Haulage AS H
				INNER JOIN dbo.DigblockLocation AS DL
					ON (DL.Digblock_Id = H.Source_Digblock_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = DL.Location_Id)
				INNER JOIN dbo.Stockpile AS S
					ON (H.Destination_Stockpile_Id = S.Stockpile_Id)
				INNER JOIN dbo.StockpileGroupStockpile AS SGS
					ON (SGS.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN @HighGradeStockpileGroup AS HGSG
					ON (SGS.Stockpile_Group_Id = HGSG.StockpileGroupId)
				LEFT JOIN dbo.HaulageGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS P
					ON (P.Grade_Id = 2 AND P.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Haulage_Id = H.Haulage_Id)
				WHERE H.Haulage_Date >= @iDateFrom AND H.Haulage_Date <= @iDateTo
					AND H.Source_Digblock_Id IS NOT NULL
					AND h.Haulage_State_Id IN ('N', 'A')
					AND h.Child_Haulage_Id IS NULL
		END
		ELSE IF @iTagId LIKE '%StockpileToCrusher' -- z
		BEGIN
			SELECT H.Haulage_Id, H.Haulage_Date, H.Tonnes, 
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI,
				H.Destination_Crusher_Id, MT.Material_Type_Id, MT.Description,
				L.LocationId As Location_Id, WFPV.Destination_Mill_Id
			FROM dbo.Haulage AS H
				INNER JOIN dbo.Crusher AS C
					ON (C.Crusher_Id = H.Destination_Crusher_Id)
				INNER JOIN dbo.CrusherLocation AS CL
					ON (CL.Crusher_Id = C.Crusher_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = CL.Location_Id)
				LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
					ON (WFPV.Source_Crusher_Id = c.Crusher_Id
						AND WFPV.Destination_Mill_Id IS NOT NULL
						AND (@iDateTo > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
						AND (@iDateFrom < WFPV.End_Date Or WFPV.End_Date IS NULL))
				LEFT JOIN dbo.Weightometer AS W
					ON (W.Weightometer_Id = WFPV.Weightometer_Id)
				LEFT JOIN dbo.MaterialType AS MT
					ON (MT.Material_Type_Id = CASE WHEN W.Weightometer_Id IS NOT NULL THEN @BeneFeedMaterialTypeId ELSE @HighGradeMaterialTypeId END)
				LEFT JOIN dbo.HaulageGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS P
					ON (P.Grade_Id = 2 AND P.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Haulage_Id = H.Haulage_Id)
				LEFT JOIN dbo.HaulageGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Haulage_Id = H.Haulage_Id)
			WHERE H.Haulage_Date >= @iDateFrom AND H.Haulage_Date <= @iDateTo
				AND h.Haulage_State_Id IN ('N', 'A')
				AND h.Child_Haulage_Id IS NULL
				AND (W.Weightometer_Type_Id LIKE '%L1%' OR W.Weightometer_Type_Id IS NULL)
				AND h.Source_Stockpile_Id IS NOT NULL
				
		END
		ELSE IF @iTagId LIKE '%OreShipped'
		BEGIN
			Select L.Name As LocationName, S.OfficialFinishTime AS CalendarDate, S.Tonnes, S.ProductCode, 
			S.CustomerNo, L.Location_Id, Fe.GradeValue As Fe, P.GradeValue As P, SiO2.GradeValue As SiO2, 
			Al2O3.GradeValue As Al2O3, LOI.GradeValue As LOI --, '--' As [--], *
			From dbo.BhpbioShippingTransactionNomination AS S
				INNER JOIN dbo.Location AS L
					ON L.Location_Id = S.HubLocationId
				INNER JOIN @Location AS FL
					ON L.Location_Id = FL.LocationId
				LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS FE
					ON (FE.GradeId = 1 AND FE.BhpbioShippingTransactionNominationId = S.BhpbioShippingTransactionNominationId)
				LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS P
					ON (P.GradeId = 2 AND P.BhpbioShippingTransactionNominationId = S.BhpbioShippingTransactionNominationId)
				LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS SiO2
					ON (SiO2.GradeId = 3 AND SiO2.BhpbioShippingTransactionNominationId = S.BhpbioShippingTransactionNominationId)
				LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS Al2O3
					ON (Al2O3.GradeId = 4 AND Al2O3.BhpbioShippingTransactionNominationId = S.BhpbioShippingTransactionNominationId)
				LEFT JOIN dbo.BhpbioShippingTransactionNominationGrade AS LOI
					ON (LOI.GradeId = 5 AND LOI.BhpbioShippingTransactionNominationId = S.BhpbioShippingTransactionNominationId)
			WHERE S.OfficialFinishTime BETWEEN @iDateFrom AND DateAdd(Second, 59, DateAdd(Minute, 59, DateAdd(Hour, 23, @iDateTo)))
			Order By S.OfficialFinishTime
		END
		ELSE IF @iTagId LIKE '%HubPostCrusherStockpileDelta'
		BEGIN
			
			DELETE FROM @Location
		
			INSERT INTO @Location
				(LocationId, ParentLocationId)
			SELECT LocationId, ParentLocationId
			FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, 0, 'site')
		
			SELECT @HubLocationTypeId = Location_Type_Id
			FROM dbo.LocationType
			WHERE Description = 'Hub'
			SELECT @SiteLocationTypeId = Location_Type_Id
			FROM dbo.LocationType
			WHERE Description = 'Site'

			SET @StockpileGroupId = 'Post Crusher'
			-- Get Removals
			INSERT INTO @StockpileDeltaHub
				(StockpileId, WeightometerSampleId, Addition, Tonnes,Hub)		
			SELECT S.Stockpile_Id, WS.Weightometer_Sample_Id, 0, WS.Tonnes, LL.Description
			FROM dbo.WeightometerSample AS WS
				INNER JOIN dbo.Stockpile AS S
					ON (S.Stockpile_Id = WS.Source_Stockpile_Id)
				INNER JOIN dbo.StockpileGroupStockpile AS SGS
					ON (SGS.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN dbo.StockpileLocation AS SL
					ON (SL.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = SL.Location_Id)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = SL.Location_Id)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.StockpileGroupStockpile SGS_D
					ON (SGS_D.Stockpile_Id = WS.Destination_Stockpile_Id
						AND SGS_D.Stockpile_Group_Id = @StockpileGroupId)
			WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
				AND SGS.Stockpile_Group_Id = @StockpileGroupId
				AND SGS_D.Stockpile_Group_Id IS NULL
				AND WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
							AND (LL.Location_Type_Id = @HubLocationTypeId OR
			(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))
			-- Get Additions
			INSERT INTO @StockpileDeltaHub
				(StockpileId, WeightometerSampleId, Addition, Tonnes,Hub)		
			SELECT S.Stockpile_Id, WS.Weightometer_Sample_ID, 1, WS.Tonnes, LL.Description
			FROM dbo.WeightometerSample AS WS
				INNER JOIN dbo.Stockpile AS S
					ON (S.Stockpile_Id = WS.Destination_Stockpile_Id)
				INNER JOIN dbo.StockpileGroupStockpile AS SGS
					ON (SGS.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN dbo.StockpileLocation AS SL
					ON (SL.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = SL.Location_Id)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = SL.Location_Id)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.StockpileGroupStockpile SGS_S
					ON (SGS_S.Stockpile_Id = WS.Source_Stockpile_Id
						AND SGS_S.Stockpile_Group_Id = @StockpileGroupId)
			WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
				AND SGS.Stockpile_Group_Id = @StockpileGroupId
				AND WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
				AND SGS_S.Stockpile_Group_Id IS NULL
							AND (LL.Location_Type_Id = @HubLocationTypeId OR
			(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))

			SELECT SD.WeightometerSampleId, WS.Weightometer_Sample_Date, CASE WHEN SD.Addition = 1 THEN SD.Tonnes ELSE -SD.Tonnes END AS MovementTonnes, 
				NULL As SampleTonnes, NULL As Fe, NULL As P, NULL As SiO2, NULL As Al2O3, NULL As LOI,
				SD.Addition, SD.Hub,WFPV.Source_Crusher_Id, WFPV.Source_Mill_Id As SourcePlant, SS.Stockpile_Name AS SourceStockpile, WFPV.Destination_Crusher_Id As DestinationCrusher, WFPV.Destination_Mill_Id As DestinationPlant, DS.Stockpile_Name AS DestinationStockpile
			FROM @StockpileDeltaHub AS SD
				INNER JOIN dbo.WeightometerSample AS WS
					ON (WS.Weightometer_Sample_Id = SD.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
					ON (WFPV.Weightometer_Id = WS.Weightometer_Id
						AND (WS.Weightometer_Sample_Date > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
						AND (WS.Weightometer_Sample_Date < WFPV.End_Date Or WFPV.End_Date IS NULL))	
				LEFT JOIN dbo.Stockpile AS SS
					ON (Coalesce(WFPV.Source_Stockpile_ID, WS.Source_Stockpile_Id) = SS.Stockpile_Id)
				LEFT JOIN dbo.Stockpile AS DS
					ON (Coalesce(WFPV.Destination_Stockpile_ID, WS.Destination_Stockpile_Id) = DS.Stockpile_Id)
			UNION ALL
			SELECT ws.Weightometer_Sample_Id, WS.Weightometer_Sample_Date, NULL AS MovementTonnes, WSV.Field_Value As SampleTonnes,
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI,
				NULL, LL.Description, WFPV.Source_Crusher_Id, WFPV.Source_Mill_Id As SourcePlant, SS.Stockpile_Name AS SourceStockpile, WFPV.Destination_Crusher_Id As DestinationCrusher, WFPV.Destination_Mill_Id As DestinationPlant, DS.Stockpile_Name AS DestinationStockpile
			FROM dbo.WeightometerSample AS ws
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (ws.Weightometer_Id = wl.Weightometer_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = wl.Location_Id)
				INNER JOIN dbo.WeightometerSampleNotes AS wsn
					ON (wsn.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
						AND wsn.Weightometer_Sample_Field_Id = @SampleSourceField)
			INNER JOIN dbo.WeightometerSampleValue AS wsv
				ON (wsv.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
					AND wsv.Weightometer_Sample_Field_Id = @SampleTonnesField)
				INNER JOIN dbo.GetBhpbioWeightometerSampleSource(@iLocationId, @iDateFrom, @iDateTo) AS wss
					ON (dbo.GetDateMonth(ws.Weightometer_Sample_Date) = wss.MonthPeriod
						AND L.LocationId = wss.LocationId
							AND wsn.Notes = wss.SampleSource)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = L.LocationId)
				LEFT JOIN dbo.WeightometerSampleGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS P
					ON (P.Grade_Id = 2 AND P.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
					ON (WFPV.Weightometer_Id = WS.Weightometer_Id
						AND (WS.Weightometer_Sample_Date > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
						AND (WS.Weightometer_Sample_Date < WFPV.End_Date Or WFPV.End_Date IS NULL))	
				LEFT JOIN dbo.Stockpile AS SS
					ON (WS.Source_Stockpile_Id = SS.Stockpile_Id)
				LEFT JOIN dbo.Stockpile AS DS
					ON (WS.Destination_Stockpile_Id = DS.Stockpile_Id)
			WHERE (LL.Location_Type_Id = @HubLocationTypeId OR 
				(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))
				AND Fe.Grade_Value IS NOT NULL
					
		END
		ELSE IF @iTagId LIKE '%SitePostCrusherStockpileDelta'
		BEGIN
			SET @StockpileGroupId = 'Post Crusher'
			SELECT @HubLocationTypeId = Location_Type_Id
			FROM dbo.LocationType
			WHERE Description = 'Hub'
			SELECT @SiteLocationTypeId = Location_Type_Id
			FROM dbo.LocationType
			WHERE Description = 'Site'
			
			-- Get Removals
			INSERT INTO @StockpileDeltaSite
				(StockpileId, WeightometerSampleId, Addition, Tonnes,Site)		
			SELECT S.Stockpile_Id, WS.Weightometer_Sample_Id, 0, WS.Tonnes, LL.Description
			FROM dbo.WeightometerSample AS WS
				INNER JOIN dbo.Stockpile AS S
					ON (S.Stockpile_Id = WS.Source_Stockpile_Id)
				INNER JOIN dbo.StockpileGroupStockpile AS SGS
					ON (SGS.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN dbo.StockpileLocation AS SL
					ON (SL.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = SL.Location_Id)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = SL.Location_Id)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.StockpileGroupStockpile SGS_D
					ON (SGS_D.Stockpile_Id = WS.Destination_Stockpile_Id
						AND SGS_D.Stockpile_Group_Id = @StockpileGroupId)
			WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
				AND SGS.Stockpile_Group_Id = @StockpileGroupId
				AND SGS_D.Stockpile_Group_Id IS NULL
				AND WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo			
				AND (LL.Location_Type_Id = @SiteLocationTypeId AND
			(BSLC.PromoteStockpiles = 0 OR BSLC.PromoteStockpiles IS NULL))
				AND WS.Weightometer_Id NOT LIKE '%Raw%'
			
			-- Get Additions
			INSERT INTO @StockpileDeltaSite
				(StockpileId, WeightometerSampleId, Addition, Tonnes, Site)		
			SELECT S.Stockpile_Id, WS.Weightometer_Sample_ID, 1, WS.Tonnes, LL.Description
			FROM dbo.WeightometerSample AS WS
				INNER JOIN dbo.Stockpile AS S
					ON (S.Stockpile_Id = WS.Destination_Stockpile_Id)
				INNER JOIN dbo.StockpileGroupStockpile AS SGS
					ON (SGS.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN dbo.StockpileLocation AS SL
					ON (SL.Stockpile_Id = S.Stockpile_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = SL.Location_Id)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = SL.Location_Id)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.StockpileGroupStockpile SGS_S
					ON (SGS_S.Stockpile_Id = WS.Source_Stockpile_Id
						AND SGS_S.Stockpile_Group_Id = @StockpileGroupId)
			WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
				AND SGS.Stockpile_Group_Id = @StockpileGroupId
				AND WS.Weightometer_Sample_Date BETWEEN @iDateFrom AND @iDateTo
				AND SGS_S.Stockpile_Group_Id IS NULL				
				AND (LL.Location_Type_Id = @SiteLocationTypeId AND
				(BSLC.PromoteStockpiles = 0 OR BSLC.PromoteStockpiles IS NULL))
				AND WS.Weightometer_Id NOT LIKE '%Raw%'

			SELECT SD.WeightometerSampleId, WS.Weightometer_Sample_Date, CASE WHEN SD.Addition = 1 THEN SD.Tonnes ELSE -SD.Tonnes END AS MovementTonnes, 
				Fe.Grade_Value As Fe, P.Grade_Value As P, SiO2.Grade_Value As SiO2, Al2O3.Grade_Value As Al2O3, LOI.Grade_Value As LOI,
				SD.Addition, SD.Site, WFPV.Source_Crusher_Id, DS.Stockpile_Name AS DestinationStockpile, SS.Stockpile_Name AS SourceStockpile --, DS.Stockpile_Name AS DestinationStockpile, S.Stockpile_Name, DTTF.Source_Crusher_Id, NULL AS Source_Stockpile_Name
			FROM @StockpileDeltaSite AS SD
				INNER JOIN dbo.WeightometerSample AS WS
					ON (WS.Weightometer_Sample_Id = SD.WeightometerSampleId)
				LEFT JOIN dbo.WeightometerSampleGrade AS FE
					ON (FE.Grade_Id = 1 AND FE.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS P
					ON (P.Grade_Id = 2 AND P.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS SiO2
					ON (SiO2.Grade_Id = 3 AND SiO2.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS Al2O3
					ON (Al2O3.Grade_Id = 4 AND Al2O3.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerSampleGrade AS LOI
					ON (LOI.Grade_Id = 5 AND LOI.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
				LEFT JOIN dbo.WeightometerFlowPeriodView AS WFPV
					ON (WFPV.Weightometer_Id = WS.Weightometer_Id
						AND (WS.Weightometer_Sample_Date > WFPV.Start_Date Or WFPV.Start_Date IS NULL)
						AND (WS.Weightometer_Sample_Date < WFPV.End_Date Or WFPV.End_Date IS NULL))	
				LEFT JOIN dbo.Stockpile AS SS
					ON (WS.Source_Stockpile_Id = SS.Stockpile_Id)
				LEFT JOIN dbo.Stockpile AS DS
					ON (WS.Destination_Stockpile_Id = DS.Stockpile_Id)
					
		END
		ELSE IF @iTagId LIKE '%PortBlendedAdjustment'
		BEGIN
			Select BPB.StartDate, BPB.EndDate, --Tonnes,
				CASE WHEN LPOINT.LocationId = BPB.DestinationHubLocationId THEN Tonnes ELSE -Tonnes END AS Tonnes,
				Fe.GradeValue As Fe, P.GradeValue As P, SiO2.GradeValue As SiO2, Al2O3.GradeValue As Al2O3, LOI.GradeValue As LOI,
				LS.Name As LoadSite, DH.Name As DestinationHub, MH.Name As MoveHub, RH.Name AS RakeHub--, '--' As [--], *
			FROM dbo.BhpbioPortBlending AS BPB
				INNER JOIN @Location AS LPOINT
					ON (LPOINT.LocationId = BPB.DestinationHubLocationId
						OR LPOINT.LocationId = BPB.LoadSiteLocationId)
				INNER JOIN dbo.Location AS MH
					ON (MH.Location_Id = BPB.MoveHubLocationId)
				INNER JOIN dbo.Location AS DH
					ON (DH.Location_Id = BPB.DestinationHubLocationId)
				INNER JOIN dbo.Location AS RH
					ON (RH.Location_Id = BPB.RakeHubLocationId)
				INNER JOIN dbo.Location AS LS
					ON (LS.Location_Id = BPB.LoadSiteLocationId)
				LEFT JOIN dbo.BhpbioPortBlendingGrade AS FE
					ON (FE.GradeId = 1 AND FE.BhpbioPortBlendingId = BPB.BhpbioPortBlendingId)
				LEFT JOIN dbo.BhpbioPortBlendingGrade AS P
					ON (P.GradeId = 2 AND P.BhpbioPortBlendingId = BPB.BhpbioPortBlendingId)
				LEFT JOIN dbo.BhpbioPortBlendingGrade AS SiO2
					ON (SiO2.GradeId = 3 AND SiO2.BhpbioPortBlendingId = BPB.BhpbioPortBlendingId)
				LEFT JOIN dbo.BhpbioPortBlendingGrade AS Al2O3
					ON (Al2O3.GradeId = 4 AND Al2O3.BhpbioPortBlendingId = BPB.BhpbioPortBlendingId)
				LEFT JOIN dbo.BhpbioPortBlendingGrade AS LOI
					ON (LOI.GradeId = 5 AND LOI.BhpbioPortBlendingId = BPB.BhpbioPortBlendingId)
			WHERE (BPB.StartDate >= @iDateFrom AND BPB.EndDate <= DateAdd(Second, 59, DateAdd(Minute, 59, DateAdd(Hour, 23, @iDateTo))))
			--	AND (BPB.MoveHubLocationId <> BPB.DestinationHubLocationId)
		END
		ELSE IF @iTagId LIKE '%PortStockpileDelta'
		BEGIN
			SELECT HL.Name As HubLocation, BPB.Tonnes, BPB.BalanceDate, 
			 BPBPREV.Tonnes As PreviousTonnes, BPBPREV.BalanceDate As PreviousDate,
			 BPB.Tonnes - BPBPREV.Tonnes As DeltaTonnes
			FROM dbo.BhpbioPortBalance AS BPB
			 INNER JOIN dbo.Location AS HL
			  ON HL.Location_Id = BPB.HubLocationId
			INNER JOIN @Location AS FL
				ON HL.Location_Id = FL.LocationId
			LEFT JOIN dbo.BhpbioPortBalance AS BPBPREV
				ON (BPBPREV.BalanceDate = DateAdd(Day, -1, Cast(Year(BPB.BalanceDate) AS Varchar) + '-' + Cast(Month(BPB.BalanceDate) AS Varchar) + '-1' )
					And BPB.HubLocationId = BPBPREV.HubLocationId)
			WHERE BPB.BalanceDate BETWEEN @iDateFrom AND @iDateTo
		END
		
		-- SElect * from dbo.BhpbioReportDataTags
		-- select * from grade

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataReview TO BhpbioGenericManager
GO

--EXEC dbo.GetBhpbioReportDataReview '1-may-2008', '31-may-2008', null, 'PostCrusherStockpileDelta'
--EXEC dbo.GetBhpbioReportDataReview '1-may-2008', '31-may-2008', null, 'ExPitToOreStockpile'
--EXEC dbo.GetBhpbioReportDataReview '1-may-2005', '31-may-2008', null, 'PortBlendedAdjustment'
--EXEC dbo.GetBhpbioReportDataReview '1-apr-2005', '30-apr-2008', 6, 'StockpileToCrusher'

--EXEC dbo.GetBhpbioReportDataReview '1-may-2005', '31-may-2008', 3, 'MineProductionActuals'


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportDataBlockModelTotal.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataBlockModelTotal') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataBlockModelTotal  
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataBlockModelTotal
(
	@iLocationId INT,
	@iAllBlocks BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		PRIMARY KEY (LocationId)
	)
	
	DECLARE @MaterialCategory VARCHAR(31)
	SET @MaterialCategory = 'Designation'

	DECLARE @Grade TABLE
	(
		Factor VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		Code VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		OrderNo INT NOT NULL,
		GCGradeValue REAL NOT NULL,
		MMGradeValue REAL NOT NULL,
		PRIMARY KEY (Factor, Code, GradeName)
	)
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataBlockModelTotal',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		
		INSERT INTO @Location
			(LocationId)
		SELECT LocationId
		FROM dbo.GetBhpbioReportLocation(@iLocationId)
		
		CREATE TABLE #FACTOR
		(
			Factor VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			Code VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			Tonnes FLOAT NULL,
			PRIMARY KEY (Factor, Code)
		)

		CREATE TABLE #FACTORGRADE
		(
			Factor VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			Code VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			GradeName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			OrderNo INT NOT NULL,
			GradeValue FLOAT NULL,
			PRIMARY KEY (Factor, Code, GradeName)
		)
		
		DECLARE @ModelBlockPartial TABLE
		(
			BlockModelId INT NOT NULL,
			ModelBlockId INT NOT NULL,
			SequenceNo INT NOT NULL,
			Code VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
			Tonnes FLOAT NULL,
			PRIMARY KEY (BlockModelId, ModelBlockId, SequenceNo, Code)
		)
		
		-- Get the MBP Records
		INSERT INTO @ModelBlockPartial
			(BlockModelId, ModelBlockId, SequenceNo, Code, Tonnes)
		SELECT MB.Block_Model_Id, MBP.Model_Block_Id, MBP.Sequence_No, MB.Code, MBP.Tonnes
		FROM dbo.ModelBlockLocation AS MBL
			INNER JOIN @Location AS L
				ON (L.LocationId = MBL.Location_Id)
			INNER JOIN dbo.ModelBlock AS MB
				ON (MB.Model_Block_Id = MBL.Model_Block_Id)
			INNER JOIN dbo.ModelBlockPartial AS MBP
				ON (MBP.Model_Block_Id = MB.Model_Block_Id)
			INNER JOIN dbo.GetMaterialsByCategory(@MaterialCategory) AS MC
				ON (MC.MaterialTypeId = MBP.Material_Type_Id)
			INNER JOIN dbo.GetBhpbioReportHighGrade() AS BRHG
				ON (BRHG.MaterialTypeId = MC.RootMaterialTypeId)
			INNER JOIN dbo.BlockModel AS BM
				ON (BM.Block_Model_Id = MB.Block_Model_Id)
		WHERE BM.Name IN ('Grade Control', 'Mining')
		
		
		-- Tonnes
		INSERT INTO #FACTOR
			(Factor, Code, Tonnes)
		SELECT 'F1Factor' AS Factor, CASE WHEN @iAllBlocks = 1 THEN MMBP.Code ELSE 'All' END, 
			Coalesce(Sum(CASE WHEN BM.Name = 'Grade Control' THEN Tonnes ELSE 0 END) /
			Nullif(Sum(CASE WHEN BM.Name = 'Mining' THEN Tonnes ELSE 0 END), 0), 0) AS Tonnes
		FROM @ModelBlockPartial AS MMBP
			INNER JOIN dbo.BlockModel AS BM
				ON (BM.Block_Model_Id = MMBP.BlockModelId)
		GROUP BY CASE WHEN @iAllBlocks = 1 THEN MMBP.Code ELSE 'All' END

		-- Grades
		INSERT INTO @Grade
			(Factor, Code, GradeName, OrderNo, GCGradeValue, MMGradeValue)
		SELECT 'F1Factor' AS Factor, GV.Code, G.Grade_Name, G.Order_No, 
			Coalesce(Sum(CASE WHEN GV.Name = 'Grade Control' THEN GV.GradeValue ELSE 0 END), 0),
			Coalesce(Sum(CASE WHEN GV.Name = 'Mining' THEN GV.GradeValue ELSE 0 END), 0)
		FROM (
				SELECT BM.Name AS Name, CASE WHEN @iAllBlocks = 1 THEN MMBP.Code ELSE 'All' END AS Code, MBPG.Grade_Id AS GradeId, 
					Sum(MBPG.Grade_Value * MMBP.Tonnes) / Nullif(Sum(MMBP.Tonnes), 0) As GradeValue
				FROM @ModelBlockPartial AS MMBP
					INNER JOIN dbo.BlockModel AS BM
						ON (BM.Block_Model_Id = MMBP.BlockModelId)
					INNER JOIN dbo.ModelBlockPartialGrade AS MBPG
						ON (MBPG.Model_Block_Id = MMBP.ModelBlockId
							AND MBPG.Sequence_No = MMBP.SequenceNo)
				GROUP BY BM.Name, CASE WHEN @iAllBlocks = 1 THEN MMBP.Code ELSE 'All' END, MBPG.Grade_Id
			) AS GV
			INNER JOIN dbo.Grade AS G
				ON (GV.GradeId = G.Grade_Id)
		GROUP BY GV.Code, G.Grade_Name, G.Order_No

		-- Grade Values
		INSERT INTO #FACTORGRADE
			(Factor, Code, GradeName, OrderNo, GradeValue)
		SELECT Factor, Code, GradeName, OrderNo,
			(GCGradeValue / NULLIF(MMGradeValue, 0))
		FROM @Grade

		-- Grade Absolute
		INSERT INTO #FACTORGRADE
			(Factor, Code, GradeName, OrderNo, GradeValue)
		SELECT Factor, Code, GradeName + 'Absolute', OrderNo + 50,
			COALESCE(ABS(GCGradeValue - MMGradeValue), 0)
		FROM @Grade
		
		-- Pivot the tables and return.
		EXEC dbo.PivotTable
			@iTargetTable = '#FACTOR',
			@iPivotTable = '#FACTORGRADE',
			@iJoinColumns = '#FACTOR.Factor = #FACTORGRADE.Factor AND #FACTOR.Code = #FACTORGRADE.Code',
			@iPivotColumn = 'GradeName',
			@iPivotValue = 'GradeValue',
			@iPivotType = 'REAL',
			@iPivotOrderColumn = 'OrderNo'

			
		SELECT *
		FROM #FACTOR
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataBlockModelTotal TO BhpbioGenericManager
GO

--EXEC dbo.GetBhpbioReportDataBlockModelTotal  50, 1

GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioShippingTransactionById.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioShippingTransactionById') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioShippingTransactionById
GO 
  
CREATE PROCEDURE dbo.GetBhpbioShippingTransactionById
(
	@iBhpbioShippingTransactionNominationId INT
)
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
	
		SELECT BhpbioShippingTransactionNominationId,
			NominationKey,
			Nomination,
			OfficialFinishTime,
			LastAuthorisedDate,
			CustomerNo,
			CustomerName,
			HubLocationId,
			ProductCode,
			Tonnes 
		FROM dbo.BhpbioShippingTransactionNomination
		WHERE BhpbioShippingTransactionNominationId = @iBhpbioShippingTransactionNominationId
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioShippingTransactionById TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.GetBhpbioReportFactorProperties.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportFactorProperties') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportFactorProperties
GO 

CREATE PROCEDURE dbo.GetBhpbioReportFactorProperties
(
	@iLocationId INT
)
WITH ENCRYPTION
AS 
BEGIN 
	SET NOCOUNT ON 

	BEGIN TRY
		DECLARE @Results TABLE
		(
			LocationId INT NULL,
			LocationName VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
			ThresholdTypeId VARCHAR(255) COLLATE DATABASE_DEFAULT NULL,
			FieldId SMALLINT NULL,
			FieldName VARCHAR(31) COLLATE DATABASE_DEFAULT NULL,
			LowThreshold FLOAT NULL,
			HighThreshold FLOAT NULL,
			AbsoluteThreshold BIT NULL,
			DisplayPrecision INT NULL,
			DisplayFormat VARCHAR(10) COLLATE DATABASE_DEFAULT NULL
		)
		DECLARE @LocationId INT
		
		SET @LocationId = @iLocationId
		IF @LocationId <= 0 OR @LocationId IS NULL
		BEGIN
			SELECT @LocationId = Location_Id
			FROM dbo.Location
			WHERE Parent_Location_Id IS NULL
		END

		INSERT INTO @Results
			(LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, LowThreshold, HighThreshold, AbsoluteThreshold)
		EXEC dbo.GetBhpbioReportThresholdList
			@iLocationId = @LocationId,
			@iThresholdTypeId = NULL,
			@iOnlyInherited = 0,
			@iOnlyLocation = 0
			
		UPDATE @Results
		SET DisplayPrecision = 0,
			DisplayFormat = 'DP'
			
		UPDATE R
		SET R.DisplayPrecision = G.Display_Precision,
			R.DisplayFormat = G.Display_Format
		FROM @Results AS R
			INNER JOIN dbo.Grade AS G
				ON R.FieldId = G.Grade_Id

		SELECT LocationId, LocationName, ThresholdTypeId, FieldId, FieldName, 
			LowThreshold, HighThreshold, AbsoluteThreshold, DisplayPrecision, DisplayFormat
		FROM @Results
			
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO
	
GRANT EXECUTE ON dbo.GetBhpbioReportFactorProperties TO BhpbioGenericManager
GO

--exec dbo.GetBhpbioReportFactorProperties 0

			

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.addbhpbiomaterialtypelocation.prc'
GO

 IF OBJECT_ID('dbo.AddBhpbioMaterialTypeLocation') IS NOT NULL
     DROP PROCEDURE dbo.AddBhpbioMaterialTypeLocation
GO 
  
CREATE PROCEDURE dbo.AddBhpbioMaterialTypeLocation
(
	@iMaterialTypeId INT,
	@iLocationId INT
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'AddBhpbioMaterialTypeLocation',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- add the material type location record
		INSERT INTO dbo.MaterialTypeLocation
		(Material_Type_Id, Location_Id)
		VALUES(@iMaterialTypeId, @iLocationId)
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.AddBhpbioMaterialTypeLocation TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.dbabhpbioblockinitialloadclearinvalid.prc'
GO

IF OBJECT_ID('dbo.DbaBhpbioBlockInitialLoadClearInvalid') IS NOT NULL
     DROP PROCEDURE dbo.DbaBhpbioBlockInitialLoadClearInvalid  
GO 
  
CREATE PROCEDURE dbo.DbaBhpbioBlockInitialLoadClearInvalid 
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Model TABLE
	(
		BlockId INT NOT NULL,
		ModelName VARCHAR(13) COLLATE DATABASE_DEFAULT NOT NULL,
		ModelOreType VARCHAR(8) COLLATE DATABASE_DEFAULT NOT NULL
	)

	DECLARE @Block TABLE
	(
		BlockId INT NOT NULL
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DbaBlockInitialLoadClearInvalid',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.ImportSyncRow AS r
					INNER JOIN dbo.Import AS i
						ON (r.ImportId = i.ImportId)
				WHERE i.ImportName = 'Blocks'
			)
		BEGIN
			-- this check has been added to stop accidental execution on a production system
			-- any blocks loaded through the Insert/Update blocks interface can "flout" these rules
			-- these rules only apply on initial load of the system
			RAISERROR('The Blocks import has already loaded data; you may only run this before the blocks data has been populated.', 16, 1)
		END

		-- remove anything with invalid Fe grades
		INSERT INTO @Model
		(
			BlockId, ModelName, ModelOreType
		)
		SELECT DISTINCT BlockId, ModelName, ModelOreType
		FROM dbo.BhpbioBlastBlockModelGradeHolding
		WHERE (GradeName = 'Fe' AND (GradeValue < 0.001 OR GradeValue > 69.9))

		-- remove models with missing / invalid grades
		INSERT INTO @Model
		(
			BlockId, ModelName, ModelOreType
		)
		SELECT DISTINCT m.BlockId, m.ModelName, m.ModelOreType
		FROM dbo.BhpbioBlastBlockModelHolding AS m
		WHERE NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
				WHERE m.BlockId = mg.BlockId
					AND m.ModelName = mg.ModelName
					AND m.ModelOreType = mg.ModelOreType
					AND mg.GradeName = 'Fe'
			)
			OR NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
				WHERE m.BlockId = mg.BlockId
					AND m.ModelName = mg.ModelName
					AND m.ModelOreType = mg.ModelOreType
					AND mg.GradeName = 'P'
			)
			OR NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
				WHERE m.BlockId = mg.BlockId
					AND m.ModelName = mg.ModelName
					AND m.ModelOreType = mg.ModelOreType
					AND mg.GradeName = 'SiO2'
			)
			OR NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
				WHERE m.BlockId = mg.BlockId
					AND m.ModelName = mg.ModelName
					AND m.ModelOreType = mg.ModelOreType
					AND mg.GradeName = 'Al2O3'
			)
			OR NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
				WHERE m.BlockId = mg.BlockId
					AND m.ModelName = mg.ModelName
					AND m.ModelOreType = mg.ModelOreType
					AND mg.GradeName = 'LOI'
			)

		-- remove models with zero tonnes
		INSERT INTO @Model
		(
			BlockId, ModelName, ModelOreType
		)
		SELECT BlockId, ModelName, ModelOreType
		FROM dbo.BhpbioBlastBlockModelHolding
		WHERE ModelTonnes = 0.0
		
		-- perform the actual delete
		DELETE mg
		FROM dbo.BhpbioBlastBlockModelGradeHolding AS mg
			INNER JOIN @Model AS d
				ON (d.BlockId = mg.BlockId
					AND d.ModelName = mg.ModelName
					AND d.ModelOreType = mg.ModelOreType)

		DELETE m
		FROM dbo.BhpbioBlastBlockModelHolding AS m
			INNER JOIN @Model AS d
				ON (d.BlockId = m.BlockId
					AND d.ModelName = m.ModelName
					AND d.ModelOreType = m.ModelOreType)
		
		-- remove "old" blocks
		INSERT INTO @Block
		(
			BlockId
		)
		SELECT BlockId
		FROM dbo.BhpbioBlastBlockHolding
		WHERE BlockedDate <= '31-DEC-1990'
		
		-- find "orphaned" blocks
		INSERT INTO @Block
		(
			BlockId
		)
		SELECT b.BlockId
		FROM dbo.BhpbioBlastBlockHolding AS b
		WHERE NOT EXISTS
			(
				SELECT 1
				FROM dbo.BhpbioBlastBlockModelHolding AS m
				WHERE b.BlockId = m.BlockId
			)

		DELETE
		FROM dbo.BhpbioBlastBlockModelGradeHolding
		WHERE BlockId IN
			(
				SELECT BlockId
				FROM @Block
			)

		DELETE
		FROM dbo.BhpbioBlastBlockModelHolding
		WHERE BlockId IN
			(
				SELECT BlockId
				FROM @Block
			)

		DELETE
		FROM dbo.BhpbioBlastBlockPointHolding
		WHERE BlockId IN
			(
				SELECT BlockId
				FROM @Block
			)

		DELETE
		FROM dbo.BhpbioBlastBlockHolding
		WHERE BlockId IN
			(
				SELECT BlockId
				FROM @Block
			)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.deletebhpbiomaterialtypelocationall.prc'
GO

IF OBJECT_ID('dbo.DeleteBhpbioMaterialTypeLocationAll') IS NOT NULL
     DROP PROCEDURE dbo.DeleteBhpbioMaterialTypeLocationAll
GO 
  
CREATE PROCEDURE dbo.DeleteBhpbioMaterialTypeLocationAll
(
	@iMaterialTypeId INT = NULL
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'DeleteBhpbioMaterialTypeLocationAll',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- delete the material type location records
		IF NOT @iMaterialTypeId IS NULL
		BEGIN
			DELETE
			FROM dbo.MaterialTypeLocation
			WHERE Material_Type_Id = @iMaterialTypeId
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.DeleteBhpbioMaterialTypeLocationAll TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiodataexceptioncount.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioDataExceptionCount') IS NOT NULL 
     DROP PROCEDURE dbo.GetBhpbioDataExceptionCount 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioDataExceptionCount
( 
    @oNum_Exceptions INT OUTPUT,
	@iLocationId INT = NULL
) 
AS
BEGIN 
    SET NOCOUNT ON 
		
	Exec dbo.UpdateBhpbioDataExceptionLocations
		
	SELECT @oNum_Exceptions = count(*)
	FROM dbo.DataException As DE
		LEFT JOIN dbo.GetBhpbioDataExceptionLocationIgnoreList(@iLocationId) I
			ON I.DataExceptionId = DE.Data_Exception_Id
	WHERE DE.Data_Exception_Status_Id = 'A'
		AND I.DataExceptionId IS NULL
END 
GO 
GRANT EXECUTE ON dbo.GetBhpbioDataExceptionCount TO BhpbioGenericManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionCount">
 <Procedure>
	Outputs the number of active data exceptions in the system
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiodataexceptionlist.prc'
GO

 IF Object_Id('dbo.GetBhpbioDataExceptionList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioDataExceptionList
GO 

CREATE PROCEDURE dbo.GetBhpbioDataExceptionList
( 
    @iDataExceptionTypeId INT = NULL,
	@iDataExceptionStatusId VARCHAR(5) = NULL,
	@iExcludeResolved BIT = 0,
	@iLocationId INT = NULL
) 


AS 

BEGIN 
    SET NOCOUNT ON 
  
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
    BEGIN TRANSACTION 
  
    SELECT DE.Data_Exception_Id, DE.Data_Exception_Type_Id, DE.Data_Exception_Date,
		DE.Data_Exception_Shift, DE.Data_Exception_Status_Id, DE.Short_Description,
		DE.Long_Description, DE.Details_Xml
	FROM dbo.DataException DE
		LEFT JOIN dbo.GetBhpbioDataExceptionLocationIgnoreList(@iLocationId) I
			ON I.DataExceptionId = DE.Data_Exception_Id
	WHERE DE.Data_Exception_Type_Id = IsNull(@iDataExceptionTypeId, DE.Data_Exception_Type_Id)
		AND DE.Data_Exception_Status_Id = IsNull(@iDataExceptionStatusId, DE.Data_Exception_Status_Id)
		AND (@iExcludeResolved = 0
			OR DE.Data_Exception_Status_Id <> 'R')
		AND I.DataExceptionId IS NULL
	ORDER BY DE.Data_Exception_Date, DE.Short_Description, DE.Long_Description
			
	COMMIT TRANSACTION 		
END 
GO
GRANT EXECUTE ON dbo.GetBhpbioDataExceptionList TO BhpbioGenericManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioDataExceptionList">
 <PROCEDURE>
	Returns a list of data exceptions for the type and/or status specified.
 </PROCEDURE>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiohaulagecorrectionlist.prc'
GO

  
If Exists (Select * From dbo.sysobjects Where id = object_id(N'[dbo].[GetBhpbioHaulageCorrectionList]') And OBJECTPROPERTY(id, N'IsProcedure') = 1)
	Drop Procedure [dbo].[GetBhpbioHaulageCorrectionList]
GO

CREATE Procedure [dbo].[GetBhpbioHaulageCorrectionList]
(
	@iFilter_Source Varchar(63) = Null,
	@iFilter_Destination Varchar(63) = Null,
	@iFilter_Description Varchar(255) = Null,
	@iTop Bit = 0,
	@iRecordLimit Int = Null,
	@iLocationId Int = Null
)


As
/*-----------------------------------------------------------------------------
--  Name: GetBhpbioHaulageCorrectionList
--  Purpose: Returns a list of the haulage in HALUAGE_RAW table with filters applied.
--  Parameters: @iFilter_Source - Returned haulage records must have this source unless null.
--				@iFilter_Destination - Returned haulage records must have this destination unless null.
--				@iFilter_Description - Returned haulage records must have this description unless null.
--				@iTop - If flagged only return the top X number of records.
-- 
--  Comments: The @iTop filter allows only a smaller subset of data to be returned
--			   to the UI to reduce processing and load time.
--  
--  Created By:		Murray Hipper
--  Created Date: 	25 October 2006
--
------------------------------------------------------------------------------*/

Begin
	Set Nocount On

	Declare @Haulage_Error_List Table 
	(
		Haulage_Raw_Id Int,
		Haulage_Date Datetime,
		Haulage_Shift_Str Varchar(63), 
		Source Varchar(255),
		Destination Varchar(255),
		Description Varchar(255)
	)

	Declare @Total_Records Int
	Declare @Top_Records Int
	DECLARE @LocationTypeId TINYINT
	DECLARE @HaulageLocationTypeId TINYINT
	
	IF @iLocationId IS NULL Or @iLocationId = -1
	BEGIN
		SELECT @iLocationId = Location_Id
		FROM Location L
			INNER JOIN LocationType LT
				On L.Location_Type_Id = LT.Location_Type_Id
		WHERE LT.Description = 'Company'
	END		
	
	SELECT @LocationTypeId = Location_Type_Id
	FROM Location
	Where Location_Id = @iLocationId
	
	SELECT @HaulageLocationTypeId = Location_Type_Id
	FROM LocationType
	Where Description = 'Site'
	
	/* Get the full list of haulage errors */
	Insert Into @Haulage_Error_List
	Select HR.Haulage_Raw_Id, HR.Haulage_Date,
		dbo.GetShiftTypeName(HR.Haulage_Shift), 
		HR.Source, HR.Destination, HRET.Description
	From HaulageRaw HR
		Inner Join HaulageRawError HRE 
			On HR.Haulage_Raw_Id = HRE.Haulage_Raw_Id
		Inner Join HaulageRawErrorType HRET 
			On HRE.Haulage_Raw_Error_Type_Id = HRET.Haulage_Raw_Error_Type_Id
		LEFT JOIN dbo.HaulageRawLocation AS HRL
			ON HRL.HaulageRawId = HR.Haulage_Raw_Id
		LEFT JOIN dbo.Location AS L
			ON L.Location_Id = HRL.SourceLocationId
	Where HR.Haulage_Raw_State_Id = 'E'
		And ((@iFilter_Source Is Null) Or (@iFilter_Source = HR.Source))
		And ((@iFilter_Destination Is Null) Or (@iFilter_Destination = HR.Destination))
		And ((@iFilter_Description Is Null) Or (@iFilter_Description = HRET.Description))
		AND (  dbo.GetLocationTypeLocationId(L.Location_Id, @LocationTypeId) = @iLocationId
					OR L.Location_Id IS NULL )
	Order By HR.Haulage_Date, dbo.GetShiftTypeOrderNo(HR.Haulage_Shift)
 
	Set @Top_Records = @iRecordLimit
	Select @Total_Records = Count(*) 
	From @Haulage_Error_List

	If @iTop = 1 And @Total_Records > @Top_Records
	Begin

		Set Rowcount @Top_Records
		
		Select * 
		From @Haulage_Error_List
		Union All
		Select -1, 0, '...' + Cast(@Total_Records - @Top_Records As Varchar) + ' more.', '', '', ''
		
		Set Rowcount 0

	End
	Else
	Begin
		Select * 
		From @Haulage_Error_List
	End
	
End
GO
GRANT EXECUTE ON dbo.GetBhpbioHaulageCorrectionList TO BhpbioGenericManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioHaulageCorrectionList">
 <Procedure>
	Returns a list of the haulage in HALUAGE_RAW table with filters applied.
	The @iTop filter allows only a smaller subset of data to be returned
	to the UI to reduce processing and load time.
	Errors are not raised.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiohaulagecorrectionlistfilter.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioHaulageCorrectionListFilter') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioHaulageCorrectionListFilter
GO
CREATE PROCEDURE dbo.GetBhpbioHaulageCorrectionListFilter
(
	@iFilterType VARCHAR(31),
	@iLocationId INT = NULL
)

AS
/*-----------------------------------------------------------------------------
--  Name: GetBhpbioHaulageCorrectionListFilter
--  Purpose: Returns a list of all the Descriptions, Source or Destinations in 
--			 Haulage_Raw.
--  Parameters: @iFilterType - Type of filter. 
--					Valid: (Source | Destination | Description) 
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
--  Updated By:		Brian Acedo
--					Coding Standards Applied
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON

	DECLARE @Filter_Table TABLE
	(
		Filter VARCHAR(255)
	)

	DECLARE @LocationTypeId TINYINT
	DECLARE @HaulageLocationTypeId TINYINT
	
	IF @iLocationId IS NULL OR @iLocationId = -1
	BEGIN
		SELECT @iLocationId = Location_Id
		FROM Location L
			INNER JOIN LocationType LT
				On L.Location_Type_Id = LT.Location_Type_Id
		WHERE LT.Description = 'Company'
	END		
	
	SELECT @LocationTypeId = Location_Type_Id
	FROM Location
	Where Location_Id = @iLocationId
	
	SELECT @HaulageLocationTypeId = Location_Type_Id
	FROM LocationType
	Where Description = 'Site'

	IF @iFilterType = 'Description'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT hret.Description
		FROM dbo.HaulageRaw AS hr
			INNER JOIN dbo.HaulageRawError AS hre 
				ON hr.Haulage_Raw_Id = hre.Haulage_Raw_Id
			INNER JOIN dbo.HaulageRawErrorType AS hret 
				ON hre.Haulage_Raw_Error_Type_Id = hret.Haulage_Raw_Error_Type_Id
			LEFT JOIN dbo.HaulageRawNotes AS HRN
				ON HRN.Haulage_Raw_Id = HR.Haulage_Raw_Id
					AND HRN.Haulage_Raw_Field_Id = 'Site'
			LEFT JOIN dbo.Location AS L
				ON L.Name = HRN.Notes
					AND L.Location_Type_Id = @HaulageLocationTypeId
		WHERE Haulage_Raw_State_Id = 'E'
			AND ( dbo.GetLocationTypeLocationId(L.Location_Id, @LocationTypeId) = @iLocationId
					OR L.Location_Id IS NULL )
		ORDER BY Description
	END
	Else IF @iFilterType = 'Source'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT HR.Source
		FROM dbo.HaulageRaw HR
			LEFT JOIN dbo.HaulageRawNotes AS HRN
				ON HRN.Haulage_Raw_Id = HR.Haulage_Raw_Id
					AND HRN.Haulage_Raw_Field_Id = 'Site'
			LEFT JOIN dbo.Location AS L
				ON L.Name = HRN.Notes
					AND L.Location_Type_Id = @HaulageLocationTypeId
		WHERE HR.Haulage_Raw_State_Id = 'E'
			AND (  dbo.GetLocationTypeLocationId(L.Location_Id, @LocationTypeId) = @iLocationId
					OR L.Location_Id IS NULL )
		ORDER BY Source
	END
	Else IF @iFilterType = 'Destination'
	BEGIN
		INSERT INTO @Filter_Table 
		(
			Filter
		)
		SELECT DISTINCT HR.Destination
		FROM dbo.HaulageRaw HR
			LEFT JOIN dbo.HaulageRawNotes AS HRN
				ON HRN.Haulage_Raw_Id = HR.Haulage_Raw_Id
					AND HRN.Haulage_Raw_Field_Id = 'Site'
			LEFT JOIN dbo.Location AS L
				ON L.Name = HRN.Notes
					AND L.Location_Type_Id = @HaulageLocationTypeId
		WHERE HR.Haulage_Raw_State_Id = 'E'
			AND (  dbo.GetLocationTypeLocationId(L.Location_Id, @LocationTypeId) = @iLocationId
					OR L.Location_Id IS NULL )
		ORDER BY Destination
	END

	SELECT Filter
	FROM @Filter_Table
END
GO
GRANT EXECUTE ON dbo.GetBhpbioHaulageCorrectionListFilter TO BhpbioGenericManager


/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioHaulageCorrectionListFilter">
 <Procedure>
	Returns a list of distinct Error type descriptions, Sources or Destinations for HaulageRaw records
	that are have an error.
	The @iFilterType determines which type of information is returned.
	Errors are not raised.
 </Procedure>
</TAG>
*/
 

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiohaulagevsplantreport.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioHaulageVsPlantReport') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioHaulageVsPlantReport
GO
 
CREATE PROCEDURE dbo.GetBhpbioHaulageVsPlantReport
(
	@iLocationId INT,
	@iFromDate DATETIME,
	@iToDate DATETIME
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @FromDate DATETIME
	DECLARE @ToDate DATETIME

	DECLARE @Crusher TABLE
	(
		CrusherId VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		PRIMARY KEY (CrusherId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioHaulageVsPlantReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- when dealing with haulage vs plant we need to realise the following:
		-- 1. only WEIGHTOMETERS can deliver to a plant
		-- 2. only CRUSHERS allow Haulage to be converted into Weightometer flows
		-- hence this is a haulage vs weightometer around crushers report

		-- The location concerned is the crusher's location
		
		-- Summary: No Date/Shift breakdown
		-- Full (No split-by-shift): Date breakdown
		-- Full (split-by-shift): Date/Shift breakdown

		-- determine the crushers
		INSERT INTO @Crusher
			(CrusherId)
		SELECT DISTINCT Crusher_Id
		FROM
			(
				SELECT cl.Crusher_Id
				FROM dbo.CrusherLocation AS cl
					INNER JOIN dbo.GetLocationSubtree(@iLocationId) AS ls
						ON (cl.Location_Id = ls.Location_Id)

				UNION ALL

				SELECT Crusher_Id
				FROM dbo.Crusher
				WHERE Crusher_Id NOT IN
					(
						SELECT Crusher_Id
						FROM dbo.CrusherLocation
					)
			) AS sub
			-- exclude Crusher to Crusher deliveries
			-- where it's a weightometer delivering to a crusher
			-- the recalc cannot actually handle this situation when weightometer and haulage delivers to the same crusher
			-- this is a haulage vs weightometer report
		WHERE NOT EXISTS
			(
				SELECT 1
				FROM dbo.WeightometerFlowPeriodView AS wfp2
				WHERE wfp2.Destination_Crusher_Id = sub.Crusher_Id
			)

		-- calculate the effective start/end dates
		IF @iFromDate IS NULL
		BEGIN
			SET @FromDate =
				(
					SELECT
						CASE
							WHEN (MIN(h.Haulage_Date) < MIN(ws.Weightometer_Sample_Date))
								OR (MIN(ws.Weightometer_Sample_Date) IS NULL) THEN MIN(h.Haulage_Date)
							ELSE MIN(ws.Weightometer_Sample_Date)
						END
					FROM @Crusher AS c
						LEFT OUTER JOIN dbo.Haulage AS h
							ON (h.Destination_Crusher_Id = c.CrusherId
								AND h.Haulage_State_Id IN ('N', 'A')
								AND h.Child_Haulage_Id IS NULL)
						LEFT OUTER JOIN dbo.WeightometerSampleView AS ws
							ON (ws.Destination_Crusher_Id = c.CrusherId)
				)
		END
		ELSE
		BEGIN
			SET @FromDate = @iFromDate
		END

		IF @iToDate IS NULL
		BEGIN
			SET @ToDate =
				(
					SELECT
						CASE
							WHEN (MAX(h.Haulage_Date) < MAX(ws.Weightometer_Sample_Date))
								OR (MAX(ws.Weightometer_Sample_Date) IS NULL) THEN MAX(h.Haulage_Date)
							ELSE MAX(ws.Weightometer_Sample_Date)
						END
					FROM @Crusher AS c
						LEFT OUTER JOIN dbo.Haulage AS h
							ON (h.Destination_Crusher_Id = c.CrusherId
								AND h.Haulage_State_Id IN ('N', 'A')
								AND h.Child_Haulage_Id IS NULL)
						LEFT OUTER JOIN dbo.WeightometerSampleView AS ws
							ON (ws.Destination_Crusher_Id = c.CrusherId)
				)
		END
		ELSE
		BEGIN
			SET @ToDate = @iToDate
		END

		-- collate the result at the lowest level
		SELECT c.CrusherId AS CrusherId,
			dl.This_Date AS TransactionDate, s.Shift AS TransactionShift,
			ISNULL(h.TotalTonnes, 0.0) AS TotalHaulageTonnes,
			ISNULL(h.DigblockTonnes, 0.0) AS DigblockHaulageTonnes,
			ISNULL(h.StockpileTonnes, 0.0) AS StockpileHaulageTonnes,
			ISNULL(ws.Effective_Tonnes, 0.0) AS ConveyorTonnes
		FROM @Crusher AS c
			CROSS JOIN dbo.GetDateList(@FromDate, @ToDate, 'Day', 1) AS dl
			CROSS JOIN dbo.ShiftType AS s
			-- collect the haulage flows
			LEFT JOIN
				(
					SELECT Haulage_Date, Haulage_Shift, Destination_Crusher_Id,
						SUM(Tonnes) AS TotalTonnes,
						SUM(CASE WHEN Source_Digblock_Id IS NOT NULL THEN Tonnes ELSE 0 END) AS DigblockTonnes,
						SUM(CASE WHEN Source_Stockpile_Id IS NOT NULL THEN Tonnes ELSE 0 END) AS StockpileTonnes
					FROM dbo.Haulage
					WHERE Haulage_State_Id IN ('N', 'A')
						AND Child_Haulage_Id IS NULL
						AND Destination_Crusher_Id IS NOT NULL
					GROUP BY Haulage_Date, Haulage_Shift, Destination_Crusher_Id
				) AS h
				ON (h.Haulage_Date = dl.This_Date
					AND h.Haulage_Shift = s.Shift
					AND h.Destination_Crusher_Id = c.CrusherId)
			-- collect the weightometer flows
			LEFT JOIN
				(
					SELECT ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift, ws.Source_Crusher_Id,
						SUM(ws.Effective_Tonnes) AS Effective_Tonnes
					FROM dbo.WeightometerSampleView AS ws
						INNER JOIN dbo.Weightometer AS w
							ON (ws.Weightometer_Id = w.Weightometer_Id)
					WHERE w.Weightometer_Type_Id IN ('L1', 'CVF+L1')
					GROUP BY ws.Weightometer_Id, ws.Weightometer_Sample_Date, ws.Weightometer_Sample_Shift, ws.Source_Crusher_Id
				) AS ws
				ON (ws.Weightometer_Sample_Date = dl.This_Date
					AND ws.Weightometer_Sample_Shift = s.Shift
					AND ws.Source_Crusher_Id = c.CrusherId)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioHaulageVsPlantReport TO CoreReporting
GRANT EXECUTE ON dbo.GetBhpbioHaulageVsPlantReport TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbioimportsrunningqueuedcount.prc'
GO

 IF OBJECT_ID('dbo.GetBhpbioImportsRunningQueuedCount') IS NOT NULL 
     DROP PROCEDURE dbo.GetBhpbioImportsRunningQueuedCount 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioImportsRunningQueuedCount 
( 
    @oNumImportsRunning INT OUTPUT
) 
WITH ENCRYPTION 
AS
BEGIN 
    SET NOCOUNT ON 
  
    SELECT @oNumImportsRunning = Count(*)
	FROM dbo.ImportJob AS J
		INNER JOIN dbo.ImportJobStatus AS S
			ON (J.ImportJobStatusId = S.ImportJobStatusId)
	WHERE S.ImportJobStatusName In ('RUNNING', 'QUEUED')
END 
GO 
GRANT EXECUTE ON dbo.GetBhpbioImportsRunningQueuedCount TO CommonImportManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioImportsRunningQueuedCount">
 <Procedure>
	Outputs the number of imports running against the system
 </Procedure>
</TAG>
*/	


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiomaterialtypelocationlist.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioMaterialTypeLocationList') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioMaterialTypeLocationList
GO 
  
CREATE PROCEDURE dbo.GetBhpbioMaterialTypeLocationList
(
	@iMaterialTypeId INT = NULL
)
WITH ENCRYPTION
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioMaterialTypeLocationList',
		@TransactionCount = @@TranCount

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- delete the material type location records
		SELECT L.Location_Id As LocationId, L.Name As LocationName,
			CASE WHEN (MTL.Location_Id IS NULL) THEN 0 ELSE 1 END AS IsIncluded
		FROM Location L
			INNER JOIN LocationType LT
				On (LT.Location_Type_Id = L.Location_Type_Id)
			LEFT JOIN dbo.MaterialTypeLocation MTL
				ON (MTL.Location_Id = L.Location_Id
					AND MTL.Material_Type_Id = @iMaterialTypeId)
		WHERE LT.Description = 'Site'
		ORDER BY L.Name

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioMaterialTypeLocationList TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbionohaulageerrors.prc'
GO

 If object_id('dbo.GetBhpbioNoHaulageErrors') is not Null 
     Drop Procedure dbo.GetBhpbioNoHaulageErrors 
Go 
  
Create Procedure dbo.GetBhpbioNoHaulageErrors 
( 
	@iLocationId INT = NULL,
    @NoErrors INT OUTPUT
) 
With Encryption
As 
Begin 
    Set NoCount On 
  
  	DECLARE @LocationTypeId TINYINT
	DECLARE @HaulageLocationTypeId TINYINT
	
	IF @iLocationId IS NULL
	BEGIN
		SELECT @iLocationId = Location_Id
		FROM Location L
			INNER JOIN LocationType LT
				On L.Location_Type_Id = LT.Location_Type_Id
		WHERE LT.Description = 'Company'
	END		
	
	SELECT @LocationTypeId = Location_Type_Id
	FROM Location
	Where Location_Id = @iLocationId
	
	SELECT @HaulageLocationTypeId = Location_Type_Id
	FROM LocationType
	Where Description = 'Site'
  
    Select @NoErrors = Count(*)
	FROM dbo.HaulageRawError E
		INNER JOIN dbo.HaulageRaw HR
			On HR.Haulage_Raw_Id = E.Haulage_Raw_Id
		LEFT JOIN dbo.HaulageRawLocation AS HRL
			ON HRL.HaulageRawId = HR.Haulage_Raw_Id
		LEFT JOIN dbo.Location AS L
			ON L.Location_Id = HRL.SourceLocationId
	WHERE HR.Haulage_Raw_State_Id = 'E'
		AND (  dbo.GetLocationTypeLocationId(L.Location_Id, @LocationTypeId) = @iLocationId
				OR L.Location_Id IS NULL )
	
End 
Go	
GRANT EXECUTE ON dbo.GetBhpbioNoHaulageErrors TO BhpbioGenericManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetBhpbioNoHaulageErrors">
 <Procedure>
	Returns the number of Haulage Raw Errors.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiostockpilebalancereport.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioStockpileBalanceReport') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioStockpileBalanceReport 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioStockpileBalanceReport 
( 
	@iLocationId INT,
    @iStockpileId INT,
	@iStartDate DATETIME,
	@iStartShift CHAR(1),
	@iEndDate DATETIME,
	@iEndShift CHAR(1),
	@iIsVisible BIT
) 
AS
BEGIN
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @StartDate DATETIME
	DECLARE @StartShift CHAR(1)
	DECLARE @EndDate DATETIME
	DECLARE @EndShift CHAR(1)
	DECLARE @PrevStartDate DATETIME
	DECLARE @PrevStartShift CHAR(1)

	DECLARE @Result TABLE
	(
		StockpileId INT NOT NULL,
		StockpileName VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialTypeId INT NOT NULL,
		MaterialAbbreviation VARCHAR(15) COLLATE DATABASE_DEFAULT NOT NULL,
		MaterialDescription VARCHAR(63) COLLATE DATABASE_DEFAULT NOT NULL,
		OpeningBalanceTonnes FLOAT NOT NULL,
		TransactionToTonnes FLOAT NOT NULL,
		TransactionFromTonnes FLOAT NOT NULL,
		AdjustmentTonnes FLOAT NOT NULL,
		ClosingBalanceTonnes FLOAT NOT NULL,
		PRIMARY KEY (StockpileId)
	)

	DECLARE @StockpileLookup TABLE
	(
		StockpileId INT NOT NULL,
		PRIMARY KEY (StockpileId)
	)

	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioStockpileBalanceReport',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- create a short-list of stockpiles
		INSERT INTO @StockpileLookup
			(StockpileId)
		SELECT DISTINCT s.Stockpile_Id
		FROM
			(
				SELECT Stockpile_Id
				FROM dbo.Stockpile AS s
				WHERE NOT EXISTS
					(
						SELECT 1
						FROM dbo.StockpileLocation AS sl
						WHERE s.Stockpile_Id = sl.Stockpile_Id
					)

				UNION ALL

				SELECT DISTINCT Stockpile_Id
				FROM dbo.StockpileLocation AS sl
					INNER JOIN dbo.GetLocationSubtree(@iLocationId) AS ls
						ON (sl.Location_Id = ls.Location_Id)
			) AS sub
			INNER JOIN dbo.Stockpile AS s
				ON (s.Stockpile_Id = sub.Stockpile_Id)
		WHERE s.Stockpile_Id = ISNULL(@iStockpileId, s.Stockpile_Id)
			AND s.Is_Visible = ISNULL(@iIsVisible, s.Is_Visible)

		-- determine the start/end dates
		IF @iStartDate IS NULL
		BEGIN
			SET @StartDate =
				(
					SELECT MIN(Start_Date)
					FROM dbo.StockpileBuild
				)
			SET @StartShift = dbo.GetFirstShiftType()
		END
		ELSE
		BEGIN
			SET @StartDate = @iStartDate
			IF @iStartShift IS NULL
			BEGIN
				SET @StartShift = dbo.GetFirstShiftType()
			END
			ELSE
			BEGIN
				SET @StartShift = @iStartShift
			END
		END

		IF @iEndDate IS NULL
		BEGIN
			SET @EndDate =
				(
					SELECT MAX(Start_Date)
					FROM dbo.StockpileBuild
				)
			SET @EndShift = dbo.GetLastShiftType()
		END
		ELSE
		BEGIN
			SET @EndDate = @iEndDate
			IF @iEndShift IS NULL
			BEGIN
				SET @EndShift = dbo.GetLastShiftType()
			END
			ELSE
			BEGIN
				SET @EndShift = @iEndShift
			END
		END

		-- get the previous date/shift
		EXEC dbo.GetPreviousDateShift
			@Date = @StartDate,
			@Shift = @StartShift,
			@Previous_Date = @PrevStartDate OUTPUT,
			@Previous_Shift = @PrevStartShift OUTPUT

		-- collect the results
		INSERT INTO @Result
		(
			StockpileId, StockpileName, MaterialTypeId, MaterialAbbreviation, MaterialDescription,
			OpeningBalanceTonnes, TransactionToTonnes,
			TransactionFromTonnes,
			AdjustmentTonnes,
			ClosingBalanceTonnes
		)
		SELECT s.Stockpile_Id, s.Stockpile_Name, mt.Material_Type_Id, mt.Abbreviation, mt.Description,
			ISNULL(openBalance.Tonnes, 0.0), ISNULL(transactionTo.TransactionTonnes, 0.0),
			ISNULL(transactionFrom.TransactionTonnes, 0.0),
			ISNULL(transactionTo.AdjustmentTonnes, 0.0) - ISNULL(transactionFrom.AdjustmentTonnes, 0.0),
			ISNULL(closingBalance.Tonnes, 0.0)
		FROM dbo.Stockpile AS s
			-- ensure the stockpiles match the required locations
			INNER JOIN @StockpileLookup AS sl
				ON (sl.StockpileId = s.Stockpile_Id)
			-- stockpiles must have builds in the required date range
			INNER JOIN
				(
					SELECT Stockpile_Id
					FROM dbo.StockpileBuild
					WHERE 
						(
							(End_Date >= @StartDate AND dbo.CompareDateShift(End_Date, End_Shift, '>=', @StartDate, @StartShift) = 1)
							OR End_Date IS NULL
						)
						AND
						(
							(Start_Date <= @EndDate AND dbo.CompareDateShift(Start_Date, Start_Shift, '<=', @EndDate, @EndShift) = 1)
							OR Start_Date IS NULL
						)
				) AS sb
				ON (s.Stockpile_Id = sb.Stockpile_Id)
			-- capture the material type info
			INNER JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = s.Material_Type_Id)
			-- opening balance based on prev stockpile balance + start build
			LEFT OUTER JOIN
				(
					SELECT s.Stockpile_Id AS Stockpile_Id,
						ISNULL(method1.Tonnes, method2.Tonnes) AS Tonnes
					FROM dbo.Stockpile AS s
						LEFT OUTER JOIN
						(
							SELECT Stockpile_Id, SUM(Tonnes) AS Tonnes
							FROM dbo.DataProcessStockpileBalance
							WHERE Data_Process_Stockpile_Balance_Date = @PrevStartDate
								AND Data_Process_Stockpile_Balance_Shift = @PrevStartShift
							GROUP BY Stockpile_Id
						) AS method1
						ON (method1.Stockpile_Id = s.Stockpile_Id)
						LEFT OUTER JOIN
						(
							SELECT sb.Stockpile_Id, SUM(sbc.Start_Tonnes) AS Tonnes
							FROM dbo.StockpileBuildComponent AS sbc
								INNER JOIN dbo.StockpileBuild AS sb
									ON (sbc.Stockpile_Id = sb.Stockpile_Id
										AND sbc.Build_Id = sb.Build_Id)
							WHERE sb.Start_Date = @StartDate
								AND sb.Start_Shift = @StartShift
							GROUP BY sb.Stockpile_ID
						) AS method2
						ON (method2.Stockpile_Id = s.Stockpile_Id)
				) AS openBalance
				ON (s.Stockpile_Id = openBalance.Stockpile_Id)
			-- tonnes added
			LEFT OUTER JOIN
				(
					SELECT Destination_Stockpile_Id AS Stockpile_Id,
						SUM(CASE WHEN Stockpile_Adjustment_Id IS NULL THEN Tonnes ELSE 0.0 END) AS TransactionTonnes,
						SUM(CASE WHEN Stockpile_Adjustment_Id IS NOT NULL THEN Tonnes ELSE 0.0 END) AS AdjustmentTonnes
					FROM dbo.DataProcessTransaction
					WHERE Data_Process_Transaction_Date BETWEEN @StartDate AND @EndDate
						AND dbo.CompareDateShift(Data_Process_Transaction_Date, Data_Process_Transaction_Shift, '>=', @StartDate, @StartShift) = 1
						AND dbo.CompareDateShift(Data_Process_Transaction_Date, Data_Process_Transaction_Shift, '<=', @EndDate, @EndShift) = 1
					GROUP BY Destination_Stockpile_Id
				) AS transactionTo
				ON (s.Stockpile_Id = transactionTo.Stockpile_Id)
			-- tonnes removed
			LEFT OUTER JOIN
				(
					SELECT Source_Stockpile_Id AS Stockpile_Id,
						SUM(CASE WHEN Stockpile_Adjustment_Id IS NULL THEN Tonnes ELSE 0.0 END) AS TransactionTonnes,
						SUM(CASE WHEN Stockpile_Adjustment_Id IS NOT NULL THEN Tonnes ELSE 0.0 END) AS AdjustmentTonnes
					FROM dbo.DataProcessTransaction
					WHERE Data_Process_Transaction_Date BETWEEN @StartDate AND @EndDate
						AND dbo.CompareDateShift(Data_Process_Transaction_Date, Data_Process_Transaction_Shift, '>=', @StartDate, @StartShift) = 1
						AND dbo.CompareDateShift(Data_Process_Transaction_Date, Data_Process_Transaction_Shift, '<=', @EndDate, @EndShift) = 1
					GROUP BY Source_Stockpile_Id
				) AS transactionFrom
				ON (s.Stockpile_Id = transactionFrom.Stockpile_Id)
			-- closing balance
			LEFT OUTER JOIN
				(
					SELECT Stockpile_Id, SUM(Tonnes) AS Tonnes
					FROM
						(
							-- locate any builds that close before the date we're querying for the closing balance
							-- the *latest* balance record is located and the closing tonnes are used
							SELECT sb.Stockpile_Id, SUM(Tonnes) AS Tonnes
							FROM dbo.StockpileBuild AS sb
								INNER JOIN dbo.DataProcessStockpileBalance AS dpsb
									ON (sb.Stockpile_Id = dpsb.Stockpile_Id
										AND sb.Build_Id = dpsb.Build_Id
										AND sb.Last_Recalc_Date = dpsb.Data_Process_Stockpile_Balance_Date
										AND sb.Last_Recalc_Shift = dpsb.Data_Process_Stockpile_Balance_Shift)
							WHERE sb.End_Date <= @EndDate
								AND dbo.CompareDateShift(sb.End_Date, sb.End_Shift, '<', @EndDate, @EndShift) = 1
							GROUP BY sb.Stockpile_Id

							UNION ALL

							SELECT Stockpile_Id, SUM(Tonnes) AS Tonnes
							FROM dbo.DataProcessStockpileBalance
							WHERE Data_Process_Stockpile_Balance_Date = @EndDate
								AND Data_Process_Stockpile_Balance_Shift = @EndShift
							GROUP BY Stockpile_Id
						) AS sub
					GROUP BY Stockpile_Id
				) AS closingBalance
				ON (s.Stockpile_Id = closingBalance.Stockpile_Id)

		-- return the results joined on the groups
		-- we may get dupes but the consuming report will group these back out
		SELECT r.StockpileId, sgs.Stockpile_Group_Id AS StockpileGroupId,
			r.StockpileName, r.MaterialTypeId, r.MaterialAbbreviation, r.MaterialDescription,
			r.OpeningBalanceTonnes, r.TransactionToTonnes, r.TransactionFromTonnes, 
			r.AdjustmentTonnes, r.ClosingBalanceTonnes
		FROM @Result AS r
			LEFT OUTER JOIN dbo.StockpileGroupStockpile AS sgs
				ON (r.StockpileId = sgs.Stockpile_Id)

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioStockpileBalanceReport TO CoreReporting
GRANT EXECUTE ON dbo.GetBhpbioStockpileBalanceReport TO BhpbioGenericManager
GO


/* testing

EXEC dbo.GetBhpbioStockpileBalanceReport
	@iLocationId = 5,
    @iStockpileId = NULL,
	@iStartDate = '02-APR-2008',
	@iStartShift = NULL,
	@iEndDate = '05-APR-2008',
	@iEndShift = NULL,
	@iIsVisible = NULL
GO

*/


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.bhpbioresolvebasic.prc'
GO

 If Exists (Select 1 From sysobjects Where ID = Object_Id('dbo.BhpbioResolveBasic'))
	Drop Procedure dbo.BhpbioResolveBasic
Go

Create Procedure dbo.BhpbioResolveBasic
(
	@iTransactionDate Datetime,
	@iCode Varchar(31),
	@iResolution_Target VarChar(11),
	@oResolved Bit = 0 Output,
	@oDigblockId VARCHAR(31) Output,
	@oStockpileId INT Output,
	@oCrusherId VARCHAR(31) Output,
	@oMillId VARCHAR(31) Output
)


As

Begin
	-- uses the basic resolution methods to resolve the record
	-- this is achieved by the following steps:
	-- 1. Attempt to map through HaulageResolveBasic (based on rules)
	-- 2. Attempt to map directly to Digblock
	-- 3. Attempt to map directly to Stockpile
	-- 4. Attempt to map directly to Crusher

	-- iResolution_Target is either SOURCE or DESTINATION

	Declare @Digblock_Id VarChar(31)
	Declare @Stockpile_Id Int
	Declare @Build_Id Int
	Declare @Component_Id Int
	Declare @Crusher_Id VarChar(31)
	Declare @Mill_Id VarChar(31)
	Declare @Haulage_Resolve_Basic_Id Int
	Declare @TransactionShift Varchar(1)
	
	SET @TransactionShift = dbo.GetFirstShiftType()

	Declare @Resolved Bit

	Set NoCount On

	Set @Resolved = 0

	-- clear all variables
	Set @Digblock_Id = Null
	Set @Stockpile_Id = Null
	Set @Build_Id = Null
	Set @Component_Id = Null
	Set @Crusher_Id = Null
	Set @Mill_Id = Null
	Set @Haulage_Resolve_Basic_Id = Null

	-- attempt to map through HaulageResolveBasic
	Set @Haulage_Resolve_Basic_Id = Null

	Select @Haulage_Resolve_Basic_Id = Haulage_Resolve_Basic_Id
	From dbo.HaulageResolveBasic HRB
	Where Code = @iCode
		And (	HRB.Haulage_Direction = 'B'
				Or (HRB.Haulage_Direction =  'S' And @iResolution_Target = 'SOURCE')
				Or (HRB.Haulage_Direction =  'D' And @iResolution_Target = 'DESTINATION'))

	If @Haulage_Resolve_Basic_Id Is Not Null
	Begin
		Select @Digblock_Id = Digblock_Id,
			@Stockpile_Id = Stockpile_Id,
			@Build_Id = Build_Id,
			@Component_Id = Component_Id,
			@Crusher_Id = Crusher_Id
		From dbo.HaulageResolveBasic
		Where Haulage_Resolve_Basic_Id = @Haulage_Resolve_Basic_Id

		Set @Resolved = 1
	End

	-----
	Set @Haulage_Resolve_Basic_Id = Null

	If @Resolved = 0
	BEGIN
		Select @Haulage_Resolve_Basic_Id = Production_Resolve_Basic_Id
		From dbo.BhpbioProductionResolveBasic HRB
		Where Code = @iCode
			And (	HRB.Production_Direction = 'B'
					Or (HRB.Production_Direction =  'S' And @iResolution_Target = 'SOURCE')
					Or (HRB.Production_Direction =  'D' And @iResolution_Target = 'DESTINATION'))

		If @Haulage_Resolve_Basic_Id Is Not Null
		Begin
			Select @Digblock_Id = Digblock_Id,
				@Stockpile_Id = Stockpile_Id,
				@Build_Id = Build_Id,
				@Component_Id = Component_Id,
				@Crusher_Id = Crusher_Id
			From dbo.BhpbioProductionResolveBasic
			Where Production_Resolve_Basic_Id = @Haulage_Resolve_Basic_Id

			Set @Resolved = 1
		End
	END
	-- attempt to map directly to Digblock
	-- note: a digblock can only be a source
	--       this may be changed in future releases
	If @iResolution_Target = 'SOURCE'
	Begin
		If @Resolved = 0
		Begin
			Select @Digblock_Id = Digblock_Id
			From dbo.Digblock
			Where Digblock_Id = Left(@iCode, 31)

			If @Digblock_Id Is Not Null
				Set @Resolved = 1
		End
	End

	-- attempt to map directly to Mill
	-- note: the old system will not allow transactions to/from Mill
	--       this is available for any future extensions
	If @Resolved = 0
	Begin
		Select @Mill_Id = Mill_Id
		From dbo.Mill
		Where Mill_Id = Left(@iCode, 31)

		If @Mill_Id Is Not Null
			Set @Resolved = 1
	End

	-- attempt to map directly to Stockpile
	If @Resolved = 0
	Begin
		Select @Stockpile_Id = Stockpile_Id
		From dbo.Stockpile
		Where Stockpile_Name = Left(@iCode, 31)

		If @Stockpile_Id Is Not Null
			Set @Resolved = 1
	End

	-- attempt to map directly to Crusher
	-- note: a crusher can only be a destination
	--       this may be changed in future releases
	If @Resolved = 0
	Begin
		Select @Crusher_Id = Crusher_Id
		From dbo.Crusher
		Where Crusher_Id = Left(@iCode, 31)

		If @Crusher_Id Is Not Null
			Set @Resolved = 1
	End



	-- based on the stockpile resolution, attempt to fill in the "missing picture" for build
	-- note: if the component is not specified,
	-- the Recalc will fill in this information (it will pro-rata out against all components)
	If (@Resolved = 1)
		And (@Stockpile_Id Is Not Null) And (@Build_Id Is Null)
	Begin
		If (@iResolution_Target = 'SOURCE')
			Set @Build_Id = dbo.GetReclaimableStockpileBuild(@Stockpile_Id, @iTransactionDate, @TransactionShift)
		Else
			Set @Build_Id = dbo.GetBuildableStockpileBuild(@Stockpile_Id, @iTransactionDate, @TransactionShift)
	End

	Set @oResolved = @Resolved
	
	IF @Resolved = 1
	BEGIN
		SET @oDigblockId = @Digblock_Id
		SET @oStockpileId = @Stockpile_Id
		SET @oCrusherId = @Crusher_Id
		SET @oMillId = @Mill_Id
	END
	
END
GO

/*
<TAG Name="Data Dictionary" ProcedureName="BhpbioResolveBasic">
 <Procedure>
	Uses the basic resolution methods to resolve the record.
	This is achieved by the following steps:
	1. Attempt to map through HaulageResolveBasic (based on rules).
	2. Attempt to map directly to Digblock.
	3. Attempt to map directly to Stockpile.
	4. Attempt to map directly to Crusher.
	5. Attempt to map directly to Mill.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.calcwhalebackvirtualflow.prc'
GO

IF OBJECT_ID('dbo.CalcWhalebackVirtualFlow') IS NOT NULL
	DROP PROCEDURE dbo.CalcWhalebackVirtualFlow
GO 

CREATE PROCEDURE dbo.CalcWhalebackVirtualFlow
(
	@iCalcDate DATETIME
)
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 
	
	SELECT @TransactionName = 'CalcWhalebackVirtualFlow',
		@TransactionCount = @@TranCount

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
	
	BEGIN TRY
		-- The purpose of the calc virtual flow is to:
		-- collect the information from MQ2 surrounding the plant
		-- collect the information from MET Balancing surrounding the plant
		-- Generate the 'corrected' records surrounding the plant representing the balanced figures.
		
		-- The process will be:
		-- Check for Met Balancing Data - if exists use this.
		--		When using MET Balancing data, MQ2 data for Plant Product 
		--		must exist so we can assign destination stockpiles to the product data
		-- If Met Balancing does not exist use MQ2 data.
		
		-- PLANT NAME = 'WB-C3-EX'
		
		-- MET BALANCING DATA
		-- Plant Inflow			: M201			: Weightometer = 201
		-- Plant Product		: M232			: Weightometer = 232
		-- Fines to Stockpile	: M251			: StreamName = 'Bene Fines S/P' And PlantName = 'Total Ore to Stockpile'
		-- Plant Reject			: M233			: Weightometer = 233
		-- Slimes to Thickener	: ThickToTail	: Weightometer = 'Thick to tail'
		
		-- To Balance we will use: (All WetTonnes)
		--	ThickToTail = M201 - M232 - M251 - M233
		--	If ThickToTail < 0 Then
		--		ThickToTail = 0 And M233 = M201 - M232 - M251
		--		If M233 < 0
		--			Raise Error
		
		-- Once Balance Achieved, this needs to be Applied to all records as detected by MQ2.
		-- The following records must be received from MQ2:
		--		M232
		-- As the following flows will be fixed they do not have to already exist:
		--		M201, M233, ThickToTail, M251

		---------------------------------------------------------------------------------------------------------------
		
		DECLARE @M201 FLOAT
		DECLARE @M232 FLOAT
		DECLARE @M251 FLOAT
		DECLARE @M233 FLOAT
		DECLARE @ThickToTail FLOAT
		
		DECLARE @Cur CURSOR
		DECLARE @WeightometerSampleId INT
		
		DECLARE @Source_Stockpile_Id INT
		DECLARE @Destination_Stockpile_Id INT
		DECLARE @Tonnes FLOAT
		DECLARE @TonnesTotal FLOAT
		
		DECLARE @GradeId SMALLINT
		DECLARE @GradeValue REAL
		
		DECLARE @Balanced BIT
		DECLARE @BalanceTypeComment VARCHAR(255)
		
		DECLARE @FeedFe REAL
		DECLARE @FeedP REAL
		DECLARE @FeedSiO2 REAL
		DECLARE @FeedAL2O3 REAL
		
		DECLARE @LOIExists BIT
		
		DECLARE @Grade TABLE
		(
			Source VARCHAR(31) COLLATE DATABASE_DEFAULT,
			Weightometer_Id VARCHAR(31) COLLATE DATABASE_DEFAULT,
			Grade_Id SMALLINT,
			Grade_Value REAL,
			PRIMARY KEY (Source, Weightometer_Id, Grade_Id)
		)
		
		SET @Balanced = 0
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.WeightometerSample
				WHERE Weightometer_Sample_Date = @iCalcDate
					AND Weightometer_Id IN
						(
							'WB-M201-Corrected', 'WB-M232-Corrected', 
							'WB-M233-Corrected', 'WB-M251-Corrected', 'WB-ThickToTail-Corrected'
						)
			)
		BEGIN
			SET @Cur = CURSOR FAST_FORWARD READ_ONLY FOR
				SELECT Weightometer_Sample_Id
				FROM dbo.WeightometerSample AS ws
				WHERE Weightometer_Sample_Date = @iCalcDate
					AND Weightometer_Id IN
						(
							'WB-M201-Corrected', 'WB-M232-Corrected', 
							'WB-M233-Corrected', 'WB-M251-Corrected', 'WB-ThickToTail-Corrected'
						)
			OPEN @Cur
			
			FETCH NEXT FROM @Cur INTO @WeightometerSampleId
			
			WHILE @@FETCH_STATUS = 0
			BEGIN
				EXEC DeleteWeightometerSample
					@iWeightometer_Sample_Id = @WeightometerSampleId
			
				FETCH NEXT FROM @Cur INTO @WeightometerSampleId
			END
			
			CLOSE @Cur
		END
		
		IF NOT EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.WeightometerSample
				WHERE Weightometer_Sample_Date = @iCalcDate
					AND Weightometer_Id In ('WB-BeneOreRaw')
			)
			AND EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioMetBalancing BMT
				WHERE BMT.Weightometer = 'M232'
					AND BMT.CalendarDate = @iCalcDate
					AND WetTonnes > 0
			)
		BEGIN
			-- RAISE DATA EXCEPTION - MQ2 TRANSACTIONS FOR BENE PRODUCT DO NOT EXIST
			PRINT '-- RAISE DATA EXCEPTION - MQ2 TRANSACTIONS FOR BENE PRODUCT DO NOT EXIST'
			SET @Balanced = 0
		END
		ELSE IF EXISTS
			(
				SELECT TOP 1 1
				FROM WeightometerSample
				WHERE Weightometer_Sample_Date = @iCalcDate
					AND Weightometer_Id In ('WB-BeneOreRaw')
			)
		BEGIN
			SET @M201 = 0 
			SET @M232 = 0
			SET @M251 = 0
			SET @M233 = 0
		
			IF EXISTS
				(
					SELECT TOP 1 1
					FROM BhpbioMETBalancing
					WHERE CalendarDate = @iCalcDate
						AND Weightometer = '201'
						AND COALESCE(WetTonnes, 0.0) > 0.0
				)
			BEGIN
				SET @BalanceTypeComment = 'MET Balance Data'
				
				SET @M201 = COALESCE(
					(
						SELECT SUM(COALESCE(WetTonnes, 0.0))
						FROM dbo.BhpbioMETBalancing
						WHERE CalendarDate = @iCalcDate
							AND Weightometer = '201'
					), 0.0)
					
				SET @M232 = COALESCE(
					(
						SELECT SUM(COALESCE(WetTonnes, 0.0))
						FROM dbo.BhpbioMETBalancing
						WHERE CalendarDate = @iCalcDate
							AND Weightometer = '232'
							AND PlantName = 'Total Ore to Loadout'
					), 0.0)
				
				SET @M251 = COALESCE(
					(
						SELECT SUM(COALESCE(WetTonnes, 0.0))
						FROM dbo.BhpbioMETBalancing
						WHERE CalendarDate = @iCalcDate
							AND StreamName = 'Bene Fines S/P' 
							AND PlantName = 'Total Ore to Stockpile'
					), 0.0)
				
				SET @M233 = COALESCE(
					(
						SELECT SUM(COALESCE(WetTonnes, 0.0))
						FROM dbo.BhpbioMETBalancing
						WHERE CalendarDate = @iCalcDate
							AND Weightometer = '233'
					), 0.0)
				
				SET @ThickToTail = COALESCE(
					(
						SELECT SUM(COALESCE(WetTonnes, 0.0))
						FROM dbo.BhpbioMETBalancing
						WHERE CalendarDate = @iCalcDate
							AND Weightometer = 'Thick to tail'
					), 0.0)
					
				INSERT INTO @Grade
					(Source, Weightometer_ID, Grade_Id, Grade_Value)
				SELECT 'MET', 
					CASE
						WHEN BMB.Weightometer = '201' THEN 'WB-M201-Corrected'
						WHEN BMB.Weightometer = '232' AND PlantName = 'Total Ore to Loadout' THEN 'WB-M232-Corrected'
						WHEN BMB.StreamName = 'Bene Fines S/P' And BMB.PlantName = 'Total Ore to Stockpile' THEN 'WB-M251-Corrected'
						WHEN BMB.Weightometer = '233' THEN 'WB-M233-Corrected'
					END,
					BMBG.GradeId, BMBG.GradeValue
				FROM dbo.BhpbioMETBalancing AS bmb
					INNER JOIN dbo.BhpbioMETBalancingGrade AS bmbg
						ON (bmbg.BhpbioMetBalancingId = bmb.BhpbioMetBalancingId)
				WHERE bmb.CalendarDate = @iCalcDate
					AND
						(
							CASE
								WHEN Weightometer = '201' THEN 1.0
								WHEN Weightometer = '232' And PlantName = 'Total Ore to Loadout' THEN 1.0
								WHEN StreamName = 'Bene Fines S/P' And PlantName = 'Total Ore to Stockpile' THEN 1.0
								WHEN Weightometer = '233' THEN 1.0
								ELSE 0.0
							END
						) > 0.0
					END
			ELSE
			BEGIN
				Print 'MQ2'
				SET @BalanceTypeComment = 'MQ2 Transaction Data'
				
				SET @M201 = COALESCE((SELECT SUM(COALESCE(Corrected_Tonnes, Tonnes, 0))
										FROM WeightometerSample
										WHERE Weightometer_Sample_Date = @iCalcDate
											AND Weightometer_Id = 'WB-C3OutflowRaw'), 0)
					
				SET @M232 = COALESCE((SELECT SUM(COALESCE(Corrected_Tonnes, Tonnes, 0))
										FROM WeightometerSample
										WHERE Weightometer_Sample_Date = @iCalcDate
											AND Weightometer_Id = 'WB-BeneOreRaw'), 0)
				
				SET @M251 = COALESCE((SELECT SUM(COALESCE(Corrected_Tonnes, Tonnes, 0))
										FROM WeightometerSample
										WHERE Weightometer_Sample_Date = @iCalcDate
											AND Weightometer_Id = 'WB-BeneFinesRaw'), 0)
				
				SET @M233 = COALESCE((SELECT SUM(COALESCE(Corrected_Tonnes, Tonnes, 0))
										FROM WeightometerSample
										WHERE Weightometer_Sample_Date = @iCalcDate
											AND Weightometer_Id = 'WB-BeneRejectRaw'), 0)
					
				INSERT INTO @Grade
				(Source, Weightometer_ID, Grade_Id, Grade_Value)
				SELECT 'MQ2', 
					CASE WHEN WS.Weightometer_Id = 'WB-C3OutFlowRaw' THEN 'WB-M201-Corrected'
						WHEN WS.Weightometer_Id = 'WB-BeneOreRaw' THEN 'WB-M232-Corrected'
						WHEN WS.Weightometer_Id = 'WB-BeneFinesRaw' THEN 'WB-M251-Corrected'
						WHEN WS.Weightometer_Id = 'WB-BeneRejectRaw' THEN 'WB-M233-Corrected' END,
					Grade_ID, SUM(WS.Tonnes*WSG.Grade_Value)/SUM(WS.Tonnes)
				FROM WeightometerSample WS
					INNER JOIN WeightometerSampleGrade WSG
						ON WS.Weightometer_Sample_Id = WSG.Weightometer_Sample_Id
				WHERE Weightometer_Sample_Date = @iCalcDate
					AND CASE WHEN WS.Weightometer_Id = 'WB-C3OutFlowRaw' THEN 1
						WHEN WS.Weightometer_Id = 'WB-BeneOreRaw' THEN 1
						WHEN WS.Weightometer_Id = 'WB-BeneFinesRaw' THEN 1
						WHEN WS.Weightometer_Id = 'WB-BeneRejectRaw' THEN 1 
						ELSE 0 END = 1
				GROUP BY WS.Weightometer_Id, WSG.Grade_Id
				HAVING SUM(WS.Tonnes) > 0
			END

			SET @ThickToTail = @M201 - @M232 - @M251 - @M233
			
			IF @ThickToTail < 0.0
			BEGIN
				SET @ThickToTail = 0
				SET @M233 = @M201 - @M232 - @M251 
				
				IF @M233 < 0.0
				BEGIN
					-- RAISE DATA EXCEPTION - MET BALANCING PRODUCT AND FINES GREATER THAN INFLOW
					Print '-- RAISE DATA EXCEPTION - MET BALANCING PRODUCT AND FINES GREATER THAN INFLOW'
					SET @Balanced = 0
				END
				ELSE
				BEGIN
					SET @Balanced = 1
				END
			END
			ELSE
			BEGIN
				SET @Balanced = 1
			END
			
			IF @Balanced = 1
			BEGIN
				Print 'Balanced'
				EXEC AddWeightometerSample
					@iWeightometer_Id = 'WB-M201-Corrected',
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iOrder_No = 1,
					@iTonnes = @M201,
					@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT
				
				EXEC AddWeightometerSample
					@iWeightometer_Id = 'WB-ThickToTail-Corrected',
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iOrder_No = 1,
					@iTonnes = @ThickToTail,
					@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT

				EXEC AddWeightometerSample
					@iWeightometer_Id = 'WB-M251-Corrected',
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iOrder_No = 1,
					@iTonnes = @M251,
					@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT
				
				EXEC AddWeightometerSample
					@iWeightometer_Id = 'WB-M233-Corrected',
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iOrder_No = 1,
					@iTonnes = @M233,
					@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT
					
				SELECT @TonnesTotal = SUM(Tonnes)
				FROM WeightometerSample
				WHERE Weightometer_Id = 'WB-BeneOreRaw'
					AND Weightometer_Sample_Date = @iCalcDate
					
				SET @Cur = CURSOR FOR
					SELECT Source_Stockpile_Id, Destination_Stockpile_Id, Tonnes
					FROM WeightometerSample
					WHERE Weightometer_Id = 'WB-BeneOreRaw'
						AND Weightometer_Sample_Date = @iCalcDate
						
				OPEN @Cur
				
				FETCH NEXT FROM @Cur INTO @Source_Stockpile_Id, @Destination_Stockpile_ID, @Tonnes
			
				WHILE @@FETCH_STATUS = 0
				BEGIN
					
					SET @Tonnes = (@Tonnes / @TonnesTotal) * @M232
					
					EXEC AddWeightometerSample
						@iWeightometer_Id = 'WB-M232-Corrected',
						@iWeightometer_Sample_Date = @iCalcDate,
						@iWeightometer_Sample_Shift = 'D',
						@iOrder_No = 1,
						@iSource_Stockpile_Id = @Source_Stockpile_Id,
						@iDestination_Stockpile_Id = @Destination_Stockpile_ID,
						@iTonnes = @Tonnes,
						@oWeightometer_Sample_Id = @WeightometerSampleId OUTPUT
						
					FETCH NEXT FROM @Cur INTO @Source_Stockpile_Id, @Destination_Stockpile_ID, @Tonnes			
				END
			
				CLOSE @Cur
				DEALLOCATE @Cur
				
				SET @Cur = CURSOR FOR
					SELECT WS.Weightometer_Sample_Id, G.Grade_ID, G.Grade_Value
					FROM @Grade G
						INNER JOIN WeightometerSample WS
							ON WS.Weightometer_ID = G.Weightometer_Id
					WHERE WS.Weightometer_Sample_Date = @iCalcDate
						AND G.Source = CASE WHEN @BalanceTypeComment = 'MET Balance Data' THEN 'MET' ELSE 'MQ2' END
				
				OPEN @Cur
				
				FETCH NEXT FROM @Cur INTO @WeightometerSampleId, @GradeId, @GradeValue
				
				WHILE @@FETCH_STATUS = 0
				BEGIN

					EXEC dbo.AddOrUpdateWeightometerSampleGrade
						@iWeightometer_Sample_Id = @WeightometerSampleId,
						@iGrade_Id = @GradeId,
						@iGrade_Value = @GradeValue
						
					FETCH NEXT FROM @Cur INTO @WeightometerSampleId, @GradeId, @GradeValue
				END
				
				CLOSE @Cur
				DEALLOCATE @Cur
				
				SELECT @GradeId = Grade_Id
				FROM Grade
				WHERE Grade_Name = 'LOI'
				
				IF NOT EXISTS (SELECT TOP 1 1 
								FROM @Grade
								WHERE Weightometer_Id = 'WB-M232-Corrected'
									AND Grade_Id = @GradeId
								)
				BEGIN
					SELECT 
						@FeedFe = Sum(CASE WHEN Gr.Grade_Name = 'FE' THEN G.Grade_Value ELSE 0 END),
						@FeedP = Sum(CASE WHEN Gr.Grade_Name = 'P' THEN G.Grade_Value ELSE 0 END),
						@FeedSiO2 = Sum(CASE WHEN Gr.Grade_Name = 'SiO2' THEN G.Grade_Value ELSE 0 END),
						@FeedAL2O3 = Sum(CASE WHEN Gr.Grade_Name = 'AL2O3' THEN G.Grade_Value ELSE 0 END)	
					FROM @Grade G
						INNER JOIN Grade Gr
							ON Gr.Grade_Id = G.Grade_Id
					WHERE G.Source = CASE WHEN @BalanceTypeComment = 'MET Balance Data' THEN 'MET' ELSE 'MQ2' END
						AND G.Weightometer_Id = 'WB-M201-Corrected'

					SELECT @WeightometerSampleId = Weightometer_Sample_Id
					FROM WeightometerSample
					WHERE Weightometer_Id = 'WB-M232-Corrected'
						AND Weightometer_Sample_Date = @iCalcDate

					IF @FeedFe > 0 AND @FeedP > 0 AND @FeedSiO2 > 0 AND @FeedAL2O3 > 0
						AND @WeightometerSampleId IS NOT NULL
					BEGIN

						SET @GradeValue = 99.7-((1.429*@FeedFe)+(2.205*@FeedP)+@FeedSiO2+@FeedAL2O3)
						
						IF @GradeValue > 0.0
						BEGIN
							EXEC dbo.AddOrUpdateWeightometerSampleGrade
								@iWeightometer_Sample_Id = @WeightometerSampleId,
								@iGrade_Id = @GradeId,
								@iGrade_Value = @GradeValue
						END
					END
					ELSE IF EXISTS(SELECT TOP 1 1 
									FROM WeightometerSampleGrade 
									WHERE Weightometer_Sample_Id = @WeightometerSampleId
										AND Grade_Id = @GradeId)
						AND @WeightometerSampleId IS NOT NULL
					BEGIN
						DELETE FROM WeightometerSampleGrade
						WHERE Weightometer_Sample_Id = @WeightometerSampleId
							AND Grade_Id = @GradeId
					END
				END
				
				-- check for 201 LOI grades and if they dont exist add them
				IF NOT EXISTS (SELECT TOP 1 1 
								FROM @Grade
								WHERE Weightometer_Id = 'WB-M201-Corrected'
									AND Grade_Id = @GradeId
								)
				BEGIN
					
					DECLARE @StartDate DATETIME
					DECLARE @EndDate DATETIME

					SET @StartDate = '1-Jul-' + CAST(CASE WHEN MONTH(@iCalcDate) <= 6 THEN YEAR(@iCalcDate) - 2 ELSE YEAR(@iCalcDate) - 1 END AS VARCHAR)
					SET @EndDate = '30-Jun-' + CAST(CASE WHEN MONTH(@iCalcDate) <= 6 THEN YEAR(@iCalcDate) - 1 ELSE YEAR(@iCalcDate) END AS VARCHAR)

					DECLARE @MaterialCategory VARCHAR(32)
					SET @MaterialCategory = 'Designation'
					DECLARE @BeneFeed INT

					SELECT @BeneFeed = MT.Material_Type_Id
					FROM MaterialType MT
						INNER JOIN MaterialCategory MTG
							ON MTG.MaterialCategoryId = MT.Material_Category_Id
					WHERE MTG.MaterialCategoryId = 'Designation'
						AND MT.Description = 'Bene Feed'

					SELECT @GradeValue = SUM(MBS.Tonnes*birm.MinedPercentage*MBS.LOI) / SUM(MBS.Tonnes*birm.MinedPercentage)
					FROM BhpbioImportReconciliationMovement birm
					INNER JOIN (Select mbl.Location_Id, SUM(MBP.Tonnes) As Tonnes,
									CASE WHEN SUM(MBP.Tonnes) > 0 THEN 
											SUM(MBPG.Grade_Value * MBP.Tonnes) 
											/ SUM(MBP.Tonnes) 
										ELSE
											NULL
										END As LOI
								FROM ModelBlockLocation mbl
								INNER JOIN ModelBlock MB
									ON MB.Model_Block_Id = mbl.Model_Block_Id
								INNER JOIN BlockModel BM
									ON BM.Block_Model_Id = MB.Block_Model_Id
								INNER JOIN ModelBlockPartial MBP
									ON MBP.Model_Block_Id = MB.Model_Block_Id
								INNER JOIN ModelBlockPartialGrade MBPG
									ON MBPG.Model_Block_Id = MBP.Model_Block_Id
										AND MBPG.Sequence_No = MBP.Sequence_No
								INNER JOIN dbo.GetMaterialsByCategory(@MaterialCategory) GMBC
									ON GMBC.MaterialTypeId = MBP.Material_Type_Id
										AND GMBC.RootMaterialTypeId = @BeneFeed
								WHERE BM.Name = 'Mining'
									AND MBPG.Grade_Id = @GradeId
								GROUP BY mbl.Location_Id
						) MBS
						ON MBS.Location_Id = birm.BlockLocationId
					WHERE [Site] = 'NEWMAN'
						AND Orebody = 'WB'
						AND DateFrom BETWEEN @StartDate AND @EndDate

					SELECT @WeightometerSampleId = Weightometer_Sample_Id
					FROM WeightometerSample
					WHERE Weightometer_Id = 'WB-M201-Corrected'
						AND Weightometer_Sample_Date = @iCalcDate

					IF @GradeValue > 0 AND @WeightometerSampleId IS NOT NULL
					BEGIN
						EXEC dbo.AddOrUpdateWeightometerSampleGrade
							@iWeightometer_Sample_Id = @WeightometerSampleId,
							@iGrade_Id = @GradeId,
							@iGrade_Value = @GradeValue
					END
					ELSE IF EXISTS(SELECT TOP 1 1 
									FROM WeightometerSampleGrade 
									WHERE Weightometer_Sample_Id = @WeightometerSampleId
										AND Grade_Id = @GradeId)
						AND @WeightometerSampleId IS NOT NULL
					BEGIN
						DELETE FROM WeightometerSampleGrade
						WHERE Weightometer_Sample_Id = @WeightometerSampleId
							AND Grade_Id = @GradeId
					END
				END
				
			END
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
					
		Exec RecalcL1Raise @iCalcDate
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.CalcWhalebackVirtualFlow TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.CalcWhalebackVirtualFlow">
 <Procedure>
	Updates the Yandi Production Data for the crushers.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.calcyandivirtualflow.prc'
GO

IF OBJECT_ID('dbo.CalcYandiVirtualFlow') IS NOT NULL
	DROP PROCEDURE dbo.CalcYandiVirtualFlow
GO 
  
CREATE PROCEDURE dbo.CalcYandiVirtualFlow
(
	@iCalcDate DATETIME
)
AS 
BEGIN 

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	SET NOCOUNT ON 
	
		SELECT @TransactionName = 'CalcYandiVirtualFlow',
		@TransactionCount = @@TranCount 

	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
	
	BEGIN TRY

		DECLARE @WeightometerInflowCount FLOAT
		DECLARE @Inflow FLOAT
		DECLARE @Outflow FLOAT
		DECLARE @InflowVirtual FLOAT
		DECLARE @WeightometerSampleId INT
		DECLARE @Counter INT
		
		DECLARE @Weightometer_ID AS VARCHAR(31)
		
		DECLARE @Cur CURSOR
				
		SET @Weightometer_ID = 	'YD-Y2_VirtualFlow'	
		
		-- GET WEIGHTOMETER INFLOW
		SELECT @Inflow = SUM(WS.Tonnes)
		FROM WeightometerSample WS
		WHERE Weightometer_Id In ('YD-ICP_To_YD-Y2', 'YD-IOWA_To_YD-Y2')
			AND Weightometer_Sample_Date = @iCalcDate

		-- GET WEIGHTOMETER INFLOWVIRTUAL
		SELECT @InflowVirtual = SUM(WS.Tonnes)
		FROM WeightometerSample WS
		WHERE Weightometer_Id In ('YD-Y2_VirtualFlow')
			AND Weightometer_Sample_Date = @iCalcDate

		-- GET WEIGHTOMETER OUTFLOW
		SELECT @Outflow = SUM(WS.Tonnes)
		FROM WeightometerSample WS
		WHERE Weightometer_Id In ('YD-Y2Outflow')
			AND Weightometer_Sample_Date = @iCalcDate

		IF Coalesce(@Inflow, 0) + Coalesce(@InflowVirtual, 0) <> Coalesce(@Outflow, 0)
		BEGIN
			IF EXISTS (SELECT *
						FROM WeightometerSample
						WHERE Weightometer_Id = @Weightometer_ID
							AND Weightometer_Sample_Date = @iCalcDate)
			BEGIN
				SET @Cur = CURSOR FOR
					SELECT Weightometer_Sample_Id
					FROM WeightometerSample
					WHERE Weightometer_Id = @Weightometer_ID
						AND Weightometer_Sample_Date = @iCalcDate
				
				OPEN @Cur
				
				FETCH NEXT FROM @Cur INTO @WeightometerSampleId
				
				WHILE @@FETCH_STATUS = 0
				BEGIN
					EXEC DeleteWeightometerSample
						@iWeightometer_Sample_Id = @WeightometerSampleId
						
					FETCH NEXT FROM @Cur INTO @WeightometerSampleId
				END
				
				CLOSE @Cur
				DEALLOCATE @Cur
			END
			
			SET @InflowVirtual = @Outflow - Coalesce(@Inflow, 0)
			
			If @InflowVirtual >= 0
			BEGIN
				EXEC AddWeightometerSample
					@iWeightometer_Id = @Weightometer_ID,
					@iWeightometer_Sample_Date = @iCalcDate,
					@iWeightometer_Sample_Shift = 'D',
					@iTonnes = @InflowVirtual,
					@iOrder_No = 1,
					@oWeightometer_Sample_Id = Null
					
				UPDATE WeightometerSample
				SET Corrected_Tonnes = NULL
				WHERE Weightometer_Id In ('YD-ICP_To_YD-Y2', 'YD-IOWA_To_YD-Y2')
					AND Weightometer_Sample_Date = @iCalcDate
			END
			ELSE
			BEGIN
				UPDATE WeightometerSample
				SET Corrected_Tonnes = Tonnes * Coalesce(@Outflow, 0) / Coalesce(@Inflow, 0)
				WHERE Weightometer_Id In ('YD-ICP_To_YD-Y2', 'YD-IOWA_To_YD-Y2')
					AND Weightometer_Sample_Date = @iCalcDate
			END
		END
		ELSE
		BEGIN
			UPDATE WeightometerSample
			SET Corrected_Tonnes = NULL
			WHERE Weightometer_Id In ('YD-ICP_To_YD-Y2', 'YD-IOWA_To_YD-Y2', @Weightometer_ID, 'YD-Y2Outflow')
				AND Weightometer_Sample_Date = @iCalcDate
		END
		
		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
					
		Exec RecalcL1Raise @iCalcDate
		
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.CalcYandiVirtualFlow TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.CalcYandiVirtualFlow">
 <Procedure>
	Updates the Yandi Production Data for the crushers.
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.updatebhpbiodataexceptionlocations.prc'
GO

IF OBJECT_ID('dbo.UpdateBhpbioDataExceptionLocations') IS NOT NULL 
     DROP PROCEDURE dbo.UpdateBhpbioDataExceptionLocations 
GO 
  
CREATE PROCEDURE dbo.UpdateBhpbioDataExceptionLocations
AS
BEGIN 
    SET NOCOUNT ON 
 
	DECLARE @NewExceptions TABLE
	(
		DataExceptionId INT,
		Details_XML XML,
		PRIMARY KEY (DataExceptionId)
	)
	
	DELETE BDEL
	FROM BhpbioDataExceptionLocation BDEL
		LEFT JOIN DataException DE
			On DE.Data_Exception_Id = BDEL.DataExceptionId
	WHERE DE.Data_Exception_Id IS NULL

	INSERT INTO @NewExceptions
	(DataExceptionId, Details_XML)
	SELECT DE.Data_Exception_Id, DE.Details_XML
	FROM DataException DE
		LEFT JOIN BhpbioDataExceptionLocation BDEL
			ON BDEL.DataExceptionId = DE.Data_Exception_Id
	WHERE BDEL.DataExceptionId IS NULL
		AND DE.Data_Exception_Status_Id <> 'R'

	IF EXISTS (SELECT TOP 1 1 FROM @NewExceptions)
	BEGIN
		-- Searching for Stockpile Id Column
		/* Data Exceptions:
			"Negative_Stockpile",
			"Stockpile_Opening_Grades_Not_Specified",
			"Source_Or_Destination_Stockpile_Balance_Exception_Record",
			"Given_Moisture_Scaling_Adjustment_Error",
			"Stockpile_Survey_In_Circular_Reference",
			"Stockpile_Group_Designation"
		*/
		INSERT INTO BhpbioDataExceptionLocation
		(DataExceptionId, LocationId)
		SELECT DE.DataExceptionId, SL.Location_Id
		FROM @NewExceptions DE
			INNER JOIN StockpileLocation SL
				ON SL.Stockpile_Id = DE.Details_XML.value('(/DocumentElement/*/Stockpile_Id)[1]', 'INT')
		WHERE Details_XML.query('
					 for $node in /descendant::node()[local-name() = 
		(
		"Negative_Stockpile", "Stockpile_Opening_Grades_Not_Specified", "Source_Or_Destination_Stockpile_Balance_Exception_Record",
		"Given_Moisture_Scaling_Adjustment_Error", "Stockpile_Survey_In_Circular_Reference", "Stockpile_Group_Designation"
		)
					] 
					 return <node>
							<namespace>{ namespace-uri($node) }</namespace>
							<localname>{ local-name($node) }</localname>
							<parent>{ local-name($node/..) }</parent>
							</node>').value('(/node/localname)[1]', 'Varchar(255)') IS NOT NULL

		-- Searching for Digblock Id Column
		/* Data Exceptions:
			"Digblock_Grades_Not_Defined",
		*/
		INSERT INTO BhpbioDataExceptionLocation
		(DataExceptionId, LocationId)
		SELECT DE.DataExceptionId, DL.Location_Id
		FROM @NewExceptions DE
			INNER JOIN DigblockLocation DL
				ON DL.Digblock_Id = DE.Details_XML.value('(/DocumentElement/*/Digblock_Id)[1]', 'Varchar(52)')
		WHERE Details_XML.query('
					 for $node in /descendant::node()[local-name() = 
		(
		"Digblock_Grades_Not_Defined"
		)
					] 
					 return <node>
							<namespace>{ namespace-uri($node) }</namespace>
							<localname>{ local-name($node) }</localname>
							<parent>{ local-name($node/..) }</parent>
							</node>').value('(/node/localname)[1]', 'Varchar(255)') IS NOT NULL


		-- Searching for Crusher Id Column
		/* Data Exceptions:
			"Inconsistent_Crusher_Deliveries_and_Removals",
		*/ 
		INSERT INTO BhpbioDataExceptionLocation
		(DataExceptionId, LocationId)
		SELECT DE.DataExceptionId, CL.Location_Id
		FROM @NewExceptions DE
			INNER JOIN CrusherLocation CL
				ON CL.Crusher_Id = DE.Details_XML.value('(/DocumentElement/*/Crusher_Id)[1]', 'Varchar(31)')
		WHERE Details_XML.query('
					 for $node in /descendant::node()[local-name() = 
		(
		"Inconsistent_Crusher_Deliveries_and_Removals"
		)
					] 
					 return <node>
							<namespace>{ namespace-uri($node) }</namespace>
							<localname>{ local-name($node) }</localname>
							<parent>{ local-name($node/..) }</parent>
							</node>').value('(/node/localname)[1]', 'Varchar(255)') IS NOT NULL

		-- Searching for Weightometer Id Column
		/* Data Exceptions:
			"Weightometer_Record_Source_Or_Destination_Not_Defined",
		*/  
		INSERT INTO BhpbioDataExceptionLocation
		(DataExceptionId, LocationId)
		SELECT DE.DataExceptionId, WL.Location_Id
		FROM @NewExceptions DE
			INNER JOIN WeightometerLocation WL
				ON WL.Weightometer_Id = DE.Details_XML.value('(/DocumentElement/*/Weightometer_Id)[1]', 'Varchar(52)')
		WHERE Details_XML.query('
					 for $node in /descendant::node()[local-name() = 
		(
		"Weightometer_Record_Source_Or_Destination_Not_Defined"
		)
					] 
					 return <node>
							<namespace>{ namespace-uri($node) }</namespace>
							<localname>{ local-name($node) }</localname>
							<parent>{ local-name($node/..) }</parent>
							</node>').value('(/node/localname)[1]', 'Varchar(255)') IS NOT NULL


		-- Searching for Mill Id Column
		/* Data Exceptions:
			"Inconsistent_Plant_Deliveries_And_Removals",
		*/ 
		INSERT INTO BhpbioDataExceptionLocation
		(DataExceptionId, LocationId)
		SELECT DE.DataExceptionId, M.Location_Id
		FROM @NewExceptions DE
			INNER JOIN MillLocation M
				ON M.Mill_Id = DE.Details_XML.value('(/DocumentElement/*/Mill_Id)[1]', 'Varchar(52)')
		WHERE Details_XML.query('
					 for $node in /descendant::node()[local-name() = 
		(
		"Inconsistent_Plant_Deliveries_And_Removals"
		)
					] 
					 return <node>
							<namespace>{ namespace-uri($node) }</namespace>
							<localname>{ local-name($node) }</localname>
							<parent>{ local-name($node/..) }</parent>
							</node>').value('(/node/localname)[1]', 'Varchar(255)') IS NOT NULL
	END
	
END 
GO 
GRANT EXECUTE ON dbo.UpdateBhpbioDataExceptionLocations TO BhpbioGenericManager

/*
<TAG Name="Data Dictionary" ProcedureName="GetDataExceptionCount">
 <Procedure>
	Outputs the number of active data exceptions in the system
 </Procedure>
</TAG>
*/	

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiohaulagemanagementlistfilter.prc'
GO


IF OBJECT_ID('dbo.GetBhpbioHaulageManagementListFilter') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioHaulageManagementListFilter
GO

CREATE PROCEDURE dbo.GetBhpbioHaulageManagementListFilter
(
	@iFilter_Type VARCHAR(31),
	@iLocation_Id INT = NULL
)

WITH ENCRYPTION 
AS
/*-----------------------------------------------------------------------------
--  Name: GetBhpbioHaulageManagementListFilter
--  Purpose: Returns a list of all the Source or Destinations in Haulage.
--  Parameters: @iFilter_Type - Type of filter. 
--					Valid: (Source | Destination | Truck) 
-- 
--  Comments: -
--  
--  Created By:		Murray Hipper
--  Created Date: 	21 October 2006
--
--  Updated By:		Brian Acedo
--					Added Location filter
--					
--  Updated By:     Alex Wong
--					Needs to use Location Subtree
------------------------------------------------------------------------------*/

BEGIN
	SET NOCOUNT ON

	DECLARE @Filter_Table TABLE
	(
		Filter_Display VARCHAR(255) COLLATE Database_Default,
		Filter_Value VARCHAR(255) COLLATE Database_Default,
		Location_Id INT
	)

	IF @iFilter_Type = 'Source'
	BEGIN
		-- Digblock	
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(d.Description, h.Source_Digblock_Id) AS Description, h.Source_Digblock_Id, IsNull(dl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Digblock AS d 
					ON h.Source_Digblock_Id = d.Digblock_Id
				LEFT JOIN dbo.DigblockLocation AS dl
					ON d.Digblock_Id = dl.Digblock_Id
						
		-- Stockpile
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(s.Stockpile_Name, h.Source_Stockpile_Id) AS Description, h.Source_Stockpile_Id, IsNull(sl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Stockpile AS s
					ON h.Source_Stockpile_Id = s.Stockpile_Id
				LEFT JOIN dbo.StockpileLocation AS sl
					ON s.Stockpile_Id = sl.Stockpile_Id
		
		-- Mill
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(m.Description, h.Source_Mill_Id) AS Description, h.Source_Mill_Id, IsNull(ml.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Mill AS m
					ON h.Source_Mill_Id = m.Mill_Id
				LEFT JOIN dbo.MillLocation AS ml
					ON m.Mill_Id = ml.Mill_Id
	END
	Else IF @iFilter_Type = 'Destination'
	BEGIN
		-- Crusher	
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct h.Destination_Crusher_Id AS Description, h.Destination_Crusher_Id, IsNull(cl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Crusher AS c 
					ON h.Destination_Crusher_Id = c.Crusher_Id
				LEFT JOIN dbo.CrusherLocation AS cl
					ON c.Crusher_Id = cl.Crusher_Id
						
		-- Stockpile
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(s.Stockpile_Name, h.Destination_Stockpile_Id) AS Description, h.Destination_Stockpile_Id, IsNull(sl.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Stockpile AS s
					ON h.Destination_Stockpile_Id = s.Stockpile_Id
				LEFT JOIN dbo.StockpileLocation AS sl
					ON s.Stockpile_Id = sl.Stockpile_Id
		
		-- Mill
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT distinct ISNULL(m.Description, h.Destination_Mill_Id) AS Description, h.Destination_Mill_Id, IsNull(ml.Location_Id, 0)
			FROM dbo.Haulage AS h
				JOIN dbo.Mill AS m
					ON h.Destination_Mill_Id = m.Mill_Id
				LEFT JOIN dbo.MillLocation AS ml
					ON m.Mill_Id = ml.Mill_Id
					
	END
	Else IF @iFilter_Type = 'Truck'
	BEGIN
		INSERT INTO @Filter_Table (Filter_Display, Filter_Value, Location_Id)
			SELECT H.Truck_Id, H.Truck_Id, Coalesce(@iLocation_Id, 0)
			FROM Haulage AS H
			GROUP BY H.Truck_Id, H.Truck_Id
	END


/*	SELECT *
	FROM @Filter_Table
	WHERE Location_Id = IsNull(@iLocation_Id, Location_Id)
	ORDER BY Filter_Display 
*/

	SELECT *
	FROM @Filter_Table
	WHERE Location_Id IN 
					(	
						SELECT Location_Id
						FROM dbo.GetLocationSubtree(@iLocation_Id)
					)
	ORDER BY Filter_Display 

END
GO
GRANT EXECUTE ON dbo.GetBhpbioHaulageManagementListFilter TO BhpbioGenericManager
GO


/*
<TAG Name="Data Dictionary" ProcedureName="GetHaulageManagementListFilter">
 <Procedure>
	Returns a list of the given filter type to display in the UI.
	Errors are not raised.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbiostockpilelistbygroups.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioStockpileListByGroups') IS NOT NULL
	DROP PROCEDURE dbo.GetBhpbioStockpileListByGroups
GO

CREATE PROCEDURE dbo.GetBhpbioStockpileListByGroups
(
	@iGroup_By_Stockpile_Groups BIT = 1,
	@iStockpile_Group_Id VARCHAR(31) = NULL,
	@iStockpile_Name VARCHAR(31) = NULL,
	@iIs_Visible BIT = NULL,
	@iIs_Completed BIT = NULL,
	@iMaterial_Type_Id INT = NULL,
	@iSort_Type INT = NULL, --Between 1-4 Defined (see final result return set for definition)
	@iInclude_Grades BIT = 1, --If used = Performance Loss when many stockpiles and/or many grades exist in client system.
	@iFilterStartDate	DATETIME = NULL,
	@iFilterEndDate DATETIME = NULL,
	@iGrade_Visibility Bit = 1,
	@iTransactionStartDate DATETIME = NULL,
	@iTransactionEndDate DATETIME = NULL,
	@iLocationId INT = NULL,
	@iRecordLimit INT = NULL,
	@iStockpileGroupsXml Xml = null,
	@iIncludeLocationsBelow BIT = NULL -- If True then include all stockpiles UNDER this location, not just AT this location
)
WITH ENCRYPTION AS
BEGIN
	SET NOCOUNT ON
	
	SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
	BEGIN TRANSACTION
		
	--Main Result SET
	CREATE TABLE dbo.#StockpileList 
	(
		Stockpile_Id INT NOT NULL, 
		Stockpile_Name VARCHAR(31) COLLATE Database_Default NULL,
		Description VARCHAR(255) COLLATE Database_Default NULL,
		Material_Type_Id INT NULL,
		Is_Completed BIT NOT NULL,
		Approved_Added_Tonnes_This_Month FLOAT NULL,
		Unapproved_Added_Tonnes_This_Month FLOAT NULL, 
		Stockpile_Added_Tonnes_This_Month FLOAT NULL,
		Removed_Tonnes_This_Month FLOAT NULL,
		Current_Tonnes FLOAT NULL, 
		Last_Adjustment_Date DATETIME,
		Last_Adjustment_Description VARCHAR(255) COLLATE Database_Default NULL,

		PRIMARY KEY (Stockpile_Id)
	)

	--For Grade Pivoting
	CREATE TABLE dbo.#StockpileListGrade 
	(
		Stockpile_Id INT NOT NULL, 
		Grade_Name VARCHAR(31) COLLATE Database_Default NOT NULL,
		Grade_Value REAL NULL,

		PRIMARY KEY (Stockpile_Id, Grade_Name)
	)
	
	--Used to enable a single lookup FROM DPT
	CREATE TABLE dbo.#TransactionSummary 
	(
		Stockpile_Id INT NOT NULL,
		Code CHAR(3) COLLATE Database_Default NOT NULL,
		Tonnes FLOAT NULL,

		PRIMARY KEY (Stockpile_Id, Code)
	)

	--Used to enable a single lookup FROM Data Process Stockpile Balance
	CREATE TABLE dbo.#BalanceSummary
	(
		Data_Process_Stockpile_Balance_Id BIGINT NOT NULL,
		Stockpile_Id INT NOT NULL,
		Tonnes FLOAT NOT NULL,

		PRIMARY KEY (Data_Process_Stockpile_Balance_Id, Stockpile_Id)
	)

	DECLARE @MonthStartDate DATETIME
	DECLARE @MonthEndDate DATETIME

	IF @iTransactionStartDate IS NOT NULL
	BEGIN
		SET @MonthStartDate = @iTransactionStartDate
	END
	ELSE
	BEGIN
		--Define the inclusive month boundary
		SET @MonthStartDate = dbo.GetDateMonth(GetDate())
	END
		
	IF @iTransactionEndDate IS NOT NULL
	BEGIN
		SET @MonthEndDate = @iTransactionEndDate
	END
	ELSE
	BEGIN
		--Define the inclusive month boundary
		SET @MonthEndDate = DateAdd(DD, -1, DateAdd(MM, 1, @MonthStartDate))
	END
	
	--Set Sort Type to default of 1 when NULL or out of range sort type is indicated
	IF Coalesce(@iSort_Type, -1) NOT BETWEEN 1 AND 4
	BEGIN 
		SET @iSort_Type = 1
	END
	
	--Ensure stockpile grouping is on when a group filter is in use, The alternative doesn't make sense, 
	IF @iStockpile_Group_Id IS NOT NULL 
	BEGIN
		SET @iGroup_By_Stockpile_Groups = 1
	END	
	INSERT INTO dbo.#StockpileList
	(
		Stockpile_Id, Stockpile_Name, Description, Material_Type_Id, Is_Completed
	)
	SELECT s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id, 
		CASE 
			WHEN Count(csb.Build_Id) = 0 THEN 
				1 
			ELSE 
				0 
			END AS Is_Completed
	FROM dbo.Stockpile AS s	
		LEFT OUTER JOIN dbo.StockpileBuild AS csb
			ON (s.Stockpile_Id = csb.Stockpile_Id
				AND csb.Stockpile_State_Id <> 'CLOSED')
		LEFT OUTER JOIN 
		(
			-- WILL THIS WORK PROPERLY WITH SET ROWCOUNT IN USE???
			SELECT sp.Stockpile_Id, IsNull(spl.Location_Id, 0) AS Location_Id
			FROM dbo.Stockpile AS sp
				LEFT OUTER JOIN dbo.StockpileLocation AS spl
					ON (sp.Stockpile_Id = spl.Stockpile_Id)		
		) AS l
			ON (s.Stockpile_Id = l.Stockpile_Id)
		LEFT JOIN StockpileGroupStockpile SG
			On SG.Stockpile_Id = s.Stockpile_Id
	WHERE s.Is_Visible = ISNULL(@iIs_Visible, s.Is_Visible)
		AND (s.Material_Type_Id = IsNull(@iMaterial_Type_Id, s.Material_Type_Id))
		AND (s.Stockpile_Name LIKE IsNull('%' + @iStockpile_Name + '%', s.Stockpile_Name))
		AND (@iStockpile_Group_Id IS NULL
			OR sg.Stockpile_Group_Id = @iStockpile_Group_Id
			)
		AND ((csb.Start_Date >= IsNull(@iFilterStartDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND ((csb.Start_Date <= IsNull(@iFilterEndDate, csb.Start_Date))
			OR csb.Start_Date IS NULL)
		AND 
			(				
				@iLocationId IS NULL
					OR (
							l.Location_Id = @iLocationId 
							AND @iIncludeLocationsBelow = 0
						)
					OR (
							l.Location_Id IN 
								(	
									SELECT Location_Id
									FROM dbo.GetLocationSubtree(@iLocationId)
								)
							AND @iIncludeLocationsBelow = 1
						)
			)
		AND 
		(
			(
				ISNULL(sg.Stockpile_Group_id, 'Stockpiles NOT Grouped') IN
					(
						SELECT col.value('GroupId[1]', 'varchar(31)')
						FROM @iStockpileGroupsXml.nodes('//StockpileGroups') AS tab(col)
					)
			)
			OR
			(
				SELECT COUNT(1)
				FROM @iStockpileGroupsXml.nodes('//StockpileGroups') AS tab(col)
			) = 0
		)
	GROUP BY s.Stockpile_Id, s.Stockpile_Name, s.Description, s.Material_Type_Id
	HAVING (@iIs_Completed = 1 AND Count(csb.Build_Id) = 0)  --SB is the count of stockpile
		OR (@iIs_Completed = 0 AND Count(csb.Build_Id) > 0)  --builds for this stockpile that arent closed
		OR (@iIs_Completed IS NULL)

	--Summarise DPT Data for the various tonnes balances required		
	INSERT INTO dbo.#TransactionSummary
	(
		Stockpile_Id, Code, Tonnes
	)	
	--Data that IS based ON the Stockpile being the Destination
	SELECT sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END	AS Code,
		Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --JOIN to Dest
			ON (sl.Stockpile_Id = dpt.Destination_Stockpile_Id)
		INNER JOIN dbo.DataTransactionTonnes AS dtt		
			ON (dtt.Data_Transaction_Tonnes_Id = dpt.Data_Transaction_Tonnes_Id)
	WHERE dpt.Data_Process_Transaction_Date Between @MonthStartDate AND @MonthEndDate 
		AND dpt.Stockpile_Adjustment_Id IS NULL
	GROUP BY sl.Stockpile_Id, 
		CASE 
			WHEN dpt.Source_Digblock_Id IS NOT NULL AND dtt.Is_Approved = 1 THEN 
				'APP' --Approved Tonnes
			WHEN dpt.Source_Digblock_Id IS NOT NULL THEN 
				'UNA' --Unapproved Tonnes
			WHEN dpt.Source_Stockpile_Id IS NOT NULL THEN 
				'ADD' --Added Tonnes
			ELSE 
				'N/A' -- Unknown, shouldn't get anything here but just in case not returned to UI anyway
		END
	UNION ALL
	--Data that IS based ON the Stockpile being the Source
	SELECT sl.Stockpile_Id, 'REM' AS Code, Sum(dpt.Tonnes) AS Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.DataProcessTransaction AS dpt --Join to Source
			ON (sl.Stockpile_Id = dpt.Source_Stockpile_Id)
	WHERE dpt.Data_Process_Transaction_Date BETWEEN @MonthStartDate AND @MonthEndDate 
		AND dpt.Stockpile_Adjustment_Id IS NULL	
	GROUP BY sl.Stockpile_Id		

	DELETE SL
	FROM dbo.#StockpileList SL
		LEFT JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id)
	WHERE dpt.Stockpile_Id IS NULL
		AND @iTransactionEndDate IS NOT NULL
		
	IF @iRecordLimit IS NOT NULL
	BEGIN
		DELETE SL
		FROM dbo.#StockpileList SL
		WHERE SL.Stockpile_Id Not In (SELECT TOP (@iRecordLimit) Stockpile_Id
										FROM dbo.#StockpileList
										ORDER BY Stockpile_Id)
	END
	
	-- Obtain the Approved for the month		
	UPDATE sl
	SET Approved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'APP')

	-- Obtain the Unapproved for the month
	UPDATE sl
	SET Unapproved_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'UNA')

	-- Obtain the Stockpile Added Tonnes for the month
	UPDATE sl
	SET Stockpile_Added_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'ADD')

	-- Obtain the Removed Tonnes for the month
	UPDATE sl
	SET Removed_Tonnes_This_Month = dpt.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.#TransactionSummary AS dpt 
			ON (dpt.Stockpile_Id = sl.Stockpile_Id
				AND dpt.Code = 'REM')	--Get the key Records for Stockpile Balance that will be used for current tonnes and grade pivoting

	--Retrieve the balance records that are used, in order to get the current tonnes
	--and also retrieve grades IF requested to (reason for the key being stored)
	INSERT INTO dbo.#BalanceSummary
	(
		Data_Process_Stockpile_Balance_Id, Stockpile_Id, Tonnes
	)
	SELECT d.Data_Process_Stockpile_Balance_Id, sl.Stockpile_Id, d.Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.StockpileBuild AS b
			ON (sl.Stockpile_Id = b.Stockpile_Id)
		INNER JOIN dbo.DataProcessStockpileBalance AS d
			ON (
					b.Stockpile_Id = d.Stockpile_Id
					AND b.Build_Id = d.Build_Id
					AND
					(
						CASE WHEN @iTransactionEndDate IS NOT NULL
							AND @iTransactionEndDate < b.Last_Recalc_Date THEN
							@iTransactionEndDate
						ELSE
							b.Last_Recalc_Date
						END
					) = d.Data_Process_Stockpile_Balance_Date 
					AND
					(
						CASE WHEN @iTransactionEndDate IS NOT NULL
							AND @iTransactionEndDate < b.Last_Recalc_Date THEN
							dbo.GetLastShiftType()
						ELSE
							b.Last_Recalc_Shift 
						END
					) = d.Data_Process_Stockpile_Balance_Shift
				)

	-- Get the Current Tonnes Value by Regrouping the data
	UPDATE sl
	SET Current_Tonnes = dsb.Current_Tonnes
	FROM dbo.#StockpileList AS sl
		INNER JOIN
		(
			SELECT bs.Stockpile_Id,
				Sum(bs.Tonnes) AS Current_Tonnes
			FROM dbo.#BalanceSummary AS bs
			GROUP BY bs.Stockpile_Id
		
		) dsb
		ON dsb.Stockpile_Id = sl.Stockpile_Id
		
	-- Add the last adjustment date AND description
	UPDATE sl
	SET sl.Last_Adjustment_Date = 
		(
			SELECT TOP 1 sa.Adjustment_Date
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
				AND sa.Adjustment_Date < @MonthEndDate
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		),
		sl.Last_Adjustment_Description = 
		(
			SELECT Top 1 sa.Description
			FROM dbo.StockpileAdjustment AS sa
				INNER JOIN dbo.ShiftType AS st
					ON (sa.Adjustment_Shift = st.Shift)
			WHERE sa.Stockpile_Id = sl.Stockpile_Id
				AND sa.Adjustment_Date < @MonthEndDate
			ORDER BY sa.Adjustment_Date DESC, st.Order_No DESC
		)
	FROM dbo.#StockpileList AS sl
							
	--Only Pivot Grades if Required to
	IF @iInclude_Grades = 1
	BEGIN
	
		--EXTRACT GRADES FROM BALANCE DATA

		--Now Populate the stockpile grades table using the balance details collected
		INSERT INTO dbo.#StockpileListGrade
		(
			Stockpile_Id, Grade_Name, 
			Grade_Value
		)
		SELECT BS.Stockpile_Id, G.Grade_Name, 
			Sum(BS.Tonnes * DPSBG.Grade_Value) / NullIf(Sum(BS.Tonnes), .00) AS Grade_Value
		FROM dbo.#BalanceSummary AS BS
			INNER JOIN dbo.DataProcessStockpileBalanceGrade AS DPSBG
				ON DPSBG.Data_Process_Stockpile_Balance_Id = BS.Data_Process_Stockpile_Balance_Id
			INNER JOIN dbo.Grade AS G
				ON DPSBG.Grade_Id = G.Grade_Id
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)
		GROUP BY BS.Stockpile_Id, G.Grade_Name

		UNION ALL

		--Dummy Grade Values Ensure All Grade are Pivoted
		SELECT -1 AS Stockpile_Id, G.Grade_Name, Null AS Grade_Value
		FROM dbo.Grade AS G
		WHERE (G.Is_Visible = @iGrade_Visibility 
			OR @iGrade_Visibility IS NULL)

		--Pivot Grades Onto Main table
		EXEC dbo.PivotTable
			@iTargetTable='#StockpileList',
			@iPivotTable='#StockpileListGrade',
			@iJoinColumns='#StockpileList.Stockpile_Id = #StockpileListGrade.Stockpile_Id',
			@iPivotColumn='Grade_Name',
			@iPivotValue='Grade_Value',
			@iPivotType='REAL'			
	END				
	
	-- Return the dataset with its stockpile groups if they exist (denormalised dataset here with many groups potentially)
	SELECT Coalesce(sg.Stockpile_Group_Id, 'Stockpiles NOT Grouped') AS Stockpile_Group_Id,
		sl.*, --May Include Grades
		mt.Description AS Material_Type_Description,
		mt.Native_Alternative,		
		mt.Abbreviation,		
		mtg.Order_No,		
		mt.Is_Waste			
	FROM dbo.#StockpileList AS sl
		INNER JOIN dbo.MaterialType AS mt
			ON (mt.Material_Type_Id = sl.Material_Type_Id)
		INNER JOIN dbo.MaterialTypeGroup AS mtg
			ON (mt.Material_Type_Group_Id = mtg.Material_Type_Group_Id)
		LEFT OUTER JOIN dbo.StockpileGroupStockpile AS sgs 
			INNER JOIN dbo.StockpileGroup AS sg
				ON (sgs.Stockpile_Group_Id = sg.Stockpile_Group_Id
					--Stockpile Ggroup Requires refiltering here, otherwise if a specific stockpile group is filtered for ealier
					--AND stockpile belongs to that group and another, the extra groups will also be returned
					AND sg.Stockpile_Group_Id = IsNull(@iStockpile_Group_Id, sg.Stockpile_Group_Id))
			--Only JOIN To stockpile GROUP IF indicated BY filter options
			ON (sgs.Stockpile_Id = CASE
									WHEN @iGroup_By_Stockpile_Groups = 0
										THEN NULL --Do not join to Stockpile group No stockpile Groups/Duplicates will be returned
									ELSE sl.Stockpile_Id --Each stockpile will be listed with each group to which it belongs
								END)
	-- Sort Type Ordering Configuration
	-- 1 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Stockpile_Name
	-- 2 = ORDER BY Coalesce(sg.Order_No, 10000), mt.Native_Alternative, sl.Stockpile_Name
	-- 3 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Description
	-- 4 = ORDER BY Coalesce(sg.Order_No, 10000), sl.Order_No, mt.Is_Waste, mt.Abbreviation, sl.Description
	
	WHERE 
		(
			ISNULL(sg.Stockpile_Group_id, 'Stockpiles NOT Grouped') IN
				(
					SELECT col.value('GroupId[1]', 'varchar(31)')
					FROM @iStockpileGroupsXml.nodes('//StockpileGroups') AS tab(col)
				)
		)
		OR
		(
			SELECT COUNT(1)
			FROM @iStockpileGroupsXml.nodes('//StockpileGroups') AS tab(col)
		) = 0
	ORDER BY Coalesce(sg.Order_No, 10000), --sort position 1
		CASE @iSort_Type --sort position 2
			WHEN 1 THEN sl.Stockpile_Name
			WHEN 2 THEN mt.Native_Alternative
			WHEN 3 THEN sl.Description
			WHEN 4 THEN Cast(mtg.Order_No AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 3
			WHEN 2 THEN sl.Stockpile_Name
			WHEN 4 THEN Cast(mt.Is_Waste AS VARCHAR)
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 4
			WHEN 4 THEN mt.Abbreviation
			ELSE '0' --no further sort defined 
		END,
		CASE @iSort_Type --sort position 5
			WHEN 4 THEN sl.Description
			ELSE '0' --no further sort defined 
		END		
	
	DROP TABLE dbo.#StockpileList
	DROP TABLE dbo.#TransactionSummary
	DROP TABLE dbo.#BalanceSummary
	DROP TABLE dbo.#StockpileListGrade

	COMMIT TRANSACTION	
END

GO
GRANT EXECUTE ON dbo.GetBhpbioStockpileListByGroups TO CoreStockpileManager
GO
/*
<TAG Name="Data Dictionary" ProcedureName="GetStockpileList">
 <Procedure>
  Returns the list of stockpile details.
 </Procedure>
</TAG>
*/

GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbioreportdataactualbeneproduct.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataActualBeneProduct') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataActualBeneProduct
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataActualBeneProduct
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	DECLARE @ProductRecord TABLE
	(
		CalendarDate DATETIME NOT NULL,
		WeightometerSampleId INT NOT NULL,
		EffectiveTonnes FLOAT NOT NULL,
		MaterialTypeId INT NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (CalendarDate, WeightometerSampleId, MaterialTypeId)
	)
	
	DECLARE @BeneProductMaterialTypeId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataActualBeneProduct',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		-- collect the location subtree
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, NULL)

		-- determine the return material type
		SET @BeneProductMaterialTypeId =
			(
				SELECT Material_Type_Id
				FROM dbo.MaterialType
				WHERE Material_Category_Id = 'Designation'
					AND Abbreviation = 'Bene Product'
			)

		INSERT INTO @ProductRecord
		(
			CalendarDate, WeightometerSampleId, EffectiveTonnes,
			MaterialTypeId, DateFrom, DateTo, ParentLocationId
		)
		SELECT b.CalendarDate, ws.Weightometer_Sample_Id, ISNULL(ws.Corrected_Tonnes, ws.Tonnes),
			@BeneProductMaterialTypeId, b.DateFrom, b.DateTo, l.ParentLocationId
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS b
			INNER JOIN dbo.WeightometerSample AS ws
				ON (ws.Weightometer_Sample_Date BETWEEN b.DateFrom AND b.DateTo)
			INNER JOIN
				(
					SELECT DISTINCT dttf.Weightometer_Sample_Id, ml.Location_Id
					FROM dbo.DataTransactionTonnesFlow AS dttf
						-- sourced from a mill
						INNER JOIN dbo.Mill AS m
							ON (m.Stockpile_Id = dttf.Source_Stockpile_Id)
						INNER JOIN dbo.MillLocation AS ml
							ON (m.Mill_Id = ml.Mill_Id)
						-- delivered to a post crusher stockpile
						INNER JOIN dbo.StockpileGroupStockpile AS sgs
							ON (dttf.Destination_Stockpile_Id = sgs.Stockpile_Id
								AND sgs.Stockpile_Group_Id = 'Post Crusher')
				) AS dttf
				ON (dttf.Weightometer_Sample_Id = ws.Weightometer_Sample_Id)
			INNER JOIN @Location AS l
				ON (l.LocationId = dttf.Location_Id)
		
		-- return Tonnes
		SELECT CalendarDate, ParentLocationId, DateFrom, DateTo, MaterialTypeId, SUM(EffectiveTonnes) AS Tonnes
		FROM @ProductRecord
		GROUP BY CalendarDate, ParentLocationId, DateFrom, DateTo, MaterialTypeId
			
		-- return Grades
		SELECT p.CalendarDate, p.ParentLocationId, p.MaterialTypeId, g.Grade_Id, g.Grade_Name AS GradeName,
			SUM(p.EffectiveTonnes * wsg.Grade_Value) / SUM(p.EffectiveTonnes) AS GradeValue
		FROM @ProductRecord AS p
			CROSS JOIN dbo.Grade AS g
			LEFT OUTER JOIN dbo.WeightometerSampleGrade AS wsg
				ON (wsg.Grade_Id = g.Grade_Id
					AND wsg.Weightometer_Sample_Id = p.WeightometerSampleId) 
		GROUP BY p.CalendarDate, p.ParentLocationId, p.DateFrom, p.DateTo, p.MaterialTypeId, g.Grade_Id, g.Grade_Name

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataActualBeneProduct TO BhpbioGenericManager
GO

/* testing

EXEC dbo.GetBhpbioReportDataActualBeneProduct 
	@iDateFrom = '1-apr-2008',
	@iDateTo = '30-apr-2008',
	@iDateBreakdown = 'MONTH',
	@iLocationId = 6,
	@iChildLocations = 1
*/


GO


Print 'Code: ReconcilorBhpbio->Schema\Procedures\dbo.DoesBhpbioQueuedBlocksJobExist.prc'
GO

IF OBJECT_ID('dbo.DoesBhpbioQueuedBlocksJobExist') IS NOT NULL
     DROP PROCEDURE dbo.DoesBhpbioQueuedBlocksJobExist
GO 
  
CREATE PROCEDURE dbo.DoesBhpbioQueuedBlocksJobExist
(
	@iImportId INT,
	@iSite VARCHAR(31),
	@iPit VARCHAR(31),
	@iBench VARCHAR(31),
	@oExists BIT OUTPUT
)

AS 
BEGIN 

	Set @oExists = dbo.BhpbioDoesQueuedBlocksJobExist(@iImportId, @iSite, @iPit, @iBench)

END
GO


GRANT EXECUTE ON dbo.DoesBhpbioQueuedBlocksJobExist TO BhpbioGenericManager
GO


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.calcvirtualflow.prc'
GO

IF OBJECT_ID('dbo.CalcVirtualFlow') IS NOT NULL
	DROP PROCEDURE dbo.CalcVirtualFlow
GO 
  
CREATE PROCEDURE dbo.CalcVirtualFlow
AS 
BEGIN 

	SET NOCOUNT ON 
	
	BEGIN TRY

		DECLARE @CalcDate DATETIME
		DECLARE @CalcVirtualFlowId INT

		SET @CalcVirtualFlowId = 0
		SELECT TOP 1 @CalcDate = Calc_Date, @CalcVirtualFlowId = Calc_Virtual_Flow_Id
		FROM CalcVirtualFlowQueue
		ORDER BY Calc_Date, Calc_Virtual_Flow_Id Desc

		WHILE (COALESCE(@CalcVirtualFlowId, 0) > 0)
		BEGIN
			EXEC dbo.CalcWhalebackVirtualFlow
				@iCalcDate = @CalcDate
			
			EXEC dbo.CalcYandiVirtualFlow
				@iCalcDate = @CalcDate	
				
			EXEC dbo.CalcNjvVirtualFlow
				@iCalcDate = @CalcDate	
			
			DELETE FROM CalcVirtualFlowQueue
			WHERE Calc_Date = @CalcDate
				AND Calc_Virtual_Flow_Id <= @CalcVirtualFlowId
			
			SET @CalcVirtualFlowId = 0
			SELECT TOP 1 @CalcDate = Calc_Date, @CalcVirtualFlowId = Calc_Virtual_Flow_Id
			FROM CalcVirtualFlowQueue
			ORDER BY Calc_Date, Calc_Virtual_Flow_Id Desc
		END
		
	END TRY
	BEGIN CATCH
		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.CalcVirtualFlow TO BhpbioGenericManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.CalcVirtualFlow">
 <Procedure>
	Processes the Calc Virtual Flow Queue in date order, and calls the Whaleback and  Yandi calc virtual flows
 </Procedure>
</TAG>
*/



GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.BhpbioTryDeleteLocation.prc'
GO

IF OBJECT_ID('dbo.BhpbioTryDeleteLocation') IS NOT NULL
     DROP PROCEDURE dbo.BhpbioTryDeleteLocation
GO 
  
CREATE PROCEDURE dbo.BhpbioTryDeleteLocation
( 
    @iLocationId INT,
	@iName VARCHAR(31),
	@iLocationTypeId TINYINT,
	@iParentLocationName VARCHAR(31),
	@oIsError BIT OUTPUT,
	@oErrorMessage VARCHAR(255) OUTPUT
)
AS
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @IsError BIT
	DECLARE @ErrorMessage VARCHAR(255)
	DECLARE @LocationId INT

	SET NOCOUNT ON 

	SELECT @TransactionName = 'TryDeleteLocation',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
		-- if the location id is not given
		IF (@iLocationId IS NULL)
		BEGIN
			-- obtain it from the other details given
			IF (@iLocationTypeId IS NOT NULL)
			BEGIN
				SET @LocationId =	
					(
						SELECT Location_Id
						FROM dbo.Location
						WHERE Name = @iName
							AND Location_Type_Id = @iLocationTypeId
					)
			END
			ELSE
			BEGIN
				SET @LocationId =	
					(
						SELECT L.Location_Id
						FROM dbo.Location AS L
							INNER JOIN dbo.Location AS PL
								ON (L.Parent_Location_Id = PL.Location_Id)
						WHERE L.Name = @iName
							AND PL.Name = @iParentLocationName
					)
			END
		END	
		ELSE
		BEGIN
			SET @LocationId = @iLocationId
		END

		SET @IsError = 0
		SET @ErrorMessage = NULL
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioApprovalData
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a F1F2F3 Approval.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioDataExceptionLocation
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Data Exception.'
		END
				
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioLocationStockpileConfiguration
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a BHPBIO Custom Configuration - Stockpiles.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioPortBalance
				WHERE HubLocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Port Balance Record.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioPortBlending
				WHERE RakeHubLocationId = @LocationId
					OR MoveHubLocationId = @LocationId
					OR DestinationHubLocationId = @LocationId
					OR LoadSiteLocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Port Blending Record.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioReportThreshold
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Reporting Threshold.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioSecurityRoleLocation
				WHERE LocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Security Role.'
		END
		
		IF EXISTS
			(
				SELECT TOP 1 1
				FROM dbo.BhpbioShippingTransactionNomination
				WHERE HubLocationId = @LocationId
			)
		BEGIN
			SET @IsError = 1
			SET @ErrorMessage = 'This location is currently in use by a Shipping Record.'
		END
		
			
		-- delete the location record
		IF @IsError = 0
		BEGIN
			EXEC dbo.TryDeleteLocation
				@iLocationId = @iLocationId,
				@iName = @iName,
				@iLocationTypeId = @iLocationTypeId,
				@iParentLocationName = @iParentLocationName,
				@oIsError = @oIsError OUTPUT,
				@oErrorMessage = @oErrorMessage OUTPUT
		END	

		-- return the check results
		SET @oIsError = @IsError
		SET @oErrorMessage = @ErrorMessage

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.BhpbioTryDeleteLocation TO CoreUtilityManager
GO

/*
<TAG Name="Data Dictionary" ProcedureName="dbo.BhpbioTryDeleteLocation">
 <Procedure>
	Attempts to deletes a record from the Location table.
	Can be called by on of the following methods:
	  1. Providing the location id
	  2. Providing the location name and parent location name, if the location is in a hierarchical group which has a parent group
	  3. Providing the location name and location type group, if the location is in an independant group
	Errors are raised if:
		The Location Exists in the Bhpbio approvals tables
		Any Core Checks.
 </Procedure>
</TAG>
*/


GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbioreportdatahubpostcrusherstockpiledelta.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataHubPostCrusherStockpileDelta') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataHubPostCrusherStockpileDelta 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataHubPostCrusherStockpileDelta
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	DECLARE @StockpileDelta TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		StockpileId INT NOT NULL,
		WeightometerSampleId INT NOT NULL,
		Tonnes FLOAT NOT NULL,
		LocationId INT NULL,
		Addition BIT NOT NULL,
		ChildLocationId INT NULL,
		PRIMARY KEY (CalendarDate, StockpileId, WeightometerSampleId, Addition)
	)
	
	DECLARE @GradeLocation TABLE
	(
		CalendarDate DATETIME NOT NULL,
		ActualLocationId INT NULL
	)
	
	DECLARE @StockpileGroupId VARCHAR(31)
	SET @StockpileGroupId = 'Post Crusher'
	DECLARE @LastShift CHAR(1)
	DECLARE @HubLocationTypeId INT
	DECLARE @SiteLocationTypeId INT
	DECLARE @SampleSourceField VARCHAR(31)
	SET @SampleSourceField = 'SampleSource'
	DECLARE @SampleTonnesField VARCHAR(31)
	SET @SampleTonnesField = 'SampleTonnes'
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataHubPostCrusherStockpileDelta',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, 'Site')

		SELECT @HubLocationTypeId = Location_Type_Id
		FROM dbo.LocationType
		WHERE Description = 'Hub'
		SELECT @SiteLocationTypeId = Location_Type_Id
		FROM dbo.LocationType
		WHERE Description = 'Site'

		-- Get Removals
		INSERT INTO @StockpileDelta
			(CalendarDate, DateFrom, DateTo, StockpileId, WeightometerSampleId, Addition, Tonnes, LocationId, ChildLocationId)		
		SELECT CalendarDate, DateFrom, DateTo, S.Stockpile_Id, WS.Weightometer_Sample_Id, 0, WS.Tonnes, L.ParentLocationId, L.LocationId
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.WeightometerSample AS WS
				ON (WS.Weightometer_Sample_Date BETWEEN B.DateFrom AND B.DateTo)
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = WS.Source_Stockpile_Id)
			INNER JOIN dbo.StockpileGroupStockpile AS SGS
				ON (SGS.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN dbo.StockpileLocation AS SL
				ON (SL.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = SL.Location_Id)
			LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
				ON (BSLC.LocationId = SL.Location_Id)
			INNER JOIN dbo.Location AS LL
				ON (LL.Location_Id = L.LocationId)
			LEFT JOIN dbo.StockpileGroupStockpile SGS_D
				ON (SGS_D.Stockpile_Id = WS.Destination_Stockpile_Id
					AND SGS_D.Stockpile_Group_Id = @StockpileGroupId)
		WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
			AND SGS.Stockpile_Group_Id = @StockpileGroupId
			AND SGS_D.Stockpile_Group_Id IS NULL -- Ensure join to check if destination is Post Crusher isn't true.
			AND (LL.Location_Type_Id = @HubLocationTypeId OR
			(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))

		-- Get Additions
		INSERT INTO @StockpileDelta
			(CalendarDate, DateFrom, DateTo, StockpileId, WeightometerSampleId, Addition, Tonnes, LocationId, ChildLocationId)		
		SELECT CalendarDate, DateFrom, DateTo, S.Stockpile_Id, WS.Weightometer_Sample_ID, 1, WS.Tonnes, L.ParentLocationId, L.LocationId
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.WeightometerSample AS WS
				ON (WS.Weightometer_Sample_Date BETWEEN B.DateFrom AND B.DateTo)
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = WS.Destination_Stockpile_Id)
			INNER JOIN dbo.StockpileGroupStockpile AS SGS
				ON (SGS.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN dbo.StockpileLocation AS SL
				ON (SL.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = SL.Location_Id)
			LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
				ON (BSLC.LocationId = SL.Location_Id)
			INNER JOIN dbo.Location AS LL
				ON (LL.Location_Id = L.LocationId)
			LEFT JOIN dbo.StockpileGroupStockpile SGS_S
				ON (SGS_S.Stockpile_Id = WS.Source_Stockpile_Id
					AND SGS_S.Stockpile_Group_Id = @StockpileGroupId)
		WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
			AND SGS.Stockpile_Group_Id = @StockpileGroupId
			AND SGS_S.Stockpile_Group_Id IS NULL  -- Ensure join to check if source is Post Crusher isn't true.
			AND (LL.Location_Type_Id = @HubLocationTypeId OR 
			(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))
			
		-- Obtain the Delta tonnes
		SELECT SD.CalendarDate, SD.DateFrom, SD.DateTo, NULL AS MaterialTypeId, SD.LocationId AS ParentLocationId,
			Sum(CASE WHEN SD.Addition = 1 THEN SD.Tonnes ELSE -SD.Tonnes END) AS Tonnes
		FROM @StockpileDelta AS SD
		GROUP BY SD.CalendarDate, SD.DateFrom, SD.DateTo, SD.LocationId

		SELECT R.CalendarDate, R.GradeName, R.MaterialTypeId, R.ParentLocationId, 
			SUM(R.GradeValue * SD.Tonnes) / NULLIF(Sum(SD.Tonnes), 0) As GradeValue
		FROM (
			-- Obtain the grade relevant for movements around the hub
			SELECT B.CalendarDate As CalendarDate, G.Grade_Name As GradeName, 
				NULL AS MaterialTypeId, L.ParentLocationId AS ParentLocationId,
				L.LocationId As LocationId,
				Sum(WSV.Field_Value * WSG.Grade_Value)
						/ NULLIF(Sum(WSV.Field_Value), 0) AS GradeValue
			FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
				INNER JOIN dbo.WeightometerSample AS ws
					ON (WS.Weightometer_Sample_Date BETWEEN B.DateFrom AND B.DateTo)
				INNER JOIN WeightometerSampleGrade WSG
					ON (ws.Weightometer_Sample_Id = WSG.Weightometer_Sample_Id)
				INNER JOIN dbo.WeightometerLocation AS wl
					ON (ws.Weightometer_Id = wl.Weightometer_Id)
				INNER JOIN @Location AS L
					ON (L.LocationId = wl.Location_Id)
				INNER JOIN dbo.WeightometerSampleNotes AS wsn
					ON (wsn.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
						AND wsn.Weightometer_Sample_Field_Id = @SampleSourceField)
				INNER JOIN dbo.WeightometerSampleValue AS wsv
					ON (wsv.Weightometer_Sample_Id = ws.Weightometer_Sample_Id
						AND wsv.Weightometer_Sample_Field_Id = @SampleTonnesField)
				INNER JOIN dbo.GetBhpbioWeightometerSampleSource(@iLocationId, @iDateFrom, @iDateTo) AS ss
					ON (dbo.GetDateMonth(ws.Weightometer_Sample_Date) = ss.MonthPeriod
						AND L.LocationId = ss.LocationId
							AND wsn.Notes = ss.SampleSource)
				INNER JOIN dbo.Location AS LL
					ON (LL.Location_Id = L.LocationId)
				LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
					ON (BSLC.LocationId = L.LocationId)
				INNER JOIN Grade G
					ON (G.Grade_Id = WSG.Grade_Id)
			WHERE (LL.Location_Type_Id = @HubLocationTypeId OR 
				(BSLC.PromoteStockpiles = 1 AND LL.Location_Type_Id = @SiteLocationTypeId))
			GROUP BY B.CalendarDate, G.Grade_Name, L.ParentLocationId, L.LocationId
			) AS R
			INNER JOIN (Select CalendarDate, ChildLocationId AS LocationId,
							ABS(Sum(CASE WHEN Addition = 1 THEN Tonnes ELSE -Tonnes END)) AS Tonnes
						FROM @StockpileDelta
						GROUP BY CalendarDate, ChildLocationId) AS SD
				ON (SD.LocationId = R.LocationId)
			GROUP BY R.CalendarDate, R.GradeName, R.MaterialTypeId, R.ParentLocationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataHubPostCrusherStockpileDelta TO BhpbioGenericManager
GO

/*
exec dbo.GetBhpbioReportDataHubPostCrusherStockpileDelta 
@iDateFrom='2008-04-01 00:00:00',@iDateTo='2008-Jun-30 00:00:00',@iDateBreakdown=NULL,@iLocationId=1,@iChildLocations=0
*/



GO


Print 'Code: ReconcilorBhpbio->schema\Procedures\dbo.getbhpbioreportdatasitepostcrusherstockpiledelta.prc'
GO

IF OBJECT_ID('dbo.GetBhpbioReportDataSitePostCrusherStockpileDelta') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataSitePostCrusherStockpileDelta 
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataSitePostCrusherStockpileDelta
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)

	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		PRIMARY KEY (LocationId)
	)

	DECLARE @StockpileDelta TABLE
	(
		CalendarDate DATETIME NOT NULL,
		DateFrom DATETIME NOT NULL,
		DateTo DATETIME NOT NULL,
		StockpileId INT NOT NULL,
		WeightometerSampleId INT NOT NULL,
		Tonnes FLOAT NOT NULL,
		LocationId INT NULL,
		Addition BIT NOT NULL,
		PRIMARY KEY (CalendarDate, StockpileId, WeightometerSampleId, Addition)
	)
	
	DECLARE @StockpileGroupId VARCHAR(31)
	SET @StockpileGroupId = 'Post Crusher'
	DECLARE @LastShift CHAR(1)

	DECLARE @HubLocationTypeId INT
	DECLARE @SiteLocationTypeId INT
	
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataSitePostCrusherStockpileDelta',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END
  
	BEGIN TRY
	
	
		SELECT @HubLocationTypeId = Location_Type_Id
		FROM dbo.LocationType
		WHERE Description = 'Hub'
		SELECT @SiteLocationTypeId = Location_Type_Id
		FROM dbo.LocationType
		WHERE Description = 'Site'
		
		INSERT INTO @Location
			(LocationId, ParentLocationId)
		SELECT LocationId, ParentLocationId
		FROM dbo.GetBhpbioReportLocationBreakdown(@iLocationId, @iChildLocations, NULL)

		-- Get Removals
		INSERT INTO @StockpileDelta
			(CalendarDate, DateFrom, DateTo, StockpileId, WeightometerSampleId, Addition, Tonnes, LocationId)		
		SELECT CalendarDate, DateFrom, DateTo, S.Stockpile_Id, WS.Weightometer_Sample_Id, 0, WS.Tonnes, L.ParentLocationId
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.WeightometerSample AS WS
				ON (WS.Weightometer_Sample_Date BETWEEN B.DateFrom AND B.DateTo)
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = WS.Source_Stockpile_Id)
			INNER JOIN dbo.StockpileGroupStockpile AS SGS
				ON (SGS.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN dbo.StockpileLocation AS SL
				ON (SL.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = SL.Location_Id)
			LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
				ON (BSLC.LocationId = SL.Location_Id)
			INNER JOIN dbo.Location AS LL
				ON (LL.Location_Id = L.LocationId)
			LEFT JOIN dbo.StockpileGroupStockpile SGS_D
				ON (SGS_D.Stockpile_Id = WS.Destination_Stockpile_Id
					AND SGS_D.Stockpile_Group_Id = @StockpileGroupId)
		WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
			AND SGS.Stockpile_Group_Id = @StockpileGroupId
			AND SGS_D.Stockpile_Group_Id IS NULL -- Ensure join to check if destination is Post Crusher isn't true.
			AND (LL.Location_Type_Id = @SiteLocationTypeId AND
			(BSLC.PromoteStockpiles = 0 OR BSLC.PromoteStockpiles IS NULL))
			AND WS.Weightometer_Id NOT LIKE '%Raw%'
			
		-- Get Additions
		INSERT INTO @StockpileDelta
			(CalendarDate, DateFrom, DateTo, StockpileId, WeightometerSampleId, Addition, Tonnes, LocationId)		
		SELECT CalendarDate, DateFrom, DateTo, S.Stockpile_Id, WS.Weightometer_Sample_ID, 1, WS.Tonnes, L.ParentLocationId
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 1 /* do not include data before start date */) AS B
			INNER JOIN dbo.WeightometerSample AS WS
				ON (WS.Weightometer_Sample_Date BETWEEN B.DateFrom AND B.DateTo)
			INNER JOIN dbo.Stockpile AS S
				ON (S.Stockpile_Id = WS.Destination_Stockpile_Id)
			INNER JOIN dbo.StockpileGroupStockpile AS SGS
				ON (SGS.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN dbo.StockpileLocation AS SL
				ON (SL.Stockpile_Id = S.Stockpile_Id)
			INNER JOIN @Location AS L
				ON (L.LocationId = SL.Location_Id)
			LEFT JOIN dbo.BhpbioLocationStockpileConfiguration AS BSLC
				ON (BSLC.LocationId = SL.Location_Id)
			INNER JOIN dbo.Location AS LL
				ON (LL.Location_Id = L.LocationId)
			LEFT JOIN dbo.StockpileGroupStockpile SGS_S
				ON (SGS_S.Stockpile_Id = WS.Source_Stockpile_Id
					AND SGS_S.Stockpile_Group_Id = @StockpileGroupId)
		WHERE Coalesce(WS.Source_Stockpile_Id, -1) <> Coalesce(WS.Destination_Stockpile_Id, -1)
			AND SGS.Stockpile_Group_Id = @StockpileGroupId
			AND SGS_S.Stockpile_Group_Id IS NULL  -- Ensure join to check if source is Post Crusher isn't true.
			AND (LL.Location_Type_Id = @SiteLocationTypeId AND
			(BSLC.PromoteStockpiles = 0 OR BSLC.PromoteStockpiles IS NULL))
			AND WS.Weightometer_Id NOT LIKE '%Raw%'
			
		-- Obtain the Delta tonnes
		SELECT SD.CalendarDate, SD.DateFrom, SD.DateTo, NULL AS MaterialTypeId, SD.LocationId AS ParentLocationId,
			Sum(CASE WHEN SD.Addition = 1 THEN SD.Tonnes ELSE -SD.Tonnes END) AS Tonnes
		FROM @StockpileDelta AS SD
		GROUP BY SD.CalendarDate, SD.DateFrom, SD.DateTo, SD.LocationId

		-- Obtain the Delta Grades
		SELECT SD.CalendarDate, G.Grade_Name As GradeName, NULL AS MaterialTypeId, SD.LocationId AS ParentLocationId,
			Sum(WS.Tonnes * WSG.Grade_Value)
			/ NULLIF(Sum(WS.Tonnes), 0) AS GradeValue
		FROM @StockpileDelta AS SD
			INNER JOIN dbo.WeightometerSample AS WS
				ON (WS.Weightometer_Sample_Id = SD.WeightometerSampleId)
			INNER JOIN dbo.WeightometerSampleGrade AS WSG
				ON (WSG.Weightometer_Sample_Id = WS.Weightometer_Sample_Id)
			INNER JOIN dbo.Grade AS G
				ON (G.Grade_Id = WSG.Grade_Id)
		GROUP BY SD.CalendarDate, G.Grade_Name, SD.LocationId

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataSitePostCrusherStockpileDelta TO BhpbioGenericManager
GO

/*
exec dbo.GetBhpbioReportDataSitePostCrusherStockpileDelta 
@iDateFrom='2008-04-01 00:00:00',@iDateTo='2008-Jun-30 00:00:00',@iDateBreakdown=NULL,@iLocationId=1,@iChildLocations=0
*/



GO



