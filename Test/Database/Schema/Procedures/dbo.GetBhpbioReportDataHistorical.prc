IF OBJECT_ID('dbo.GetBhpbioReportDataHistorical') IS NOT NULL
     DROP PROCEDURE dbo.GetBhpbioReportDataHistorical
GO 
  
CREATE PROCEDURE dbo.GetBhpbioReportDataHistorical
(
	@iDateFrom DATETIME,
	@iDateTo DATETIME,
	@iDateBreakdown VARCHAR(31),
	@iLocationId INT,
	@iChildLocations BIT
)
WITH ENCRYPTION
AS 
BEGIN 
	-- Provides a list of Tags, Tonnes and Grades for the requested period
	-- This is generated by querying directly from (and aggregating content from) dbo.BhpbioReportDataHistorical
	--
	-- Works based on the following assumptions:
	-- 1. The underlying tables has NO gaps in the data for HistoricalStartDate <= x <= SystemStartDate
	--    This applies independantly for MONTH and QUARTER.
	-- 2. The dates requested must make sense (i.e. fall on a month/quarter period)
	--    i.e. when MONTH then first-day-of-month-from to last-day-of-month-to (i.e. 01-JAN to 31-JAN)
	--         when QUARTER then then first-day-of-quarter-from to last-day-of-quarter-to  (i.e. 01-JAN to 31-MAR)
	--         when YEAR - this is simply mapped back to a quarter
	-- 3. When reporting MONTHLY,  data held only QUARTERLY is extrapolated over the months being reported
	--      there is no other fancy fall-backs supported (MONTHLY aggregated to QUARTERS for example)
	-- 4. All content returned can be mass-aggregated; FxFACTOR tags are explicitly removed for this reason.
	--    All of this content will be further manipulated within the consuming calculation classes.

	DECLARE @TransactionCount INT
	DECLARE @TransactionName VARCHAR(32)
	
	DECLARE @Location TABLE
	(
		LocationId INT NOT NULL,
		ParentLocationId INT NULL,
		IncludeStart DATETIME NOT NULL,
		IncludeEnd DATETIME NOT NULL
		PRIMARY KEY (LocationId, IncludeStart, IncludeEnd)
	)
	
	DECLARE @DataBreakdown VARCHAR(31)
	DECLARE @SystemStartDate DATETIME
	DECLARE @LocationTypeId INT
	DECLARE @LocationTypeDescription VARCHAR(31)
	SET @LocationTypeDescription = 'Pit'
		
	SET NOCOUNT ON 

	SELECT @TransactionName = 'GetBhpbioReportDataHistorical',
		@TransactionCount = @@TranCount 

	-- if there are no transactions available then start a new one
	-- if there is already a transaction then only mark a savepoint
	IF @TransactionCount = 0
	BEGIN
		SET TRANSACTION ISOLATION LEVEL REPEATABLE READ 
		BEGIN TRANSACTION
	END
	ELSE
	BEGIN
		SAVE TRANSACTION @TransactionName
	END

	BEGIN TRY
		-- validate that the FROM/TO date is valid
		IF DAY(@iDateFrom) <> 1
		BEGIN
			RAISERROR('The From Date must be the first day of the month.', 16, 1)
		END
		IF DAY(@iDateTo+1) <> 1
		BEGIN
			RAISERROR('The To Date must be the last day of the month.', 16, 1)
		END

		SET @SystemStartDate =
			(
				SELECT Cast(Value AS DATETIME)
				FROM dbo.Setting 
				WHERE Setting_Id = 'SYSTEM_START_DATE'
			)

		-- if no Date Breakdown is specified then default the Data Breakdown to month
		-- although quaterly data is generally available it's a hit-and-miss exercise of data appearing / not appearing
		-- based on the dates selected.  it has been decided to "keep it consistent" by forcing it to Month
		-- note that the Date Breakdown and the Data Breakdown are different concepts;
		-- Date Breakdown represents how we want the output results to look.  One record?  By Month?  By Quarter?
		-- Data Breakdown represents at what level the data is stored at
		SET @DataBreakdown = @iDateBreakdown
		IF @DataBreakdown IS NULL
		BEGIN
			-- default to MONTH
			SET @DataBreakdown = 'MONTH'
			-- if the requested dates are QUARTER compatible then use this instead
			IF (MONTH(@iDateFrom) IN (1, 4, 7, 10)) AND (MONTH(@iDateTo) IN (3, 6, 9, 12))
			BEGIN
				SET @DataBreakdown = 'QUARTER'
			END	
		END
		ELSE IF @DataBreakdown = 'YEAR'
		BEGIN
			-- If a YEAR breakdown is selected, use quarters
			SET @DataBreakdown = 'QUARTER'
		END
		
		-- determine the locations to be included
		INSERT INTO @Location
			(LocationId, ParentLocationId, IncludeStart, IncludeEnd)
		SELECT LocationId, ParentLocationId, IncludeStart, IncludeEnd
		FROM dbo.GetBhpbioReportLocationBreakdownWithOverride(@iLocationId, @iChildLocations, @LocationTypeDescription, @iDateFrom, @iDateTo)

		-- remove any locaitons which have thier parent already listed
--		DELETE AL
--		FROM @Location AS AL	
--			INNER JOIN dbo.Location AS L
--				ON (L.Location_Id = AL.LocationId)
--			INNER JOIN (
--						SELECT IHD.LocationId 
--						FROM dbo.BhpbioReportDataHistorical AS IHD
--							INNER JOIN @Location AS IL
--								ON (IL.LocationId = IHD.LocationId)
--						GROUP BY IHD.LocationId
--						) AS HL
--				ON (L.Parent_Location_Id = HL.LocationId)

		-- create a table to collate historic data
		--    in some cases this table will be augmented if neccessary by further aggregation logic
		DECLARE @historicData TABLE (
			TagId VARCHAR(63) COLLATE DATABASE_DEFAULT NOT NULL, 
			LocationId INT NOT NULL, 
			MaterialTypeId INT NULL, 
			CalendarDate DATETIME, 
			DateFrom DATETIME, 
			DateTo DATETIME, 
			DateBreakdown VARCHAR(31) COLLATE DATABASE_DEFAULT NOT NULL, 
			ProductSize VARCHAR(5) NULL,
			Tonnes FLOAT NULL, 
			Fe FLOAT NULL, 
			P FLOAT NULL, 
			SiO2 FLOAT NULL, 
			Al2O3 FLOAT NULL, 
			LOI FLOAT NULL
		)
		
		-- insert the base historic data that matches the date range and location filters
		INSERT INTO @historicData (TagId, LocationId, MaterialTypeId, CalendarDate, DateFrom, DateTo, DateBreakdown, ProductSize, Tonnes, Fe, P, SiO2, Al2O3, LOI)
		SELECT his.TagId, his.LocationId, his.MaterialTypeId, his.CalendarDate, his.DateFrom, his.DateTo, his.DateBreakdown, /* ProductSize*/ 'TOTAL', his.Tonnes, his.Fe, his.P, his.SiO2, his.Al2O3, his.LOI
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 0) AS B
			INNER JOIN dbo.BhpbioReportDataHistorical AS his
				ON (his.DateBreakdown = @DataBreakdown
					AND his.DateFrom >= b.DateFrom
					AND his.DateTo <= b.DateTo)
			INNER JOIN @Location AS l
				ON (l.LocationId = his.LocationId
					AND his.CalendarDate Between l.IncludeStart and l.IncludeEnd)
		
		-- if the data breakdown is MONTH
		-- then bring in historic data that is available at the quarterly level as a priority
		IF @DataBreakdown = 'MONTH'
		BEGIN
						
			-- create and populate a table that will store the list of tags that exist at a quarterly level
			DECLARE @quarterlyTags TABLE (TagId VARCHAR(63))
			
			-- Determine the set of tags that exist at a quarter level
			INSERT INTO @quarterlyTags(TagId)
			SELECT DISTINCT h.TagId 
			FROM dbo.BhpbioReportDataHistorical h
			WHERE h.DateBreakdown = 'QUARTER'
			
			-- delete already built historic data where the tag exists in quarterly data (quarterly will be used in preference)
			DELETE h 
			FROM @historicData h
			WHERE EXISTS (SELECT qt.TagId FROM @quarterlyTags qt WHERE qt.TagId = h.TagId)
				
			-- set up a loop that iterates as many times as there are months in a quarter
			DECLARE @monthsInAQuarter INTEGER
			SET @monthsInAQuarter = 3 -- there are 3 months in a quarter
			DECLARE @monthInQuarterIndex INTEGER
			SET @monthInQuarterIndex = 0 -- start at the first month in the quarter
			
			-- loop until all months have been processed
			WHILE @monthInQuarterIndex < @monthsInAQuarter
			BEGIN
				-- insert additional history data for each month in each quarter
				INSERT INTO @historicData (TagId, LocationId, MaterialTypeId, CalendarDate, DateFrom, DateTo, DateBreakdown, Tonnes, Fe, P, SiO2, Al2O3, LOI, ProductSize)
				SELECT	his.TagId, 
						his.LocationId, 
						his.MaterialTypeId, 
						-- the calendar date, date from and date to columns must be calculated from the original quarter values
						DateAdd(month, @monthInQuarterIndex, his.DateFrom), -- add the appropriate number of months to the original date from (ie each month in the quarter)
						DateAdd(month, @monthInQuarterIndex, his.DateFrom), -- add the appropriate number of months to the original date from (ie each month in the quarter)
						DateAdd(day,-1,DateAdd(month, @monthInQuarterIndex + 1, his.DateFrom)), -- the date to is one month further than date from, minus a day to get back to the last day of the month
						'MONTH', 
						his.Tonnes / @monthsInAQuarter, -- each month has a proportion of the tonnes
						his.Fe, 
						his.P, 
						his.SiO2, 
						his.Al2O3, 
						his.LOI,
						'TOTAL'
				FROM dbo.BhpbioReportDataHistorical AS his
					INNER JOIN @Location AS l
						ON (l.LocationId = his.LocationId
							AND his.CalendarDate between l.IncludeStart and l.IncludeEnd)
					INNER JOIN @quarterlyTags qot ON qot.TagId = his.TagId
				WHERE DateAdd(month, @monthInQuarterIndex, his.CalendarDate) BETWEEN @iDateFrom AND @iDateTo
					AND his.DateBreakdown = 'QUARTER'
				
				SET @monthInQuarterIndex = @monthInQuarterIndex + 1
			END
		END

		SELECT his.TagId AS CalcId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, ProductSize,
			his.MaterialTypeId, SUM(Tonnes) AS Tonnes
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 0) AS b
			INNER JOIN @historicData AS his
				ON (his.DateBreakdown = @DataBreakdown
					AND his.DateFrom >= b.DateFrom
					AND his.DateTo <= b.DateTo)
			INNER JOIN @Location AS l
				ON (l.LocationId = his.LocationId
					AND his.CalendarDate between l.IncludeStart and l.IncludeEnd)
			LEFT JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = his.MaterialTypeId) 
		WHERE his.DateTo < @SystemStartDate
			AND (MT.Description <> 'Bene Product' OR MT.Description IS NULL)
			-- explicitly REMOVE the Factor based entries as they won't make sense in the output (they can't be aggregated)
			AND his.TagId NOT IN ('F1Factor', 'F2Factor', 'F3Factor')
		GROUP BY his.TagId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, his.MaterialTypeId, ProductSize

		SELECT his.TagId AS CalcId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, ProductSize,
			his.MaterialTypeId, SUM(his.Tonnes) AS Tonnes, g.Grade_Name AS GradeName,
			SUM
			(
				CASE
					WHEN g.Grade_Name = 'Al2O3' THEN his.Al2O3 * his.Tonnes
					WHEN g.Grade_Name = 'Fe' THEN his.Fe * his.Tonnes
					WHEN g.Grade_Name = 'LOI' THEN his.LOI * his.Tonnes
					WHEN g.Grade_Name = 'SiO2' THEN his.SiO2 * his.Tonnes
					WHEN g.Grade_Name = 'P' THEN his.P * his.Tonnes
					ELSE NULL
				END
			) / NULLIF(SUM(his.Tonnes), 0.0) As GradeValue
		FROM dbo.GetBhpbioReportBreakdown(@iDateBreakdown, @iDateFrom, @iDateTo, 0) AS B
			INNER JOIN @historicData AS his
				ON (his.DateBreakdown = @DataBreakdown
					AND his.DateFrom >= b.DateFrom
					AND his.DateTo <= b.DateTo)
			INNER JOIN @Location AS l
				ON (l.LocationId = his.LocationId
					AND his.CalendarDate between l.IncludeStart and l.IncludeEnd)
			LEFT JOIN dbo.MaterialType AS mt
				ON (mt.Material_Type_Id = his.MaterialTypeId) 
			CROSS JOIN dbo.Grade AS g
		WHERE his.DateTo < @SystemStartDate
			AND (mt.Description <> 'Bene Product' OR mt.Description IS NULL)
			-- explicitly REMOVE the Factor based entries as they won't make sense in the output (they can't be aggregated)
			AND his.TagId NOT IN ('F1Factor', 'F2Factor', 'F3Factor')
		GROUP BY his.TagId, b.CalendarDate, b.DateFrom, b.DateTo, l.ParentLocationId, his.MaterialTypeId, g.Grade_Name, ProductSize

		-- if we started a new transaction that is still valid then commit the changes
		IF (@TransactionCount = 0) AND (XAct_State() = 1)
		BEGIN
			COMMIT TRANSACTION
		END
	END TRY
	BEGIN CATCH
		-- if we started a transaction then roll it back
		IF (@TransactionCount = 0)
		BEGIN
			ROLLBACK TRANSACTION
		END
		-- if we are part of an existing transaction and 
		ELSE IF (XAct_State() = 1) AND (@TransactionCount > 0)
		BEGIN
			ROLLBACK TRANSACTION @TransactionName
		END

		EXEC dbo.StandardCatchBlock
	END CATCH
END 
GO

GRANT EXECUTE ON dbo.GetBhpbioReportDataHistorical TO BhpbioGenericManager
GO

-- TEST
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '31-mar-2007', null, null, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '1-jan-2007', 'MONTH', 7, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2007', '31-mar-2008', 'QUARTER', 6, null
--EXEC GetBhpbioReportDataHistorical '1-jan-2005', '1-jan-2009', 'YEAR', 7, null
--exec dbo.GetBhpbioReportDataHistorical @iDateFrom='Jan  1 1998 12:00:00:000AM',@iDateTo='Dec 31 2009 12:00:00:000AM',@iDateBreakdown='YEAR',@iLocationId=6,@iChildLocations=0
--exec dbo.GetBhpbioReportDataHistorical @iDateFrom='2009-01-01 00:00:00',@iDateTo='2009-12-31 00:00:00',@iDateBreakdown=NULL,@iLocationId=6,@iChildLocations=0

